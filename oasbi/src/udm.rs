#[allow(unused_imports)]
use reqwest::header::{HeaderMap, HeaderValue};

#[allow(unused_imports)]
pub use crate::progenitor_client::{ByteStream, Error, ResponseValue};
#[allow(unused_imports)]
use crate::progenitor_client::{RequestBuilderExt, encode_path};
///
/// Types used as operation parameters and responses.
#[allow(clippy::all)]
pub mod types {
	/// Error types.
	pub mod error {
		/// Error from a TryFrom or FromStr implementation.
		pub struct ConversionError(::std::borrow::Cow<'static, str>);
		impl ::std::error::Error for ConversionError {}
		impl ::std::fmt::Display for ConversionError {
			fn fmt(
				&self,
				f: &mut ::std::fmt::Formatter<'_>,
			) -> Result<(), ::std::fmt::Error> {
				::std::fmt::Display::fmt(&self.0, f)
			}
		}

		impl ::std::fmt::Debug for ConversionError {
			fn fmt(
				&self,
				f: &mut ::std::fmt::Formatter<'_>,
			) -> Result<(), ::std::fmt::Error> {
				::std::fmt::Debug::fmt(&self.0, f)
			}
		}

		impl From<&'static str> for ConversionError {
			fn from(value: &'static str) -> Self {
				Self(value.into())
			}
		}

		impl From<String> for ConversionError {
			fn from(value: String) -> Self {
				Self(value.into())
			}
		}
	}

	/// AccessAndMobilitySubscriptionData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "3gppChargingCharacteristics": {
	///      "$ref": "#/components/schemas/3GppChargingCharacteristics"
	///    },
	///    "activeTime": {
	///      "$ref": "#/components/schemas/DurationSecRm"
	///    },
	///    "adjacentPlmnRestrictions": {
	///      "description": "A map (list of key-value pairs where PlmnId serves
	/// as key) of PlmnRestriction",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/PlmnRestriction"
	///      }
	///    },
	///    "aerialUeSubInfo": {
	///      "$ref": "#/components/schemas/AerialUeSubscriptionInfo"
	///    },
	///    "cMsisdn": {
	///      "$ref": "#/components/schemas/CMsisdn"
	///    },
	///    "cagData": {
	///      "$ref": "#/components/schemas/CagData"
	///    },
	///    "coreNetworkTypeRestrictions": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/CoreNetworkType"
	///      }
	///    },
	///    "ecRestrictionDataNb": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "ecRestrictionDataWb": {
	///      "$ref": "#/components/schemas/EcRestrictionDataWb"
	///    },
	///    "edrxParametersList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/EdrxParameters"
	///      },
	///      "minItems": 1
	///    },
	///    "expectedUeBehaviourList": {
	///      "$ref": "#/components/schemas/ExpectedUeBehaviourData"
	///    },
	///    "forbiddenAreas": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Area"
	///      }
	///    },
	///    "gpsis": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Gpsi"
	///      }
	///    },
	///    "hssGroupId": {
	///      "$ref": "#/components/schemas/NfGroupId"
	///    },
	///    "iabOperationAllowed": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "internalGroupIds": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/GroupId"
	///      },
	///      "minItems": 1
	///    },
	///    "mcsPriority": {
	///      "$ref": "#/components/schemas/McsPriorityIndicator"
	///    },
	///    "mdtConfiguration": {
	///      "$ref": "#/components/schemas/MdtConfiguration"
	///    },
	///    "mdtUserConsent": {
	///      "$ref": "#/components/schemas/MdtUserConsent"
	///    },
	///    "micoAllowed": {
	///      "$ref": "#/components/schemas/MicoAllowed"
	///    },
	///    "mpsPriority": {
	///      "$ref": "#/components/schemas/MpsPriorityIndicator"
	///    },
	///    "nbIoTUePriority": {
	///      "$ref": "#/components/schemas/NbIoTUePriority"
	///    },
	///    "nssai": {
	///      "$ref": "#/components/schemas/Nssai"
	///    },
	///    "nssaiInclusionAllowed": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "odbPacketServices": {
	///      "$ref": "#/components/schemas/OdbPacketServices"
	///    },
	///    "pcfSelectionAssistanceInfos": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/PcfSelectionAssistanceInfo"
	///      },
	///      "minItems": 1
	///    },
	///    "primaryRatRestrictions": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/RatType"
	///      },
	///      "uniqueItems": true
	///    },
	///    "ptwParametersList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/PtwParameters"
	///      },
	///      "minItems": 1
	///    },
	///    "ratRestrictions": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/RatType"
	///      },
	///      "uniqueItems": true
	///    },
	///    "remoteProvInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "rfspIndex": {
	///      "$ref": "#/components/schemas/RfspIndexRm"
	///    },
	///    "rgWirelineCharacteristics": {
	///      "$ref": "#/components/schemas/Bytes"
	///    },
	///    "roamingRestrictions": {
	///      "$ref": "#/components/schemas/RoamingRestrictions"
	///    },
	///    "routingIndicator": {
	///      "type": "string",
	///      "pattern": "^[0-9]{1,4}$"
	///    },
	///    "secondaryRatRestrictions": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/RatType"
	///      },
	///      "uniqueItems": true
	///    },
	///    "serviceAreaRestriction": {
	///      "$ref": "#/components/schemas/ServiceAreaRestriction"
	///    },
	///    "serviceGapTime": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "sharedAmDataIds": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/SharedDataId"
	///      },
	///      "minItems": 1
	///    },
	///    "sharedVnGroupDataIds": {
	///      "description": "A map(list of key-value pairs) where GroupId serves
	/// as key of SharedDataId",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/SharedDataId"
	///      }
	///    },
	///    "sorInfo": {
	///      "$ref": "#/components/schemas/SorInfo"
	///    },
	///    "sorInfoExpectInd": {
	///      "type": "boolean"
	///    },
	///    "sorUpdateIndicatorList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/SorUpdateIndicator"
	///      },
	///      "minItems": 1
	///    },
	///    "sorafRetrieval": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "stnSr": {
	///      "$ref": "#/components/schemas/StnSr"
	///    },
	///    "subsRegTimer": {
	///      "$ref": "#/components/schemas/DurationSecRm"
	///    },
	///    "subscribedDnnList": {
	///      "type": "array",
	///      "items": {
	///        "anyOf": [
	///          {
	///            "$ref": "#/components/schemas/Dnn"
	///          },
	///          {
	///            "$ref": "#/components/schemas/WildcardDnn"
	///          }
	///        ]
	///      }
	///    },
	///    "subscribedUeAmbr": {
	///      "$ref": "#/components/schemas/AmbrRm"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "traceData": {
	///      "$ref": "#/components/schemas/TraceData"
	///    },
	///    "ueUsageType": {
	///      "$ref": "#/components/schemas/UeUsageType"
	///    },
	///    "upuInfo": {
	///      "$ref": "#/components/schemas/UpuInfo"
	///    },
	///    "wirelineForbiddenAreas": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/WirelineArea"
	///      }
	///    },
	///    "wirelineServiceAreaRestriction": {
	///      "$ref": "#/components/schemas/WirelineServiceAreaRestriction"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AccessAndMobilitySubscriptionData {
		#[serde(
			rename = "activeTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub active_time: Option<DurationSecRm>,
		/// A map (list of key-value pairs where PlmnId serves as key) of
		/// PlmnRestriction
		#[serde(
			rename = "adjacentPlmnRestrictions",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub adjacent_plmn_restrictions: ::std::collections::HashMap<String, PlmnRestriction>,
		#[serde(
			rename = "aerialUeSubInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub aerial_ue_sub_info: Option<AerialUeSubscriptionInfo>,
		#[serde(rename = "cMsisdn", default, skip_serializing_if = "Option::is_none")]
		pub c_msisdn: Option<CMsisdn>,
		#[serde(rename = "cagData", default, skip_serializing_if = "Option::is_none")]
		pub cag_data: Option<CagData>,
		#[serde(
			rename = "coreNetworkTypeRestrictions",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub core_network_type_restrictions: Vec<CoreNetworkType>,
		#[serde(rename = "ecRestrictionDataNb", default)]
		pub ec_restriction_data_nb: bool,
		#[serde(
			rename = "ecRestrictionDataWb",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ec_restriction_data_wb: Option<EcRestrictionDataWb>,
		#[serde(
			rename = "edrxParametersList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub edrx_parameters_list: Vec<EdrxParameters>,
		#[serde(
			rename = "expectedUeBehaviourList",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub expected_ue_behaviour_list: Option<ExpectedUeBehaviourData>,
		#[serde(
			rename = "forbiddenAreas",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub forbidden_areas: Vec<Area>,
		#[serde(default, skip_serializing_if = "Vec::is_empty")]
		pub gpsis: Vec<Gpsi>,
		#[serde(
			rename = "hssGroupId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub hss_group_id: Option<NfGroupId>,
		#[serde(rename = "iabOperationAllowed", default)]
		pub iab_operation_allowed: bool,
		#[serde(
			rename = "internalGroupIds",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub internal_group_ids: Vec<GroupId>,
		#[serde(
			rename = "mcsPriority",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mcs_priority: Option<McsPriorityIndicator>,
		#[serde(
			rename = "mdtConfiguration",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mdt_configuration: Option<MdtConfiguration>,
		#[serde(
			rename = "mdtUserConsent",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mdt_user_consent: Option<MdtUserConsent>,
		#[serde(
			rename = "micoAllowed",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mico_allowed: Option<MicoAllowed>,
		#[serde(
			rename = "mpsPriority",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mps_priority: Option<MpsPriorityIndicator>,
		#[serde(
			rename = "nbIoTUePriority",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub nb_io_t_ue_priority: Option<NbIoTUePriority>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub nssai: Option<Nssai>,
		#[serde(rename = "nssaiInclusionAllowed", default)]
		pub nssai_inclusion_allowed: bool,
		#[serde(
			rename = "odbPacketServices",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub odb_packet_services: Option<OdbPacketServices>,
		#[serde(
			rename = "pcfSelectionAssistanceInfos",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub pcf_selection_assistance_infos: Vec<PcfSelectionAssistanceInfo>,
		#[serde(
			rename = "primaryRatRestrictions",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub primary_rat_restrictions: Option<Vec<RatType>>,
		#[serde(
			rename = "ptwParametersList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub ptw_parameters_list: Vec<PtwParameters>,
		#[serde(
			rename = "ratRestrictions",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub rat_restrictions: Option<Vec<RatType>>,
		#[serde(rename = "remoteProvInd", default)]
		pub remote_prov_ind: bool,
		#[serde(rename = "rfspIndex", default, skip_serializing_if = "Option::is_none")]
		pub rfsp_index: Option<RfspIndexRm>,
		#[serde(
			rename = "rgWirelineCharacteristics",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub rg_wireline_characteristics: Option<Bytes>,
		#[serde(
			rename = "roamingRestrictions",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub roaming_restrictions: Option<RoamingRestrictions>,
		#[serde(
			rename = "routingIndicator",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub routing_indicator: Option<AccessAndMobilitySubscriptionDataRoutingIndicator>,
		#[serde(
			rename = "secondaryRatRestrictions",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub secondary_rat_restrictions: Option<Vec<RatType>>,
		#[serde(
			rename = "serviceAreaRestriction",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub service_area_restriction: Option<ServiceAreaRestriction>,
		#[serde(
			rename = "serviceGapTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub service_gap_time: Option<DurationSec>,
		#[serde(
			rename = "sharedAmDataIds",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub shared_am_data_ids: Vec<SharedDataId>,
		/// A map(list of key-value pairs) where GroupId serves as key of
		/// SharedDataId
		#[serde(
			rename = "sharedVnGroupDataIds",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub shared_vn_group_data_ids: ::std::collections::HashMap<String, SharedDataId>,
		#[serde(rename = "sorInfo", default, skip_serializing_if = "Option::is_none")]
		pub sor_info: Option<SorInfo>,
		#[serde(
			rename = "sorInfoExpectInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub sor_info_expect_ind: Option<bool>,
		#[serde(
			rename = "sorUpdateIndicatorList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub sor_update_indicator_list: Vec<SorUpdateIndicator>,
		#[serde(rename = "sorafRetrieval", default)]
		pub soraf_retrieval: bool,
		#[serde(rename = "stnSr", default, skip_serializing_if = "Option::is_none")]
		pub stn_sr: Option<StnSr>,
		#[serde(
			rename = "subsRegTimer",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub subs_reg_timer: Option<DurationSecRm>,
		#[serde(
			rename = "subscribedDnnList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub subscribed_dnn_list: Vec<AccessAndMobilitySubscriptionDataSubscribedDnnListItem>,
		#[serde(
			rename = "subscribedUeAmbr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub subscribed_ue_ambr: Option<AmbrRm>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
		#[serde(
			rename = "3gppChargingCharacteristics",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub three_gpp_charging_characteristics: Option<_3gppChargingCharacteristics>,
		#[serde(rename = "traceData", default, skip_serializing_if = "Option::is_none")]
		pub trace_data: Option<TraceData>,
		#[serde(
			rename = "ueUsageType",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ue_usage_type: Option<UeUsageType>,
		#[serde(rename = "upuInfo", default, skip_serializing_if = "Option::is_none")]
		pub upu_info: Option<UpuInfo>,
		#[serde(
			rename = "wirelineForbiddenAreas",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub wireline_forbidden_areas: Vec<WirelineArea>,
		#[serde(
			rename = "wirelineServiceAreaRestriction",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub wireline_service_area_restriction: Option<WirelineServiceAreaRestriction>,
	}

	impl From<&AccessAndMobilitySubscriptionData> for AccessAndMobilitySubscriptionData {
		fn from(value: &AccessAndMobilitySubscriptionData) -> Self {
			value.clone()
		}
	}

	/// AccessAndMobilitySubscriptionDataRoutingIndicator
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[0-9]{1,4}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct AccessAndMobilitySubscriptionDataRoutingIndicator(String);
	impl ::std::ops::Deref for AccessAndMobilitySubscriptionDataRoutingIndicator {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<AccessAndMobilitySubscriptionDataRoutingIndicator> for String {
		fn from(value: AccessAndMobilitySubscriptionDataRoutingIndicator) -> Self {
			value.0
		}
	}

	impl From<&AccessAndMobilitySubscriptionDataRoutingIndicator>
		for AccessAndMobilitySubscriptionDataRoutingIndicator
	{
		fn from(value: &AccessAndMobilitySubscriptionDataRoutingIndicator) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for AccessAndMobilitySubscriptionDataRoutingIndicator {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9]{1,4}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9]{1,4}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for AccessAndMobilitySubscriptionDataRoutingIndicator {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for AccessAndMobilitySubscriptionDataRoutingIndicator {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for AccessAndMobilitySubscriptionDataRoutingIndicator {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for AccessAndMobilitySubscriptionDataRoutingIndicator {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// AccessAndMobilitySubscriptionDataSubscribedDnnListItem
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "anyOf": [
	///    {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    {
	///      "$ref": "#/components/schemas/WildcardDnn"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AccessAndMobilitySubscriptionDataSubscribedDnnListItem {
		#[serde(flatten, default, skip_serializing_if = "Option::is_none")]
		pub subtype_0: Option<Dnn>,
		#[serde(flatten, default, skip_serializing_if = "Option::is_none")]
		pub subtype_1: Option<WildcardDnn>,
	}

	impl From<&AccessAndMobilitySubscriptionDataSubscribedDnnListItem>
		for AccessAndMobilitySubscriptionDataSubscribedDnnListItem
	{
		fn from(value: &AccessAndMobilitySubscriptionDataSubscribedDnnListItem) -> Self {
			value.clone()
		}
	}

	/// AccessNetworkId
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "HRPD",
	///    "WIMAX",
	///    "WLAN",
	///    "ETHERNET"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum AccessNetworkId {
		#[default]
		#[serde(rename = "HRPD")]
		Hrpd,
		#[serde(rename = "WIMAX")]
		Wimax,
		#[serde(rename = "WLAN")]
		Wlan,
		#[serde(rename = "ETHERNET")]
		Ethernet,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&AccessNetworkId> for AccessNetworkId {
		fn from(value: &AccessNetworkId) -> Self {
			value.clone()
		}
	}

	impl ToString for AccessNetworkId {
		fn to_string(&self) -> String {
			match *self {
				Self::Hrpd => "HRPD".to_string(),
				Self::Wimax => "WIMAX".to_string(),
				Self::Wlan => "WLAN".to_string(),
				Self::Ethernet => "ETHERNET".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for AccessNetworkId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"HRPD" => Ok(Self::Hrpd),
				"WIMAX" => Ok(Self::Wimax),
				"WLAN" => Ok(Self::Wlan),
				"ETHERNET" => Ok(Self::Ethernet),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for AccessNetworkId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for AccessNetworkId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for AccessNetworkId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Represents the access technology
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents the access technology",
	///  "type": "string",
	///  "enum": [
	///    "NR",
	///    "EUTRAN_IN_WBS1_MODE_AND_NBS1_MODE",
	///    "EUTRAN_IN_NBS1_MODE_ONLY",
	///    "EUTRAN_IN_WBS1_MODE_ONLY",
	///    "UTRAN",
	///    "GSM_AND_ECGSM_IoT",
	///    "GSM_WITHOUT_ECGSM_IoT",
	///    "ECGSM_IoT_ONLY",
	///    "CDMA_1xRTT",
	///    "CDMA_HRPD",
	///    "GSM_COMPACT"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum AccessTech {
		#[default]
		#[serde(rename = "NR")]
		Nr,
		#[serde(rename = "EUTRAN_IN_WBS1_MODE_AND_NBS1_MODE")]
		EutranInWbs1ModeAndNbs1Mode,
		#[serde(rename = "EUTRAN_IN_NBS1_MODE_ONLY")]
		EutranInNbs1ModeOnly,
		#[serde(rename = "EUTRAN_IN_WBS1_MODE_ONLY")]
		EutranInWbs1ModeOnly,
		#[serde(rename = "UTRAN")]
		Utran,
		#[serde(rename = "GSM_AND_ECGSM_IoT")]
		GsmAndEcgsmIoT,
		#[serde(rename = "GSM_WITHOUT_ECGSM_IoT")]
		GsmWithoutEcgsmIoT,
		#[serde(rename = "ECGSM_IoT_ONLY")]
		EcgsmIoTOnly,
		#[serde(rename = "CDMA_1xRTT")]
		Cdma1xRtt,
		#[serde(rename = "CDMA_HRPD")]
		CdmaHrpd,
		#[serde(rename = "GSM_COMPACT")]
		GsmCompact,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&AccessTech> for AccessTech {
		fn from(value: &AccessTech) -> Self {
			value.clone()
		}
	}

	impl ToString for AccessTech {
		fn to_string(&self) -> String {
			match *self {
				Self::Nr => "NR".to_string(),
				Self::EutranInWbs1ModeAndNbs1Mode => {
					"EUTRAN_IN_WBS1_MODE_AND_NBS1_MODE".to_string()
				}
				Self::EutranInNbs1ModeOnly => "EUTRAN_IN_NBS1_MODE_ONLY".to_string(),
				Self::EutranInWbs1ModeOnly => "EUTRAN_IN_WBS1_MODE_ONLY".to_string(),
				Self::Utran => "UTRAN".to_string(),
				Self::GsmAndEcgsmIoT => "GSM_AND_ECGSM_IoT".to_string(),
				Self::GsmWithoutEcgsmIoT => "GSM_WITHOUT_ECGSM_IoT".to_string(),
				Self::EcgsmIoTOnly => "ECGSM_IoT_ONLY".to_string(),
				Self::Cdma1xRtt => "CDMA_1xRTT".to_string(),
				Self::CdmaHrpd => "CDMA_HRPD".to_string(),
				Self::GsmCompact => "GSM_COMPACT".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for AccessTech {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"NR" => Ok(Self::Nr),
				"EUTRAN_IN_WBS1_MODE_AND_NBS1_MODE" => Ok(Self::EutranInWbs1ModeAndNbs1Mode),
				"EUTRAN_IN_NBS1_MODE_ONLY" => Ok(Self::EutranInNbs1ModeOnly),
				"EUTRAN_IN_WBS1_MODE_ONLY" => Ok(Self::EutranInWbs1ModeOnly),
				"UTRAN" => Ok(Self::Utran),
				"GSM_AND_ECGSM_IoT" => Ok(Self::GsmAndEcgsmIoT),
				"GSM_WITHOUT_ECGSM_IoT" => Ok(Self::GsmWithoutEcgsmIoT),
				"ECGSM_IoT_ONLY" => Ok(Self::EcgsmIoTOnly),
				"CDMA_1xRTT" => Ok(Self::Cdma1xRtt),
				"CDMA_HRPD" => Ok(Self::CdmaHrpd),
				"GSM_COMPACT" => Ok(Self::GsmCompact),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for AccessTech {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for AccessTech {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for AccessTech {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Error returned in the access token response message
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Error returned in the access token response message",
	///  "type": "object",
	///  "required": [
	///    "error"
	///  ],
	///  "properties": {
	///    "error": {
	///      "type": "string",
	///      "enum": [
	///        "invalid_request",
	///        "invalid_client",
	///        "invalid_grant",
	///        "unauthorized_client",
	///        "unsupported_grant_type",
	///        "invalid_scope"
	///      ]
	///    },
	///    "error_description": {
	///      "type": "string"
	///    },
	///    "error_uri": {
	///      "type": "string"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AccessTokenErr {
		pub error: AccessTokenErrError,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub error_description: Option<String>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub error_uri: Option<String>,
	}

	impl From<&AccessTokenErr> for AccessTokenErr {
		fn from(value: &AccessTokenErr) -> Self {
			value.clone()
		}
	}

	/// AccessTokenErrError
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "invalid_request",
	///    "invalid_client",
	///    "invalid_grant",
	///    "unauthorized_client",
	///    "unsupported_grant_type",
	///    "invalid_scope"
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Copy,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum AccessTokenErrError {
		#[default]
		#[serde(rename = "invalid_request")]
		InvalidRequest,
		#[serde(rename = "invalid_client")]
		InvalidClient,
		#[serde(rename = "invalid_grant")]
		InvalidGrant,
		#[serde(rename = "unauthorized_client")]
		UnauthorizedClient,
		#[serde(rename = "unsupported_grant_type")]
		UnsupportedGrantType,
		#[serde(rename = "invalid_scope")]
		InvalidScope,
	}

	impl From<&AccessTokenErrError> for AccessTokenErrError {
		fn from(value: &AccessTokenErrError) -> Self {
			value.clone()
		}
	}

	impl ToString for AccessTokenErrError {
		fn to_string(&self) -> String {
			match *self {
				Self::InvalidRequest => "invalid_request".to_string(),
				Self::InvalidClient => "invalid_client".to_string(),
				Self::InvalidGrant => "invalid_grant".to_string(),
				Self::UnauthorizedClient => "unauthorized_client".to_string(),
				Self::UnsupportedGrantType => "unsupported_grant_type".to_string(),
				Self::InvalidScope => "invalid_scope".to_string(),
			}
		}
	}

	impl std::str::FromStr for AccessTokenErrError {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"invalid_request" => Ok(Self::InvalidRequest),
				"invalid_client" => Ok(Self::InvalidClient),
				"invalid_grant" => Ok(Self::InvalidGrant),
				"unauthorized_client" => Ok(Self::UnauthorizedClient),
				"unsupported_grant_type" => Ok(Self::UnsupportedGrantType),
				"invalid_scope" => Ok(Self::InvalidScope),
				_ => Err("invalid value".into()),
			}
		}
	}

	impl std::convert::TryFrom<&str> for AccessTokenErrError {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for AccessTokenErrError {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for AccessTokenErrError {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Contains information related to the access token request
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains information related to the access token
	/// request",
	///  "type": "object",
	///  "required": [
	///    "grant_type",
	///    "nfInstanceId",
	///    "scope"
	///  ],
	///  "properties": {
	///    "grant_type": {
	///      "type": "string",
	///      "enum": [
	///        "client_credentials"
	///      ]
	///    },
	///    "hnrfAccessTokenUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "nfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "nfType": {
	///      "$ref": "#/components/schemas/NFType"
	///    },
	///    "requesterFqdn": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "requesterPlmn": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "requesterPlmnList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/PlmnId"
	///      },
	///      "minItems": 2
	///    },
	///    "requesterSnpnList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/PlmnIdNid"
	///      },
	///      "minItems": 1
	///    },
	///    "requesterSnssaiList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Snssai"
	///      },
	///      "minItems": 1
	///    },
	///    "scope": {
	///      "type": "string",
	///      "pattern": "^([a-zA-Z0-9_:-]+)( [a-zA-Z0-9_:-]+)*$"
	///    },
	///    "sourceNfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "targetNfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "targetNfServiceSetId": {
	///      "$ref": "#/components/schemas/NfServiceSetId"
	///    },
	///    "targetNfSetId": {
	///      "$ref": "#/components/schemas/NfSetId"
	///    },
	///    "targetNfType": {
	///      "$ref": "#/components/schemas/NFType"
	///    },
	///    "targetNsiList": {
	///      "type": "array",
	///      "items": {
	///        "type": "string"
	///      },
	///      "minItems": 1
	///    },
	///    "targetPlmn": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "targetSnpn": {
	///      "$ref": "#/components/schemas/PlmnIdNid"
	///    },
	///    "targetSnssaiList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Snssai"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AccessTokenReq {
		pub grant_type: AccessTokenReqGrantType,
		#[serde(
			rename = "hnrfAccessTokenUri",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub hnrf_access_token_uri: Option<Uri>,
		#[serde(rename = "nfInstanceId")]
		pub nf_instance_id: NfInstanceId,
		#[serde(rename = "nfType", default, skip_serializing_if = "Option::is_none")]
		pub nf_type: Option<NfType>,
		#[serde(
			rename = "requesterFqdn",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub requester_fqdn: Option<Fqdn>,
		#[serde(
			rename = "requesterPlmn",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub requester_plmn: Option<PlmnId>,
		#[serde(
			rename = "requesterPlmnList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub requester_plmn_list: Vec<PlmnId>,
		#[serde(
			rename = "requesterSnpnList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub requester_snpn_list: Vec<PlmnIdNid>,
		#[serde(
			rename = "requesterSnssaiList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub requester_snssai_list: Vec<Snssai>,
		pub scope: AccessTokenReqScope,
		#[serde(
			rename = "sourceNfInstanceId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub source_nf_instance_id: Option<NfInstanceId>,
		#[serde(
			rename = "targetNfInstanceId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub target_nf_instance_id: Option<NfInstanceId>,
		#[serde(
			rename = "targetNfServiceSetId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub target_nf_service_set_id: Option<NfServiceSetId>,
		#[serde(
			rename = "targetNfSetId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub target_nf_set_id: Option<NfSetId>,
		#[serde(
			rename = "targetNfType",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub target_nf_type: Option<NfType>,
		#[serde(
			rename = "targetNsiList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub target_nsi_list: Vec<String>,
		#[serde(
			rename = "targetPlmn",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub target_plmn: Option<PlmnId>,
		#[serde(
			rename = "targetSnpn",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub target_snpn: Option<PlmnIdNid>,
		#[serde(
			rename = "targetSnssaiList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub target_snssai_list: Vec<Snssai>,
	}

	impl From<&AccessTokenReq> for AccessTokenReq {
		fn from(value: &AccessTokenReq) -> Self {
			value.clone()
		}
	}

	/// AccessTokenReqGrantType
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "client_credentials"
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Copy,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum AccessTokenReqGrantType {
		#[default]
		#[serde(rename = "client_credentials")]
		ClientCredentials,
	}

	impl From<&AccessTokenReqGrantType> for AccessTokenReqGrantType {
		fn from(value: &AccessTokenReqGrantType) -> Self {
			value.clone()
		}
	}

	impl ToString for AccessTokenReqGrantType {
		fn to_string(&self) -> String {
			match *self {
				Self::ClientCredentials => "client_credentials".to_string(),
			}
		}
	}

	impl std::str::FromStr for AccessTokenReqGrantType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"client_credentials" => Ok(Self::ClientCredentials),
				_ => Err("invalid value".into()),
			}
		}
	}

	impl std::convert::TryFrom<&str> for AccessTokenReqGrantType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for AccessTokenReqGrantType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for AccessTokenReqGrantType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// AccessTokenReqScope
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^([a-zA-Z0-9_:-]+)( [a-zA-Z0-9_:-]+)*$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct AccessTokenReqScope(String);
	impl ::std::ops::Deref for AccessTokenReqScope {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<AccessTokenReqScope> for String {
		fn from(value: AccessTokenReqScope) -> Self {
			value.0
		}
	}

	impl From<&AccessTokenReqScope> for AccessTokenReqScope {
		fn from(value: &AccessTokenReqScope) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for AccessTokenReqScope {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^([a-zA-Z0-9_:-]+)( [a-zA-Z0-9_:-]+)*$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err(
					"doesn't match pattern \"^([a-zA-Z0-9_:-]+)( [a-zA-Z0-9_:-]+)*$\"".into(),
				);
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for AccessTokenReqScope {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for AccessTokenReqScope {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for AccessTokenReqScope {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for AccessTokenReqScope {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Indicates whether the access is  via 3GPP or via non-3GPP.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates whether the access is  via 3GPP or via
	/// non-3GPP.",
	///  "type": "string",
	///  "enum": [
	///    "3GPP_ACCESS",
	///    "NON_3GPP_ACCESS"
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Copy,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum AccessType {
		#[default]
		#[serde(rename = "3GPP_ACCESS")]
		ThreeGppAccess,
		#[serde(rename = "NON_3GPP_ACCESS")]
		Non3gppAccess,
	}

	impl From<&AccessType> for AccessType {
		fn from(value: &AccessType) -> Self {
			value.clone()
		}
	}

	impl ToString for AccessType {
		fn to_string(&self) -> String {
			match *self {
				Self::ThreeGppAccess => "3GPP_ACCESS".to_string(),
				Self::Non3gppAccess => "NON_3GPP_ACCESS".to_string(),
			}
		}
	}

	impl std::str::FromStr for AccessType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"3GPP_ACCESS" => Ok(Self::ThreeGppAccess),
				"NON_3GPP_ACCESS" => Ok(Self::Non3gppAccess),
				_ => Err("invalid value".into()),
			}
		}
	}

	impl std::convert::TryFrom<&str> for AccessType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for AccessType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for AccessType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Contains indication whether the acknowledgement from UE is needed.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains indication whether the acknowledgement from UE
	/// is needed.",
	///  "type": "boolean"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AckInd(pub bool);
	impl ::std::ops::Deref for AckInd {
		type Target = bool;
		fn deref(&self) -> &bool {
			&self.0
		}
	}

	impl From<AckInd> for bool {
		fn from(value: AckInd) -> Self {
			value.0
		}
	}

	impl From<&AckInd> for AckInd {
		fn from(value: &AckInd) -> Self {
			value.clone()
		}
	}

	impl From<bool> for AckInd {
		fn from(value: bool) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for AckInd {
		type Err = <bool as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for AckInd {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for AckInd {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for AckInd {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for AckInd {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// AcknowledgeInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "provisioningTime"
	///  ],
	///  "properties": {
	///    "provisioningTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "sorMacIue": {
	///      "$ref": "#/components/schemas/SorMac"
	///    },
	///    "sorTransparentContainer": {
	///      "$ref": "#/components/schemas/Bytes"
	///    },
	///    "ueNotReachable": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "upuMacIue": {
	///      "$ref": "#/components/schemas/UpuMac"
	///    },
	///    "upuTransparentContainer": {
	///      "$ref": "#/components/schemas/Bytes"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AcknowledgeInfo {
		#[serde(rename = "provisioningTime")]
		pub provisioning_time: DateTime,
		#[serde(rename = "sorMacIue", default, skip_serializing_if = "Option::is_none")]
		pub sor_mac_iue: Option<SorMac>,
		#[serde(
			rename = "sorTransparentContainer",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub sor_transparent_container: Option<Bytes>,
		#[serde(rename = "ueNotReachable", default)]
		pub ue_not_reachable: bool,
		#[serde(rename = "upuMacIue", default, skip_serializing_if = "Option::is_none")]
		pub upu_mac_iue: Option<UpuMac>,
		#[serde(
			rename = "upuTransparentContainer",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub upu_transparent_container: Option<Bytes>,
	}

	impl From<&AcknowledgeInfo> for AcknowledgeInfo {
		fn from(value: &AcknowledgeInfo) -> Self {
			value.clone()
		}
	}

	/// The ACS information for the 5G-RG is defined in BBF TR-069 [42] or in
	/// BBF TR-369
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The ACS information for the 5G-RG is defined in BBF
	/// TR-069 [42] or in BBF TR-369",
	///  "type": "object",
	///  "properties": {
	///    "acsIpv4Addr": {
	///      "$ref": "#/components/schemas/Ipv4Addr"
	///    },
	///    "acsIpv6Addr": {
	///      "$ref": "#/components/schemas/Ipv6Addr"
	///    },
	///    "acsUrl": {
	///      "$ref": "#/components/schemas/Uri"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AcsInfo {
		#[serde(
			rename = "acsIpv4Addr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub acs_ipv4_addr: Option<Ipv4Addr>,
		#[serde(
			rename = "acsIpv6Addr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub acs_ipv6_addr: Option<Ipv6Addr>,
		#[serde(rename = "acsUrl", default, skip_serializing_if = "Option::is_none")]
		pub acs_url: Option<Uri>,
	}

	impl From<&AcsInfo> for AcsInfo {
		fn from(value: &AcsInfo) -> Self {
			value.clone()
		}
	}

	/// This data type is defined in the same way as the 'AcsInfo' data type,
	/// but with the  OpenAPI 'nullable: true' property.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This data type is defined in the same way as the
	/// 'AcsInfo' data type, but with the  OpenAPI 'nullable: true'
	/// property.\n",
	///  "anyOf": [
	///    {
	///      "$ref": "#/components/schemas/AcsInfo"
	///    },
	///    {
	///      "$ref": "#/components/schemas/NullValue"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum AcsInfoRm {
		#[default]
		AcsInfo(AcsInfo),
		NullValue(NullValue),
	}

	impl From<&AcsInfoRm> for AcsInfoRm {
		fn from(value: &AcsInfoRm) -> Self {
			value.clone()
		}
	}

	impl From<AcsInfo> for AcsInfoRm {
		fn from(value: AcsInfo) -> Self {
			Self::AcsInfo(value)
		}
	}

	impl From<NullValue> for AcsInfoRm {
		fn from(value: NullValue) -> Self {
			Self::NullValue(value)
		}
	}

	/// AdditionalSnssaiData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "requiredAuthnAuthz": {
	///      "type": "boolean"
	///    },
	///    "subscribedNsSrgList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/NsSrg"
	///      },
	///      "minItems": 1
	///    },
	///    "subscribedUeSliceMbr": {
	///      "$ref": "#/components/schemas/SliceMbrRm"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AdditionalSnssaiData {
		#[serde(
			rename = "requiredAuthnAuthz",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub required_authn_authz: Option<bool>,
		#[serde(
			rename = "subscribedNsSrgList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub subscribed_ns_srg_list: Vec<NsSrg>,
		#[serde(
			rename = "subscribedUeSliceMbr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub subscribed_ue_slice_mbr: Option<SliceMbrRm>,
	}

	impl From<&AdditionalSnssaiData> for AdditionalSnssaiData {
		fn from(value: &AdditionalSnssaiData) -> Self {
			value.clone()
		}
	}

	/// Indicates the Aerial service for the UE is allowed or not allowed,
	/// possible values are - AERIAL_UE_ALLOWED: Aerial service for the UE is
	/// allowed. - AERIAL_UE_NOT_ALLOWED: Aerial service for the UE is not
	/// allowed.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates the Aerial service for the UE is allowed or
	/// not allowed, possible values are - AERIAL_UE_ALLOWED: Aerial service for
	/// the UE is allowed. - AERIAL_UE_NOT_ALLOWED: Aerial service for the UE is
	/// not allowed.\n",
	///  "type": "string",
	///  "enum": [
	///    "AERIAL_UE_ALLOWED",
	///    "AERIAL_UE_NOT_ALLOWED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum AerialUeIndication {
		#[default]
		#[serde(rename = "AERIAL_UE_ALLOWED")]
		AerialUeAllowed,
		#[serde(rename = "AERIAL_UE_NOT_ALLOWED")]
		AerialUeNotAllowed,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&AerialUeIndication> for AerialUeIndication {
		fn from(value: &AerialUeIndication) -> Self {
			value.clone()
		}
	}

	impl ToString for AerialUeIndication {
		fn to_string(&self) -> String {
			match *self {
				Self::AerialUeAllowed => "AERIAL_UE_ALLOWED".to_string(),
				Self::AerialUeNotAllowed => "AERIAL_UE_NOT_ALLOWED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for AerialUeIndication {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"AERIAL_UE_ALLOWED" => Ok(Self::AerialUeAllowed),
				"AERIAL_UE_NOT_ALLOWED" => Ok(Self::AerialUeNotAllowed),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for AerialUeIndication {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for AerialUeIndication {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for AerialUeIndication {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Contains the Aerial UE Subscription Information, it at least contains
	/// the Aerial UE Indication.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the Aerial UE Subscription Information, it at
	/// least contains the Aerial UE Indication.",
	///  "type": "object",
	///  "required": [
	///    "aerialUeInd"
	///  ],
	///  "properties": {
	///    "3gppUavId": {
	///      "$ref": "#/components/schemas/Gpsi"
	///    },
	///    "aerialUeInd": {
	///      "$ref": "#/components/schemas/AerialUeIndication"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AerialUeSubscriptionInfo {
		#[serde(rename = "aerialUeInd")]
		pub aerial_ue_ind: AerialUeIndication,
		#[serde(rename = "3gppUavId", default, skip_serializing_if = "Option::is_none")]
		pub three_gpp_uav_id: Option<Gpsi>,
	}

	impl From<&AerialUeSubscriptionInfo> for AerialUeSubscriptionInfo {
		fn from(value: &AerialUeSubscriptionInfo) -> Self {
			value.clone()
		}
	}

	/// AfExternal
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "afId": {
	///      "$ref": "#/components/schemas/AfId"
	///    },
	///    "allowedGeographicArea": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/GeographicArea"
	///      },
	///      "minItems": 1
	///    },
	///    "privacyCheckRelatedAction": {
	///      "$ref": "#/components/schemas/PrivacyCheckRelatedAction"
	///    },
	///    "validTimePeriod": {
	///      "$ref": "#/components/schemas/ValidTimePeriod"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AfExternal {
		#[serde(rename = "afId", default, skip_serializing_if = "Option::is_none")]
		pub af_id: Option<AfId>,
		#[serde(
			rename = "allowedGeographicArea",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub allowed_geographic_area: Vec<GeographicArea>,
		#[serde(
			rename = "privacyCheckRelatedAction",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub privacy_check_related_action: Option<PrivacyCheckRelatedAction>,
		#[serde(
			rename = "validTimePeriod",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub valid_time_period: Option<ValidTimePeriod>,
	}

	impl From<&AfExternal> for AfExternal {
		fn from(value: &AfExternal) -> Self {
			value.clone()
		}
	}

	/// AfId
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct AfId(pub String);
	impl ::std::ops::Deref for AfId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<AfId> for String {
		fn from(value: AfId) -> Self {
			value.0
		}
	}

	impl From<&AfId> for AfId {
		fn from(value: &AfId) -> Self {
			value.clone()
		}
	}

	impl From<String> for AfId {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for AfId {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for AfId {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Indicates value of the age of the location estimate.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates value of the age of the location estimate.",
	///  "type": "integer",
	///  "maximum": 32767.0,
	///  "minimum": 0.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AgeOfLocationEstimate(pub i64);
	impl ::std::ops::Deref for AgeOfLocationEstimate {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<AgeOfLocationEstimate> for i64 {
		fn from(value: AgeOfLocationEstimate) -> Self {
			value.0
		}
	}

	impl From<&AgeOfLocationEstimate> for AgeOfLocationEstimate {
		fn from(value: &AgeOfLocationEstimate) -> Self {
			value.clone()
		}
	}

	impl From<i64> for AgeOfLocationEstimate {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for AgeOfLocationEstimate {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for AgeOfLocationEstimate {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for AgeOfLocationEstimate {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for AgeOfLocationEstimate {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for AgeOfLocationEstimate {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Altitude
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates value of altitude.",
	///  "type": "number",
	///  "format": "double",
	///  "maximum": 32767.0,
	///  "minimum": -32767.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Altitude(pub f64);
	impl ::std::ops::Deref for Altitude {
		type Target = f64;
		fn deref(&self) -> &f64 {
			&self.0
		}
	}

	impl From<Altitude> for f64 {
		fn from(value: Altitude) -> Self {
			value.0
		}
	}

	impl From<&Altitude> for Altitude {
		fn from(value: &Altitude) -> Self {
			value.clone()
		}
	}

	impl From<f64> for Altitude {
		fn from(value: f64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for Altitude {
		type Err = <f64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for Altitude {
		type Error = <f64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for Altitude {
		type Error = <f64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for Altitude {
		type Error = <f64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for Altitude {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Contains the maximum aggregated uplink and downlink bit rates.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the maximum aggregated uplink and downlink bit
	/// rates.",
	///  "type": "object",
	///  "required": [
	///    "downlink",
	///    "uplink"
	///  ],
	///  "properties": {
	///    "downlink": {
	///      "$ref": "#/components/schemas/BitRate"
	///    },
	///    "uplink": {
	///      "$ref": "#/components/schemas/BitRate"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Ambr {
		pub downlink: BitRate,
		pub uplink: BitRate,
	}

	impl From<&Ambr> for Ambr {
		fn from(value: &Ambr) -> Self {
			value.clone()
		}
	}

	/// This data type is defined in the same way as the 'Ambr' data type, but
	/// with the OpenAPI 'nullable: true' property."
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This data type is defined in the same way as the 'Ambr'
	/// data type, but with the OpenAPI 'nullable: true' property.\"\n",
	///  "anyOf": [
	///    {
	///      "$ref": "#/components/schemas/Ambr"
	///    },
	///    {
	///      "$ref": "#/components/schemas/NullValue"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum AmbrRm {
		#[default]
		Ambr(Ambr),
		NullValue(NullValue),
	}

	impl From<&AmbrRm> for AmbrRm {
		fn from(value: &AmbrRm) -> Self {
			value.clone()
		}
	}

	impl From<Ambr> for AmbrRm {
		fn from(value: Ambr) -> Self {
			Self::Ambr(value)
		}
	}

	impl From<NullValue> for AmbrRm {
		fn from(value: NullValue) -> Self {
			Self::NullValue(value)
		}
	}

	/// Amf3GppAccessRegistration
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "amfInstanceId",
	///    "deregCallbackUri",
	///    "guami",
	///    "ratType"
	///  ],
	///  "properties": {
	///    "adminDeregSubWithdrawn": {
	///      "type": "boolean"
	///    },
	///    "amfEeSubscriptionId": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "amfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "amfServiceNameDereg": {
	///      "$ref": "#/components/schemas/ServiceName"
	///    },
	///    "amfServiceNamePcscfRest": {
	///      "$ref": "#/components/schemas/ServiceName"
	///    },
	///    "backupAmfInfo": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/BackupAmfInfo"
	///      },
	///      "minItems": 1
	///    },
	///    "contextInfo": {
	///      "$ref": "#/components/schemas/ContextInfo"
	///    },
	///    "dataRestorationCallbackUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "deregCallbackUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "disasterRoamingInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "drFlag": {
	///      "$ref": "#/components/schemas/DualRegistrationFlag"
	///    },
	///    "emergencyRegistrationInd": {
	///      "type": "boolean"
	///    },
	///    "epsInterworkingInfo": {
	///      "$ref": "#/components/schemas/EpsInterworkingInfo"
	///    },
	///    "guami": {
	///      "$ref": "#/components/schemas/Guami"
	///    },
	///    "imsVoPs": {
	///      "$ref": "#/components/schemas/ImsVoPs"
	///    },
	///    "initialRegistrationInd": {
	///      "type": "boolean"
	///    },
	///    "lastSynchronizationTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "noEeSubscriptionInd": {
	///      "type": "boolean"
	///    },
	///    "pcscfRestorationCallbackUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "pei": {
	///      "$ref": "#/components/schemas/Pei"
	///    },
	///    "purgeFlag": {
	///      "$ref": "#/components/schemas/PurgeFlag"
	///    },
	///    "ratType": {
	///      "$ref": "#/components/schemas/RatType"
	///    },
	///    "reRegistrationRequired": {
	///      "type": "boolean"
	///    },
	///    "registrationTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "resetIds": {
	///      "type": "array",
	///      "items": {
	///        "type": "string"
	///      },
	///      "minItems": 1
	///    },
	///    "sorSnpnSiSupported": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "supi": {
	///      "$ref": "#/components/schemas/Supi"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "udrRestartInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "ueMINTCapability": {
	///      "type": "boolean"
	///    },
	///    "ueReachableInd": {
	///      "$ref": "#/components/schemas/UeReachableInd"
	///    },
	///    "ueSrvccCapability": {
	///      "type": "boolean"
	///    },
	///    "urrpIndicator": {
	///      "type": "boolean"
	///    },
	///    "vgmlcAddress": {
	///      "$ref": "#/components/schemas/VgmlcAddress"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Amf3GppAccessRegistration {
		#[serde(
			rename = "adminDeregSubWithdrawn",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub admin_dereg_sub_withdrawn: Option<bool>,
		#[serde(
			rename = "amfEeSubscriptionId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub amf_ee_subscription_id: Option<Uri>,
		#[serde(rename = "amfInstanceId")]
		pub amf_instance_id: NfInstanceId,
		#[serde(
			rename = "amfServiceNameDereg",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub amf_service_name_dereg: Option<ServiceName>,
		#[serde(
			rename = "amfServiceNamePcscfRest",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub amf_service_name_pcscf_rest: Option<ServiceName>,
		#[serde(
			rename = "backupAmfInfo",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub backup_amf_info: Vec<BackupAmfInfo>,
		#[serde(
			rename = "contextInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub context_info: Option<ContextInfo>,
		#[serde(
			rename = "dataRestorationCallbackUri",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub data_restoration_callback_uri: Option<Uri>,
		#[serde(rename = "deregCallbackUri")]
		pub dereg_callback_uri: Uri,
		#[serde(rename = "disasterRoamingInd", default)]
		pub disaster_roaming_ind: bool,
		#[serde(rename = "drFlag", default, skip_serializing_if = "Option::is_none")]
		pub dr_flag: Option<DualRegistrationFlag>,
		#[serde(
			rename = "emergencyRegistrationInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub emergency_registration_ind: Option<bool>,
		#[serde(
			rename = "epsInterworkingInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub eps_interworking_info: Option<EpsInterworkingInfo>,
		pub guami: Guami,
		#[serde(rename = "imsVoPs", default, skip_serializing_if = "Option::is_none")]
		pub ims_vo_ps: Option<ImsVoPs>,
		#[serde(
			rename = "initialRegistrationInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub initial_registration_ind: Option<bool>,
		#[serde(
			rename = "lastSynchronizationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub last_synchronization_time: Option<DateTime>,
		#[serde(
			rename = "noEeSubscriptionInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub no_ee_subscription_ind: Option<bool>,
		#[serde(
			rename = "pcscfRestorationCallbackUri",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pcscf_restoration_callback_uri: Option<Uri>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub pei: Option<Pei>,
		#[serde(rename = "purgeFlag", default, skip_serializing_if = "Option::is_none")]
		pub purge_flag: Option<PurgeFlag>,
		#[serde(rename = "ratType")]
		pub rat_type: RatType,
		#[serde(
			rename = "reRegistrationRequired",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub re_registration_required: Option<bool>,
		#[serde(
			rename = "registrationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub registration_time: Option<DateTime>,
		#[serde(rename = "resetIds", default, skip_serializing_if = "Vec::is_empty")]
		pub reset_ids: Vec<String>,
		#[serde(rename = "sorSnpnSiSupported", default)]
		pub sor_snpn_si_supported: bool,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub supi: Option<Supi>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
		#[serde(rename = "udrRestartInd", default)]
		pub udr_restart_ind: bool,
		#[serde(
			rename = "ueMINTCapability",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ue_mint_capability: Option<bool>,
		#[serde(
			rename = "ueReachableInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ue_reachable_ind: Option<UeReachableInd>,
		#[serde(
			rename = "ueSrvccCapability",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ue_srvcc_capability: Option<bool>,
		#[serde(
			rename = "urrpIndicator",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub urrp_indicator: Option<bool>,
		#[serde(
			rename = "vgmlcAddress",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub vgmlc_address: Option<VgmlcAddress>,
	}

	impl From<&Amf3GppAccessRegistration> for Amf3GppAccessRegistration {
		fn from(value: &Amf3GppAccessRegistration) -> Self {
			value.clone()
		}
	}

	/// Amf3GppAccessRegistrationModification
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "guami"
	///  ],
	///  "properties": {
	///    "backupAmfInfo": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/BackupAmfInfo"
	///      }
	///    },
	///    "epsInterworkingInfo": {
	///      "$ref": "#/components/schemas/EpsInterworkingInfo"
	///    },
	///    "guami": {
	///      "$ref": "#/components/schemas/Guami"
	///    },
	///    "imsVoPs": {
	///      "$ref": "#/components/schemas/ImsVoPs"
	///    },
	///    "pei": {
	///      "$ref": "#/components/schemas/Pei"
	///    },
	///    "purgeFlag": {
	///      "$ref": "#/components/schemas/PurgeFlag"
	///    },
	///    "ueMINTCapability": {
	///      "type": "boolean"
	///    },
	///    "ueSrvccCapability": {
	///      "type": [
	///        "boolean",
	///        "null"
	///      ]
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Amf3GppAccessRegistrationModification {
		#[serde(
			rename = "backupAmfInfo",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub backup_amf_info: Vec<BackupAmfInfo>,
		#[serde(
			rename = "epsInterworkingInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub eps_interworking_info: Option<EpsInterworkingInfo>,
		pub guami: Guami,
		#[serde(rename = "imsVoPs", default, skip_serializing_if = "Option::is_none")]
		pub ims_vo_ps: Option<ImsVoPs>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub pei: Option<Pei>,
		#[serde(rename = "purgeFlag", default, skip_serializing_if = "Option::is_none")]
		pub purge_flag: Option<PurgeFlag>,
		#[serde(
			rename = "ueMINTCapability",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ue_mint_capability: Option<bool>,
		#[serde(
			rename = "ueSrvccCapability",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ue_srvcc_capability: Option<bool>,
	}

	impl From<&Amf3GppAccessRegistrationModification> for Amf3GppAccessRegistrationModification {
		fn from(value: &Amf3GppAccessRegistrationModification) -> Self {
			value.clone()
		}
	}

	/// AmfDeregInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "deregReason"
	///  ],
	///  "properties": {
	///    "deregReason": {
	///      "$ref": "#/components/schemas/DeregistrationReason"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AmfDeregInfo {
		#[serde(rename = "deregReason")]
		pub dereg_reason: DeregistrationReason,
	}

	impl From<&AmfDeregInfo> for AmfDeregInfo {
		fn from(value: &AmfDeregInfo) -> Self {
			value.clone()
		}
	}

	/// String identifying the AMF ID composed of AMF Region ID (8 bits), AMF
	/// Set ID (10 bits) and AMF  Pointer (6 bits) as specified in clause 2.10.1
	/// of 3GPP TS 23.003. It is encoded as a string of  6 hexadecimal
	/// characters (i.e., 24 bits).
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String identifying the AMF ID composed of AMF Region ID
	/// (8 bits), AMF Set ID (10 bits) and AMF  Pointer (6 bits) as specified in
	/// clause 2.10.1 of 3GPP TS 23.003. It is encoded as a string of  6
	/// hexadecimal characters (i.e., 24 bits). \n",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{6}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct AmfId(String);
	impl ::std::ops::Deref for AmfId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<AmfId> for String {
		fn from(value: AmfId) -> Self {
			value.0
		}
	}

	impl From<&AmfId> for AmfId {
		fn from(value: &AmfId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for AmfId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{6}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{6}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for AmfId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for AmfId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for AmfId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for AmfId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// AmfInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "amfInstanceId",
	///    "guami"
	///  ],
	///  "properties": {
	///    "accessType": {
	///      "$ref": "#/components/schemas/AccessType"
	///    },
	///    "amfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "guami": {
	///      "$ref": "#/components/schemas/Guami"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AmfInfo {
		#[serde(
			rename = "accessType",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub access_type: Option<AccessType>,
		#[serde(rename = "amfInstanceId")]
		pub amf_instance_id: NfInstanceId,
		pub guami: Guami,
	}

	impl From<&AmfInfo> for AmfInfo {
		fn from(value: &AmfInfo) -> Self {
			value.clone()
		}
	}

	/// AmfNon3GppAccessRegistration
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "amfInstanceId",
	///    "deregCallbackUri",
	///    "guami",
	///    "imsVoPs",
	///    "ratType"
	///  ],
	///  "properties": {
	///    "adminDeregSubWithdrawn": {
	///      "type": "boolean"
	///    },
	///    "amfEeSubscriptionId": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "amfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "amfServiceNameDereg": {
	///      "$ref": "#/components/schemas/ServiceName"
	///    },
	///    "amfServiceNamePcscfRest": {
	///      "$ref": "#/components/schemas/ServiceName"
	///    },
	///    "backupAmfInfo": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/BackupAmfInfo"
	///      },
	///      "minItems": 1
	///    },
	///    "contextInfo": {
	///      "$ref": "#/components/schemas/ContextInfo"
	///    },
	///    "dataRestorationCallbackUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "deregCallbackUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "disasterRoamingInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "guami": {
	///      "$ref": "#/components/schemas/Guami"
	///    },
	///    "imsVoPs": {
	///      "$ref": "#/components/schemas/ImsVoPs"
	///    },
	///    "lastSynchronizationTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "noEeSubscriptionInd": {
	///      "type": "boolean"
	///    },
	///    "pcscfRestorationCallbackUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "pei": {
	///      "$ref": "#/components/schemas/Pei"
	///    },
	///    "purgeFlag": {
	///      "$ref": "#/components/schemas/PurgeFlag"
	///    },
	///    "ratType": {
	///      "$ref": "#/components/schemas/RatType"
	///    },
	///    "reRegistrationRequired": {
	///      "type": "boolean"
	///    },
	///    "registrationTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "resetIds": {
	///      "type": "array",
	///      "items": {
	///        "type": "string"
	///      },
	///      "minItems": 1
	///    },
	///    "sorSnpnSiSupported": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "supi": {
	///      "$ref": "#/components/schemas/Supi"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "udrRestartInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "urrpIndicator": {
	///      "type": "boolean"
	///    },
	///    "vgmlcAddress": {
	///      "$ref": "#/components/schemas/VgmlcAddress"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AmfNon3GppAccessRegistration {
		#[serde(
			rename = "adminDeregSubWithdrawn",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub admin_dereg_sub_withdrawn: Option<bool>,
		#[serde(
			rename = "amfEeSubscriptionId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub amf_ee_subscription_id: Option<Uri>,
		#[serde(rename = "amfInstanceId")]
		pub amf_instance_id: NfInstanceId,
		#[serde(
			rename = "amfServiceNameDereg",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub amf_service_name_dereg: Option<ServiceName>,
		#[serde(
			rename = "amfServiceNamePcscfRest",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub amf_service_name_pcscf_rest: Option<ServiceName>,
		#[serde(
			rename = "backupAmfInfo",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub backup_amf_info: Vec<BackupAmfInfo>,
		#[serde(
			rename = "contextInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub context_info: Option<ContextInfo>,
		#[serde(
			rename = "dataRestorationCallbackUri",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub data_restoration_callback_uri: Option<Uri>,
		#[serde(rename = "deregCallbackUri")]
		pub dereg_callback_uri: Uri,
		#[serde(rename = "disasterRoamingInd", default)]
		pub disaster_roaming_ind: bool,
		pub guami: Guami,
		#[serde(rename = "imsVoPs")]
		pub ims_vo_ps: ImsVoPs,
		#[serde(
			rename = "lastSynchronizationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub last_synchronization_time: Option<DateTime>,
		#[serde(
			rename = "noEeSubscriptionInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub no_ee_subscription_ind: Option<bool>,
		#[serde(
			rename = "pcscfRestorationCallbackUri",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pcscf_restoration_callback_uri: Option<Uri>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub pei: Option<Pei>,
		#[serde(rename = "purgeFlag", default, skip_serializing_if = "Option::is_none")]
		pub purge_flag: Option<PurgeFlag>,
		#[serde(rename = "ratType")]
		pub rat_type: RatType,
		#[serde(
			rename = "reRegistrationRequired",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub re_registration_required: Option<bool>,
		#[serde(
			rename = "registrationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub registration_time: Option<DateTime>,
		#[serde(rename = "resetIds", default, skip_serializing_if = "Vec::is_empty")]
		pub reset_ids: Vec<String>,
		#[serde(rename = "sorSnpnSiSupported", default)]
		pub sor_snpn_si_supported: bool,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub supi: Option<Supi>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
		#[serde(rename = "udrRestartInd", default)]
		pub udr_restart_ind: bool,
		#[serde(
			rename = "urrpIndicator",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub urrp_indicator: Option<bool>,
		#[serde(
			rename = "vgmlcAddress",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub vgmlc_address: Option<VgmlcAddress>,
	}

	impl From<&AmfNon3GppAccessRegistration> for AmfNon3GppAccessRegistration {
		fn from(value: &AmfNon3GppAccessRegistration) -> Self {
			value.clone()
		}
	}

	/// AmfNon3GppAccessRegistrationModification
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "guami"
	///  ],
	///  "properties": {
	///    "backupAmfInfo": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/BackupAmfInfo"
	///      }
	///    },
	///    "guami": {
	///      "$ref": "#/components/schemas/Guami"
	///    },
	///    "imsVoPs": {
	///      "$ref": "#/components/schemas/ImsVoPs"
	///    },
	///    "pei": {
	///      "$ref": "#/components/schemas/Pei"
	///    },
	///    "purgeFlag": {
	///      "$ref": "#/components/schemas/PurgeFlag"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AmfNon3GppAccessRegistrationModification {
		#[serde(
			rename = "backupAmfInfo",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub backup_amf_info: Vec<BackupAmfInfo>,
		pub guami: Guami,
		#[serde(rename = "imsVoPs", default, skip_serializing_if = "Option::is_none")]
		pub ims_vo_ps: Option<ImsVoPs>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub pei: Option<Pei>,
		#[serde(rename = "purgeFlag", default, skip_serializing_if = "Option::is_none")]
		pub purge_flag: Option<PurgeFlag>,
	}

	impl From<&AmfNon3GppAccessRegistrationModification> for AmfNon3GppAccessRegistrationModification {
		fn from(value: &AmfNon3GppAccessRegistrationModification) -> Self {
			value.clone()
		}
	}

	/// Indicates value of angle.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates value of angle.",
	///  "type": "integer",
	///  "maximum": 360.0,
	///  "minimum": 0.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Angle(pub i64);
	impl ::std::ops::Deref for Angle {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<Angle> for i64 {
		fn from(value: Angle) -> Self {
			value.0
		}
	}

	impl From<&Angle> for Angle {
		fn from(value: &Angle) -> Self {
			value.clone()
		}
	}

	impl From<i64> for Angle {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for Angle {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for Angle {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for Angle {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for Angle {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for Angle {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// AppDescriptor
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "appId": {
	///      "type": "string"
	///    },
	///    "osId": {
	///      "$ref": "#/components/schemas/OsId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AppDescriptor {
		#[serde(rename = "appId", default, skip_serializing_if = "Option::is_none")]
		pub app_id: Option<String>,
		#[serde(rename = "osId", default, skip_serializing_if = "Option::is_none")]
		pub os_id: Option<OsId>,
	}

	impl From<&AppDescriptor> for AppDescriptor {
		fn from(value: &AppDescriptor) -> Self {
			value.clone()
		}
	}

	/// AppPortId
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "destinationPort": {
	///      "$ref": "#/components/schemas/Uint16"
	///    },
	///    "originatorPort": {
	///      "$ref": "#/components/schemas/Uint16"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AppPortId {
		#[serde(
			rename = "destinationPort",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub destination_port: Option<Uint16>,
		#[serde(
			rename = "originatorPort",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub originator_port: Option<Uint16>,
	}

	impl From<&AppPortId> for AppPortId {
		fn from(value: &AppPortId) -> Self {
			value.clone()
		}
	}

	/// Provides area information.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Provides area information.",
	///  "type": "object",
	///  "oneOf": [
	///    {
	///      "required": [
	///        "tacs"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "areaCode"
	///      ]
	///    }
	///  ],
	///  "properties": {
	///    "areaCode": {
	///      "$ref": "#/components/schemas/AreaCode"
	///    },
	///    "tacs": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Tac"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum Area {
		#[default]
		Variant0 { tacs: Vec<Tac> },
		Variant1 {
			#[serde(rename = "areaCode")]
			area_code: AreaCode,
		},
	}

	impl From<&Area> for Area {
		fn from(value: &Area) -> Self {
			value.clone()
		}
	}

	/// Values are operator specific.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Values are operator specific.",
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct AreaCode(pub String);
	impl ::std::ops::Deref for AreaCode {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<AreaCode> for String {
		fn from(value: AreaCode) -> Self {
			value.0
		}
	}

	impl From<&AreaCode> for AreaCode {
		fn from(value: &AreaCode) -> Self {
			value.clone()
		}
	}

	impl From<String> for AreaCode {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for AreaCode {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for AreaCode {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Contain the area based on Cells or Tracking Areas.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contain the area based on Cells or Tracking Areas.",
	///  "type": "object",
	///  "properties": {
	///    "eutraCellIdList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/EutraCellId"
	///      },
	///      "minItems": 1
	///    },
	///    "nrCellIdList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/NrCellId"
	///      },
	///      "minItems": 1
	///    },
	///    "tacInfoPerPlmn": {
	///      "description": "A map (list of key-value pairs) where PlmnId
	/// converted to a string serves as key\n",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/TacInfo"
	///      }
	///    },
	///    "tacList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Tac"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AreaScope {
		#[serde(
			rename = "eutraCellIdList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub eutra_cell_id_list: Vec<EutraCellId>,
		#[serde(
			rename = "nrCellIdList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub nr_cell_id_list: Vec<NrCellId>,
		/// A map (list of key-value pairs) where PlmnId converted to a string
		/// serves as key
		#[serde(
			rename = "tacInfoPerPlmn",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub tac_info_per_plmn: ::std::collections::HashMap<String, TacInfo>,
		#[serde(rename = "tacList", default, skip_serializing_if = "Vec::is_empty")]
		pub tac_list: Vec<Tac>,
	}

	impl From<&AreaScope> for AreaScope {
		fn from(value: &AreaScope) -> Self {
			value.clone()
		}
	}

	/// Integer value indicating the ARFCN applicable for a downlink, uplink or
	/// bi-directional (TDD) NR global frequency raster, as definition of
	/// "ARFCN-ValueNR" IE in clause 6.3.2 of 3GPP TS 38.331.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Integer value indicating the ARFCN applicable for a
	/// downlink, uplink or bi-directional (TDD) NR global frequency raster, as
	/// definition of \"ARFCN-ValueNR\" IE in clause 6.3.2 of 3GPP TS
	/// 38.331.\n",
	///  "type": "integer",
	///  "maximum": 3279165.0,
	///  "minimum": 0.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ArfcnValueNr(pub i64);
	impl ::std::ops::Deref for ArfcnValueNr {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<ArfcnValueNr> for i64 {
		fn from(value: ArfcnValueNr) -> Self {
			value.0
		}
	}

	impl From<&ArfcnValueNr> for ArfcnValueNr {
		fn from(value: &ArfcnValueNr) -> Self {
			value.clone()
		}
	}

	impl From<i64> for ArfcnValueNr {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for ArfcnValueNr {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for ArfcnValueNr {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for ArfcnValueNr {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for ArfcnValueNr {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for ArfcnValueNr {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Contains Allocation and Retention Priority information.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains Allocation and Retention Priority
	/// information.",
	///  "type": "object",
	///  "required": [
	///    "preemptCap",
	///    "preemptVuln",
	///    "priorityLevel"
	///  ],
	///  "properties": {
	///    "preemptCap": {
	///      "$ref": "#/components/schemas/PreemptionCapability"
	///    },
	///    "preemptVuln": {
	///      "$ref": "#/components/schemas/PreemptionVulnerability"
	///    },
	///    "priorityLevel": {
	///      "$ref": "#/components/schemas/ArpPriorityLevel"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Arp {
		#[serde(rename = "preemptCap")]
		pub preempt_cap: PreemptionCapability,
		#[serde(rename = "preemptVuln")]
		pub preempt_vuln: PreemptionVulnerability,
		#[serde(rename = "priorityLevel")]
		pub priority_level: ArpPriorityLevel,
	}

	impl From<&Arp> for Arp {
		fn from(value: &Arp) -> Self {
			value.clone()
		}
	}

	/// nullable true shall not be used for this attribute. Unsigned integer
	/// indicating the ARP Priority Level (see clause 5.7.2.2 of 3GPP TS 23.501,
	/// within the range 1 to 15.Values are ordered in decreasing order of
	/// priority, i.e. with 1 as the highest priority and 15 as the lowest
	/// priority.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "nullable true shall not be used for this attribute.
	/// Unsigned integer indicating the ARP Priority Level (see clause 5.7.2.2
	/// of 3GPP TS 23.501, within the range 1 to 15.Values are ordered in
	/// decreasing order of priority, i.e. with 1 as the highest priority and 15
	/// as the lowest priority. \n",
	///  "type": [
	///    "integer",
	///    "null"
	///  ],
	///  "maximum": 15.0,
	///  "minimum": 1.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ArpPriorityLevel(pub Option<i64>);
	impl ::std::ops::Deref for ArpPriorityLevel {
		type Target = Option<i64>;
		fn deref(&self) -> &Option<i64> {
			&self.0
		}
	}

	impl From<ArpPriorityLevel> for Option<i64> {
		fn from(value: ArpPriorityLevel) -> Self {
			value.0
		}
	}

	impl From<&ArpPriorityLevel> for ArpPriorityLevel {
		fn from(value: &ArpPriorityLevel) -> Self {
			value.clone()
		}
	}

	impl From<Option<i64>> for ArpPriorityLevel {
		fn from(value: Option<i64>) -> Self {
			Self(value)
		}
	}

	/// AssociationType
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "IMEI_CHANGE",
	///    "IMEISV_CHANGE"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum AssociationType {
		#[default]
		#[serde(rename = "IMEI_CHANGE")]
		ImeiChange,
		#[serde(rename = "IMEISV_CHANGE")]
		ImeisvChange,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&AssociationType> for AssociationType {
		fn from(value: &AssociationType) -> Self {
			value.clone()
		}
	}

	impl ToString for AssociationType {
		fn to_string(&self) -> String {
			match *self {
				Self::ImeiChange => "IMEI_CHANGE".to_string(),
				Self::ImeisvChange => "IMEISV_CHANGE".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for AssociationType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"IMEI_CHANGE" => Ok(Self::ImeiChange),
				"IMEISV_CHANGE" => Ok(Self::ImeisvChange),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for AssociationType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for AssociationType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for AssociationType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// AuthEvent
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "authType",
	///    "nfInstanceId",
	///    "servingNetworkName",
	///    "success",
	///    "timeStamp"
	///  ],
	///  "properties": {
	///    "authRemovalInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "authType": {
	///      "$ref": "#/components/schemas/AuthType"
	///    },
	///    "dataRestorationCallbackUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "nfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "nfSetId": {
	///      "$ref": "#/components/schemas/NfSetId"
	///    },
	///    "resetIds": {
	///      "type": "array",
	///      "items": {
	///        "type": "string"
	///      },
	///      "minItems": 1
	///    },
	///    "servingNetworkName": {
	///      "$ref": "#/components/schemas/ServingNetworkName"
	///    },
	///    "success": {
	///      "$ref": "#/components/schemas/Success"
	///    },
	///    "timeStamp": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "udrRestartInd": {
	///      "default": false,
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AuthEvent {
		#[serde(rename = "authRemovalInd", default)]
		pub auth_removal_ind: bool,
		#[serde(rename = "authType")]
		pub auth_type: AuthType,
		#[serde(
			rename = "dataRestorationCallbackUri",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub data_restoration_callback_uri: Option<Uri>,
		#[serde(rename = "nfInstanceId")]
		pub nf_instance_id: NfInstanceId,
		#[serde(rename = "nfSetId", default, skip_serializing_if = "Option::is_none")]
		pub nf_set_id: Option<NfSetId>,
		#[serde(rename = "resetIds", default, skip_serializing_if = "Vec::is_empty")]
		pub reset_ids: Vec<String>,
		#[serde(rename = "servingNetworkName")]
		pub serving_network_name: ServingNetworkName,
		pub success: Success,
		#[serde(rename = "timeStamp")]
		pub time_stamp: DateTime,
		#[serde(rename = "udrRestartInd", default)]
		pub udr_restart_ind: bool,
	}

	impl From<&AuthEvent> for AuthEvent {
		fn from(value: &AuthEvent) -> Self {
			value.clone()
		}
	}

	/// AuthType
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "5G_AKA",
	///    "EAP_AKA_PRIME",
	///    "EAP_TLS",
	///    "NONE",
	///    "EAP_TTLS"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum AuthType {
		#[default]
		#[serde(rename = "5G_AKA")]
		FiveGAka,
		#[serde(rename = "EAP_AKA_PRIME")]
		EapAkaPrime,
		#[serde(rename = "EAP_TLS")]
		EapTls,
		#[serde(rename = "NONE")]
		None,
		#[serde(rename = "EAP_TTLS")]
		EapTtls,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&AuthType> for AuthType {
		fn from(value: &AuthType) -> Self {
			value.clone()
		}
	}

	impl ToString for AuthType {
		fn to_string(&self) -> String {
			match *self {
				Self::FiveGAka => "5G_AKA".to_string(),
				Self::EapAkaPrime => "EAP_AKA_PRIME".to_string(),
				Self::EapTls => "EAP_TLS".to_string(),
				Self::None => "NONE".to_string(),
				Self::EapTtls => "EAP_TTLS".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for AuthType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"5G_AKA" => Ok(Self::FiveGAka),
				"EAP_AKA_PRIME" => Ok(Self::EapAkaPrime),
				"EAP_TLS" => Ok(Self::EapTls),
				"NONE" => Ok(Self::None),
				"EAP_TTLS" => Ok(Self::EapTtls),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for AuthType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for AuthType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for AuthType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Represents authorization update information.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents authorization update information.",
	///  "type": "object",
	///  "required": [
	///    "authorizationData"
	///  ],
	///  "properties": {
	///    "authorizationData": {
	///      "$ref": "#/components/schemas/ServiceSpecificAuthorizationData"
	///    },
	///    "invalidCause": {
	///      "$ref": "#/components/schemas/InvalidCause"
	///    },
	///    "invalidityInd": {
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AuthUpdateInfo {
		#[serde(rename = "authorizationData")]
		pub authorization_data: ServiceSpecificAuthorizationData,
		#[serde(
			rename = "invalidCause",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub invalid_cause: Option<InvalidCause>,
		#[serde(
			rename = "invalidityInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub invalidity_ind: Option<bool>,
	}

	impl From<&AuthUpdateInfo> for AuthUpdateInfo {
		fn from(value: &AuthUpdateInfo) -> Self {
			value.clone()
		}
	}

	/// Represents an authorization update notification.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents an authorization update notification.",
	///  "type": "object",
	///  "required": [
	///    "authUpdateInfoList",
	///    "serviceType"
	///  ],
	///  "properties": {
	///    "afId": {
	///      "type": "string"
	///    },
	///    "authUpdateInfoList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/AuthUpdateInfo"
	///      },
	///      "minItems": 1
	///    },
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "serviceType": {
	///      "$ref": "#/components/schemas/ServiceType"
	///    },
	///    "snssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AuthUpdateNotification {
		#[serde(rename = "afId", default, skip_serializing_if = "Option::is_none")]
		pub af_id: Option<String>,
		#[serde(rename = "authUpdateInfoList")]
		pub auth_update_info_list: Vec<AuthUpdateInfo>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub dnn: Option<Dnn>,
		#[serde(
			rename = "mtcProviderInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mtc_provider_information: Option<MtcProviderInformation>,
		#[serde(rename = "serviceType")]
		pub service_type: ServiceType,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub snssai: Option<Snssai>,
	}

	impl From<&AuthUpdateNotification> for AuthUpdateNotification {
		fn from(value: &AuthUpdateNotification) -> Self {
			value.clone()
		}
	}

	/// AuthenticatedInd
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "boolean"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AuthenticatedInd(pub bool);
	impl ::std::ops::Deref for AuthenticatedInd {
		type Target = bool;
		fn deref(&self) -> &bool {
			&self.0
		}
	}

	impl From<AuthenticatedInd> for bool {
		fn from(value: AuthenticatedInd) -> Self {
			value.0
		}
	}

	impl From<&AuthenticatedInd> for AuthenticatedInd {
		fn from(value: &AuthenticatedInd) -> Self {
			value.clone()
		}
	}

	impl From<bool> for AuthenticatedInd {
		fn from(value: bool) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for AuthenticatedInd {
		type Err = <bool as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for AuthenticatedInd {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for AuthenticatedInd {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for AuthenticatedInd {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for AuthenticatedInd {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// AuthenticationInfoRequest
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "ausfInstanceId",
	///    "servingNetworkName"
	///  ],
	///  "properties": {
	///    "ausfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "cellCagInfo": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/CagId"
	///      },
	///      "minItems": 1
	///    },
	///    "disasterRoamingInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "n5gcInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "nswoInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "resynchronizationInfo": {
	///      "$ref": "#/components/schemas/ResynchronizationInfo"
	///    },
	///    "servingNetworkName": {
	///      "$ref": "#/components/schemas/ServingNetworkName"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AuthenticationInfoRequest {
		#[serde(rename = "ausfInstanceId")]
		pub ausf_instance_id: NfInstanceId,
		#[serde(rename = "cellCagInfo", default, skip_serializing_if = "Vec::is_empty")]
		pub cell_cag_info: Vec<CagId>,
		#[serde(rename = "disasterRoamingInd", default)]
		pub disaster_roaming_ind: bool,
		#[serde(rename = "n5gcInd", default)]
		pub n5gc_ind: bool,
		#[serde(rename = "nswoInd", default)]
		pub nswo_ind: bool,
		#[serde(
			rename = "resynchronizationInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub resynchronization_info: Option<ResynchronizationInfo>,
		#[serde(rename = "servingNetworkName")]
		pub serving_network_name: ServingNetworkName,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&AuthenticationInfoRequest> for AuthenticationInfoRequest {
		fn from(value: &AuthenticationInfoRequest) -> Self {
			value.clone()
		}
	}

	/// AuthenticationInfoResult
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "authType"
	///  ],
	///  "properties": {
	///    "akmaInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "authAaa": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "authType": {
	///      "$ref": "#/components/schemas/AuthType"
	///    },
	///    "authenticationVector": {
	///      "$ref": "#/components/schemas/AuthenticationVector"
	///    },
	///    "pvsInfo": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/ServerAddressingInfo"
	///      },
	///      "minItems": 1
	///    },
	///    "routingId": {
	///      "type": "string",
	///      "pattern": "^[0-9]{1,4}$"
	///    },
	///    "supi": {
	///      "$ref": "#/components/schemas/Supi"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AuthenticationInfoResult {
		#[serde(rename = "akmaInd", default)]
		pub akma_ind: bool,
		#[serde(rename = "authAaa", default)]
		pub auth_aaa: bool,
		#[serde(rename = "authType")]
		pub auth_type: AuthType,
		#[serde(
			rename = "authenticationVector",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub authentication_vector: Option<AuthenticationVector>,
		#[serde(rename = "pvsInfo", default, skip_serializing_if = "Vec::is_empty")]
		pub pvs_info: Vec<ServerAddressingInfo>,
		#[serde(rename = "routingId", default, skip_serializing_if = "Option::is_none")]
		pub routing_id: Option<AuthenticationInfoResultRoutingId>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub supi: Option<Supi>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&AuthenticationInfoResult> for AuthenticationInfoResult {
		fn from(value: &AuthenticationInfoResult) -> Self {
			value.clone()
		}
	}

	/// AuthenticationInfoResultRoutingId
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[0-9]{1,4}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct AuthenticationInfoResultRoutingId(String);
	impl ::std::ops::Deref for AuthenticationInfoResultRoutingId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<AuthenticationInfoResultRoutingId> for String {
		fn from(value: AuthenticationInfoResultRoutingId) -> Self {
			value.0
		}
	}

	impl From<&AuthenticationInfoResultRoutingId> for AuthenticationInfoResultRoutingId {
		fn from(value: &AuthenticationInfoResultRoutingId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for AuthenticationInfoResultRoutingId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9]{1,4}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9]{1,4}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for AuthenticationInfoResultRoutingId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for AuthenticationInfoResultRoutingId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for AuthenticationInfoResultRoutingId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for AuthenticationInfoResultRoutingId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// AuthenticationVector
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "oneOf": [
	///    {
	///      "$ref": "#/components/schemas/AvEapAkaPrime"
	///    },
	///    {
	///      "$ref": "#/components/schemas/Av5GHeAka"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum AuthenticationVector {
		#[default]
		AvEapAkaPrime(AvEapAkaPrime),
		Av5GHeAka(Av5GHeAka),
	}

	impl From<&AuthenticationVector> for AuthenticationVector {
		fn from(value: &AuthenticationVector) -> Self {
			value.clone()
		}
	}

	impl From<AvEapAkaPrime> for AuthenticationVector {
		fn from(value: AvEapAkaPrime) -> Self {
			Self::AvEapAkaPrime(value)
		}
	}

	impl From<Av5GHeAka> for AuthenticationVector {
		fn from(value: Av5GHeAka) -> Self {
			Self::Av5GHeAka(value)
		}
	}

	/// Represents NIDD authorization data.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents NIDD authorization data.",
	///  "type": "object",
	///  "required": [
	///    "authorizationData"
	///  ],
	///  "properties": {
	///    "authorizationData": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/UserIdentifier"
	///      },
	///      "minItems": 1,
	///      "uniqueItems": true
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AuthorizationData {
		#[serde(rename = "authorizationData")]
		pub authorization_data: Vec<UserIdentifier>,
		#[serde(
			rename = "validityTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub validity_time: Option<DateTime>,
	}

	impl From<&AuthorizationData> for AuthorizationData {
		fn from(value: &AuthorizationData) -> Self {
			value.clone()
		}
	}

	/// Represents NIDD authorization information.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents NIDD authorization information.",
	///  "type": "object",
	///  "required": [
	///    "authUpdateCallbackUri",
	///    "dnn",
	///    "mtcProviderInformation",
	///    "snssai"
	///  ],
	///  "properties": {
	///    "afId": {
	///      "type": "string"
	///    },
	///    "authUpdateCallbackUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "contextInfo": {
	///      "$ref": "#/components/schemas/ContextInfo"
	///    },
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "nefId": {
	///      "$ref": "#/components/schemas/NefId"
	///    },
	///    "snssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AuthorizationInfo {
		#[serde(rename = "afId", default, skip_serializing_if = "Option::is_none")]
		pub af_id: Option<String>,
		#[serde(rename = "authUpdateCallbackUri")]
		pub auth_update_callback_uri: Uri,
		#[serde(
			rename = "contextInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub context_info: Option<ContextInfo>,
		pub dnn: Dnn,
		#[serde(rename = "mtcProviderInformation")]
		pub mtc_provider_information: MtcProviderInformation,
		#[serde(rename = "nefId", default, skip_serializing_if = "Option::is_none")]
		pub nef_id: Option<NefId>,
		pub snssai: Snssai,
		#[serde(
			rename = "validityTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub validity_time: Option<DateTime>,
	}

	impl From<&AuthorizationInfo> for AuthorizationInfo {
		fn from(value: &AuthorizationInfo) -> Self {
			value.clone()
		}
	}

	/// UE Id of the Authorization Data.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "UE Id of the Authorization Data.",
	///  "type": "object",
	///  "required": [
	///    "supi"
	///  ],
	///  "properties": {
	///    "gpsi": {
	///      "$ref": "#/components/schemas/Gpsi"
	///    },
	///    "supi": {
	///      "$ref": "#/components/schemas/Supi"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AuthorizationUeId {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub gpsi: Option<Gpsi>,
		pub supi: Supi,
	}

	impl From<&AuthorizationUeId> for AuthorizationUeId {
		fn from(value: &AuthorizationUeId) -> Self {
			value.clone()
		}
	}

	/// Autn
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{32}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Autn(String);
	impl ::std::ops::Deref for Autn {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Autn> for String {
		fn from(value: Autn) -> Self {
			value.0
		}
	}

	impl From<&Autn> for Autn {
		fn from(value: &Autn) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Autn {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{32}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{32}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Autn {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Autn {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Autn {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Autn {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Auts
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{28}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Auts(String);
	impl ::std::ops::Deref for Auts {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Auts> for String {
		fn from(value: Auts) -> Self {
			value.0
		}
	}

	impl From<&Auts> for Auts {
		fn from(value: &Auts) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Auts {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{28}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{28}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Auts {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Auts {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Auts {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Auts {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Av5GHeAka
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "autn",
	///    "avType",
	///    "kausf",
	///    "rand",
	///    "xresStar"
	///  ],
	///  "properties": {
	///    "autn": {
	///      "$ref": "#/components/schemas/Autn"
	///    },
	///    "avType": {
	///      "$ref": "#/components/schemas/AvType"
	///    },
	///    "kausf": {
	///      "$ref": "#/components/schemas/Kausf"
	///    },
	///    "rand": {
	///      "$ref": "#/components/schemas/Rand"
	///    },
	///    "xresStar": {
	///      "$ref": "#/components/schemas/XresStar"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Av5GHeAka {
		pub autn: Autn,
		#[serde(rename = "avType")]
		pub av_type: AvType,
		pub kausf: Kausf,
		pub rand: Rand,
		#[serde(rename = "xresStar")]
		pub xres_star: XresStar,
	}

	impl From<&Av5GHeAka> for Av5GHeAka {
		fn from(value: &Av5GHeAka) -> Self {
			value.clone()
		}
	}

	/// AvEapAkaPrime
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "autn",
	///    "avType",
	///    "ckPrime",
	///    "ikPrime",
	///    "rand",
	///    "xres"
	///  ],
	///  "properties": {
	///    "autn": {
	///      "$ref": "#/components/schemas/Autn"
	///    },
	///    "avType": {
	///      "$ref": "#/components/schemas/AvType"
	///    },
	///    "ckPrime": {
	///      "$ref": "#/components/schemas/CkPrime"
	///    },
	///    "ikPrime": {
	///      "$ref": "#/components/schemas/IkPrime"
	///    },
	///    "rand": {
	///      "$ref": "#/components/schemas/Rand"
	///    },
	///    "xres": {
	///      "$ref": "#/components/schemas/Xres"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AvEapAkaPrime {
		pub autn: Autn,
		#[serde(rename = "avType")]
		pub av_type: AvType,
		#[serde(rename = "ckPrime")]
		pub ck_prime: CkPrime,
		#[serde(rename = "ikPrime")]
		pub ik_prime: IkPrime,
		pub rand: Rand,
		pub xres: Xres,
	}

	impl From<&AvEapAkaPrime> for AvEapAkaPrime {
		fn from(value: &AvEapAkaPrime) -> Self {
			value.clone()
		}
	}

	/// AvEpsAka
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "autn",
	///    "avType",
	///    "kasme",
	///    "rand",
	///    "xres"
	///  ],
	///  "properties": {
	///    "autn": {
	///      "$ref": "#/components/schemas/Autn"
	///    },
	///    "avType": {
	///      "$ref": "#/components/schemas/HssAvType"
	///    },
	///    "kasme": {
	///      "$ref": "#/components/schemas/Kasme"
	///    },
	///    "rand": {
	///      "$ref": "#/components/schemas/Rand"
	///    },
	///    "xres": {
	///      "$ref": "#/components/schemas/Xres"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AvEpsAka {
		pub autn: Autn,
		#[serde(rename = "avType")]
		pub av_type: HssAvType,
		pub kasme: Kasme,
		pub rand: Rand,
		pub xres: Xres,
	}

	impl From<&AvEpsAka> for AvEpsAka {
		fn from(value: &AvEpsAka) -> Self {
			value.clone()
		}
	}

	/// AvImsGbaEapAka
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "autn",
	///    "avType",
	///    "ck",
	///    "ik",
	///    "rand",
	///    "xres"
	///  ],
	///  "properties": {
	///    "autn": {
	///      "$ref": "#/components/schemas/Autn"
	///    },
	///    "avType": {
	///      "$ref": "#/components/schemas/HssAvType"
	///    },
	///    "ck": {
	///      "$ref": "#/components/schemas/ConfidentialityKey"
	///    },
	///    "ik": {
	///      "$ref": "#/components/schemas/IntegrityKey"
	///    },
	///    "rand": {
	///      "$ref": "#/components/schemas/Rand"
	///    },
	///    "xres": {
	///      "$ref": "#/components/schemas/Xres"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct AvImsGbaEapAka {
		pub autn: Autn,
		#[serde(rename = "avType")]
		pub av_type: HssAvType,
		pub ck: ConfidentialityKey,
		pub ik: IntegrityKey,
		pub rand: Rand,
		pub xres: Xres,
	}

	impl From<&AvImsGbaEapAka> for AvImsGbaEapAka {
		fn from(value: &AvImsGbaEapAka) -> Self {
			value.clone()
		}
	}

	/// AvType
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "5G_HE_AKA",
	///    "EAP_AKA_PRIME"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum AvType {
		#[default]
		#[serde(rename = "5G_HE_AKA")]
		FiveGHeAka,
		#[serde(rename = "EAP_AKA_PRIME")]
		EapAkaPrime,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&AvType> for AvType {
		fn from(value: &AvType) -> Self {
			value.clone()
		}
	}

	impl ToString for AvType {
		fn to_string(&self) -> String {
			match *self {
				Self::FiveGHeAka => "5G_HE_AKA".to_string(),
				Self::EapAkaPrime => "EAP_AKA_PRIME".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for AvType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"5G_HE_AKA" => Ok(Self::FiveGHeAka),
				"EAP_AKA_PRIME" => Ok(Self::EapAkaPrime),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for AvType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for AvType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for AvType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Provides details of the Backup AMF.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Provides details of the Backup AMF.",
	///  "type": "object",
	///  "required": [
	///    "backupAmf"
	///  ],
	///  "properties": {
	///    "backupAmf": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "guamiList": {
	///      "description": "If present, this IE shall contain the list of GUAMI(s) (supported by the AMF) for which the backupAmf IE applies.\n",
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Guami"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct BackupAmfInfo {
		#[serde(rename = "backupAmf")]
		pub backup_amf: Fqdn,
		/// If present, this IE shall contain the list of GUAMI(s) (supported by
		/// the AMF) for which the backupAmf IE applies.
		#[serde(rename = "guamiList", default, skip_serializing_if = "Vec::is_empty")]
		pub guami_list: Vec<Guami>,
	}

	impl From<&BackupAmfInfo> for BackupAmfInfo {
		fn from(value: &BackupAmfInfo) -> Self {
			value.clone()
		}
	}

	/// Parameters "replaceableInd" and "rechargeableInd" are only included if
	/// the value of Parameter "batteryInd" is true.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Parameters \"replaceableInd\" and \"rechargeableInd\" are only included if the value of Parameter \"batteryInd\" is true.\n",
	///  "type": "object",
	///  "properties": {
	///    "batteryInd": {
	///      "description": "This IE shall indicate whether the UE is battery
	/// powered or not. true: the UE is battery powered; false or absent: the UE
	/// is not battery powered\n",
	///      "type": "boolean"
	///    },
	///    "rechargeableInd": {
	///      "description": "This IE shall indicate whether the battery of the
	/// UE is rechargeable or not. true: the battery of UE is rechargeable;
	/// false or absent: the battery of the UE is not rechargeable.\n",
	///      "type": "boolean"
	///    },
	///    "replaceableInd": {
	///      "description": "This IE shall indicate whether the battery of the
	/// UE is replaceable or not. true: the battery of the UE is replaceable;
	/// false or absent: the battery of the UE is not replaceable.\n",
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct BatteryIndication {
		/// This IE shall indicate whether the UE is battery powered or not.
		/// true: the UE is battery powered; false or absent: the UE is not
		/// battery powered
		#[serde(
			rename = "batteryInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub battery_ind: Option<bool>,
		/// This IE shall indicate whether the battery of the UE is rechargeable
		/// or not. true: the battery of UE is rechargeable; false or absent:
		/// the battery of the UE is not rechargeable.
		#[serde(
			rename = "rechargeableInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub rechargeable_ind: Option<bool>,
		/// This IE shall indicate whether the battery of the UE is replaceable
		/// or not. true: the battery of the UE is replaceable; false or absent:
		/// the battery of the UE is not replaceable.
		#[serde(
			rename = "replaceableInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub replaceable_ind: Option<bool>,
	}

	impl From<&BatteryIndication> for BatteryIndication {
		fn from(value: &BatteryIndication) -> Self {
			value.clone()
		}
	}

	/// This data type is defined in the same way as the 'BatteryIndication'
	/// data type, but with the OpenAPI 'nullable: true' property.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This data type is defined in the same way as the
	/// 'BatteryIndication' data type, but with the OpenAPI 'nullable: true'
	/// property.\n",
	///  "anyOf": [
	///    {
	///      "$ref": "#/components/schemas/BatteryIndication"
	///    },
	///    {
	///      "$ref": "#/components/schemas/NullValue"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum BatteryIndicationRm {
		#[default]
		BatteryIndication(BatteryIndication),
		NullValue(NullValue),
	}

	impl From<&BatteryIndicationRm> for BatteryIndicationRm {
		fn from(value: &BatteryIndicationRm) -> Self {
			value.clone()
		}
	}

	impl From<BatteryIndication> for BatteryIndicationRm {
		fn from(value: BatteryIndication) -> Self {
			Self::BatteryIndication(value)
		}
	}

	impl From<NullValue> for BatteryIndicationRm {
		fn from(value: NullValue) -> Self {
			Self::NullValue(value)
		}
	}

	/// string with format 'binary' as defined in OpenAPI.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "string with format 'binary' as defined in OpenAPI.",
	///  "type": "string",
	///  "format": "binary"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct Binary(pub String);
	impl ::std::ops::Deref for Binary {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Binary> for String {
		fn from(value: Binary) -> Self {
			value.0
		}
	}

	impl From<&Binary> for Binary {
		fn from(value: &Binary) -> Self {
			value.clone()
		}
	}

	impl From<String> for Binary {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for Binary {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for Binary {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// String representing a bit rate; the prefixes follow the standard symbols
	/// from The International System of Units, and represent x1000 multipliers,
	/// with the exception that prefix "K" is used to represent the standard
	/// symbol "k".
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String representing a bit rate; the prefixes follow the
	/// standard symbols from The International System of Units, and represent
	/// x1000 multipliers, with the exception that prefix \"K\" is used to
	/// represent the standard symbol \"k\".\n",
	///  "type": "string",
	///  "pattern": "^\\d+(\\.\\d+)? (bps|Kbps|Mbps|Gbps|Tbps)$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct BitRate(String);
	impl ::std::ops::Deref for BitRate {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<BitRate> for String {
		fn from(value: BitRate) -> Self {
			value.0
		}
	}

	impl From<&BitRate> for BitRate {
		fn from(value: &BitRate) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for BitRate {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^\\d+(\\.\\d+)? (bps|Kbps|Mbps|Gbps|Tbps)$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err(
					"doesn't match pattern \"^\\d+(\\.\\d+)? (bps|Kbps|Mbps|Gbps|Tbps)$\"".into(),
				);
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for BitRate {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for BitRate {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for BitRate {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for BitRate {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// string with format 'bytes' as defined in OpenAPI
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "string with format 'bytes' as defined in OpenAPI",
	///  "type": "string",
	///  "format": "byte"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct Bytes(pub String);
	impl ::std::ops::Deref for Bytes {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Bytes> for String {
		fn from(value: Bytes) -> Self {
			value.0
		}
	}

	impl From<&Bytes> for Bytes {
		fn from(value: &Bytes) -> Self {
			value.clone()
		}
	}

	impl From<String> for Bytes {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for Bytes {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for Bytes {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// String representing the C-MSISDN as defined in clause 18.7 of 3GPP TS
	/// 23.003.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String representing the C-MSISDN as defined in clause
	/// 18.7 of 3GPP TS 23.003.",
	///  "type": "string",
	///  "pattern": "^[0-9]{5,15}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct CMsisdn(String);
	impl ::std::ops::Deref for CMsisdn {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<CMsisdn> for String {
		fn from(value: CMsisdn) -> Self {
			value.0
		}
	}

	impl From<&CMsisdn> for CMsisdn {
		fn from(value: &CMsisdn) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for CMsisdn {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9]{5,15}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9]{5,15}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for CMsisdn {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for CMsisdn {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for CMsisdn {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for CMsisdn {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// CagData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "cagInfos"
	///  ],
	///  "properties": {
	///    "cagInfos": {
	///      "description": "A map (list of key-value pairs where PlmnId serves
	/// as key) of CagInfo",
	///      "type": "object",
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/CagInfo"
	///      }
	///    },
	///    "provisioningTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct CagData {
		/// A map (list of key-value pairs where PlmnId serves as key) of
		/// CagInfo
		#[serde(rename = "cagInfos")]
		pub cag_infos: ::std::collections::HashMap<String, CagInfo>,
		#[serde(
			rename = "provisioningTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub provisioning_time: Option<DateTime>,
	}

	impl From<&CagData> for CagData {
		fn from(value: &CagData) -> Self {
			value.clone()
		}
	}

	/// String containing a Closed Access Group Identifier.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String containing a Closed Access Group Identifier.",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{8}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct CagId(String);
	impl ::std::ops::Deref for CagId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<CagId> for String {
		fn from(value: CagId) -> Self {
			value.0
		}
	}

	impl From<&CagId> for CagId {
		fn from(value: &CagId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for CagId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{8}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{8}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for CagId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for CagId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for CagId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for CagId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// CagInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "allowedCagList"
	///  ],
	///  "properties": {
	///    "allowedCagList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/CagId"
	///      }
	///    },
	///    "cagOnlyIndicator": {
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct CagInfo {
		#[serde(rename = "allowedCagList")]
		pub allowed_cag_list: Vec<CagId>,
		#[serde(
			rename = "cagOnlyIndicator",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub cag_only_indicator: Option<bool>,
	}

	impl From<&CagInfo> for CagInfo {
		fn from(value: &CagInfo) -> Self {
			value.clone()
		}
	}

	/// Contains a Cell Global Identification as defined in 3GPP TS 23.003,
	/// clause 4.3.1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains a Cell Global Identification as defined in
	/// 3GPP TS 23.003, clause 4.3.1.",
	///  "type": "object",
	///  "required": [
	///    "cellId",
	///    "lac",
	///    "plmnId"
	///  ],
	///  "properties": {
	///    "cellId": {
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]{4}$"
	///    },
	///    "lac": {
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]{4}$"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct CellGlobalId {
		#[serde(rename = "cellId")]
		pub cell_id: CellGlobalIdCellId,
		pub lac: CellGlobalIdLac,
		#[serde(rename = "plmnId")]
		pub plmn_id: PlmnId,
	}

	impl From<&CellGlobalId> for CellGlobalId {
		fn from(value: &CellGlobalId) -> Self {
			value.clone()
		}
	}

	/// CellGlobalIdCellId
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{4}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct CellGlobalIdCellId(String);
	impl ::std::ops::Deref for CellGlobalIdCellId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<CellGlobalIdCellId> for String {
		fn from(value: CellGlobalIdCellId) -> Self {
			value.0
		}
	}

	impl From<&CellGlobalIdCellId> for CellGlobalIdCellId {
		fn from(value: &CellGlobalIdCellId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for CellGlobalIdCellId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{4}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{4}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for CellGlobalIdCellId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for CellGlobalIdCellId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for CellGlobalIdCellId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for CellGlobalIdCellId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// CellGlobalIdLac
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{4}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct CellGlobalIdLac(String);
	impl ::std::ops::Deref for CellGlobalIdLac {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<CellGlobalIdLac> for String {
		fn from(value: CellGlobalIdLac) -> Self {
			value.0
		}
	}

	impl From<&CellGlobalIdLac> for CellGlobalIdLac {
		fn from(value: &CellGlobalIdLac) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for CellGlobalIdLac {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{4}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{4}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for CellGlobalIdLac {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for CellGlobalIdLac {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for CellGlobalIdLac {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for CellGlobalIdLac {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// It contains data which need to be changed.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "It contains data which need to be changed.",
	///  "type": "object",
	///  "required": [
	///    "op",
	///    "path"
	///  ],
	///  "properties": {
	///    "from": {
	///      "description": "indicates the path of the source JSON element
	/// (according to JSON Pointer syntax)  being moved or copied to the
	/// location indicated by the \"path\" attribute. It shall  be present if
	/// the \"op\" attribute is of value \"MOVE\".\n",
	///      "type": "string"
	///    },
	///    "newValue": {},
	///    "op": {
	///      "$ref": "#/components/schemas/ChangeType"
	///    },
	///    "origValue": {},
	///    "path": {
	///      "description": "contains a JSON pointer value (as defined in IETF
	/// RFC 6901) that references a target  location within the resource on
	/// which the change has been applied.\n",
	///      "type": "string"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ChangeItem {
		/// indicates the path of the source JSON element (according to JSON
		/// Pointer syntax)  being moved or copied to the location indicated by
		/// the "path" attribute. It shall  be present if the "op" attribute is
		/// of value "MOVE".
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub from: Option<String>,
		#[serde(rename = "newValue", default, skip_serializing_if = "Option::is_none")]
		pub new_value: Option<::serde_json::Value>,
		pub op: ChangeType,
		#[serde(rename = "origValue", default, skip_serializing_if = "Option::is_none")]
		pub orig_value: Option<::serde_json::Value>,
		/// contains a JSON pointer value (as defined in IETF RFC 6901) that
		/// references a target  location within the resource on which the
		/// change has been applied.
		pub path: String,
	}

	impl From<&ChangeItem> for ChangeItem {
		fn from(value: &ChangeItem) -> Self {
			value.clone()
		}
	}

	/// ChangeOfSupiPeiAssociationReport
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "newPei"
	///  ],
	///  "properties": {
	///    "newPei": {
	///      "$ref": "#/components/schemas/Pei"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ChangeOfSupiPeiAssociationReport {
		#[serde(rename = "newPei")]
		pub new_pei: Pei,
	}

	impl From<&ChangeOfSupiPeiAssociationReport> for ChangeOfSupiPeiAssociationReport {
		fn from(value: &ChangeOfSupiPeiAssociationReport) -> Self {
			value.clone()
		}
	}

	/// Indicates the type of change to be performed.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates the type of change to be performed.",
	///  "type": "string",
	///  "enum": [
	///    "ADD",
	///    "MOVE",
	///    "REMOVE",
	///    "REPLACE"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum ChangeType {
		#[default]
		#[serde(rename = "ADD")]
		Add,
		#[serde(rename = "MOVE")]
		Move,
		#[serde(rename = "REMOVE")]
		Remove,
		#[serde(rename = "REPLACE")]
		Replace,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&ChangeType> for ChangeType {
		fn from(value: &ChangeType) -> Self {
			value.clone()
		}
	}

	impl ToString for ChangeType {
		fn to_string(&self) -> String {
			match *self {
				Self::Add => "ADD".to_string(),
				Self::Move => "MOVE".to_string(),
				Self::Remove => "REMOVE".to_string(),
				Self::Replace => "REPLACE".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for ChangeType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"ADD" => Ok(Self::Add),
				"MOVE" => Ok(Self::Move),
				"REMOVE" => Ok(Self::Remove),
				"REPLACE" => Ok(Self::Replace),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for ChangeType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for ChangeType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for ChangeType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Indicates a Civic address.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates a Civic address.",
	///  "type": "object",
	///  "properties": {
	///    "A1": {
	///      "type": "string"
	///    },
	///    "A2": {
	///      "type": "string"
	///    },
	///    "A3": {
	///      "type": "string"
	///    },
	///    "A4": {
	///      "type": "string"
	///    },
	///    "A5": {
	///      "type": "string"
	///    },
	///    "A6": {
	///      "type": "string"
	///    },
	///    "ADDCODE": {
	///      "type": "string"
	///    },
	///    "BLD": {
	///      "type": "string"
	///    },
	///    "FLR": {
	///      "type": "string"
	///    },
	///    "HNO": {
	///      "type": "string"
	///    },
	///    "HNS": {
	///      "type": "string"
	///    },
	///    "LMK": {
	///      "type": "string"
	///    },
	///    "LOC": {
	///      "type": "string"
	///    },
	///    "NAM": {
	///      "type": "string"
	///    },
	///    "PC": {
	///      "type": "string"
	///    },
	///    "PCN": {
	///      "type": "string"
	///    },
	///    "PLC": {
	///      "type": "string"
	///    },
	///    "POBOX": {
	///      "type": "string"
	///    },
	///    "POD": {
	///      "type": "string"
	///    },
	///    "POM": {
	///      "type": "string"
	///    },
	///    "PRD": {
	///      "type": "string"
	///    },
	///    "PRM": {
	///      "type": "string"
	///    },
	///    "RD": {
	///      "type": "string"
	///    },
	///    "RDBR": {
	///      "type": "string"
	///    },
	///    "RDSEC": {
	///      "type": "string"
	///    },
	///    "RDSUBBR": {
	///      "type": "string"
	///    },
	///    "ROOM": {
	///      "type": "string"
	///    },
	///    "SEAT": {
	///      "type": "string"
	///    },
	///    "STS": {
	///      "type": "string"
	///    },
	///    "UNIT": {
	///      "type": "string"
	///    },
	///    "country": {
	///      "type": "string"
	///    },
	///    "method": {
	///      "type": "string"
	///    },
	///    "providedBy": {
	///      "type": "string"
	///    },
	///    "usageRules": {
	///      "type": "string"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct CivicAddress {
		#[serde(rename = "A1", default, skip_serializing_if = "Option::is_none")]
		pub a1: Option<String>,
		#[serde(rename = "A2", default, skip_serializing_if = "Option::is_none")]
		pub a2: Option<String>,
		#[serde(rename = "A3", default, skip_serializing_if = "Option::is_none")]
		pub a3: Option<String>,
		#[serde(rename = "A4", default, skip_serializing_if = "Option::is_none")]
		pub a4: Option<String>,
		#[serde(rename = "A5", default, skip_serializing_if = "Option::is_none")]
		pub a5: Option<String>,
		#[serde(rename = "A6", default, skip_serializing_if = "Option::is_none")]
		pub a6: Option<String>,
		#[serde(rename = "ADDCODE", default, skip_serializing_if = "Option::is_none")]
		pub addcode: Option<String>,
		#[serde(rename = "BLD", default, skip_serializing_if = "Option::is_none")]
		pub bld: Option<String>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub country: Option<String>,
		#[serde(rename = "FLR", default, skip_serializing_if = "Option::is_none")]
		pub flr: Option<String>,
		#[serde(rename = "HNO", default, skip_serializing_if = "Option::is_none")]
		pub hno: Option<String>,
		#[serde(rename = "HNS", default, skip_serializing_if = "Option::is_none")]
		pub hns: Option<String>,
		#[serde(rename = "LMK", default, skip_serializing_if = "Option::is_none")]
		pub lmk: Option<String>,
		#[serde(rename = "LOC", default, skip_serializing_if = "Option::is_none")]
		pub loc: Option<String>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub method: Option<String>,
		#[serde(rename = "NAM", default, skip_serializing_if = "Option::is_none")]
		pub nam: Option<String>,
		#[serde(rename = "PC", default, skip_serializing_if = "Option::is_none")]
		pub pc: Option<String>,
		#[serde(rename = "PCN", default, skip_serializing_if = "Option::is_none")]
		pub pcn: Option<String>,
		#[serde(rename = "PLC", default, skip_serializing_if = "Option::is_none")]
		pub plc: Option<String>,
		#[serde(rename = "POBOX", default, skip_serializing_if = "Option::is_none")]
		pub pobox: Option<String>,
		#[serde(rename = "POD", default, skip_serializing_if = "Option::is_none")]
		pub pod: Option<String>,
		#[serde(rename = "POM", default, skip_serializing_if = "Option::is_none")]
		pub pom: Option<String>,
		#[serde(rename = "PRD", default, skip_serializing_if = "Option::is_none")]
		pub prd: Option<String>,
		#[serde(rename = "PRM", default, skip_serializing_if = "Option::is_none")]
		pub prm: Option<String>,
		#[serde(
			rename = "providedBy",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub provided_by: Option<String>,
		#[serde(rename = "RD", default, skip_serializing_if = "Option::is_none")]
		pub rd: Option<String>,
		#[serde(rename = "RDBR", default, skip_serializing_if = "Option::is_none")]
		pub rdbr: Option<String>,
		#[serde(rename = "RDSEC", default, skip_serializing_if = "Option::is_none")]
		pub rdsec: Option<String>,
		#[serde(rename = "RDSUBBR", default, skip_serializing_if = "Option::is_none")]
		pub rdsubbr: Option<String>,
		#[serde(rename = "ROOM", default, skip_serializing_if = "Option::is_none")]
		pub room: Option<String>,
		#[serde(rename = "SEAT", default, skip_serializing_if = "Option::is_none")]
		pub seat: Option<String>,
		#[serde(rename = "STS", default, skip_serializing_if = "Option::is_none")]
		pub sts: Option<String>,
		#[serde(rename = "UNIT", default, skip_serializing_if = "Option::is_none")]
		pub unit: Option<String>,
		#[serde(
			rename = "usageRules",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub usage_rules: Option<String>,
	}

	impl From<&CivicAddress> for CivicAddress {
		fn from(value: &CivicAddress) -> Self {
			value.clone()
		}
	}

	/// CkPrime
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{32}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct CkPrime(String);
	impl ::std::ops::Deref for CkPrime {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<CkPrime> for String {
		fn from(value: CkPrime) -> Self {
			value.0
		}
	}

	impl From<&CkPrime> for CkPrime {
		fn from(value: &CkPrime) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for CkPrime {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{32}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{32}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for CkPrime {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for CkPrime {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for CkPrime {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for CkPrime {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Represents the connection management state of a UE for an access type
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents the connection management state of a UE for
	/// an access type",
	///  "type": "object",
	///  "required": [
	///    "accessType",
	///    "cmState"
	///  ],
	///  "properties": {
	///    "accessType": {
	///      "$ref": "#/components/schemas/AccessType"
	///    },
	///    "cmState": {
	///      "$ref": "#/components/schemas/CmState"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct CmInfo {
		#[serde(rename = "accessType")]
		pub access_type: AccessType,
		#[serde(rename = "cmState")]
		pub cm_state: CmState,
	}

	impl From<&CmInfo> for CmInfo {
		fn from(value: &CmInfo) -> Self {
			value.clone()
		}
	}

	/// CmInfoReport
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "newCmInfoList"
	///  ],
	///  "properties": {
	///    "newCmInfoList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/CmInfo"
	///      },
	///      "maxItems": 2,
	///      "minItems": 1
	///    },
	///    "oldCmInfoList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/CmInfo"
	///      },
	///      "maxItems": 2,
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct CmInfoReport {
		#[serde(rename = "newCmInfoList")]
		pub new_cm_info_list: Vec<CmInfo>,
		#[serde(
			rename = "oldCmInfoList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub old_cm_info_list: Vec<CmInfo>,
	}

	impl From<&CmInfoReport> for CmInfoReport {
		fn from(value: &CmInfoReport) -> Self {
			value.clone()
		}
	}

	/// Describes the connection management state of a UE
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Describes the connection management state of a UE",
	///  "type": "string",
	///  "enum": [
	///    "IDLE",
	///    "CONNECTED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum CmState {
		#[default]
		#[serde(rename = "IDLE")]
		Idle,
		#[serde(rename = "CONNECTED")]
		Connected,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&CmState> for CmState {
		fn from(value: &CmState) -> Self {
			value.clone()
		}
	}

	impl ToString for CmState {
		fn to_string(&self) -> String {
			match *self {
				Self::Idle => "IDLE".to_string(),
				Self::Connected => "CONNECTED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for CmState {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"IDLE" => Ok(Self::Idle),
				"CONNECTED" => Ok(Self::Connected),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for CmState {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for CmState {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for CmState {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// CnType
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "SINGLE_4G",
	///    "SINGLE_5G",
	///    "DUAL_4G5G"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum CnType {
		#[default]
		#[serde(rename = "SINGLE_4G")]
		Single4g,
		#[serde(rename = "SINGLE_5G")]
		Single5g,
		#[serde(rename = "DUAL_4G5G")]
		Dual4g5g,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&CnType> for CnType {
		fn from(value: &CnType) -> Self {
			value.clone()
		}
	}

	impl ToString for CnType {
		fn to_string(&self) -> String {
			match *self {
				Self::Single4g => "SINGLE_4G".to_string(),
				Self::Single5g => "SINGLE_5G".to_string(),
				Self::Dual4g5g => "DUAL_4G5G".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for CnType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"SINGLE_4G" => Ok(Self::Single4g),
				"SINGLE_5G" => Ok(Self::Single5g),
				"DUAL_4G5G" => Ok(Self::Dual4g5g),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for CnType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for CnType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for CnType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// CnTypeChangeReport
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "newCnType"
	///  ],
	///  "properties": {
	///    "newCnType": {
	///      "$ref": "#/components/schemas/CnType"
	///    },
	///    "oldCnType": {
	///      "$ref": "#/components/schemas/CnType"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct CnTypeChangeReport {
		#[serde(rename = "newCnType")]
		pub new_cn_type: CnType,
		#[serde(rename = "oldCnType", default, skip_serializing_if = "Option::is_none")]
		pub old_cn_type: Option<CnType>,
	}

	impl From<&CnTypeChangeReport> for CnTypeChangeReport {
		fn from(value: &CnTypeChangeReport) -> Self {
			value.clone()
		}
	}

	/// CodeWord
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct CodeWord(pub String);
	impl ::std::ops::Deref for CodeWord {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<CodeWord> for String {
		fn from(value: CodeWord) -> Self {
			value.0
		}
	}

	impl From<&CodeWord> for CodeWord {
		fn from(value: &CodeWord) -> Self {
			value.clone()
		}
	}

	impl From<String> for CodeWord {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for CodeWord {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for CodeWord {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// CodeWordInd
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "CODEWORD_CHECK_IN_UE",
	///    "CODEWORD_CHECK_IN_GMLC"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum CodeWordInd {
		#[default]
		#[serde(rename = "CODEWORD_CHECK_IN_UE")]
		CodewordCheckInUe,
		#[serde(rename = "CODEWORD_CHECK_IN_GMLC")]
		CodewordCheckInGmlc,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&CodeWordInd> for CodeWordInd {
		fn from(value: &CodeWordInd) -> Self {
			value.clone()
		}
	}

	impl ToString for CodeWordInd {
		fn to_string(&self) -> String {
			match *self {
				Self::CodewordCheckInUe => "CODEWORD_CHECK_IN_UE".to_string(),
				Self::CodewordCheckInGmlc => "CODEWORD_CHECK_IN_GMLC".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for CodeWordInd {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"CODEWORD_CHECK_IN_UE" => Ok(Self::CodewordCheckInUe),
				"CODEWORD_CHECK_IN_GMLC" => Ok(Self::CodewordCheckInGmlc),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for CodeWordInd {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for CodeWordInd {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for CodeWordInd {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// The enumeration CollectionPeriodRmmLteMdt defines Collection period for
	/// RRM measurements LTE for MDT in the trace. See 3GPP TS 32.422 for
	/// further description of the values. It shall comply with the provisions
	/// defined in table 5.6.3.15-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration CollectionPeriodRmmLteMdt defines
	/// Collection period for RRM measurements LTE for MDT in the trace. See
	/// 3GPP TS 32.422 for further description of the values. It shall comply
	/// with the provisions defined in table 5.6.3.15-1.\n",
	///  "type": "string",
	///  "enum": [
	///    1024,
	///    1280,
	///    2048,
	///    2560,
	///    5120,
	///    10240,
	///    60000
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum CollectionPeriodRmmLteMdt {
		#[default]
		#[serde(rename = "1024")]
		NUM1024,
		#[serde(rename = "1280")]
		NUM1280,
		#[serde(rename = "2048")]
		NUM2048,
		#[serde(rename = "2560")]
		NUM2560,
		#[serde(rename = "5120")]
		NUM5120,
		#[serde(rename = "10240")]
		NUM10240,
		#[serde(rename = "60000")]
		NUM60000,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&CollectionPeriodRmmLteMdt> for CollectionPeriodRmmLteMdt {
		fn from(value: &CollectionPeriodRmmLteMdt) -> Self {
			value.clone()
		}
	}

	impl ToString for CollectionPeriodRmmLteMdt {
		fn to_string(&self) -> String {
			match *self {
				Self::NUM1024 => "1024".to_string(),
				Self::NUM1280 => "1280".to_string(),
				Self::NUM2048 => "2048".to_string(),
				Self::NUM2560 => "2560".to_string(),
				Self::NUM5120 => "5120".to_string(),
				Self::NUM10240 => "10240".to_string(),
				Self::NUM60000 => "60000".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for CollectionPeriodRmmLteMdt {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"1024" => Ok(Self::NUM1024),
				"1280" => Ok(Self::NUM1280),
				"2048" => Ok(Self::NUM2048),
				"2560" => Ok(Self::NUM2560),
				"5120" => Ok(Self::NUM5120),
				"10240" => Ok(Self::NUM10240),
				"60000" => Ok(Self::NUM60000),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for CollectionPeriodRmmLteMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for CollectionPeriodRmmLteMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for CollectionPeriodRmmLteMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// The enumeration CollectionPeriodRmmNrMdt defines Collection period for
	/// RRM measurements NR for MDT in the trace. See 3GPP TS 32.422 for further
	/// description of the values. It shall comply with the provisions defined
	/// in table 5.6.3.19-1
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration CollectionPeriodRmmNrMdt defines
	/// Collection period for RRM measurements NR for MDT in the trace. See 3GPP
	/// TS 32.422 for further description of the values. It shall comply with
	/// the provisions defined in table 5.6.3.19-1\n",
	///  "type": "string",
	///  "enum": [
	///    1024,
	///    2048,
	///    5120,
	///    10240,
	///    60000
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum CollectionPeriodRmmNrMdt {
		#[default]
		#[serde(rename = "1024")]
		NUM1024,
		#[serde(rename = "2048")]
		NUM2048,
		#[serde(rename = "5120")]
		NUM5120,
		#[serde(rename = "10240")]
		NUM10240,
		#[serde(rename = "60000")]
		NUM60000,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&CollectionPeriodRmmNrMdt> for CollectionPeriodRmmNrMdt {
		fn from(value: &CollectionPeriodRmmNrMdt) -> Self {
			value.clone()
		}
	}

	impl ToString for CollectionPeriodRmmNrMdt {
		fn to_string(&self) -> String {
			match *self {
				Self::NUM1024 => "1024".to_string(),
				Self::NUM2048 => "2048".to_string(),
				Self::NUM5120 => "5120".to_string(),
				Self::NUM10240 => "10240".to_string(),
				Self::NUM60000 => "60000".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for CollectionPeriodRmmNrMdt {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"1024" => Ok(Self::NUM1024),
				"2048" => Ok(Self::NUM2048),
				"5120" => Ok(Self::NUM5120),
				"10240" => Ok(Self::NUM10240),
				"60000" => Ok(Self::NUM60000),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for CollectionPeriodRmmNrMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for CollectionPeriodRmmNrMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for CollectionPeriodRmmNrMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// CommunicationCharacteristics
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "properties": {
	///    "ppActiveTime": {
	///      "$ref": "#/components/schemas/PpActiveTime"
	///    },
	///    "ppDlPacketCount": {
	///      "$ref": "#/components/schemas/PpDlPacketCount"
	///    },
	///    "ppDlPacketCountExt": {
	///      "$ref": "#/components/schemas/PpDlPacketCountExt"
	///    },
	///    "ppMaximumLatency": {
	///      "$ref": "#/components/schemas/PpMaximumLatency"
	///    },
	///    "ppMaximumResponseTime": {
	///      "$ref": "#/components/schemas/PpMaximumResponseTime"
	///    },
	///    "ppSubsRegTimer": {
	///      "$ref": "#/components/schemas/PpSubsRegTimer"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct CommunicationCharacteristics(pub Option<CommunicationCharacteristicsInner>);
	impl ::std::ops::Deref for CommunicationCharacteristics {
		type Target = Option<CommunicationCharacteristicsInner>;
		fn deref(&self) -> &Option<CommunicationCharacteristicsInner> {
			&self.0
		}
	}

	impl From<CommunicationCharacteristics> for Option<CommunicationCharacteristicsInner> {
		fn from(value: CommunicationCharacteristics) -> Self {
			value.0
		}
	}

	impl From<&CommunicationCharacteristics> for CommunicationCharacteristics {
		fn from(value: &CommunicationCharacteristics) -> Self {
			value.clone()
		}
	}

	impl From<Option<CommunicationCharacteristicsInner>> for CommunicationCharacteristics {
		fn from(value: Option<CommunicationCharacteristicsInner>) -> Self {
			Self(value)
		}
	}

	/// CommunicationCharacteristicsAf
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "properties": {
	///    "maximumLatency": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "maximumResponseTime": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "ppDlPacketCount": {
	///      "$ref": "#/components/schemas/PpDlPacketCount"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct CommunicationCharacteristicsAf(pub Option<CommunicationCharacteristicsAfInner>);
	impl ::std::ops::Deref for CommunicationCharacteristicsAf {
		type Target = Option<CommunicationCharacteristicsAfInner>;
		fn deref(&self) -> &Option<CommunicationCharacteristicsAfInner> {
			&self.0
		}
	}

	impl From<CommunicationCharacteristicsAf> for Option<CommunicationCharacteristicsAfInner> {
		fn from(value: CommunicationCharacteristicsAf) -> Self {
			value.0
		}
	}

	impl From<&CommunicationCharacteristicsAf> for CommunicationCharacteristicsAf {
		fn from(value: &CommunicationCharacteristicsAf) -> Self {
			value.clone()
		}
	}

	impl From<Option<CommunicationCharacteristicsAfInner>> for CommunicationCharacteristicsAf {
		fn from(value: Option<CommunicationCharacteristicsAfInner>) -> Self {
			Self(value)
		}
	}

	/// CommunicationCharacteristicsAfInner
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "maximumLatency": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "maximumResponseTime": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "ppDlPacketCount": {
	///      "$ref": "#/components/schemas/PpDlPacketCount"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct CommunicationCharacteristicsAfInner {
		#[serde(
			rename = "maximumLatency",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub maximum_latency: Option<DurationSec>,
		#[serde(
			rename = "maximumResponseTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub maximum_response_time: Option<DurationSec>,
		#[serde(
			rename = "ppDlPacketCount",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pp_dl_packet_count: Option<PpDlPacketCount>,
	}

	impl From<&CommunicationCharacteristicsAfInner> for CommunicationCharacteristicsAfInner {
		fn from(value: &CommunicationCharacteristicsAfInner) -> Self {
			value.clone()
		}
	}

	/// CommunicationCharacteristicsInner
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "ppActiveTime": {
	///      "$ref": "#/components/schemas/PpActiveTime"
	///    },
	///    "ppDlPacketCount": {
	///      "$ref": "#/components/schemas/PpDlPacketCount"
	///    },
	///    "ppDlPacketCountExt": {
	///      "$ref": "#/components/schemas/PpDlPacketCountExt"
	///    },
	///    "ppMaximumLatency": {
	///      "$ref": "#/components/schemas/PpMaximumLatency"
	///    },
	///    "ppMaximumResponseTime": {
	///      "$ref": "#/components/schemas/PpMaximumResponseTime"
	///    },
	///    "ppSubsRegTimer": {
	///      "$ref": "#/components/schemas/PpSubsRegTimer"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct CommunicationCharacteristicsInner {
		#[serde(
			rename = "ppActiveTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pp_active_time: Option<PpActiveTime>,
		#[serde(
			rename = "ppDlPacketCount",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pp_dl_packet_count: Option<PpDlPacketCount>,
		#[serde(
			rename = "ppDlPacketCountExt",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pp_dl_packet_count_ext: Option<PpDlPacketCountExt>,
		#[serde(
			rename = "ppMaximumLatency",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pp_maximum_latency: Option<PpMaximumLatency>,
		#[serde(
			rename = "ppMaximumResponseTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pp_maximum_response_time: Option<PpMaximumResponseTime>,
		#[serde(
			rename = "ppSubsRegTimer",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pp_subs_reg_timer: Option<PpSubsRegTimer>,
	}

	impl From<&CommunicationCharacteristicsInner> for CommunicationCharacteristicsInner {
		fn from(value: &CommunicationCharacteristicsInner) -> Self {
			value.clone()
		}
	}

	/// Indicates value of confidence.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates value of confidence.",
	///  "type": "integer",
	///  "maximum": 100.0,
	///  "minimum": 0.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Confidence(pub i64);
	impl ::std::ops::Deref for Confidence {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<Confidence> for i64 {
		fn from(value: Confidence) -> Self {
			value.0
		}
	}

	impl From<&Confidence> for Confidence {
		fn from(value: &Confidence) -> Self {
			value.clone()
		}
	}

	impl From<i64> for Confidence {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for Confidence {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for Confidence {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for Confidence {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for Confidence {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for Confidence {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// ConfidentialityKey
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{32}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct ConfidentialityKey(String);
	impl ::std::ops::Deref for ConfidentialityKey {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<ConfidentialityKey> for String {
		fn from(value: ConfidentialityKey) -> Self {
			value.0
		}
	}

	impl From<&ConfidentialityKey> for ConfidentialityKey {
		fn from(value: &ConfidentialityKey) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for ConfidentialityKey {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{32}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{32}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for ConfidentialityKey {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for ConfidentialityKey {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for ConfidentialityKey {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for ConfidentialityKey {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// ContextInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "origHeaders": {
	///      "type": "array",
	///      "items": {
	///        "type": "string"
	///      },
	///      "minItems": 1
	///    },
	///    "requestHeaders": {
	///      "type": "array",
	///      "items": {
	///        "type": "string"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ContextInfo {
		#[serde(rename = "origHeaders", default, skip_serializing_if = "Vec::is_empty")]
		pub orig_headers: Vec<String>,
		#[serde(
			rename = "requestHeaders",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub request_headers: Vec<String>,
	}

	impl From<&ContextInfo> for ContextInfo {
		fn from(value: &ContextInfo) -> Self {
			value.clone()
		}
	}

	/// It contains the Core Network type 5GC or EPC.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "It contains the Core Network type 5GC or EPC.",
	///  "type": "string",
	///  "enum": [
	///    "5GC",
	///    "EPC"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum CoreNetworkType {
		#[default]
		#[serde(rename = "5GC")]
		FiveGc,
		#[serde(rename = "EPC")]
		Epc,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&CoreNetworkType> for CoreNetworkType {
		fn from(value: &CoreNetworkType) -> Self {
			value.clone()
		}
	}

	impl ToString for CoreNetworkType {
		fn to_string(&self) -> String {
			match *self {
				Self::FiveGc => "5GC".to_string(),
				Self::Epc => "EPC".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for CoreNetworkType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"5GC" => Ok(Self::FiveGc),
				"EPC" => Ok(Self::Epc),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for CoreNetworkType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for CoreNetworkType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for CoreNetworkType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// CounterSoR.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "CounterSoR.",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{4}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct CounterSor(String);
	impl ::std::ops::Deref for CounterSor {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<CounterSor> for String {
		fn from(value: CounterSor) -> Self {
			value.0
		}
	}

	impl From<&CounterSor> for CounterSor {
		fn from(value: &CounterSor) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for CounterSor {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{4}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{4}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for CounterSor {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for CounterSor {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for CounterSor {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for CounterSor {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// CounterUPU.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "CounterUPU.",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{4}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct CounterUpu(String);
	impl ::std::ops::Deref for CounterUpu {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<CounterUpu> for String {
		fn from(value: CounterUpu) -> Self {
			value.0
		}
	}

	impl From<&CounterUpu> for CounterUpu {
		fn from(value: &CounterUpu) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for CounterUpu {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{4}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{4}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for CounterUpu {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for CounterUpu {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for CounterUpu {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for CounterUpu {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// CreatedEeSubscription
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "eeSubscription"
	///  ],
	///  "properties": {
	///    "eeSubscription": {
	///      "$ref": "#/components/schemas/EeSubscription"
	///    },
	///    "epcStatusInd": {
	///      "type": "boolean"
	///    },
	///    "eventReports": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/MonitoringReport"
	///      },
	///      "minItems": 1
	///    },
	///    "failedMoniConfigsEPC": {
	///      "description": "A map (list of key-value pairs where referenceId
	/// converted from integer to string serves as key; see clause 6.4.6.3.2) of
	/// FailedMonitoringConfiguration, the key value \"ALL\" may be used to
	/// identify a map entry which contains the failed cause of the EE
	/// subscription was not successful in EPC domain.",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/FailedMonitoringConfiguration"
	///      }
	///    },
	///    "failedMonitoringConfigs": {
	///      "description": "A map (list of key-value pairs where referenceId
	/// converted from integer to string serves as key; see clause 6.4.6.3.2) of
	/// FailedMonitoringConfiguration",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/FailedMonitoringConfiguration"
	///      }
	///    },
	///    "numberOfUes": {
	///      "$ref": "#/components/schemas/Uinteger"
	///    },
	///    "resetIds": {
	///      "type": "array",
	///      "items": {
	///        "type": "string"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct CreatedEeSubscription {
		#[serde(rename = "eeSubscription")]
		pub ee_subscription: EeSubscription,
		#[serde(
			rename = "epcStatusInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub epc_status_ind: Option<bool>,
		#[serde(
			rename = "eventReports",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub event_reports: Vec<MonitoringReport>,
		/// A map (list of key-value pairs where referenceId converted from
		/// integer to string serves as key; see clause 6.4.6.3.2) of
		/// FailedMonitoringConfiguration, the key value "ALL" may be used to
		/// identify a map entry which contains the failed cause of the EE
		/// subscription was not successful in EPC domain.
		#[serde(
			rename = "failedMoniConfigsEPC",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub failed_moni_configs_epc:
			::std::collections::HashMap<String, FailedMonitoringConfiguration>,
		/// A map (list of key-value pairs where referenceId converted from
		/// integer to string serves as key; see clause 6.4.6.3.2) of
		/// FailedMonitoringConfiguration
		#[serde(
			rename = "failedMonitoringConfigs",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub failed_monitoring_configs:
			::std::collections::HashMap<String, FailedMonitoringConfiguration>,
		#[serde(
			rename = "numberOfUes",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub number_of_ues: Option<Uinteger>,
		#[serde(rename = "resetIds", default, skip_serializing_if = "Vec::is_empty")]
		pub reset_ids: Vec<String>,
	}

	impl From<&CreatedEeSubscription> for CreatedEeSubscription {
		fn from(value: &CreatedEeSubscription) -> Self {
			value.clone()
		}
	}

	/// Contains identities representing those UEs potentially affected by a
	/// data-loss event at the UDR
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains identities representing those UEs potentially
	/// affected by a data-loss event at the UDR",
	///  "type": "object",
	///  "properties": {
	///    "dnnList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Dnn"
	///      },
	///      "minItems": 1
	///    },
	///    "gpsiRanges": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/IdentityRange"
	///      },
	///      "minItems": 1
	///    },
	///    "lastReplicationTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "recoveryTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "resetIds": {
	///      "type": "array",
	///      "items": {
	///        "type": "string"
	///      },
	///      "minItems": 1
	///    },
	///    "sNssaiList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Snssai"
	///      },
	///      "minItems": 1
	///    },
	///    "supiRanges": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/SupiRange"
	///      },
	///      "minItems": 1
	///    },
	///    "udmGroupId": {
	///      "$ref": "#/components/schemas/NfGroupId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DataRestorationNotification {
		#[serde(rename = "dnnList", default, skip_serializing_if = "Vec::is_empty")]
		pub dnn_list: Vec<Dnn>,
		#[serde(rename = "gpsiRanges", default, skip_serializing_if = "Vec::is_empty")]
		pub gpsi_ranges: Vec<IdentityRange>,
		#[serde(
			rename = "lastReplicationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub last_replication_time: Option<DateTime>,
		#[serde(rename = "plmnId", default, skip_serializing_if = "Option::is_none")]
		pub plmn_id: Option<PlmnId>,
		#[serde(
			rename = "recoveryTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub recovery_time: Option<DateTime>,
		#[serde(rename = "resetIds", default, skip_serializing_if = "Vec::is_empty")]
		pub reset_ids: Vec<String>,
		#[serde(rename = "sNssaiList", default, skip_serializing_if = "Vec::is_empty")]
		pub s_nssai_list: Vec<Snssai>,
		#[serde(rename = "supiRanges", default, skip_serializing_if = "Vec::is_empty")]
		pub supi_ranges: Vec<SupiRange>,
		#[serde(
			rename = "udmGroupId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub udm_group_id: Option<NfGroupId>,
	}

	impl From<&DataRestorationNotification> for DataRestorationNotification {
		fn from(value: &DataRestorationNotification) -> Self {
			value.clone()
		}
	}

	/// DataSetName
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "AM",
	///    "SMF_SEL",
	///    "UEC_SMF",
	///    "UEC_SMSF",
	///    "SMS_SUB",
	///    "SM",
	///    "TRACE",
	///    "SMS_MNG",
	///    "LCS_PRIVACY",
	///    "LCS_MO",
	///    "UEC_AMF",
	///    "V2X",
	///    "LCS_BCA",
	///    "PROSE",
	///    "UC",
	///    "MBS"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum DataSetName {
		#[default]
		#[serde(rename = "AM")]
		Am,
		#[serde(rename = "SMF_SEL")]
		SmfSel,
		#[serde(rename = "UEC_SMF")]
		UecSmf,
		#[serde(rename = "UEC_SMSF")]
		UecSmsf,
		#[serde(rename = "SMS_SUB")]
		SmsSub,
		#[serde(rename = "SM")]
		Sm,
		#[serde(rename = "TRACE")]
		Trace,
		#[serde(rename = "SMS_MNG")]
		SmsMng,
		#[serde(rename = "LCS_PRIVACY")]
		LcsPrivacy,
		#[serde(rename = "LCS_MO")]
		LcsMo,
		#[serde(rename = "UEC_AMF")]
		UecAmf,
		#[serde(rename = "V2X")]
		V2x,
		#[serde(rename = "LCS_BCA")]
		LcsBca,
		#[serde(rename = "PROSE")]
		Prose,
		#[serde(rename = "UC")]
		Uc,
		#[serde(rename = "MBS")]
		Mbs,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&DataSetName> for DataSetName {
		fn from(value: &DataSetName) -> Self {
			value.clone()
		}
	}

	impl ToString for DataSetName {
		fn to_string(&self) -> String {
			match *self {
				Self::Am => "AM".to_string(),
				Self::SmfSel => "SMF_SEL".to_string(),
				Self::UecSmf => "UEC_SMF".to_string(),
				Self::UecSmsf => "UEC_SMSF".to_string(),
				Self::SmsSub => "SMS_SUB".to_string(),
				Self::Sm => "SM".to_string(),
				Self::Trace => "TRACE".to_string(),
				Self::SmsMng => "SMS_MNG".to_string(),
				Self::LcsPrivacy => "LCS_PRIVACY".to_string(),
				Self::LcsMo => "LCS_MO".to_string(),
				Self::UecAmf => "UEC_AMF".to_string(),
				Self::V2x => "V2X".to_string(),
				Self::LcsBca => "LCS_BCA".to_string(),
				Self::Prose => "PROSE".to_string(),
				Self::Uc => "UC".to_string(),
				Self::Mbs => "MBS".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for DataSetName {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"AM" => Ok(Self::Am),
				"SMF_SEL" => Ok(Self::SmfSel),
				"UEC_SMF" => Ok(Self::UecSmf),
				"UEC_SMSF" => Ok(Self::UecSmsf),
				"SMS_SUB" => Ok(Self::SmsSub),
				"SM" => Ok(Self::Sm),
				"TRACE" => Ok(Self::Trace),
				"SMS_MNG" => Ok(Self::SmsMng),
				"LCS_PRIVACY" => Ok(Self::LcsPrivacy),
				"LCS_MO" => Ok(Self::LcsMo),
				"UEC_AMF" => Ok(Self::UecAmf),
				"V2X" => Ok(Self::V2x),
				"LCS_BCA" => Ok(Self::LcsBca),
				"PROSE" => Ok(Self::Prose),
				"UC" => Ok(Self::Uc),
				"MBS" => Ok(Self::Mbs),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for DataSetName {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for DataSetName {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for DataSetName {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// DatalinkReportingConfiguration
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "dddStatusList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/DlDataDeliveryStatus"
	///      },
	///      "minItems": 1
	///    },
	///    "dddTrafficDes": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/DddTrafficDescriptor"
	///      },
	///      "minItems": 1
	///    },
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "slice": {
	///      "$ref": "#/components/schemas/Snssai"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DatalinkReportingConfiguration {
		#[serde(
			rename = "dddStatusList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub ddd_status_list: Vec<DlDataDeliveryStatus>,
		#[serde(
			rename = "dddTrafficDes",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub ddd_traffic_des: Vec<DddTrafficDescriptor>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub dnn: Option<Dnn>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub slice: Option<Snssai>,
	}

	impl From<&DatalinkReportingConfiguration> for DatalinkReportingConfiguration {
		fn from(value: &DatalinkReportingConfiguration) -> Self {
			value.clone()
		}
	}

	/// DatasetNames
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "array",
	///  "items": {
	///    "$ref": "#/components/schemas/DataSetName"
	///  },
	///  "minItems": 2,
	///  "uniqueItems": true
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DatasetNames(pub Vec<DataSetName>);
	impl ::std::ops::Deref for DatasetNames {
		type Target = Vec<DataSetName>;
		fn deref(&self) -> &Vec<DataSetName> {
			&self.0
		}
	}

	impl From<DatasetNames> for Vec<DataSetName> {
		fn from(value: DatasetNames) -> Self {
			value.0
		}
	}

	impl From<&DatasetNames> for DatasetNames {
		fn from(value: &DatasetNames) -> Self {
			value.clone()
		}
	}

	impl From<Vec<DataSetName>> for DatasetNames {
		fn from(value: Vec<DataSetName>) -> Self {
			Self(value)
		}
	}

	/// string with format 'date-time' as defined in OpenAPI.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "string with format 'date-time' as defined in OpenAPI.",
	///  "type": "string",
	///  "format": "date-time"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DateTime(pub chrono::DateTime<chrono::offset::Utc>);
	impl ::std::ops::Deref for DateTime {
		type Target = chrono::DateTime<chrono::offset::Utc>;
		fn deref(&self) -> &chrono::DateTime<chrono::offset::Utc> {
			&self.0
		}
	}

	impl From<DateTime> for chrono::DateTime<chrono::offset::Utc> {
		fn from(value: DateTime) -> Self {
			value.0
		}
	}

	impl From<&DateTime> for DateTime {
		fn from(value: &DateTime) -> Self {
			value.clone()
		}
	}

	impl From<chrono::DateTime<chrono::offset::Utc>> for DateTime {
		fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for DateTime {
		type Err = <chrono::DateTime<chrono::offset::Utc> as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for DateTime {
		type Error = <chrono::DateTime<chrono::offset::Utc> as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for DateTime {
		type Error = <chrono::DateTime<chrono::offset::Utc> as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for DateTime {
		type Error = <chrono::DateTime<chrono::offset::Utc> as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for DateTime {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// integer between and including 1 and 7 denoting a weekday. 1 shall
	/// indicate Monday, and the subsequent weekdays  shall be indicated with
	/// the next higher numbers. 7 shall indicate Sunday.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "integer between and including 1 and 7 denoting a
	/// weekday. 1 shall indicate Monday, and the subsequent weekdays  shall be
	/// indicated with the next higher numbers. 7 shall indicate Sunday.\n",
	///  "type": "integer",
	///  "maximum": 7.0,
	///  "minimum": 1.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DayOfWeek(pub i64);
	impl ::std::ops::Deref for DayOfWeek {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<DayOfWeek> for i64 {
		fn from(value: DayOfWeek) -> Self {
			value.0
		}
	}

	impl From<&DayOfWeek> for DayOfWeek {
		fn from(value: &DayOfWeek) -> Self {
			value.clone()
		}
	}

	impl From<i64> for DayOfWeek {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for DayOfWeek {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for DayOfWeek {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for DayOfWeek {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for DayOfWeek {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for DayOfWeek {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Contains a Traffic Descriptor.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains a Traffic Descriptor.",
	///  "type": "object",
	///  "properties": {
	///    "ipv4Addr": {
	///      "$ref": "#/components/schemas/Ipv4Addr"
	///    },
	///    "ipv6Addr": {
	///      "$ref": "#/components/schemas/Ipv6Addr"
	///    },
	///    "macAddr": {
	///      "$ref": "#/components/schemas/MacAddr48"
	///    },
	///    "portNumber": {
	///      "$ref": "#/components/schemas/Uinteger"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DddTrafficDescriptor {
		#[serde(rename = "ipv4Addr", default, skip_serializing_if = "Option::is_none")]
		pub ipv4_addr: Option<Ipv4Addr>,
		#[serde(rename = "ipv6Addr", default, skip_serializing_if = "Option::is_none")]
		pub ipv6_addr: Option<Ipv6Addr>,
		#[serde(rename = "macAddr", default, skip_serializing_if = "Option::is_none")]
		pub mac_addr: Option<MacAddr48>,
		#[serde(
			rename = "portNumber",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub port_number: Option<Uinteger>,
	}

	impl From<&DddTrafficDescriptor> for DddTrafficDescriptor {
		fn from(value: &DddTrafficDescriptor) -> Self {
			value.clone()
		}
	}

	/// Deconceal Request Data
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Deconceal Request Data",
	///  "type": "object",
	///  "required": [
	///    "suci"
	///  ],
	///  "properties": {
	///    "suci": {
	///      "$ref": "#/components/schemas/Suci"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DeconcealReqData {
		pub suci: Suci,
	}

	impl From<&DeconcealReqData> for DeconcealReqData {
		fn from(value: &DeconcealReqData) -> Self {
			value.clone()
		}
	}

	/// Deconceal Response Data
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Deconceal Response Data",
	///  "type": "object",
	///  "required": [
	///    "supi"
	///  ],
	///  "properties": {
	///    "supi": {
	///      "$ref": "#/components/schemas/Supi"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DeconcealRspData {
		pub supi: Supi,
	}

	impl From<&DeconcealRspData> for DeconcealRspData {
		fn from(value: &DeconcealRspData) -> Self {
			value.clone()
		}
	}

	/// DefaultUnrelatedClass
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "allowedGeographicArea": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/GeographicArea"
	///      },
	///      "minItems": 1
	///    },
	///    "codeWordInd": {
	///      "$ref": "#/components/schemas/CodeWordInd"
	///    },
	///    "codeWordList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/CodeWord"
	///      },
	///      "minItems": 1
	///    },
	///    "privacyCheckRelatedAction": {
	///      "$ref": "#/components/schemas/PrivacyCheckRelatedAction"
	///    },
	///    "validTimePeriod": {
	///      "$ref": "#/components/schemas/ValidTimePeriod"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DefaultUnrelatedClass {
		#[serde(
			rename = "allowedGeographicArea",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub allowed_geographic_area: Vec<GeographicArea>,
		#[serde(
			rename = "codeWordInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub code_word_ind: Option<CodeWordInd>,
		#[serde(
			rename = "codeWordList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub code_word_list: Vec<CodeWord>,
		#[serde(
			rename = "privacyCheckRelatedAction",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub privacy_check_related_action: Option<PrivacyCheckRelatedAction>,
		#[serde(
			rename = "validTimePeriod",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub valid_time_period: Option<ValidTimePeriod>,
	}

	impl From<&DefaultUnrelatedClass> for DefaultUnrelatedClass {
		fn from(value: &DefaultUnrelatedClass) -> Self {
			value.clone()
		}
	}

	/// DeregistrationData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "deregReason"
	///  ],
	///  "properties": {
	///    "accessType": {
	///      "$ref": "#/components/schemas/AccessType"
	///    },
	///    "deregReason": {
	///      "$ref": "#/components/schemas/DeregistrationReason"
	///    },
	///    "newSmfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "pduSessionId": {
	///      "$ref": "#/components/schemas/PduSessionId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DeregistrationData {
		#[serde(
			rename = "accessType",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub access_type: Option<AccessType>,
		#[serde(rename = "deregReason")]
		pub dereg_reason: DeregistrationReason,
		#[serde(
			rename = "newSmfInstanceId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub new_smf_instance_id: Option<NfInstanceId>,
		#[serde(
			rename = "pduSessionId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pdu_session_id: Option<PduSessionId>,
	}

	impl From<&DeregistrationData> for DeregistrationData {
		fn from(value: &DeregistrationData) -> Self {
			value.clone()
		}
	}

	/// DeregistrationReason
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "UE_INITIAL_REGISTRATION",
	///    "UE_REGISTRATION_AREA_CHANGE",
	///    "SUBSCRIPTION_WITHDRAWN",
	///    "5GS_TO_EPS_MOBILITY",
	///    "5GS_TO_EPS_MOBILITY_UE_INITIAL_REGISTRATION",
	///    "REREGISTRATION_REQUIRED",
	///    "SMF_CONTEXT_TRANSFERRED",
	///    "DUPLICATE_PDU_SESSION",
	///    "DISASTER_CONDITION_TERMINATED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum DeregistrationReason {
		#[default]
		#[serde(rename = "UE_INITIAL_REGISTRATION")]
		UeInitialRegistration,
		#[serde(rename = "UE_REGISTRATION_AREA_CHANGE")]
		UeRegistrationAreaChange,
		#[serde(rename = "SUBSCRIPTION_WITHDRAWN")]
		SubscriptionWithdrawn,
		#[serde(rename = "5GS_TO_EPS_MOBILITY")]
		FiveGsToEpsMobility,
		#[serde(rename = "5GS_TO_EPS_MOBILITY_UE_INITIAL_REGISTRATION")]
		FiveGsToEpsMobilityUeInitialRegistration,
		#[serde(rename = "REREGISTRATION_REQUIRED")]
		ReregistrationRequired,
		#[serde(rename = "SMF_CONTEXT_TRANSFERRED")]
		SmfContextTransferred,
		#[serde(rename = "DUPLICATE_PDU_SESSION")]
		DuplicatePduSession,
		#[serde(rename = "DISASTER_CONDITION_TERMINATED")]
		DisasterConditionTerminated,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&DeregistrationReason> for DeregistrationReason {
		fn from(value: &DeregistrationReason) -> Self {
			value.clone()
		}
	}

	impl ToString for DeregistrationReason {
		fn to_string(&self) -> String {
			match *self {
				Self::UeInitialRegistration => "UE_INITIAL_REGISTRATION".to_string(),
				Self::UeRegistrationAreaChange => "UE_REGISTRATION_AREA_CHANGE".to_string(),
				Self::SubscriptionWithdrawn => "SUBSCRIPTION_WITHDRAWN".to_string(),
				Self::FiveGsToEpsMobility => "5GS_TO_EPS_MOBILITY".to_string(),
				Self::FiveGsToEpsMobilityUeInitialRegistration => {
					"5GS_TO_EPS_MOBILITY_UE_INITIAL_REGISTRATION".to_string()
				}
				Self::ReregistrationRequired => "REREGISTRATION_REQUIRED".to_string(),
				Self::SmfContextTransferred => "SMF_CONTEXT_TRANSFERRED".to_string(),
				Self::DuplicatePduSession => "DUPLICATE_PDU_SESSION".to_string(),
				Self::DisasterConditionTerminated => "DISASTER_CONDITION_TERMINATED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for DeregistrationReason {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"UE_INITIAL_REGISTRATION" => Ok(Self::UeInitialRegistration),
				"UE_REGISTRATION_AREA_CHANGE" => Ok(Self::UeRegistrationAreaChange),
				"SUBSCRIPTION_WITHDRAWN" => Ok(Self::SubscriptionWithdrawn),
				"5GS_TO_EPS_MOBILITY" => Ok(Self::FiveGsToEpsMobility),
				"5GS_TO_EPS_MOBILITY_UE_INITIAL_REGISTRATION" => {
					Ok(Self::FiveGsToEpsMobilityUeInitialRegistration)
				}
				"REREGISTRATION_REQUIRED" => Ok(Self::ReregistrationRequired),
				"SMF_CONTEXT_TRANSFERRED" => Ok(Self::SmfContextTransferred),
				"DUPLICATE_PDU_SESSION" => Ok(Self::DuplicatePduSession),
				"DISASTER_CONDITION_TERMINATED" => Ok(Self::DisasterConditionTerminated),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for DeregistrationReason {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for DeregistrationReason {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for DeregistrationReason {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Possible values are:
	/// - BUFFERED: The first downlink data is buffered with extended buffering
	///   matching the
	///  source of the downlink traffic.
	/// - TRANSMITTED: The first downlink data matching the source of the
	///   downlink traffic is
	///  transmitted after previous buffering or discarding of corresponding
	/// packet(s) because  the UE of the PDU Session becomes ACTIVE, and
	/// buffered data can be delivered to UE.
	/// - DISCARDED: The first downlink data matching the source of the downlink
	///   traffic is
	///  discarded because the Extended Buffering time, as determined by the
	/// SMF, expires or  the amount of downlink data to be buffered is
	/// exceeded.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Possible values are:\n- BUFFERED: The first downlink
	/// data is buffered with extended buffering matching the\n  source of the
	/// downlink traffic.\n- TRANSMITTED: The first downlink data matching the
	/// source of the downlink traffic is\n  transmitted after previous
	/// buffering or discarding of corresponding packet(s) because\n  the UE of
	/// the PDU Session becomes ACTIVE, and buffered data can be delivered to
	/// UE.\n- DISCARDED: The first downlink data matching the source of the
	/// downlink traffic is\n  discarded because the Extended Buffering time, as
	/// determined by the SMF, expires or\n  the amount of downlink data to be
	/// buffered is exceeded.\n",
	///  "type": "string",
	///  "enum": [
	///    "BUFFERED",
	///    "TRANSMITTED",
	///    "DISCARDED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum DlDataDeliveryStatus {
		#[default]
		#[serde(rename = "BUFFERED")]
		Buffered,
		#[serde(rename = "TRANSMITTED")]
		Transmitted,
		#[serde(rename = "DISCARDED")]
		Discarded,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&DlDataDeliveryStatus> for DlDataDeliveryStatus {
		fn from(value: &DlDataDeliveryStatus) -> Self {
			value.clone()
		}
	}

	impl ToString for DlDataDeliveryStatus {
		fn to_string(&self) -> String {
			match *self {
				Self::Buffered => "BUFFERED".to_string(),
				Self::Transmitted => "TRANSMITTED".to_string(),
				Self::Discarded => "DISCARDED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for DlDataDeliveryStatus {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"BUFFERED" => Ok(Self::Buffered),
				"TRANSMITTED" => Ok(Self::Transmitted),
				"DISCARDED" => Ok(Self::Discarded),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for DlDataDeliveryStatus {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for DlDataDeliveryStatus {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for DlDataDeliveryStatus {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// String representing a Data Network as defined in clause 9A of 3GPP TS
	/// 23.003;  it shall contain either a DNN Network Identifier, or a full DNN
	/// with both the Network  Identifier and Operator Identifier, as specified
	/// in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in
	/// which the labels are separated by dots  (e.g. "Label1.Label2.Label3").
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String representing a Data Network as defined in clause
	/// 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier,
	/// or a full DNN with both the Network  Identifier and Operator Identifier,
	/// as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded
	/// as string in which the labels are separated by dots  (e.g.
	/// \"Label1.Label2.Label3\").\n",
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct Dnn(pub String);
	impl ::std::ops::Deref for Dnn {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Dnn> for String {
		fn from(value: Dnn) -> Self {
			value.0
		}
	}

	impl From<&Dnn> for Dnn {
		fn from(value: &Dnn) -> Self {
			value.clone()
		}
	}

	impl From<String> for Dnn {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for Dnn {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for Dnn {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// DnnConfiguration
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "pduSessionTypes",
	///    "sscModes"
	///  ],
	///  "properties": {
	///    "3gppChargingCharacteristics": {
	///      "$ref": "#/components/schemas/3GppChargingCharacteristics"
	///    },
	///    "5gQosProfile": {
	///      "$ref": "#/components/schemas/SubscribedDefaultQos"
	///    },
	///    "acsInfo": {
	///      "$ref": "#/components/schemas/AcsInfo"
	///    },
	///    "additionalDnAaaAddresses": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/IpAddress"
	///      },
	///      "minItems": 1
	///    },
	///    "additionalEcsAddrConfigInfos": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/EcsAddrConfigInfo"
	///      },
	///      "minItems": 1
	///    },
	///    "additionalSharedEcsAddrConfigInfoIds": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/SharedDataId"
	///      },
	///      "minItems": 1
	///    },
	///    "aerialUeInd": {
	///      "$ref": "#/components/schemas/AerialUeIndication"
	///    },
	///    "atsssAllowed": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "dnAaaAddress": {
	///      "$ref": "#/components/schemas/IpAddress"
	///    },
	///    "dnAaaFqdn": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "dnAaaIpAddressAllocation": {
	///      "type": "boolean"
	///    },
	///    "easDiscoveryAuthorized": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "ecsAddrConfigInfo": {
	///      "$ref": "#/components/schemas/EcsAddrConfigInfo"
	///    },
	///    "iptvAccCtrlInfo": {
	///      "type": "string"
	///    },
	///    "ipv4FrameRouteList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/FrameRouteInfo"
	///      },
	///      "minItems": 1
	///    },
	///    "ipv4Index": {
	///      "$ref": "#/components/schemas/IpIndex"
	///    },
	///    "ipv6FrameRouteList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/FrameRouteInfo"
	///      },
	///      "minItems": 1
	///    },
	///    "ipv6Index": {
	///      "$ref": "#/components/schemas/IpIndex"
	///    },
	///    "iwkEpsInd": {
	///      "$ref": "#/components/schemas/IwkEpsInd"
	///    },
	///    "niddInfo": {
	///      "$ref": "#/components/schemas/NiddInformation"
	///    },
	///    "niddNefId": {
	///      "$ref": "#/components/schemas/NefId"
	///    },
	///    "onboardingInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "pduSessionContinuityInd": {
	///      "$ref": "#/components/schemas/PduSessionContinuityInd"
	///    },
	///    "pduSessionTypes": {
	///      "$ref": "#/components/schemas/PduSessionTypes"
	///    },
	///    "redundantSessionAllowed": {
	///      "type": "boolean"
	///    },
	///    "secondaryAuth": {
	///      "type": "boolean"
	///    },
	///    "sessionAmbr": {
	///      "$ref": "#/components/schemas/Ambr"
	///    },
	///    "sharedEcsAddrConfigInfo": {
	///      "$ref": "#/components/schemas/SharedDataId"
	///    },
	///    "sscModes": {
	///      "$ref": "#/components/schemas/SscModes"
	///    },
	///    "staticIpAddress": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/IpAddress"
	///      },
	///      "maxItems": 2,
	///      "minItems": 1
	///    },
	///    "subscribedMaxIpv6PrefixSize": {
	///      "type": "integer"
	///    },
	///    "uavSecondaryAuth": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "upSecurity": {
	///      "$ref": "#/components/schemas/UpSecurity"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DnnConfiguration {
		#[serde(rename = "acsInfo", default, skip_serializing_if = "Option::is_none")]
		pub acs_info: Option<AcsInfo>,
		#[serde(
			rename = "additionalDnAaaAddresses",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub additional_dn_aaa_addresses: Vec<IpAddress>,
		#[serde(
			rename = "additionalEcsAddrConfigInfos",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub additional_ecs_addr_config_infos: Vec<EcsAddrConfigInfo>,
		#[serde(
			rename = "additionalSharedEcsAddrConfigInfoIds",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub additional_shared_ecs_addr_config_info_ids: Vec<SharedDataId>,
		#[serde(
			rename = "aerialUeInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub aerial_ue_ind: Option<AerialUeIndication>,
		#[serde(rename = "atsssAllowed", default)]
		pub atsss_allowed: bool,
		#[serde(
			rename = "dnAaaAddress",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub dn_aaa_address: Option<IpAddress>,
		#[serde(rename = "dnAaaFqdn", default, skip_serializing_if = "Option::is_none")]
		pub dn_aaa_fqdn: Option<Fqdn>,
		#[serde(
			rename = "dnAaaIpAddressAllocation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub dn_aaa_ip_address_allocation: Option<bool>,
		#[serde(rename = "easDiscoveryAuthorized", default)]
		pub eas_discovery_authorized: bool,
		#[serde(
			rename = "ecsAddrConfigInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ecs_addr_config_info: Option<EcsAddrConfigInfo>,
		#[serde(
			rename = "5gQosProfile",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub five_g_qos_profile: Option<SubscribedDefaultQos>,
		#[serde(
			rename = "iptvAccCtrlInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub iptv_acc_ctrl_info: Option<String>,
		#[serde(
			rename = "ipv4FrameRouteList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub ipv4_frame_route_list: Vec<FrameRouteInfo>,
		#[serde(rename = "ipv4Index", default, skip_serializing_if = "Option::is_none")]
		pub ipv4_index: Option<IpIndex>,
		#[serde(
			rename = "ipv6FrameRouteList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub ipv6_frame_route_list: Vec<FrameRouteInfo>,
		#[serde(rename = "ipv6Index", default, skip_serializing_if = "Option::is_none")]
		pub ipv6_index: Option<IpIndex>,
		#[serde(rename = "iwkEpsInd", default, skip_serializing_if = "Option::is_none")]
		pub iwk_eps_ind: Option<IwkEpsInd>,
		#[serde(rename = "niddInfo", default, skip_serializing_if = "Option::is_none")]
		pub nidd_info: Option<NiddInformation>,
		#[serde(rename = "niddNefId", default, skip_serializing_if = "Option::is_none")]
		pub nidd_nef_id: Option<NefId>,
		#[serde(rename = "onboardingInd", default)]
		pub onboarding_ind: bool,
		#[serde(
			rename = "pduSessionContinuityInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pdu_session_continuity_ind: Option<PduSessionContinuityInd>,
		#[serde(rename = "pduSessionTypes")]
		pub pdu_session_types: PduSessionTypes,
		#[serde(
			rename = "redundantSessionAllowed",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub redundant_session_allowed: Option<bool>,
		#[serde(
			rename = "secondaryAuth",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub secondary_auth: Option<bool>,
		#[serde(
			rename = "sessionAmbr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub session_ambr: Option<Ambr>,
		#[serde(
			rename = "sharedEcsAddrConfigInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub shared_ecs_addr_config_info: Option<SharedDataId>,
		#[serde(rename = "sscModes")]
		pub ssc_modes: SscModes,
		#[serde(
			rename = "staticIpAddress",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub static_ip_address: Vec<IpAddress>,
		#[serde(
			rename = "subscribedMaxIpv6PrefixSize",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub subscribed_max_ipv6_prefix_size: Option<i64>,
		#[serde(
			rename = "3gppChargingCharacteristics",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub three_gpp_charging_characteristics: Option<_3gppChargingCharacteristics>,
		#[serde(rename = "uavSecondaryAuth", default)]
		pub uav_secondary_auth: bool,
		#[serde(
			rename = "upSecurity",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub up_security: Option<UpSecurity>,
	}

	impl From<&DnnConfiguration> for DnnConfiguration {
		fn from(value: &DnnConfiguration) -> Self {
			value.clone()
		}
	}

	/// DnnIndicator
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "boolean"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DnnIndicator(pub bool);
	impl ::std::ops::Deref for DnnIndicator {
		type Target = bool;
		fn deref(&self) -> &bool {
			&self.0
		}
	}

	impl From<DnnIndicator> for bool {
		fn from(value: DnnIndicator) -> Self {
			value.0
		}
	}

	impl From<&DnnIndicator> for DnnIndicator {
		fn from(value: &DnnIndicator) -> Self {
			value.clone()
		}
	}

	impl From<bool> for DnnIndicator {
		fn from(value: bool) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for DnnIndicator {
		type Err = <bool as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for DnnIndicator {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for DnnIndicator {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for DnnIndicator {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for DnnIndicator {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// DnnInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "dnn"
	///  ],
	///  "properties": {
	///    "defaultDnnIndicator": {
	///      "$ref": "#/components/schemas/DnnIndicator"
	///    },
	///    "dnn": {
	///      "anyOf": [
	///        {
	///          "$ref": "#/components/schemas/Dnn"
	///        },
	///        {
	///          "$ref": "#/components/schemas/WildcardDnn"
	///        }
	///      ]
	///    },
	///    "dnnBarred": {
	///      "type": "boolean"
	///    },
	///    "invokeNefInd": {
	///      "type": "boolean"
	///    },
	///    "iwkEpsInd": {
	///      "$ref": "#/components/schemas/IwkEpsInd"
	///    },
	///    "lboRoamingAllowed": {
	///      "$ref": "#/components/schemas/LboRoamingAllowed"
	///    },
	///    "sameSmfInd": {
	///      "type": "boolean"
	///    },
	///    "smfList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/NfInstanceId"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DnnInfo {
		#[serde(
			rename = "defaultDnnIndicator",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub default_dnn_indicator: Option<DnnIndicator>,
		pub dnn: DnnInfoDnn,
		#[serde(rename = "dnnBarred", default, skip_serializing_if = "Option::is_none")]
		pub dnn_barred: Option<bool>,
		#[serde(
			rename = "invokeNefInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub invoke_nef_ind: Option<bool>,
		#[serde(rename = "iwkEpsInd", default, skip_serializing_if = "Option::is_none")]
		pub iwk_eps_ind: Option<IwkEpsInd>,
		#[serde(
			rename = "lboRoamingAllowed",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub lbo_roaming_allowed: Option<LboRoamingAllowed>,
		#[serde(
			rename = "sameSmfInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub same_smf_ind: Option<bool>,
		#[serde(rename = "smfList", default, skip_serializing_if = "Vec::is_empty")]
		pub smf_list: Vec<NfInstanceId>,
	}

	impl From<&DnnInfo> for DnnInfo {
		fn from(value: &DnnInfo) -> Self {
			value.clone()
		}
	}

	/// DnnInfoDnn
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "anyOf": [
	///    {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    {
	///      "$ref": "#/components/schemas/WildcardDnn"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DnnInfoDnn {
		#[serde(flatten, default, skip_serializing_if = "Option::is_none")]
		pub subtype_0: Option<Dnn>,
		#[serde(flatten, default, skip_serializing_if = "Option::is_none")]
		pub subtype_1: Option<WildcardDnn>,
	}

	impl From<&DnnInfoDnn> for DnnInfoDnn {
		fn from(value: &DnnInfoDnn) -> Self {
			value.clone()
		}
	}

	/// DualRegistrationFlag
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "boolean"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DualRegistrationFlag(pub bool);
	impl ::std::ops::Deref for DualRegistrationFlag {
		type Target = bool;
		fn deref(&self) -> &bool {
			&self.0
		}
	}

	impl From<DualRegistrationFlag> for bool {
		fn from(value: DualRegistrationFlag) -> Self {
			value.0
		}
	}

	impl From<&DualRegistrationFlag> for DualRegistrationFlag {
		fn from(value: &DualRegistrationFlag) -> Self {
			value.clone()
		}
	}

	impl From<bool> for DualRegistrationFlag {
		fn from(value: bool) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for DualRegistrationFlag {
		type Err = <bool as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for DualRegistrationFlag {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for DualRegistrationFlag {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for DualRegistrationFlag {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for DualRegistrationFlag {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// indicating a time in seconds.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "indicating a time in seconds.",
	///  "type": "integer"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DurationSec(pub i64);
	impl ::std::ops::Deref for DurationSec {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<DurationSec> for i64 {
		fn from(value: DurationSec) -> Self {
			value.0
		}
	}

	impl From<&DurationSec> for DurationSec {
		fn from(value: &DurationSec) -> Self {
			value.clone()
		}
	}

	impl From<i64> for DurationSec {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for DurationSec {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for DurationSec {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for DurationSec {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for DurationSec {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for DurationSec {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// indicating a time in seconds with OpenAPI defined 'nullable: true'
	/// property.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "indicating a time in seconds with OpenAPI defined
	/// 'nullable: true' property.",
	///  "type": [
	///    "integer",
	///    "null"
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct DurationSecRm(pub Option<i64>);
	impl ::std::ops::Deref for DurationSecRm {
		type Target = Option<i64>;
		fn deref(&self) -> &Option<i64> {
			&self.0
		}
	}

	impl From<DurationSecRm> for Option<i64> {
		fn from(value: DurationSecRm) -> Self {
			value.0
		}
	}

	impl From<&DurationSecRm> for DurationSecRm {
		fn from(value: &DurationSecRm) -> Self {
			value.clone()
		}
	}

	impl From<Option<i64>> for DurationSecRm {
		fn from(value: Option<i64>) -> Self {
			Self(value)
		}
	}

	/// E164Number
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[0-9]{1,15}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct E164Number(String);
	impl ::std::ops::Deref for E164Number {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<E164Number> for String {
		fn from(value: E164Number) -> Self {
			value.0
		}
	}

	impl From<&E164Number> for E164Number {
		fn from(value: &E164Number) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for E164Number {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9]{1,15}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9]{1,15}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for E164Number {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for E164Number {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for E164Number {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for E164Number {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// This represents the identifier of the eNB ID as specified in clause
	/// 9.2.1.37 of  3GPP TS 36.413. The string shall be formatted with the
	/// following pattern
	/// '^('MacroeNB-[A-Fa-f0-9]{5}|LMacroeNB-[A-Fa-f0-9]{6}|SMacroeNB-[A-Fa-f0-9]{5}
	/// |HomeeNB-[A-Fa-f0-9]{7})$'. The value of the eNB ID shall be encoded in
	/// hexadecimal representation. Each character in the  string shall take a
	/// value of "0" to "9", "a" to "f" or "A" to "F" and shall represent 4
	/// bits.  The padding 0 shall be added to make multiple nibbles, so the
	/// most significant character  representing the padding 0 if required
	/// together with the 4 most significant bits of the eNB ID  shall appear
	/// first in the string, and the character representing the 4 least
	/// significant bit  of the eNB ID (to form a nibble) shall appear last in
	/// the string.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This represents the identifier of the eNB ID as
	/// specified in clause 9.2.1.37 of  3GPP TS 36.413. The string shall be
	/// formatted with the following pattern
	/// '^('MacroeNB-[A-Fa-f0-9]{5}|LMacroeNB-[A-Fa-f0-9]{6}|SMacroeNB-[A-Fa-f0-9]{5}
	/// |HomeeNB-[A-Fa-f0-9]{7})$'. The value of the eNB ID shall be encoded in
	/// hexadecimal representation. Each character in the  string shall take a
	/// value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall
	/// represent 4 bits.  The padding 0 shall be added to make multiple
	/// nibbles, so the most significant character  representing the padding 0
	/// if required together with the 4 most significant bits of the eNB ID
	/// shall appear first in the string, and the character representing the 4
	/// least significant bit  of the eNB ID (to form a nibble) shall appear
	/// last in the string.\n",
	///  "type": "string",
	///  "pattern":
	/// "^(MacroeNB-[A-Fa-f0-9]{5}|LMacroeNB-[A-Fa-f0-9]{6}|SMacroeNB-[A-Fa-f0-9]{5}|HomeeNB-[A-Fa-f0-9]{7})$"
	///
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct ENbId(String);
	impl ::std::ops::Deref for ENbId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<ENbId> for String {
		fn from(value: ENbId) -> Self {
			value.0
		}
	}

	impl From<&ENbId> for ENbId {
		fn from(value: &ENbId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for ENbId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress :: Regex :: new ("^(MacroeNB-[A-Fa-f0-9]{5}|LMacroeNB-[A-Fa-f0-9]{6}|SMacroeNB-[A-Fa-f0-9]{5}|HomeeNB-[A-Fa-f0-9]{7})$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(MacroeNB-[A-Fa-f0-9]{5}|LMacroeNB-[A-Fa-f0-9]{6}|SMacroeNB-[A-Fa-f0-9]{5}|HomeeNB-[A-Fa-f0-9]{7})$\"" . into ()) ; }
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for ENbId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for ENbId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for ENbId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for ENbId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// EcRestriction
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "required": [
	///    "afInstanceId",
	///    "referenceId"
	///  ],
	///  "properties": {
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "plmnEcInfos": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/PlmnEcInfo"
	///      },
	///      "minItems": 1
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct EcRestriction(pub Option<EcRestrictionInner>);
	impl ::std::ops::Deref for EcRestriction {
		type Target = Option<EcRestrictionInner>;
		fn deref(&self) -> &Option<EcRestrictionInner> {
			&self.0
		}
	}

	impl From<EcRestriction> for Option<EcRestrictionInner> {
		fn from(value: EcRestriction) -> Self {
			value.0
		}
	}

	impl From<&EcRestriction> for EcRestriction {
		fn from(value: &EcRestriction) -> Self {
			value.clone()
		}
	}

	impl From<Option<EcRestrictionInner>> for EcRestriction {
		fn from(value: Option<EcRestrictionInner>) -> Self {
			Self(value)
		}
	}

	/// EcRestrictionDataWb
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "anyOf": [
	///    {
	///      "required": [
	///        "ecModeARestricted"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "ecModeBRestricted"
	///      ]
	///    }
	///  ],
	///  "properties": {
	///    "ecModeARestricted": {
	///      "type": "boolean"
	///    },
	///    "ecModeBRestricted": {
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum EcRestrictionDataWb {
		#[default]
		Variant0 {
			#[serde(rename = "ecModeARestricted")]
			ec_mode_a_restricted: bool,
		},
		Variant1 {
			#[serde(rename = "ecModeBRestricted")]
			ec_mode_b_restricted: bool,
		},
	}

	impl From<&EcRestrictionDataWb> for EcRestrictionDataWb {
		fn from(value: &EcRestrictionDataWb) -> Self {
			value.clone()
		}
	}

	/// EcRestrictionInner
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "afInstanceId",
	///    "referenceId"
	///  ],
	///  "properties": {
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "plmnEcInfos": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/PlmnEcInfo"
	///      },
	///      "minItems": 1
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct EcRestrictionInner {
		#[serde(rename = "afInstanceId")]
		pub af_instance_id: String,
		#[serde(
			rename = "mtcProviderInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mtc_provider_information: Option<MtcProviderInformation>,
		#[serde(rename = "plmnEcInfos", default, skip_serializing_if = "Vec::is_empty")]
		pub plmn_ec_infos: Vec<PlmnEcInfo>,
		#[serde(rename = "referenceId")]
		pub reference_id: ReferenceId,
	}

	impl From<&EcRestrictionInner> for EcRestrictionInner {
		fn from(value: &EcRestrictionInner) -> Self {
			value.clone()
		}
	}

	/// Contains the ECGI (E-UTRAN Cell Global Identity), as described in 3GPP
	/// 23.003
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the ECGI (E-UTRAN Cell Global Identity), as
	/// described in 3GPP 23.003",
	///  "type": "object",
	///  "required": [
	///    "eutraCellId",
	///    "plmnId"
	///  ],
	///  "properties": {
	///    "eutraCellId": {
	///      "$ref": "#/components/schemas/EutraCellId"
	///    },
	///    "nid": {
	///      "$ref": "#/components/schemas/Nid"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Ecgi {
		#[serde(rename = "eutraCellId")]
		pub eutra_cell_id: EutraCellId,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub nid: Option<Nid>,
		#[serde(rename = "plmnId")]
		pub plmn_id: PlmnId,
	}

	impl From<&Ecgi> for Ecgi {
		fn from(value: &Ecgi) -> Self {
			value.clone()
		}
	}

	/// EcsAddrConfigInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "properties": {
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "ecsServerAddr": {
	///      "$ref": "#/components/schemas/EcsServerAddr"
	///    },
	///    "snssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    },
	///    "spatialValidityCond": {
	///      "$ref": "#/components/schemas/SpatialValidityCond"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct EcsAddrConfigInfo(pub Option<EcsAddrConfigInfoInner>);
	impl ::std::ops::Deref for EcsAddrConfigInfo {
		type Target = Option<EcsAddrConfigInfoInner>;
		fn deref(&self) -> &Option<EcsAddrConfigInfoInner> {
			&self.0
		}
	}

	impl From<EcsAddrConfigInfo> for Option<EcsAddrConfigInfoInner> {
		fn from(value: EcsAddrConfigInfo) -> Self {
			value.0
		}
	}

	impl From<&EcsAddrConfigInfo> for EcsAddrConfigInfo {
		fn from(value: &EcsAddrConfigInfo) -> Self {
			value.clone()
		}
	}

	impl From<Option<EcsAddrConfigInfoInner>> for EcsAddrConfigInfo {
		fn from(value: Option<EcsAddrConfigInfoInner>) -> Self {
			Self(value)
		}
	}

	/// EcsAddrConfigInfoInner
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "ecsServerAddr": {
	///      "$ref": "#/components/schemas/EcsServerAddr"
	///    },
	///    "snssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    },
	///    "spatialValidityCond": {
	///      "$ref": "#/components/schemas/SpatialValidityCond"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct EcsAddrConfigInfoInner {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub dnn: Option<Dnn>,
		#[serde(
			rename = "ecsServerAddr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ecs_server_addr: Option<EcsServerAddr>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub snssai: Option<Snssai>,
		#[serde(
			rename = "spatialValidityCond",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub spatial_validity_cond: Option<SpatialValidityCond>,
	}

	impl From<&EcsAddrConfigInfoInner> for EcsAddrConfigInfoInner {
		fn from(value: &EcsAddrConfigInfoInner) -> Self {
			value.clone()
		}
	}

	/// Contains the Edge Configuration Server Address Configuration Information
	/// as defined in clause 5.2.3.6.1 of 3GPP TS 23.502.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the Edge Configuration Server Address
	/// Configuration Information as defined in clause 5.2.3.6.1 of 3GPP TS
	/// 23.502.\n",
	///  "type": "object",
	///  "properties": {
	///    "ecsFqdnList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Fqdn"
	///      },
	///      "minItems": 1
	///    },
	///    "ecsIpAddressList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/IpAddr"
	///      },
	///      "minItems": 1
	///    },
	///    "ecsProviderId": {
	///      "type": "string"
	///    },
	///    "ecsUriList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Uri"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct EcsServerAddr {
		#[serde(rename = "ecsFqdnList", default, skip_serializing_if = "Vec::is_empty")]
		pub ecs_fqdn_list: Vec<Fqdn>,
		#[serde(
			rename = "ecsIpAddressList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub ecs_ip_address_list: Vec<IpAddr>,
		#[serde(
			rename = "ecsProviderId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ecs_provider_id: Option<String>,
		#[serde(rename = "ecsUriList", default, skip_serializing_if = "Vec::is_empty")]
		pub ecs_uri_list: Vec<Uri>,
	}

	impl From<&EcsServerAddr> for EcsServerAddr {
		fn from(value: &EcsServerAddr) -> Self {
			value.clone()
		}
	}

	/// EdrxParameters
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "edrxValue",
	///    "ratType"
	///  ],
	///  "properties": {
	///    "edrxValue": {
	///      "type": "string",
	///      "pattern": "^([0-1]{4})$"
	///    },
	///    "ratType": {
	///      "$ref": "#/components/schemas/RatType"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct EdrxParameters {
		#[serde(rename = "edrxValue")]
		pub edrx_value: EdrxParametersEdrxValue,
		#[serde(rename = "ratType")]
		pub rat_type: RatType,
	}

	impl From<&EdrxParameters> for EdrxParameters {
		fn from(value: &EdrxParameters) -> Self {
			value.clone()
		}
	}

	/// EdrxParametersEdrxValue
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^([0-1]{4})$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct EdrxParametersEdrxValue(String);
	impl ::std::ops::Deref for EdrxParametersEdrxValue {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<EdrxParametersEdrxValue> for String {
		fn from(value: EdrxParametersEdrxValue) -> Self {
			value.0
		}
	}

	impl From<&EdrxParametersEdrxValue> for EdrxParametersEdrxValue {
		fn from(value: &EdrxParametersEdrxValue) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for EdrxParametersEdrxValue {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^([0-1]{4})$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^([0-1]{4})$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for EdrxParametersEdrxValue {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for EdrxParametersEdrxValue {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for EdrxParametersEdrxValue {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for EdrxParametersEdrxValue {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// EeMonitoringRevoked
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "revokedMonitoringEventList"
	///  ],
	///  "properties": {
	///    "excludeGpsiList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Gpsi"
	///      },
	///      "minItems": 1
	///    },
	///    "removedGpsi": {
	///      "$ref": "#/components/schemas/Gpsi"
	///    },
	///    "revokedMonitoringEventList": {
	///      "description": "A map (list of key-value pairs where ReferenceId
	/// serves as key) of MonitoringEvents",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/MonitoringEvent"
	///      }
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct EeMonitoringRevoked {
		#[serde(
			rename = "excludeGpsiList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub exclude_gpsi_list: Vec<Gpsi>,
		#[serde(
			rename = "removedGpsi",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub removed_gpsi: Option<Gpsi>,
		/// A map (list of key-value pairs where ReferenceId serves as key) of
		/// MonitoringEvents
		#[serde(rename = "revokedMonitoringEventList")]
		pub revoked_monitoring_event_list: ::std::collections::HashMap<String, MonitoringEvent>,
	}

	impl From<&EeMonitoringRevoked> for EeMonitoringRevoked {
		fn from(value: &EeMonitoringRevoked) -> Self {
			value.clone()
		}
	}

	/// EeSubscription
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "callbackReference",
	///    "monitoringConfigurations"
	///  ],
	///  "properties": {
	///    "callbackReference": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "contextInfo": {
	///      "$ref": "#/components/schemas/ContextInfo"
	///    },
	///    "dataRestorationCallbackUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "epcAppliedInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "excludeGpsiList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Gpsi"
	///      },
	///      "minItems": 1
	///    },
	///    "gpsi": {
	///      "$ref": "#/components/schemas/Gpsi"
	///    },
	///    "includeGpsiList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Gpsi"
	///      },
	///      "minItems": 1
	///    },
	///    "monitoringConfigurations": {
	///      "description": "A map (list of key-value pairs where ReferenceId
	/// serves as key) of MonitoringConfigurations",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/MonitoringConfiguration"
	///      }
	///    },
	///    "notifyCorrelationId": {
	///      "type": "string"
	///    },
	///    "reportingOptions": {
	///      "$ref": "#/components/schemas/ReportingOptions"
	///    },
	///    "scefDiamHost": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "scefDiamRealm": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "secondCallbackRef": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "subscriptionId": {
	///      "type": "string"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "udrRestartInd": {
	///      "default": false,
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct EeSubscription {
		#[serde(rename = "callbackReference")]
		pub callback_reference: Uri,
		#[serde(
			rename = "contextInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub context_info: Option<ContextInfo>,
		#[serde(
			rename = "dataRestorationCallbackUri",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub data_restoration_callback_uri: Option<Uri>,
		#[serde(rename = "epcAppliedInd", default)]
		pub epc_applied_ind: bool,
		#[serde(
			rename = "excludeGpsiList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub exclude_gpsi_list: Vec<Gpsi>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub gpsi: Option<Gpsi>,
		#[serde(
			rename = "includeGpsiList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub include_gpsi_list: Vec<Gpsi>,
		/// A map (list of key-value pairs where ReferenceId serves as key) of
		/// MonitoringConfigurations
		#[serde(rename = "monitoringConfigurations")]
		pub monitoring_configurations: ::std::collections::HashMap<String, MonitoringConfiguration>,
		#[serde(
			rename = "notifyCorrelationId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub notify_correlation_id: Option<String>,
		#[serde(
			rename = "reportingOptions",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub reporting_options: Option<ReportingOptions>,
		#[serde(
			rename = "scefDiamHost",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub scef_diam_host: Option<Fqdn>,
		#[serde(
			rename = "scefDiamRealm",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub scef_diam_realm: Option<Fqdn>,
		#[serde(
			rename = "secondCallbackRef",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub second_callback_ref: Option<Uri>,
		#[serde(
			rename = "subscriptionId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub subscription_id: Option<String>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
		#[serde(rename = "udrRestartInd", default)]
		pub udr_restart_ind: bool,
	}

	impl From<&EeSubscription> for EeSubscription {
		fn from(value: &EeSubscription) -> Self {
			value.clone()
		}
	}

	/// Ellipsoid Arc.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Ellipsoid Arc.",
	///  "allOf": [
	///    {
	///      "$ref": "#/components/schemas/GADShape"
	///    },
	///    {
	///      "type": "object",
	///      "required": [
	///        "confidence",
	///        "includedAngle",
	///        "innerRadius",
	///        "offsetAngle",
	///        "point",
	///        "uncertaintyRadius"
	///      ],
	///      "properties": {
	///        "confidence": {
	///          "$ref": "#/components/schemas/Confidence"
	///        },
	///        "includedAngle": {
	///          "$ref": "#/components/schemas/Angle"
	///        },
	///        "innerRadius": {
	///          "$ref": "#/components/schemas/InnerRadius"
	///        },
	///        "offsetAngle": {
	///          "$ref": "#/components/schemas/Angle"
	///        },
	///        "point": {
	///          "$ref": "#/components/schemas/GeographicalCoordinates"
	///        },
	///        "uncertaintyRadius": {
	///          "$ref": "#/components/schemas/Uncertainty"
	///        }
	///      }
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct EllipsoidArc {
		pub confidence: Confidence,
		#[serde(rename = "includedAngle")]
		pub included_angle: Angle,
		#[serde(rename = "innerRadius")]
		pub inner_radius: InnerRadius,
		#[serde(rename = "offsetAngle")]
		pub offset_angle: Angle,
		pub point: GeographicalCoordinates,
		pub shape: SupportedGadShapes,
		#[serde(rename = "uncertaintyRadius")]
		pub uncertainty_radius: Uncertainty,
	}

	impl From<&EllipsoidArc> for EllipsoidArc {
		fn from(value: &EllipsoidArc) -> Self {
			value.clone()
		}
	}

	/// EmergencyInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "oneOf": [
	///    {
	///      "required": [
	///        "pgwFqdn"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "pgwIpAddress"
	///      ]
	///    }
	///  ],
	///  "properties": {
	///    "epdgInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "pgwFqdn": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "pgwIpAddress": {
	///      "$ref": "#/components/schemas/IpAddress"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "smfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum EmergencyInfo {
		#[default]
		Variant0 {
			#[serde(rename = "epdgInd", default)]
			epdg_ind: bool,
			#[serde(rename = "pgwFqdn")]
			pgw_fqdn: Fqdn,
			#[serde(rename = "plmnId", default, skip_serializing_if = "Option::is_none")]
			plmn_id: Option<PlmnId>,
			#[serde(
				rename = "smfInstanceId",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			smf_instance_id: Option<NfInstanceId>,
		},
		Variant1 {
			#[serde(rename = "epdgInd", default)]
			epdg_ind: bool,
			#[serde(rename = "pgwIpAddress")]
			pgw_ip_address: IpAddress,
			#[serde(rename = "plmnId", default, skip_serializing_if = "Option::is_none")]
			plmn_id: Option<PlmnId>,
			#[serde(
				rename = "smfInstanceId",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			smf_instance_id: Option<NfInstanceId>,
		},
	}

	impl From<&EmergencyInfo> for EmergencyInfo {
		fn from(value: &EmergencyInfo) -> Self {
			value.clone()
		}
	}

	/// EnhancedCoverageRestrictionData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "plmnEcInfoList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/PlmnEcInfo"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct EnhancedCoverageRestrictionData {
		#[serde(
			rename = "plmnEcInfoList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub plmn_ec_info_list: Vec<PlmnEcInfo>,
	}

	impl From<&EnhancedCoverageRestrictionData> for EnhancedCoverageRestrictionData {
		fn from(value: &EnhancedCoverageRestrictionData) -> Self {
			value.clone()
		}
	}

	/// EpsInterworkingInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "epsIwkPgws": {
	///      "description": "A map (list of key-value pairs where Dnn serves as
	/// key) of EpsIwkPgws",
	///      "type": "object",
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/EpsIwkPgw"
	///      }
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct EpsInterworkingInfo {
		/// A map (list of key-value pairs where Dnn serves as key) of
		/// EpsIwkPgws
		#[serde(
			rename = "epsIwkPgws",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub eps_iwk_pgws: ::std::collections::HashMap<String, EpsIwkPgw>,
	}

	impl From<&EpsInterworkingInfo> for EpsInterworkingInfo {
		fn from(value: &EpsInterworkingInfo) -> Self {
			value.clone()
		}
	}

	/// EpsIwkPgw
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "pgwFqdn",
	///    "smfInstanceId"
	///  ],
	///  "properties": {
	///    "pgwFqdn": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "smfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct EpsIwkPgw {
		#[serde(rename = "pgwFqdn")]
		pub pgw_fqdn: Fqdn,
		#[serde(rename = "plmnId", default, skip_serializing_if = "Option::is_none")]
		pub plmn_id: Option<PlmnId>,
		#[serde(rename = "smfInstanceId")]
		pub smf_instance_id: NfInstanceId,
	}

	impl From<&EpsIwkPgw> for EpsIwkPgw {
		fn from(value: &EpsIwkPgw) -> Self {
			value.clone()
		}
	}

	/// 28-bit string identifying an E-UTRA Cell Id as specified in clause
	/// 9.3.1.9 of  3GPP TS 38.413, in hexadecimal representation. Each
	/// character in the string shall take a  value of "0" to "9", "a" to "f" or
	/// "A" to "F" and shall represent 4 bits. The most  significant character
	/// representing the 4 most significant bits of the Cell Id shall appear
	/// first in the string, and the character representing the 4 least
	/// significant bit of the  Cell Id shall appear last in the string.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "28-bit string identifying an E-UTRA Cell Id as
	/// specified in clause 9.3.1.9 of  3GPP TS 38.413, in hexadecimal
	/// representation. Each character in the string shall take a  value of
	/// \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4
	/// bits. The most  significant character representing the 4 most
	/// significant bits of the Cell Id shall appear  first in the string, and
	/// the character representing the 4 least significant bit of the  Cell Id
	/// shall appear last in the string. \n",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{7}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct EutraCellId(String);
	impl ::std::ops::Deref for EutraCellId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<EutraCellId> for String {
		fn from(value: EutraCellId) -> Self {
			value.0
		}
	}

	impl From<&EutraCellId> for EutraCellId {
		fn from(value: &EutraCellId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for EutraCellId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{7}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{7}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for EutraCellId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for EutraCellId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for EutraCellId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for EutraCellId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Contains the E-UTRA user location.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the E-UTRA user location.",
	///  "type": "object",
	///  "required": [
	///    "ecgi",
	///    "tai"
	///  ],
	///  "properties": {
	///    "ageOfLocationInformation": {
	///      "description": "The value represents the elapsed time in minutes
	/// since the last network contact of the mobile station.  Value \"0\"
	/// indicates that the location information was obtained after a successful
	/// paging procedure for Active Location Retrieval when the UE is in idle
	/// mode or after a successful NG-RAN location reporting procedure with the
	/// eNB when the UE is in connected mode.  Any other value than \"0\"
	/// indicates that the location information is the last known one.  See 3GPP
	/// TS 29.002 clause 17.7.8.\n",
	///      "type": "integer",
	///      "maximum": 32767.0,
	///      "minimum": 0.0
	///    },
	///    "ecgi": {
	///      "$ref": "#/components/schemas/Ecgi"
	///    },
	///    "geodeticInformation": {
	///      "description": "Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763 (1999) [24] clause 3.88.2. Only the description of an ellipsoid point with uncertainty circle is allowed to be used.\n",
	///      "type": "string",
	///      "pattern": "^[0-9A-F]{20}$"
	///    },
	///    "geographicalInformation": {
	///      "description": "Refer to geographical Information. See 3GPP TS
	/// 23.032 clause 7.3.2. Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.\n",
	///      "type": "string",
	///      "pattern": "^[0-9A-F]{16}$"
	///    },
	///    "globalENbId": {
	///      "$ref": "#/components/schemas/GlobalRanNodeId"
	///    },
	///    "globalNgenbId": {
	///      "$ref": "#/components/schemas/GlobalRanNodeId"
	///    },
	///    "ignoreEcgi": {
	///      "description": "This flag when present shall indicate that the Ecgi
	/// shall be ignored When present, it shall be set as follows: - true: ecgi
	/// shall be ignored. - false (default): ecgi shall not be ignored.\n",
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "ignoreTai": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "tai": {
	///      "$ref": "#/components/schemas/Tai"
	///    },
	///    "ueLocationTimestamp": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct EutraLocation {
		/// The value represents the elapsed time in minutes since the last
		/// network contact of the mobile station.  Value "0" indicates that the
		/// location information was obtained after a successful paging
		/// procedure for Active Location Retrieval when the UE is in idle mode
		/// or after a successful NG-RAN location reporting procedure with the
		/// eNB when the UE is in connected mode.  Any other value than "0"
		/// indicates that the location information is the last known one.  See
		/// 3GPP TS 29.002 clause 17.7.8.
		#[serde(
			rename = "ageOfLocationInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub age_of_location_information: Option<i64>,
		pub ecgi: Ecgi,
		/// Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763
		/// (1999) [24] clause 3.88.2. Only the description of an ellipsoid
		/// point with uncertainty circle is allowed to be used.
		#[serde(
			rename = "geodeticInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub geodetic_information: Option<EutraLocationGeodeticInformation>,
		/// Refer to geographical Information. See 3GPP TS 23.032 clause 7.3.2.
		/// Only the description of an ellipsoid point with uncertainty circle
		/// is allowed to be used.
		#[serde(
			rename = "geographicalInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub geographical_information: Option<EutraLocationGeographicalInformation>,
		#[serde(
			rename = "globalENbId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub global_e_nb_id: Option<GlobalRanNodeId>,
		#[serde(
			rename = "globalNgenbId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub global_ngenb_id: Option<GlobalRanNodeId>,
		/// This flag when present shall indicate that the Ecgi shall be ignored
		/// When present, it shall be set as follows: - true: ecgi shall be
		/// ignored. - false (default): ecgi shall not be ignored.
		#[serde(rename = "ignoreEcgi", default)]
		pub ignore_ecgi: bool,
		#[serde(rename = "ignoreTai", default)]
		pub ignore_tai: bool,
		pub tai: Tai,
		#[serde(
			rename = "ueLocationTimestamp",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ue_location_timestamp: Option<DateTime>,
	}

	impl From<&EutraLocation> for EutraLocation {
		fn from(value: &EutraLocation) -> Self {
			value.clone()
		}
	}

	/// Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763
	/// (1999) [24] clause 3.88.2. Only the description of an ellipsoid point
	/// with uncertainty circle is allowed to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763 (1999) [24] clause 3.88.2. Only the description of an ellipsoid point with uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{20}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct EutraLocationGeodeticInformation(String);
	impl ::std::ops::Deref for EutraLocationGeodeticInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<EutraLocationGeodeticInformation> for String {
		fn from(value: EutraLocationGeodeticInformation) -> Self {
			value.0
		}
	}

	impl From<&EutraLocationGeodeticInformation> for EutraLocationGeodeticInformation {
		fn from(value: &EutraLocationGeodeticInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for EutraLocationGeodeticInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{20}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for EutraLocationGeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for EutraLocationGeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for EutraLocationGeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for EutraLocationGeodeticInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Refer to geographical Information. See 3GPP TS 23.032 clause 7.3.2. Only
	/// the description of an ellipsoid point with uncertainty circle is allowed
	/// to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refer to geographical Information. See 3GPP TS 23.032
	/// clause 7.3.2. Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{16}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct EutraLocationGeographicalInformation(String);
	impl ::std::ops::Deref for EutraLocationGeographicalInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<EutraLocationGeographicalInformation> for String {
		fn from(value: EutraLocationGeographicalInformation) -> Self {
			value.0
		}
	}

	impl From<&EutraLocationGeographicalInformation> for EutraLocationGeographicalInformation {
		fn from(value: &EutraLocationGeographicalInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for EutraLocationGeographicalInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{16}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for EutraLocationGeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for EutraLocationGeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for EutraLocationGeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for EutraLocationGeographicalInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// The enumeration EventForMdt defines events triggered measurement for
	/// logged MDT in the trace. See 3GPP TS 32.422 for further description of
	/// the values. It shall comply with the provisions defined in table
	/// 5.6.3.11-1
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration EventForMdt defines events triggered
	/// measurement for logged MDT in the trace. See 3GPP TS 32.422 for further
	/// description of the values. It shall comply with the provisions defined
	/// in table 5.6.3.11-1\n",
	///  "type": "string",
	///  "enum": [
	///    "OUT_OF_COVERAG",
	///    "A2_EVENT"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum EventForMdt {
		#[default]
		#[serde(rename = "OUT_OF_COVERAG")]
		OutOfCoverag,
		#[serde(rename = "A2_EVENT")]
		A2Event,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&EventForMdt> for EventForMdt {
		fn from(value: &EventForMdt) -> Self {
			value.clone()
		}
	}

	impl ToString for EventForMdt {
		fn to_string(&self) -> String {
			match *self {
				Self::OutOfCoverag => "OUT_OF_COVERAG".to_string(),
				Self::A2Event => "A2_EVENT".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for EventForMdt {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"OUT_OF_COVERAG" => Ok(Self::OutOfCoverag),
				"A2_EVENT" => Ok(Self::A2Event),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for EventForMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for EventForMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for EventForMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Possible values are:
	/// - LOAD_LEVEL_INFORMATION: Represent the analytics of load level
	///   information of corresponding network slice.
	/// - NETWORK_PERFORMANCE: Represent the analytics of network performance
	///   information.
	/// - NF_LOAD: Indicates that the event subscribed is NF Load.
	/// - SERVICE_EXPERIENCE: Represent the analytics of service experience
	///   information of the specific applications.
	/// - UE_MOBILITY: Represent the analytics of UE mobility.
	/// - UE_COMMUNICATION: Represent the analytics of UE communication.
	/// - QOS_SUSTAINABILITY: Represent the analytics of QoS sustainability
	///   information in the certain area.
	/// - ABNORMAL_BEHAVIOUR: Indicates that the event subscribed is abnormal
	///   behaviour information.
	/// - USER_DATA_CONGESTION: Represent the analytics of the user data
	///   congestion in the certain area.
	/// - NSI_LOAD_LEVEL: Represent the analytics of Network Slice and the
	///   optionally associated Network Slice Instance.
	/// - SM_CONGESTION: Represent the analytics of Session Management
	///   congestion control experience information for specific DNN and/or
	///   S-NSSAI.
	/// - DISPERSION: Represents the analytics of dispersion.
	/// - RED_TRANS_EXP: Represents the analytics of Redundant Transmission
	///   Experience.
	/// - WLAN_PERFORMANCE: Represents the analytics of WLAN performance.
	/// - DN_PERFORMANCE: Represents the analytics of DN performance.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Possible values are:\n- LOAD_LEVEL_INFORMATION:
	/// Represent the analytics of load level information of corresponding
	/// network slice.\n- NETWORK_PERFORMANCE: Represent the analytics of
	/// network performance information.\n- NF_LOAD: Indicates that the event
	/// subscribed is NF Load.\n- SERVICE_EXPERIENCE: Represent the analytics of
	/// service experience information of the specific applications.\n-
	/// UE_MOBILITY: Represent the analytics of UE mobility.\n-
	/// UE_COMMUNICATION: Represent the analytics of UE communication.\n-
	/// QOS_SUSTAINABILITY: Represent the analytics of QoS sustainability
	/// information in the certain area.\n- ABNORMAL_BEHAVIOUR: Indicates that
	/// the event subscribed is abnormal behaviour information.\n-
	/// USER_DATA_CONGESTION: Represent the analytics of the user data
	/// congestion in the certain area.\n- NSI_LOAD_LEVEL: Represent the
	/// analytics of Network Slice and the optionally associated Network Slice
	/// Instance.\n- SM_CONGESTION: Represent the analytics of Session
	/// Management congestion control experience information for specific DNN
	/// and/or S-NSSAI.\n- DISPERSION: Represents the analytics of
	/// dispersion.\n- RED_TRANS_EXP: Represents the analytics of Redundant
	/// Transmission Experience.\n- WLAN_PERFORMANCE: Represents the analytics
	/// of WLAN performance.\n- DN_PERFORMANCE: Represents the analytics of DN
	/// performance.\n",
	///  "type": "string",
	///  "enum": [
	///    "LOAD_LEVEL_INFORMATION",
	///    "NETWORK_PERFORMANCE",
	///    "NF_LOAD",
	///    "SERVICE_EXPERIENCE",
	///    "UE_MOBILITY",
	///    "UE_COMMUNICATION",
	///    "QOS_SUSTAINABILITY",
	///    "ABNORMAL_BEHAVIOUR",
	///    "USER_DATA_CONGESTION",
	///    "NSI_LOAD_LEVEL",
	///    "SM_CONGESTION",
	///    "DISPERSION",
	///    "RED_TRANS_EXP",
	///    "WLAN_PERFORMANCE",
	///    "DN_PERFORMANCE"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum EventId {
		#[default]
		#[serde(rename = "LOAD_LEVEL_INFORMATION")]
		LoadLevelInformation,
		#[serde(rename = "NETWORK_PERFORMANCE")]
		NetworkPerformance,
		#[serde(rename = "NF_LOAD")]
		NfLoad,
		#[serde(rename = "SERVICE_EXPERIENCE")]
		ServiceExperience,
		#[serde(rename = "UE_MOBILITY")]
		UeMobility,
		#[serde(rename = "UE_COMMUNICATION")]
		UeCommunication,
		#[serde(rename = "QOS_SUSTAINABILITY")]
		QosSustainability,
		#[serde(rename = "ABNORMAL_BEHAVIOUR")]
		AbnormalBehaviour,
		#[serde(rename = "USER_DATA_CONGESTION")]
		UserDataCongestion,
		#[serde(rename = "NSI_LOAD_LEVEL")]
		NsiLoadLevel,
		#[serde(rename = "SM_CONGESTION")]
		SmCongestion,
		#[serde(rename = "DISPERSION")]
		Dispersion,
		#[serde(rename = "RED_TRANS_EXP")]
		RedTransExp,
		#[serde(rename = "WLAN_PERFORMANCE")]
		WlanPerformance,
		#[serde(rename = "DN_PERFORMANCE")]
		DnPerformance,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&EventId> for EventId {
		fn from(value: &EventId) -> Self {
			value.clone()
		}
	}

	impl ToString for EventId {
		fn to_string(&self) -> String {
			match *self {
				Self::LoadLevelInformation => "LOAD_LEVEL_INFORMATION".to_string(),
				Self::NetworkPerformance => "NETWORK_PERFORMANCE".to_string(),
				Self::NfLoad => "NF_LOAD".to_string(),
				Self::ServiceExperience => "SERVICE_EXPERIENCE".to_string(),
				Self::UeMobility => "UE_MOBILITY".to_string(),
				Self::UeCommunication => "UE_COMMUNICATION".to_string(),
				Self::QosSustainability => "QOS_SUSTAINABILITY".to_string(),
				Self::AbnormalBehaviour => "ABNORMAL_BEHAVIOUR".to_string(),
				Self::UserDataCongestion => "USER_DATA_CONGESTION".to_string(),
				Self::NsiLoadLevel => "NSI_LOAD_LEVEL".to_string(),
				Self::SmCongestion => "SM_CONGESTION".to_string(),
				Self::Dispersion => "DISPERSION".to_string(),
				Self::RedTransExp => "RED_TRANS_EXP".to_string(),
				Self::WlanPerformance => "WLAN_PERFORMANCE".to_string(),
				Self::DnPerformance => "DN_PERFORMANCE".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for EventId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"LOAD_LEVEL_INFORMATION" => Ok(Self::LoadLevelInformation),
				"NETWORK_PERFORMANCE" => Ok(Self::NetworkPerformance),
				"NF_LOAD" => Ok(Self::NfLoad),
				"SERVICE_EXPERIENCE" => Ok(Self::ServiceExperience),
				"UE_MOBILITY" => Ok(Self::UeMobility),
				"UE_COMMUNICATION" => Ok(Self::UeCommunication),
				"QOS_SUSTAINABILITY" => Ok(Self::QosSustainability),
				"ABNORMAL_BEHAVIOUR" => Ok(Self::AbnormalBehaviour),
				"USER_DATA_CONGESTION" => Ok(Self::UserDataCongestion),
				"NSI_LOAD_LEVEL" => Ok(Self::NsiLoadLevel),
				"SM_CONGESTION" => Ok(Self::SmCongestion),
				"DISPERSION" => Ok(Self::Dispersion),
				"RED_TRANS_EXP" => Ok(Self::RedTransExp),
				"WLAN_PERFORMANCE" => Ok(Self::WlanPerformance),
				"DN_PERFORMANCE" => Ok(Self::DnPerformance),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for EventId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for EventId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for EventId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// EventReportMode
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "PERIODIC",
	///    "ON_EVENT_DETECTION"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum EventReportMode {
		#[default]
		#[serde(rename = "PERIODIC")]
		Periodic,
		#[serde(rename = "ON_EVENT_DETECTION")]
		OnEventDetection,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&EventReportMode> for EventReportMode {
		fn from(value: &EventReportMode) -> Self {
			value.clone()
		}
	}

	impl ToString for EventReportMode {
		fn to_string(&self) -> String {
			match *self {
				Self::Periodic => "PERIODIC".to_string(),
				Self::OnEventDetection => "ON_EVENT_DETECTION".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for EventReportMode {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"PERIODIC" => Ok(Self::Periodic),
				"ON_EVENT_DETECTION" => Ok(Self::OnEventDetection),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for EventReportMode {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for EventReportMode {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for EventReportMode {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// EventType
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "LOSS_OF_CONNECTIVITY",
	///    "UE_REACHABILITY_FOR_DATA",
	///    "UE_REACHABILITY_FOR_SMS",
	///    "LOCATION_REPORTING",
	///    "CHANGE_OF_SUPI_PEI_ASSOCIATION",
	///    "ROAMING_STATUS",
	///    "COMMUNICATION_FAILURE",
	///    "AVAILABILITY_AFTER_DDN_FAILURE",
	///    "CN_TYPE_CHANGE",
	///    "DL_DATA_DELIVERY_STATUS",
	///    "PDN_CONNECTIVITY_STATUS",
	///    "UE_CONNECTION_MANAGEMENT_STATE",
	///    "ACCESS_TYPE_REPORT",
	///    "REGISTRATION_STATE_REPORT",
	///    "CONNECTIVITY_STATE_REPORT",
	///    "TYPE_ALLOCATION_CODE_REPORT",
	///    "FREQUENT_MOBILITY_REGISTRATION_REPORT",
	///    "PDU_SES_REL",
	///    "PDU_SES_EST",
	///    "UE_MEMORY_AVAILABLE_FOR_SMS"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum EventType {
		#[default]
		#[serde(rename = "LOSS_OF_CONNECTIVITY")]
		LossOfConnectivity,
		#[serde(rename = "UE_REACHABILITY_FOR_DATA")]
		UeReachabilityForData,
		#[serde(rename = "UE_REACHABILITY_FOR_SMS")]
		UeReachabilityForSms,
		#[serde(rename = "LOCATION_REPORTING")]
		LocationReporting,
		#[serde(rename = "CHANGE_OF_SUPI_PEI_ASSOCIATION")]
		ChangeOfSupiPeiAssociation,
		#[serde(rename = "ROAMING_STATUS")]
		RoamingStatus,
		#[serde(rename = "COMMUNICATION_FAILURE")]
		CommunicationFailure,
		#[serde(rename = "AVAILABILITY_AFTER_DDN_FAILURE")]
		AvailabilityAfterDdnFailure,
		#[serde(rename = "CN_TYPE_CHANGE")]
		CnTypeChange,
		#[serde(rename = "DL_DATA_DELIVERY_STATUS")]
		DlDataDeliveryStatus,
		#[serde(rename = "PDN_CONNECTIVITY_STATUS")]
		PdnConnectivityStatus,
		#[serde(rename = "UE_CONNECTION_MANAGEMENT_STATE")]
		UeConnectionManagementState,
		#[serde(rename = "ACCESS_TYPE_REPORT")]
		AccessTypeReport,
		#[serde(rename = "REGISTRATION_STATE_REPORT")]
		RegistrationStateReport,
		#[serde(rename = "CONNECTIVITY_STATE_REPORT")]
		ConnectivityStateReport,
		#[serde(rename = "TYPE_ALLOCATION_CODE_REPORT")]
		TypeAllocationCodeReport,
		#[serde(rename = "FREQUENT_MOBILITY_REGISTRATION_REPORT")]
		FrequentMobilityRegistrationReport,
		#[serde(rename = "PDU_SES_REL")]
		PduSesRel,
		#[serde(rename = "PDU_SES_EST")]
		PduSesEst,
		#[serde(rename = "UE_MEMORY_AVAILABLE_FOR_SMS")]
		UeMemoryAvailableForSms,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&EventType> for EventType {
		fn from(value: &EventType) -> Self {
			value.clone()
		}
	}

	impl ToString for EventType {
		fn to_string(&self) -> String {
			match *self {
				Self::LossOfConnectivity => "LOSS_OF_CONNECTIVITY".to_string(),
				Self::UeReachabilityForData => "UE_REACHABILITY_FOR_DATA".to_string(),
				Self::UeReachabilityForSms => "UE_REACHABILITY_FOR_SMS".to_string(),
				Self::LocationReporting => "LOCATION_REPORTING".to_string(),
				Self::ChangeOfSupiPeiAssociation => "CHANGE_OF_SUPI_PEI_ASSOCIATION".to_string(),
				Self::RoamingStatus => "ROAMING_STATUS".to_string(),
				Self::CommunicationFailure => "COMMUNICATION_FAILURE".to_string(),
				Self::AvailabilityAfterDdnFailure => "AVAILABILITY_AFTER_DDN_FAILURE".to_string(),
				Self::CnTypeChange => "CN_TYPE_CHANGE".to_string(),
				Self::DlDataDeliveryStatus => "DL_DATA_DELIVERY_STATUS".to_string(),
				Self::PdnConnectivityStatus => "PDN_CONNECTIVITY_STATUS".to_string(),
				Self::UeConnectionManagementState => "UE_CONNECTION_MANAGEMENT_STATE".to_string(),
				Self::AccessTypeReport => "ACCESS_TYPE_REPORT".to_string(),
				Self::RegistrationStateReport => "REGISTRATION_STATE_REPORT".to_string(),
				Self::ConnectivityStateReport => "CONNECTIVITY_STATE_REPORT".to_string(),
				Self::TypeAllocationCodeReport => "TYPE_ALLOCATION_CODE_REPORT".to_string(),
				Self::FrequentMobilityRegistrationReport => {
					"FREQUENT_MOBILITY_REGISTRATION_REPORT".to_string()
				}
				Self::PduSesRel => "PDU_SES_REL".to_string(),
				Self::PduSesEst => "PDU_SES_EST".to_string(),
				Self::UeMemoryAvailableForSms => "UE_MEMORY_AVAILABLE_FOR_SMS".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for EventType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"LOSS_OF_CONNECTIVITY" => Ok(Self::LossOfConnectivity),
				"UE_REACHABILITY_FOR_DATA" => Ok(Self::UeReachabilityForData),
				"UE_REACHABILITY_FOR_SMS" => Ok(Self::UeReachabilityForSms),
				"LOCATION_REPORTING" => Ok(Self::LocationReporting),
				"CHANGE_OF_SUPI_PEI_ASSOCIATION" => Ok(Self::ChangeOfSupiPeiAssociation),
				"ROAMING_STATUS" => Ok(Self::RoamingStatus),
				"COMMUNICATION_FAILURE" => Ok(Self::CommunicationFailure),
				"AVAILABILITY_AFTER_DDN_FAILURE" => Ok(Self::AvailabilityAfterDdnFailure),
				"CN_TYPE_CHANGE" => Ok(Self::CnTypeChange),
				"DL_DATA_DELIVERY_STATUS" => Ok(Self::DlDataDeliveryStatus),
				"PDN_CONNECTIVITY_STATUS" => Ok(Self::PdnConnectivityStatus),
				"UE_CONNECTION_MANAGEMENT_STATE" => Ok(Self::UeConnectionManagementState),
				"ACCESS_TYPE_REPORT" => Ok(Self::AccessTypeReport),
				"REGISTRATION_STATE_REPORT" => Ok(Self::RegistrationStateReport),
				"CONNECTIVITY_STATE_REPORT" => Ok(Self::ConnectivityStateReport),
				"TYPE_ALLOCATION_CODE_REPORT" => Ok(Self::TypeAllocationCodeReport),
				"FREQUENT_MOBILITY_REGISTRATION_REPORT" => {
					Ok(Self::FrequentMobilityRegistrationReport)
				}
				"PDU_SES_REL" => Ok(Self::PduSesRel),
				"PDU_SES_EST" => Ok(Self::PduSesEst),
				"UE_MEMORY_AVAILABLE_FOR_SMS" => Ok(Self::UeMemoryAvailableForSms),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for EventType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for EventType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for EventType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// ExpectedUeBehaviour
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "required": [
	///    "afInstanceId",
	///    "referenceId"
	///  ],
	///  "properties": {
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "batteryIndication": {
	///      "$ref": "#/components/schemas/BatteryIndicationRm"
	///    },
	///    "communicationDurationTime": {
	///      "$ref": "#/components/schemas/DurationSecRm"
	///    },
	///    "expectedUmts": {
	///      "description": "Identifies the UE's expected geographical movement.
	/// The attribute is only applicable in 5G.",
	///      "type": [
	///        "array",
	///        "null"
	///      ],
	///      "items": {
	///        "$ref": "#/components/schemas/LocationArea"
	///      },
	///      "minItems": 1
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "periodicTime": {
	///      "$ref": "#/components/schemas/DurationSecRm"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    },
	///    "scheduledCommunicationTime": {
	///      "$ref": "#/components/schemas/ScheduledCommunicationTimeRm"
	///    },
	///    "scheduledCommunicationType": {
	///      "$ref": "#/components/schemas/ScheduledCommunicationTypeRm"
	///    },
	///    "stationaryIndication": {
	///      "$ref": "#/components/schemas/StationaryIndicationRm"
	///    },
	///    "trafficProfile": {
	///      "$ref": "#/components/schemas/TrafficProfileRm"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ExpectedUeBehaviour(pub Option<ExpectedUeBehaviourInner>);
	impl ::std::ops::Deref for ExpectedUeBehaviour {
		type Target = Option<ExpectedUeBehaviourInner>;
		fn deref(&self) -> &Option<ExpectedUeBehaviourInner> {
			&self.0
		}
	}

	impl From<ExpectedUeBehaviour> for Option<ExpectedUeBehaviourInner> {
		fn from(value: ExpectedUeBehaviour) -> Self {
			value.0
		}
	}

	impl From<&ExpectedUeBehaviour> for ExpectedUeBehaviour {
		fn from(value: &ExpectedUeBehaviour) -> Self {
			value.clone()
		}
	}

	impl From<Option<ExpectedUeBehaviourInner>> for ExpectedUeBehaviour {
		fn from(value: Option<ExpectedUeBehaviourInner>) -> Self {
			Self(value)
		}
	}

	/// ExpectedUeBehaviourData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "batteryIndication": {
	///      "$ref": "#/components/schemas/BatteryIndication"
	///    },
	///    "communicationDurationTime": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "expectedUmts": {
	///      "description": "Identifies the UE's expected geographical movement.
	/// The attribute is only applicable in 5G.",
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/LocationArea"
	///      },
	///      "minItems": 1
	///    },
	///    "periodicTime": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "scheduledCommunicationTime": {
	///      "$ref": "#/components/schemas/ScheduledCommunicationTime"
	///    },
	///    "scheduledCommunicationType": {
	///      "$ref": "#/components/schemas/ScheduledCommunicationType"
	///    },
	///    "stationaryIndication": {
	///      "$ref": "#/components/schemas/StationaryIndication"
	///    },
	///    "trafficProfile": {
	///      "$ref": "#/components/schemas/TrafficProfile"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ExpectedUeBehaviourData {
		#[serde(
			rename = "batteryIndication",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub battery_indication: Option<BatteryIndication>,
		#[serde(
			rename = "communicationDurationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub communication_duration_time: Option<DurationSec>,
		/// Identifies the UE's expected geographical movement. The attribute is
		/// only applicable in 5G.
		#[serde(
			rename = "expectedUmts",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub expected_umts: Vec<LocationArea>,
		#[serde(
			rename = "periodicTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub periodic_time: Option<DurationSec>,
		#[serde(
			rename = "scheduledCommunicationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub scheduled_communication_time: Option<ScheduledCommunicationTime>,
		#[serde(
			rename = "scheduledCommunicationType",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub scheduled_communication_type: Option<ScheduledCommunicationType>,
		#[serde(
			rename = "stationaryIndication",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub stationary_indication: Option<StationaryIndication>,
		#[serde(
			rename = "trafficProfile",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub traffic_profile: Option<TrafficProfile>,
		#[serde(
			rename = "validityTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub validity_time: Option<DateTime>,
	}

	impl From<&ExpectedUeBehaviourData> for ExpectedUeBehaviourData {
		fn from(value: &ExpectedUeBehaviourData) -> Self {
			value.clone()
		}
	}

	/// ExpectedUeBehaviourInner
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "afInstanceId",
	///    "referenceId"
	///  ],
	///  "properties": {
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "batteryIndication": {
	///      "$ref": "#/components/schemas/BatteryIndicationRm"
	///    },
	///    "communicationDurationTime": {
	///      "$ref": "#/components/schemas/DurationSecRm"
	///    },
	///    "expectedUmts": {
	///      "description": "Identifies the UE's expected geographical movement.
	/// The attribute is only applicable in 5G.",
	///      "type": [
	///        "array",
	///        "null"
	///      ],
	///      "items": {
	///        "$ref": "#/components/schemas/LocationArea"
	///      },
	///      "minItems": 1
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "periodicTime": {
	///      "$ref": "#/components/schemas/DurationSecRm"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    },
	///    "scheduledCommunicationTime": {
	///      "$ref": "#/components/schemas/ScheduledCommunicationTimeRm"
	///    },
	///    "scheduledCommunicationType": {
	///      "$ref": "#/components/schemas/ScheduledCommunicationTypeRm"
	///    },
	///    "stationaryIndication": {
	///      "$ref": "#/components/schemas/StationaryIndicationRm"
	///    },
	///    "trafficProfile": {
	///      "$ref": "#/components/schemas/TrafficProfileRm"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ExpectedUeBehaviourInner {
		#[serde(rename = "afInstanceId")]
		pub af_instance_id: String,
		#[serde(
			rename = "batteryIndication",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub battery_indication: Option<BatteryIndicationRm>,
		#[serde(
			rename = "communicationDurationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub communication_duration_time: Option<DurationSecRm>,
		/// Identifies the UE's expected geographical movement. The attribute is
		/// only applicable in 5G.
		#[serde(
			rename = "expectedUmts",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub expected_umts: Option<Vec<LocationArea>>,
		#[serde(
			rename = "mtcProviderInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mtc_provider_information: Option<MtcProviderInformation>,
		#[serde(
			rename = "periodicTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub periodic_time: Option<DurationSecRm>,
		#[serde(rename = "referenceId")]
		pub reference_id: ReferenceId,
		#[serde(
			rename = "scheduledCommunicationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub scheduled_communication_time: Option<ScheduledCommunicationTimeRm>,
		#[serde(
			rename = "scheduledCommunicationType",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub scheduled_communication_type: Option<ScheduledCommunicationTypeRm>,
		#[serde(
			rename = "stationaryIndication",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub stationary_indication: Option<StationaryIndicationRm>,
		#[serde(
			rename = "trafficProfile",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub traffic_profile: Option<TrafficProfileRm>,
		#[serde(
			rename = "validityTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub validity_time: Option<DateTime>,
	}

	impl From<&ExpectedUeBehaviourInner> for ExpectedUeBehaviourInner {
		fn from(value: &ExpectedUeBehaviourInner) -> Self {
			value.clone()
		}
	}

	/// ExtGroupId
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^extgroupid-[^@]+@[^@]+$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct ExtGroupId(String);
	impl ::std::ops::Deref for ExtGroupId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<ExtGroupId> for String {
		fn from(value: ExtGroupId) -> Self {
			value.0
		}
	}

	impl From<&ExtGroupId> for ExtGroupId {
		fn from(value: &ExtGroupId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for ExtGroupId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^extgroupid-[^@]+@[^@]+$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^extgroupid-[^@]+@[^@]+$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for ExtGroupId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for ExtGroupId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for ExtGroupId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for ExtGroupId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Contains identifiers of shared Session Management Subscription Data and
	/// optionally individual Session Management Subscription Data.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains identifiers of shared Session Management
	/// Subscription Data and optionally individual Session Management
	/// Subscription Data.",
	///  "type": "object",
	///  "required": [
	///    "sharedSmSubsDataIds"
	///  ],
	///  "properties": {
	///    "individualSmSubsData": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/SessionManagementSubscriptionData"
	///      }
	///    },
	///    "sharedSmSubsDataIds": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/SharedDataId"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ExtendedSmSubsData {
		#[serde(
			rename = "individualSmSubsData",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub individual_sm_subs_data: Vec<SessionManagementSubscriptionData>,
		#[serde(rename = "sharedSmSubsDataIds")]
		pub shared_sm_subs_data_ids: Vec<SharedDataId>,
	}

	impl From<&ExtendedSmSubsData> for ExtendedSmSubsData {
		fn from(value: &ExtendedSmSubsData) -> Self {
			value.clone()
		}
	}

	/// String identifying External Group Identifier that identifies a group
	/// made up of one or more  subscriptions associated to a group of IMSIs, as
	/// specified in clause 19.7.3 of 3GPP TS 23.003.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String identifying External Group Identifier that identifies a group made up of one or more  subscriptions associated to a group of IMSIs, as specified in clause 19.7.3 of 3GPP TS 23.003. \n",
	///  "type": "string",
	///  "pattern": "^extgroupid-[^@]+@[^@]+$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct ExternalGroupId(String);
	impl ::std::ops::Deref for ExternalGroupId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<ExternalGroupId> for String {
		fn from(value: ExternalGroupId) -> Self {
			value.0
		}
	}

	impl From<&ExternalGroupId> for ExternalGroupId {
		fn from(value: &ExternalGroupId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for ExternalGroupId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^extgroupid-[^@]+@[^@]+$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^extgroupid-[^@]+@[^@]+$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for ExternalGroupId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for ExternalGroupId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for ExternalGroupId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for ExternalGroupId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// ExternalUnrelatedClass
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "properties": {
	///    "afExternals": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/AfExternal"
	///      },
	///      "minItems": 1
	///    },
	///    "lcsClientExternals": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/LcsClientExternal"
	///      },
	///      "minItems": 1
	///    },
	///    "lcsClientGroupExternals": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/LcsClientGroupExternal"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ExternalUnrelatedClass {
		#[serde(rename = "afExternals", default, skip_serializing_if = "Vec::is_empty")]
		pub af_externals: Vec<AfExternal>,
		#[serde(
			rename = "lcsClientExternals",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub lcs_client_externals: Vec<LcsClientExternal>,
		#[serde(
			rename = "lcsClientGroupExternals",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub lcs_client_group_externals: Vec<LcsClientGroupExternal>,
	}

	impl From<&ExternalUnrelatedClass> for ExternalUnrelatedClass {
		fn from(value: &ExternalUnrelatedClass) -> Self {
			value.clone()
		}
	}

	/// Indicates the Failed cause of the failed Monitoring Configuration in the
	/// EE subscription
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates the Failed cause of the failed Monitoring
	/// Configuration in the EE subscription",
	///  "type": "string",
	///  "enum": [
	///    "AF_NOT_ALLOWED",
	///    "MTC_PROVIDER_NOT_ALLOWED",
	///    "MONITORING_NOT_ALLOWED",
	///    "UNSUPPORTED_MONITORING_EVENT_TYPE",
	///    "UNSUPPORTED_MONITORING_REPORT_OPTIONS",
	///    "UNSPECIFIED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum FailedCause {
		#[default]
		#[serde(rename = "AF_NOT_ALLOWED")]
		AfNotAllowed,
		#[serde(rename = "MTC_PROVIDER_NOT_ALLOWED")]
		MtcProviderNotAllowed,
		#[serde(rename = "MONITORING_NOT_ALLOWED")]
		MonitoringNotAllowed,
		#[serde(rename = "UNSUPPORTED_MONITORING_EVENT_TYPE")]
		UnsupportedMonitoringEventType,
		#[serde(rename = "UNSUPPORTED_MONITORING_REPORT_OPTIONS")]
		UnsupportedMonitoringReportOptions,
		#[serde(rename = "UNSPECIFIED")]
		Unspecified,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&FailedCause> for FailedCause {
		fn from(value: &FailedCause) -> Self {
			value.clone()
		}
	}

	impl ToString for FailedCause {
		fn to_string(&self) -> String {
			match *self {
				Self::AfNotAllowed => "AF_NOT_ALLOWED".to_string(),
				Self::MtcProviderNotAllowed => "MTC_PROVIDER_NOT_ALLOWED".to_string(),
				Self::MonitoringNotAllowed => "MONITORING_NOT_ALLOWED".to_string(),
				Self::UnsupportedMonitoringEventType => {
					"UNSUPPORTED_MONITORING_EVENT_TYPE".to_string()
				}
				Self::UnsupportedMonitoringReportOptions => {
					"UNSUPPORTED_MONITORING_REPORT_OPTIONS".to_string()
				}
				Self::Unspecified => "UNSPECIFIED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for FailedCause {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"AF_NOT_ALLOWED" => Ok(Self::AfNotAllowed),
				"MTC_PROVIDER_NOT_ALLOWED" => Ok(Self::MtcProviderNotAllowed),
				"MONITORING_NOT_ALLOWED" => Ok(Self::MonitoringNotAllowed),
				"UNSUPPORTED_MONITORING_EVENT_TYPE" => Ok(Self::UnsupportedMonitoringEventType),
				"UNSUPPORTED_MONITORING_REPORT_OPTIONS" => {
					Ok(Self::UnsupportedMonitoringReportOptions)
				}
				"UNSPECIFIED" => Ok(Self::Unspecified),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for FailedCause {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for FailedCause {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for FailedCause {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Contains the event type and failed cause of the failed Monitoring
	/// Configuration in the EE subscription
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the event type and failed cause of the failed
	/// Monitoring Configuration in the EE subscription",
	///  "type": "object",
	///  "required": [
	///    "eventType",
	///    "failedCause"
	///  ],
	///  "properties": {
	///    "eventType": {
	///      "$ref": "#/components/schemas/EventType"
	///    },
	///    "failedCause": {
	///      "$ref": "#/components/schemas/FailedCause"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct FailedMonitoringConfiguration {
		#[serde(rename = "eventType")]
		pub event_type: EventType,
		#[serde(rename = "failedCause")]
		pub failed_cause: FailedCause,
	}

	impl From<&FailedMonitoringConfiguration> for FailedMonitoringConfiguration {
		fn from(value: &FailedMonitoringConfiguration) -> Self {
			value.clone()
		}
	}

	/// Float
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "string with format 'float' as defined in OpenAPI.",
	///  "type": "number",
	///  "format": "float"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Float(pub f32);
	impl ::std::ops::Deref for Float {
		type Target = f32;
		fn deref(&self) -> &f32 {
			&self.0
		}
	}

	impl From<Float> for f32 {
		fn from(value: Float) -> Self {
			value.0
		}
	}

	impl From<&Float> for Float {
		fn from(value: &Float) -> Self {
			value.clone()
		}
	}

	impl From<f32> for Float {
		fn from(value: f32) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for Float {
		type Err = <f32 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for Float {
		type Error = <f32 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for Float {
		type Error = <f32 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for Float {
		type Error = <f32 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for Float {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Fully Qualified Domain Name
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Fully Qualified Domain Name",
	///  "type": "string",
	///  "maxLength": 253,
	///  "minLength": 4,
	///  "pattern":
	/// "^([0-9A-Za-z]([-0-9A-Za-z]{0,61}[0-9A-Za-z])?\\.)+[A-Za-z]{2,63}\\.?$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Fqdn(String);
	impl ::std::ops::Deref for Fqdn {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Fqdn> for String {
		fn from(value: Fqdn) -> Self {
			value.0
		}
	}

	impl From<&Fqdn> for Fqdn {
		fn from(value: &Fqdn) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Fqdn {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if value.len() > 253usize {
				return Err("longer than 253 characters".into());
			}
			if value.len() < 4usize {
				return Err("shorter than 4 characters".into());
			}
			if regress::Regex::new(
				"^([0-9A-Za-z]([-0-9A-Za-z]{0,61}[0-9A-Za-z])?\\.)+[A-Za-z]{2,63}\\.?$",
			)
			.unwrap()
			.find(value)
			.is_none()
			{
				return Err("doesn't match pattern \
				            \"^([0-9A-Za-z]([-0-9A-Za-z]{0,61}[0-9A-Za-z])?\\.)+[A-Za-z]{2,63}\\\
				            .?$\""
					.into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Fqdn {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Fqdn {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Fqdn {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Fqdn {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Fully Qualified Domain Name, but it also allows the null value
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Fully Qualified Domain Name, but it also allows the
	/// null value",
	///  "anyOf": [
	///    {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    {
	///      "$ref": "#/components/schemas/NullValue"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum FqdnRm {
		#[default]
		Fqdn(Fqdn),
		NullValue(NullValue),
	}

	impl From<&FqdnRm> for FqdnRm {
		fn from(value: &FqdnRm) -> Self {
			value.clone()
		}
	}

	impl From<Fqdn> for FqdnRm {
		fn from(value: Fqdn) -> Self {
			Self::Fqdn(value)
		}
	}

	impl From<NullValue> for FqdnRm {
		fn from(value: NullValue) -> Self {
			Self::NullValue(value)
		}
	}

	/// FrameRouteInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "ipv4Mask": {
	///      "$ref": "#/components/schemas/Ipv4AddrMask"
	///    },
	///    "ipv6Prefix": {
	///      "$ref": "#/components/schemas/Ipv6Prefix"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct FrameRouteInfo {
		#[serde(rename = "ipv4Mask", default, skip_serializing_if = "Option::is_none")]
		pub ipv4_mask: Option<Ipv4AddrMask>,
		#[serde(
			rename = "ipv6Prefix",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ipv6_prefix: Option<Ipv6Prefix>,
	}

	impl From<&FrameRouteInfo> for FrameRouteInfo {
		fn from(value: &FrameRouteInfo) -> Self {
			value.clone()
		}
	}

	/// Provides the G-NB identifier.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Provides the G-NB identifier.",
	///  "type": "object",
	///  "required": [
	///    "bitLength",
	///    "gNBValue"
	///  ],
	///  "properties": {
	///    "bitLength": {
	///      "description": "Unsigned integer representing the bit length of the
	/// gNB ID as defined in clause 9.3.1.6 of 3GPP TS 38.413 [11], within the
	/// range 22 to 32.\n",
	///      "type": "integer",
	///      "maximum": 32.0,
	///      "minimum": 22.0
	///    },
	///    "gNBValue": {
	///      "description": "This represents the identifier of the gNB. The
	/// value of the gNB ID shall be encoded in hexadecimal representation. Each
	/// character in the string shall take a value of \"0\" to \"9\", \"a\" to
	/// \"f\" or \"A\" to \"F\" and shall represent 4 bits. The padding 0 shall
	/// be added to make multiple nibbles,  the most significant character
	/// representing the padding 0 if required together with the 4 most
	/// significant bits of the gNB ID shall appear first in the string, and the
	/// character representing the 4 least significant bit of the gNB ID shall
	/// appear last in the string.\n",
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]{6,8}$"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct GNbId {
		/// Unsigned integer representing the bit length of the gNB ID as
		/// defined in clause 9.3.1.6 of 3GPP TS 38.413 [11], within the range
		/// 22 to 32.
		#[serde(rename = "bitLength")]
		pub bit_length: i64,
		/// This represents the identifier of the gNB. The value of the gNB ID
		/// shall be encoded in hexadecimal representation. Each character in
		/// the string shall take a value of "0" to "9", "a" to "f" or "A" to
		/// "F" and shall represent 4 bits. The padding 0 shall be added to make
		/// multiple nibbles,  the most significant character representing the
		/// padding 0 if required together with the 4 most significant bits of
		/// the gNB ID shall appear first in the string, and the character
		/// representing the 4 least significant bit of the gNB ID shall appear
		/// last in the string.
		#[serde(rename = "gNBValue")]
		pub g_nb_value: GNbIdGNbValue,
	}

	impl From<&GNbId> for GNbId {
		fn from(value: &GNbId) -> Self {
			value.clone()
		}
	}

	/// This represents the identifier of the gNB. The value of the gNB ID shall
	/// be encoded in hexadecimal representation. Each character in the string
	/// shall take a value of "0" to "9", "a" to "f" or "A" to "F" and shall
	/// represent 4 bits. The padding 0 shall be added to make multiple nibbles,
	/// the most significant character representing the padding 0 if required
	/// together with the 4 most significant bits of the gNB ID shall appear
	/// first in the string, and the character representing the 4 least
	/// significant bit of the gNB ID shall appear last in the string.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This represents the identifier of the gNB. The value of
	/// the gNB ID shall be encoded in hexadecimal representation. Each
	/// character in the string shall take a value of \"0\" to \"9\", \"a\" to
	/// \"f\" or \"A\" to \"F\" and shall represent 4 bits. The padding 0 shall
	/// be added to make multiple nibbles,  the most significant character
	/// representing the padding 0 if required together with the 4 most
	/// significant bits of the gNB ID shall appear first in the string, and the
	/// character representing the 4 least significant bit of the gNB ID shall
	/// appear last in the string.\n",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{6,8}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct GNbIdGNbValue(String);
	impl ::std::ops::Deref for GNbIdGNbValue {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<GNbIdGNbValue> for String {
		fn from(value: GNbIdGNbValue) -> Self {
			value.0
		}
	}

	impl From<&GNbIdGNbValue> for GNbIdGNbValue {
		fn from(value: &GNbIdGNbValue) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for GNbIdGNbValue {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{6,8}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{6,8}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for GNbIdGNbValue {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for GNbIdGNbValue {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for GNbIdGNbValue {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for GNbIdGNbValue {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Common base type for GAD shapes.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Common base type for GAD shapes.",
	///  "type": "object",
	///  "required": [
	///    "shape"
	///  ],
	///  "properties": {
	///    "shape": {
	///      "$ref": "#/components/schemas/SupportedGADShapes"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct GadShape {
		pub shape: SupportedGadShapes,
	}

	impl From<&GadShape> for GadShape {
		fn from(value: &GadShape) -> Self {
			value.clone()
		}
	}

	/// GbaAuthType
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "DIGEST_AKAV1_MD5"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum GbaAuthType {
		#[default]
		#[serde(rename = "DIGEST_AKAV1_MD5")]
		DigestAkav1Md5,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&GbaAuthType> for GbaAuthType {
		fn from(value: &GbaAuthType) -> Self {
			value.clone()
		}
	}

	impl ToString for GbaAuthType {
		fn to_string(&self) -> String {
			match *self {
				Self::DigestAkav1Md5 => "DIGEST_AKAV1_MD5".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for GbaAuthType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"DIGEST_AKAV1_MD5" => Ok(Self::DigestAkav1Md5),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for GbaAuthType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for GbaAuthType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for GbaAuthType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// GbaAuthenticationInfoRequest
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "authType"
	///  ],
	///  "properties": {
	///    "authType": {
	///      "$ref": "#/components/schemas/GbaAuthType"
	///    },
	///    "resynchronizationInfo": {
	///      "$ref": "#/components/schemas/schemas-ResynchronizationInfo"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct GbaAuthenticationInfoRequest {
		#[serde(rename = "authType")]
		pub auth_type: GbaAuthType,
		#[serde(
			rename = "resynchronizationInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub resynchronization_info: Option<SchemasResynchronizationInfo>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&GbaAuthenticationInfoRequest> for GbaAuthenticationInfoRequest {
		fn from(value: &GbaAuthenticationInfoRequest) -> Self {
			value.clone()
		}
	}

	/// GbaAuthenticationInfoResult
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "3gAkaAv": {
	///      "$ref": "#/components/schemas/3GAkaAv"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct GbaAuthenticationInfoResult {
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
		#[serde(rename = "3gAkaAv", default, skip_serializing_if = "Option::is_none")]
		pub three_g_aka_av: Option<_3gAkaAv>,
	}

	impl From<&GbaAuthenticationInfoResult> for GbaAuthenticationInfoResult {
		fn from(value: &GbaAuthenticationInfoResult) -> Self {
			value.clone()
		}
	}

	/// Global Cable Identifier uniquely identifying the connection between the
	/// 5G-CRG or FN-CRG to the 5GS. See clause 28.15.4 of 3GPP TS 23.003. This
	/// shall be encoded as a string per clause 28.15.4 of 3GPP TS 23.003, and
	/// compliant with the syntax specified  in clause 2.2  of IETF RFC 7542 for
	/// the username part of a NAI. The GCI value is specified in CableLabs
	/// WR-TR-5WWC-ARCH.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Global Cable Identifier uniquely identifying the
	/// connection between the 5G-CRG or FN-CRG to the 5GS. See clause 28.15.4
	/// of 3GPP TS 23.003. This shall be encoded as a string per clause 28.15.4
	/// of 3GPP TS 23.003, and compliant with the syntax specified  in clause
	/// 2.2  of IETF RFC 7542 for the username part of a NAI. The GCI value is
	/// specified in CableLabs WR-TR-5WWC-ARCH.\n",
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct Gci(pub String);
	impl ::std::ops::Deref for Gci {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Gci> for String {
		fn from(value: Gci) -> Self {
			value.0
		}
	}

	impl From<&Gci> for Gci {
		fn from(value: &Gci) -> Self {
			value.clone()
		}
	}

	impl From<String> for Gci {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for Gci {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for Gci {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// List of geographic area or list of civic address info
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "List of geographic area or list of civic address info",
	///  "type": "object",
	///  "properties": {
	///    "civicAddressList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/CivicAddress"
	///      },
	///      "minItems": 1
	///    },
	///    "geographicAreaList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/GeographicArea"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct GeoServiceArea {
		#[serde(
			rename = "civicAddressList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub civic_address_list: Vec<CivicAddress>,
		#[serde(
			rename = "geographicAreaList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub geographic_area_list: Vec<GeographicArea>,
	}

	impl From<&GeoServiceArea> for GeoServiceArea {
		fn from(value: &GeoServiceArea) -> Self {
			value.clone()
		}
	}

	/// Geographic area specified by different shape.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Geographic area specified by different shape.",
	///  "anyOf": [
	///    {
	///      "$ref": "#/components/schemas/Point"
	///    },
	///    {
	///      "$ref": "#/components/schemas/PointUncertaintyCircle"
	///    },
	///    {
	///      "$ref": "#/components/schemas/PointUncertaintyEllipse"
	///    },
	///    {
	///      "$ref": "#/components/schemas/Polygon"
	///    },
	///    {
	///      "$ref": "#/components/schemas/PointAltitude"
	///    },
	///    {
	///      "$ref": "#/components/schemas/PointAltitudeUncertainty"
	///    },
	///    {
	///      "$ref": "#/components/schemas/EllipsoidArc"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct GeographicArea {
		#[serde(flatten, default, skip_serializing_if = "Option::is_none")]
		pub subtype_0: Option<Point>,
		#[serde(flatten, default, skip_serializing_if = "Option::is_none")]
		pub subtype_1: Option<PointUncertaintyCircle>,
		#[serde(flatten, default, skip_serializing_if = "Option::is_none")]
		pub subtype_2: Option<PointUncertaintyEllipse>,
		#[serde(flatten, default, skip_serializing_if = "Option::is_none")]
		pub subtype_3: Option<Polygon>,
		#[serde(flatten, default, skip_serializing_if = "Option::is_none")]
		pub subtype_4: Option<PointAltitude>,
		#[serde(flatten, default, skip_serializing_if = "Option::is_none")]
		pub subtype_5: Option<PointAltitudeUncertainty>,
		#[serde(flatten, default, skip_serializing_if = "Option::is_none")]
		pub subtype_6: Option<EllipsoidArc>,
	}

	impl From<&GeographicArea> for GeographicArea {
		fn from(value: &GeographicArea) -> Self {
			value.clone()
		}
	}

	/// Geographical coordinates.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Geographical coordinates.",
	///  "type": "object",
	///  "required": [
	///    "lat",
	///    "lon"
	///  ],
	///  "properties": {
	///    "lat": {
	///      "type": "number",
	///      "format": "double",
	///      "maximum": 90.0,
	///      "minimum": -90.0
	///    },
	///    "lon": {
	///      "type": "number",
	///      "format": "double",
	///      "maximum": 180.0,
	///      "minimum": -180.0
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct GeographicalCoordinates {
		pub lat: f64,
		pub lon: f64,
	}

	impl From<&GeographicalCoordinates> for GeographicalCoordinates {
		fn from(value: &GeographicalCoordinates) -> Self {
			value.clone()
		}
	}

	/// Exactly one of cgi, sai or lai shall be present.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Exactly one of cgi, sai or lai shall be present.",
	///  "type": "object",
	///  "oneOf": [
	///    {
	///      "required": [
	///        "cgi"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "sai"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "lai"
	///      ]
	///    }
	///  ],
	///  "properties": {
	///    "ageOfLocationInformation": {
	///      "description": "The value represents the elapsed time in minutes since the last network contact of the mobile station. Value \"0\" indicates that the location information was obtained after a successful paging procedure for  Active Location Retrieval when the UE is in idle mode or after a successful location reporting procedure the UE is in connected mode. Any other value than \"0\" indicates that the location information is the last known one. See 3GPP TS 29.002 clause 17.7.8.\n",
	///      "type": "integer",
	///      "maximum": 32767.0,
	///      "minimum": 0.0
	///    },
	///    "cgi": {
	///      "$ref": "#/components/schemas/CellGlobalId"
	///    },
	///    "geodeticInformation": {
	///      "description": "Refers to Calling Geodetic Location.See ITU-T
	/// Recommendation Q.763 (1999) clause 3.88.2.  Only the description of an
	/// ellipsoid point with uncertainty circle is allowed to be used.\n",
	///      "type": "string",
	///      "pattern": "^[0-9A-F]{20}$"
	///    },
	///    "geographicalInformation": {
	///      "description": "Refer to geographical Information.See 3GPP TS
	/// 23.032 clause 7.3.2. Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.\n",
	///      "type": "string",
	///      "pattern": "^[0-9A-F]{16}$"
	///    },
	///    "lai": {
	///      "$ref": "#/components/schemas/LocationAreaId"
	///    },
	///    "locationNumber": {
	///      "description": "Location number within the PLMN. See 3GPP TS
	/// 23.003, clause 4.5.",
	///      "type": "string"
	///    },
	///    "mscNumber": {
	///      "description": "MSC number. See 3GPP TS 23.003 clause 5.1.",
	///      "type": "string"
	///    },
	///    "rai": {
	///      "$ref": "#/components/schemas/RoutingAreaId"
	///    },
	///    "sai": {
	///      "$ref": "#/components/schemas/ServiceAreaId"
	///    },
	///    "ueLocationTimestamp": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "vlrNumber": {
	///      "description": "VLR number. See 3GPP TS 23.003 clause 5.1.",
	///      "type": "string"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum GeraLocation {
		#[default]
		Variant0 {
			/// The value represents the elapsed time in minutes since the last
			/// network contact of the mobile station. Value "0" indicates that
			/// the location information was obtained after a successful paging
			/// procedure for  Active Location Retrieval when the UE is in idle
			/// mode or after a successful location reporting procedure the UE
			/// is in connected mode. Any other value than "0" indicates that
			/// the location information is the last known one. See 3GPP TS
			/// 29.002 clause 17.7.8.
			#[serde(
				rename = "ageOfLocationInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			age_of_location_information: Option<i64>,
			cgi: CellGlobalId,
			/// Refers to Calling Geodetic Location.See ITU-T Recommendation
			/// Q.763 (1999) clause 3.88.2.  Only the description of an
			/// ellipsoid point with uncertainty circle is allowed to be used.
			#[serde(
				rename = "geodeticInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			geodetic_information: Option<GeraLocationVariant0GeodeticInformation>,
			/// Refer to geographical Information.See 3GPP TS 23.032 clause
			/// 7.3.2. Only the description of an ellipsoid point with
			/// uncertainty circle is allowed to be used.
			#[serde(
				rename = "geographicalInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			geographical_information: Option<GeraLocationVariant0GeographicalInformation>,
			/// Location number within the PLMN. See 3GPP TS 23.003, clause 4.5.
			#[serde(
				rename = "locationNumber",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			location_number: Option<String>,
			/// MSC number. See 3GPP TS 23.003 clause 5.1.
			#[serde(rename = "mscNumber", default, skip_serializing_if = "Option::is_none")]
			msc_number: Option<String>,
			#[serde(default, skip_serializing_if = "Option::is_none")]
			rai: Option<RoutingAreaId>,
			#[serde(
				rename = "ueLocationTimestamp",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			ue_location_timestamp: Option<DateTime>,
			/// VLR number. See 3GPP TS 23.003 clause 5.1.
			#[serde(rename = "vlrNumber", default, skip_serializing_if = "Option::is_none")]
			vlr_number: Option<String>,
		},
		Variant1 {
			/// The value represents the elapsed time in minutes since the last
			/// network contact of the mobile station. Value "0" indicates that
			/// the location information was obtained after a successful paging
			/// procedure for  Active Location Retrieval when the UE is in idle
			/// mode or after a successful location reporting procedure the UE
			/// is in connected mode. Any other value than "0" indicates that
			/// the location information is the last known one. See 3GPP TS
			/// 29.002 clause 17.7.8.
			#[serde(
				rename = "ageOfLocationInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			age_of_location_information: Option<i64>,
			/// Refers to Calling Geodetic Location.See ITU-T Recommendation
			/// Q.763 (1999) clause 3.88.2.  Only the description of an
			/// ellipsoid point with uncertainty circle is allowed to be used.
			#[serde(
				rename = "geodeticInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			geodetic_information: Option<GeraLocationVariant1GeodeticInformation>,
			/// Refer to geographical Information.See 3GPP TS 23.032 clause
			/// 7.3.2. Only the description of an ellipsoid point with
			/// uncertainty circle is allowed to be used.
			#[serde(
				rename = "geographicalInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			geographical_information: Option<GeraLocationVariant1GeographicalInformation>,
			/// Location number within the PLMN. See 3GPP TS 23.003, clause 4.5.
			#[serde(
				rename = "locationNumber",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			location_number: Option<String>,
			/// MSC number. See 3GPP TS 23.003 clause 5.1.
			#[serde(rename = "mscNumber", default, skip_serializing_if = "Option::is_none")]
			msc_number: Option<String>,
			#[serde(default, skip_serializing_if = "Option::is_none")]
			rai: Option<RoutingAreaId>,
			sai: ServiceAreaId,
			#[serde(
				rename = "ueLocationTimestamp",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			ue_location_timestamp: Option<DateTime>,
			/// VLR number. See 3GPP TS 23.003 clause 5.1.
			#[serde(rename = "vlrNumber", default, skip_serializing_if = "Option::is_none")]
			vlr_number: Option<String>,
		},
		Variant2 {
			/// The value represents the elapsed time in minutes since the last
			/// network contact of the mobile station. Value "0" indicates that
			/// the location information was obtained after a successful paging
			/// procedure for  Active Location Retrieval when the UE is in idle
			/// mode or after a successful location reporting procedure the UE
			/// is in connected mode. Any other value than "0" indicates that
			/// the location information is the last known one. See 3GPP TS
			/// 29.002 clause 17.7.8.
			#[serde(
				rename = "ageOfLocationInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			age_of_location_information: Option<i64>,
			/// Refers to Calling Geodetic Location.See ITU-T Recommendation
			/// Q.763 (1999) clause 3.88.2.  Only the description of an
			/// ellipsoid point with uncertainty circle is allowed to be used.
			#[serde(
				rename = "geodeticInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			geodetic_information: Option<GeraLocationVariant2GeodeticInformation>,
			/// Refer to geographical Information.See 3GPP TS 23.032 clause
			/// 7.3.2. Only the description of an ellipsoid point with
			/// uncertainty circle is allowed to be used.
			#[serde(
				rename = "geographicalInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			geographical_information: Option<GeraLocationVariant2GeographicalInformation>,
			lai: LocationAreaId,
			/// Location number within the PLMN. See 3GPP TS 23.003, clause 4.5.
			#[serde(
				rename = "locationNumber",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			location_number: Option<String>,
			/// MSC number. See 3GPP TS 23.003 clause 5.1.
			#[serde(rename = "mscNumber", default, skip_serializing_if = "Option::is_none")]
			msc_number: Option<String>,
			#[serde(default, skip_serializing_if = "Option::is_none")]
			rai: Option<RoutingAreaId>,
			#[serde(
				rename = "ueLocationTimestamp",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			ue_location_timestamp: Option<DateTime>,
			/// VLR number. See 3GPP TS 23.003 clause 5.1.
			#[serde(rename = "vlrNumber", default, skip_serializing_if = "Option::is_none")]
			vlr_number: Option<String>,
		},
	}

	impl From<&GeraLocation> for GeraLocation {
		fn from(value: &GeraLocation) -> Self {
			value.clone()
		}
	}

	/// Refers to Calling Geodetic Location.See ITU-T Recommendation Q.763
	/// (1999) clause 3.88.2.  Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refers to Calling Geodetic Location.See ITU-T
	/// Recommendation Q.763 (1999) clause 3.88.2.  Only the description of an
	/// ellipsoid point with uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{20}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct GeraLocationVariant0GeodeticInformation(String);
	impl ::std::ops::Deref for GeraLocationVariant0GeodeticInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<GeraLocationVariant0GeodeticInformation> for String {
		fn from(value: GeraLocationVariant0GeodeticInformation) -> Self {
			value.0
		}
	}

	impl From<&GeraLocationVariant0GeodeticInformation> for GeraLocationVariant0GeodeticInformation {
		fn from(value: &GeraLocationVariant0GeodeticInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for GeraLocationVariant0GeodeticInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{20}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for GeraLocationVariant0GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for GeraLocationVariant0GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for GeraLocationVariant0GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for GeraLocationVariant0GeodeticInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Refer to geographical Information.See 3GPP TS 23.032 clause 7.3.2. Only
	/// the description of an ellipsoid point with uncertainty circle is allowed
	/// to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refer to geographical Information.See 3GPP TS 23.032
	/// clause 7.3.2. Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{16}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct GeraLocationVariant0GeographicalInformation(String);
	impl ::std::ops::Deref for GeraLocationVariant0GeographicalInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<GeraLocationVariant0GeographicalInformation> for String {
		fn from(value: GeraLocationVariant0GeographicalInformation) -> Self {
			value.0
		}
	}

	impl From<&GeraLocationVariant0GeographicalInformation>
		for GeraLocationVariant0GeographicalInformation
	{
		fn from(value: &GeraLocationVariant0GeographicalInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for GeraLocationVariant0GeographicalInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{16}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for GeraLocationVariant0GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for GeraLocationVariant0GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for GeraLocationVariant0GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for GeraLocationVariant0GeographicalInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Refers to Calling Geodetic Location.See ITU-T Recommendation Q.763
	/// (1999) clause 3.88.2.  Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refers to Calling Geodetic Location.See ITU-T
	/// Recommendation Q.763 (1999) clause 3.88.2.  Only the description of an
	/// ellipsoid point with uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{20}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct GeraLocationVariant1GeodeticInformation(String);
	impl ::std::ops::Deref for GeraLocationVariant1GeodeticInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<GeraLocationVariant1GeodeticInformation> for String {
		fn from(value: GeraLocationVariant1GeodeticInformation) -> Self {
			value.0
		}
	}

	impl From<&GeraLocationVariant1GeodeticInformation> for GeraLocationVariant1GeodeticInformation {
		fn from(value: &GeraLocationVariant1GeodeticInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for GeraLocationVariant1GeodeticInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{20}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for GeraLocationVariant1GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for GeraLocationVariant1GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for GeraLocationVariant1GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for GeraLocationVariant1GeodeticInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Refer to geographical Information.See 3GPP TS 23.032 clause 7.3.2. Only
	/// the description of an ellipsoid point with uncertainty circle is allowed
	/// to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refer to geographical Information.See 3GPP TS 23.032
	/// clause 7.3.2. Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{16}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct GeraLocationVariant1GeographicalInformation(String);
	impl ::std::ops::Deref for GeraLocationVariant1GeographicalInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<GeraLocationVariant1GeographicalInformation> for String {
		fn from(value: GeraLocationVariant1GeographicalInformation) -> Self {
			value.0
		}
	}

	impl From<&GeraLocationVariant1GeographicalInformation>
		for GeraLocationVariant1GeographicalInformation
	{
		fn from(value: &GeraLocationVariant1GeographicalInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for GeraLocationVariant1GeographicalInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{16}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for GeraLocationVariant1GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for GeraLocationVariant1GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for GeraLocationVariant1GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for GeraLocationVariant1GeographicalInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Refers to Calling Geodetic Location.See ITU-T Recommendation Q.763
	/// (1999) clause 3.88.2.  Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refers to Calling Geodetic Location.See ITU-T
	/// Recommendation Q.763 (1999) clause 3.88.2.  Only the description of an
	/// ellipsoid point with uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{20}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct GeraLocationVariant2GeodeticInformation(String);
	impl ::std::ops::Deref for GeraLocationVariant2GeodeticInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<GeraLocationVariant2GeodeticInformation> for String {
		fn from(value: GeraLocationVariant2GeodeticInformation) -> Self {
			value.0
		}
	}

	impl From<&GeraLocationVariant2GeodeticInformation> for GeraLocationVariant2GeodeticInformation {
		fn from(value: &GeraLocationVariant2GeodeticInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for GeraLocationVariant2GeodeticInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{20}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for GeraLocationVariant2GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for GeraLocationVariant2GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for GeraLocationVariant2GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for GeraLocationVariant2GeodeticInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Refer to geographical Information.See 3GPP TS 23.032 clause 7.3.2. Only
	/// the description of an ellipsoid point with uncertainty circle is allowed
	/// to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refer to geographical Information.See 3GPP TS 23.032
	/// clause 7.3.2. Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{16}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct GeraLocationVariant2GeographicalInformation(String);
	impl ::std::ops::Deref for GeraLocationVariant2GeographicalInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<GeraLocationVariant2GeographicalInformation> for String {
		fn from(value: GeraLocationVariant2GeographicalInformation) -> Self {
			value.0
		}
	}

	impl From<&GeraLocationVariant2GeographicalInformation>
		for GeraLocationVariant2GeographicalInformation
	{
		fn from(value: &GeraLocationVariant2GeographicalInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for GeraLocationVariant2GeographicalInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{16}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for GeraLocationVariant2GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for GeraLocationVariant2GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for GeraLocationVariant2GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for GeraLocationVariant2GeographicalInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// One of the six attributes n3IwfId, gNbIdm, ngeNbId, wagfId, tngfId,
	/// eNbId shall be present.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "One of the six attributes n3IwfId, gNbIdm, ngeNbId,
	/// wagfId, tngfId, eNbId shall be present.\n",
	///  "type": "object",
	///  "oneOf": [
	///    {
	///      "required": [
	///        "n3IwfId"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "gNbId"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "ngeNbId"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "wagfId"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "tngfId"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "eNbId"
	///      ]
	///    }
	///  ],
	///  "required": [
	///    "plmnId"
	///  ],
	///  "properties": {
	///    "eNbId": {
	///      "$ref": "#/components/schemas/ENbId"
	///    },
	///    "gNbId": {
	///      "$ref": "#/components/schemas/GNbId"
	///    },
	///    "n3IwfId": {
	///      "$ref": "#/components/schemas/N3IwfId"
	///    },
	///    "ngeNbId": {
	///      "$ref": "#/components/schemas/NgeNbId"
	///    },
	///    "nid": {
	///      "$ref": "#/components/schemas/Nid"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "tngfId": {
	///      "$ref": "#/components/schemas/TngfId"
	///    },
	///    "wagfId": {
	///      "$ref": "#/components/schemas/WAgfId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum GlobalRanNodeId {
		#[default]
		Variant0 {
			#[serde(rename = "n3IwfId")]
			n3_iwf_id: N3IwfId,
			#[serde(default, skip_serializing_if = "Option::is_none")]
			nid: Option<Nid>,
			#[serde(rename = "plmnId")]
			plmn_id: PlmnId,
		},
		Variant1 {
			#[serde(rename = "gNbId")]
			g_nb_id: GNbId,
			#[serde(default, skip_serializing_if = "Option::is_none")]
			nid: Option<Nid>,
			#[serde(rename = "plmnId")]
			plmn_id: PlmnId,
		},
		Variant2 {
			#[serde(rename = "ngeNbId")]
			nge_nb_id: NgeNbId,
			#[serde(default, skip_serializing_if = "Option::is_none")]
			nid: Option<Nid>,
			#[serde(rename = "plmnId")]
			plmn_id: PlmnId,
		},
		Variant3 {
			#[serde(default, skip_serializing_if = "Option::is_none")]
			nid: Option<Nid>,
			#[serde(rename = "plmnId")]
			plmn_id: PlmnId,
			#[serde(rename = "wagfId")]
			wagf_id: WAgfId,
		},
		Variant4 {
			#[serde(default, skip_serializing_if = "Option::is_none")]
			nid: Option<Nid>,
			#[serde(rename = "plmnId")]
			plmn_id: PlmnId,
			#[serde(rename = "tngfId")]
			tngf_id: TngfId,
		},
		Variant5 {
			#[serde(rename = "eNbId")]
			e_nb_id: ENbId,
			#[serde(default, skip_serializing_if = "Option::is_none")]
			nid: Option<Nid>,
			#[serde(rename = "plmnId")]
			plmn_id: PlmnId,
		},
	}

	impl From<&GlobalRanNodeId> for GlobalRanNodeId {
		fn from(value: &GlobalRanNodeId) -> Self {
			value.clone()
		}
	}

	/// String identifying a Gpsi shall contain either an External Id or an
	/// MSISDN.  It shall be formatted as follows -External Identifier=
	/// "extid-'extid', where 'extid'  shall be formatted according to clause
	/// 19.7.2 of 3GPP TS 23.003 that describes an  External Identifier.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String identifying a Gpsi shall contain either an
	/// External Id or an MSISDN.  It shall be formatted as follows -External
	/// Identifier= \"extid-'extid', where 'extid'  shall be formatted according
	/// to clause 19.7.2 of 3GPP TS 23.003 that describes an  External
	/// Identifier. \n",
	///  "type": "string",
	///  "pattern": "^(msisdn-[0-9]{5,15}|extid-[^@]+@[^@]+|.+)$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Gpsi(String);
	impl ::std::ops::Deref for Gpsi {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Gpsi> for String {
		fn from(value: Gpsi) -> Self {
			value.0
		}
	}

	impl From<&Gpsi> for Gpsi {
		fn from(value: &Gpsi) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Gpsi {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^(msisdn-[0-9]{5,15}|extid-[^@]+@[^@]+|.+)$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \
				            \"^(msisdn-[0-9]{5,15}|extid-[^@]+@[^@]+|.+)$\""
					.into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Gpsi {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Gpsi {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Gpsi {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Gpsi {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Type of GPSI (MSISDN or External-ID)
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Type of GPSI (MSISDN or External-ID)",
	///  "type": "string",
	///  "enum": [
	///    "MSISDN",
	///    "EXT_ID",
	///    "EXT_GROUP_ID"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum GpsiType {
		#[default]
		#[serde(rename = "MSISDN")]
		Msisdn,
		#[serde(rename = "EXT_ID")]
		ExtId,
		#[serde(rename = "EXT_GROUP_ID")]
		ExtGroupId,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&GpsiType> for GpsiType {
		fn from(value: &GpsiType) -> Self {
			value.clone()
		}
	}

	impl ToString for GpsiType {
		fn to_string(&self) -> String {
			match *self {
				Self::Msisdn => "MSISDN".to_string(),
				Self::ExtId => "EXT_ID".to_string(),
				Self::ExtGroupId => "EXT_GROUP_ID".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for GpsiType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"MSISDN" => Ok(Self::Msisdn),
				"EXT_ID" => Ok(Self::ExtId),
				"EXT_GROUP_ID" => Ok(Self::ExtGroupId),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for GpsiType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for GpsiType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for GpsiType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// String identifying a group of devices network internal globally unique
	/// ID which identifies a set of IMSIs, as specified in clause 19.9 of 3GPP
	/// TS 23.003.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String identifying a group of devices network internal
	/// globally unique ID which identifies a set of IMSIs, as specified in
	/// clause 19.9 of 3GPP TS 23.003. \n",
	///  "type": "string",
	///  "pattern":
	/// "^[A-Fa-f0-9]{8}-[0-9]{3}-[0-9]{2,3}-([A-Fa-f0-9][A-Fa-f0-9]){1,10}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct GroupId(String);
	impl ::std::ops::Deref for GroupId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<GroupId> for String {
		fn from(value: GroupId) -> Self {
			value.0
		}
	}

	impl From<&GroupId> for GroupId {
		fn from(value: &GroupId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for GroupId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new(
				"^[A-Fa-f0-9]{8}-[0-9]{3}-[0-9]{2,3}-([A-Fa-f0-9][A-Fa-f0-9]){1,10}$",
			)
			.unwrap()
			.find(value)
			.is_none()
			{
				return Err("doesn't match pattern \
				            \"^[A-Fa-f0-9]{8}-[0-9]{3}-[0-9]{2,3}-([A-Fa-f0-9][A-Fa-f0-9]){1,\
				            10}$\""
					.into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for GroupId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for GroupId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for GroupId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for GroupId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// GroupIdentifiers
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "extGroupId": {
	///      "$ref": "#/components/schemas/ExtGroupId"
	///    },
	///    "intGroupId": {
	///      "$ref": "#/components/schemas/GroupId"
	///    },
	///    "ueIdList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/UeId"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct GroupIdentifiers {
		#[serde(
			rename = "extGroupId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ext_group_id: Option<ExtGroupId>,
		#[serde(
			rename = "intGroupId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub int_group_id: Option<GroupId>,
		#[serde(rename = "ueIdList", default, skip_serializing_if = "Vec::is_empty")]
		pub ue_id_list: Vec<UeId>,
	}

	impl From<&GroupIdentifiers> for GroupIdentifiers {
		fn from(value: &GroupIdentifiers) -> Self {
			value.clone()
		}
	}

	/// Globally Unique AMF Identifier constructed out of PLMN, Network and AMF
	/// identity.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Globally Unique AMF Identifier constructed out of PLMN,
	/// Network and AMF identity.",
	///  "type": "object",
	///  "required": [
	///    "amfId",
	///    "plmnId"
	///  ],
	///  "properties": {
	///    "amfId": {
	///      "$ref": "#/components/schemas/AmfId"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnIdNid"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Guami {
		#[serde(rename = "amfId")]
		pub amf_id: AmfId,
		#[serde(rename = "plmnId")]
		pub plmn_id: PlmnIdNid,
	}

	impl From<&Guami> for Guami {
		fn from(value: &Guami) -> Self {
			value.clone()
		}
	}

	/// This IE represents the identifier of the HFC node Id as specified in
	/// CableLabs WR-TR-5WWC-ARCH. It is provisioned by the wireline operator as
	/// part of wireline operations and may contain up to six characters.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This IE represents the identifier of the HFC node Id as
	/// specified in CableLabs WR-TR-5WWC-ARCH. It is provisioned by the
	/// wireline operator as part of wireline operations and may contain up to
	/// six characters.\n",
	///  "type": "string",
	///  "maxLength": 6
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct HfcNId(String);
	impl ::std::ops::Deref for HfcNId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<HfcNId> for String {
		fn from(value: HfcNId) -> Self {
			value.0
		}
	}

	impl From<&HfcNId> for HfcNId {
		fn from(value: &HfcNId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for HfcNId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if value.len() > 6usize {
				return Err("longer than 6 characters".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for HfcNId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for HfcNId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for HfcNId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for HfcNId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// REpresents the HFC Node Identifer received over NGAP.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "REpresents the HFC Node Identifer received over NGAP.",
	///  "type": "object",
	///  "required": [
	///    "hfcNId"
	///  ],
	///  "properties": {
	///    "hfcNId": {
	///      "$ref": "#/components/schemas/HfcNId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct HfcNodeId {
		#[serde(rename = "hfcNId")]
		pub hfc_n_id: HfcNId,
	}

	impl From<&HfcNodeId> for HfcNodeId {
		fn from(value: &HfcNodeId) -> Self {
			value.clone()
		}
	}

	/// HssAuthType
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "EPS_AKA",
	///    "EAP_AKA",
	///    "EAP_AKA_PRIME",
	///    "IMS_AKA",
	///    "GBA_AKA",
	///    "UMTS_AKA"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum HssAuthType {
		#[default]
		#[serde(rename = "EPS_AKA")]
		EpsAka,
		#[serde(rename = "EAP_AKA")]
		EapAka,
		#[serde(rename = "EAP_AKA_PRIME")]
		EapAkaPrime,
		#[serde(rename = "IMS_AKA")]
		ImsAka,
		#[serde(rename = "GBA_AKA")]
		GbaAka,
		#[serde(rename = "UMTS_AKA")]
		UmtsAka,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&HssAuthType> for HssAuthType {
		fn from(value: &HssAuthType) -> Self {
			value.clone()
		}
	}

	impl ToString for HssAuthType {
		fn to_string(&self) -> String {
			match *self {
				Self::EpsAka => "EPS_AKA".to_string(),
				Self::EapAka => "EAP_AKA".to_string(),
				Self::EapAkaPrime => "EAP_AKA_PRIME".to_string(),
				Self::ImsAka => "IMS_AKA".to_string(),
				Self::GbaAka => "GBA_AKA".to_string(),
				Self::UmtsAka => "UMTS_AKA".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for HssAuthType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"EPS_AKA" => Ok(Self::EpsAka),
				"EAP_AKA" => Ok(Self::EapAka),
				"EAP_AKA_PRIME" => Ok(Self::EapAkaPrime),
				"IMS_AKA" => Ok(Self::ImsAka),
				"GBA_AKA" => Ok(Self::GbaAka),
				"UMTS_AKA" => Ok(Self::UmtsAka),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for HssAuthType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for HssAuthType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for HssAuthType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// HssAuthTypeInUri
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "eps-aka",
	///    "eap-aka",
	///    "eap-aka-prime",
	///    "ims-aka",
	///    "gba-aka"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum HssAuthTypeInUri {
		#[default]
		#[serde(rename = "eps-aka")]
		EpsAka,
		#[serde(rename = "eap-aka")]
		EapAka,
		#[serde(rename = "eap-aka-prime")]
		EapAkaPrime,
		#[serde(rename = "ims-aka")]
		ImsAka,
		#[serde(rename = "gba-aka")]
		GbaAka,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&HssAuthTypeInUri> for HssAuthTypeInUri {
		fn from(value: &HssAuthTypeInUri) -> Self {
			value.clone()
		}
	}

	impl ToString for HssAuthTypeInUri {
		fn to_string(&self) -> String {
			match *self {
				Self::EpsAka => "eps-aka".to_string(),
				Self::EapAka => "eap-aka".to_string(),
				Self::EapAkaPrime => "eap-aka-prime".to_string(),
				Self::ImsAka => "ims-aka".to_string(),
				Self::GbaAka => "gba-aka".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for HssAuthTypeInUri {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"eps-aka" => Ok(Self::EpsAka),
				"eap-aka" => Ok(Self::EapAka),
				"eap-aka-prime" => Ok(Self::EapAkaPrime),
				"ims-aka" => Ok(Self::ImsAka),
				"gba-aka" => Ok(Self::GbaAka),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for HssAuthTypeInUri {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for HssAuthTypeInUri {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for HssAuthTypeInUri {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// HssAuthenticationInfoRequest
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "hssAuthType",
	///    "numOfRequestedVectors"
	///  ],
	///  "properties": {
	///    "anId": {
	///      "$ref": "#/components/schemas/AccessNetworkId"
	///    },
	///    "hssAuthType": {
	///      "$ref": "#/components/schemas/HssAuthType"
	///    },
	///    "numOfRequestedVectors": {
	///      "$ref": "#/components/schemas/NumOfRequestedVectors"
	///    },
	///    "requestingNodeType": {
	///      "$ref": "#/components/schemas/NodeType"
	///    },
	///    "resynchronizationInfo": {
	///      "$ref": "#/components/schemas/ResynchronizationInfo"
	///    },
	///    "servingNetworkId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct HssAuthenticationInfoRequest {
		#[serde(rename = "anId", default, skip_serializing_if = "Option::is_none")]
		pub an_id: Option<AccessNetworkId>,
		#[serde(rename = "hssAuthType")]
		pub hss_auth_type: HssAuthType,
		#[serde(rename = "numOfRequestedVectors")]
		pub num_of_requested_vectors: NumOfRequestedVectors,
		#[serde(
			rename = "requestingNodeType",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub requesting_node_type: Option<NodeType>,
		#[serde(
			rename = "resynchronizationInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub resynchronization_info: Option<ResynchronizationInfo>,
		#[serde(
			rename = "servingNetworkId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub serving_network_id: Option<PlmnId>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&HssAuthenticationInfoRequest> for HssAuthenticationInfoRequest {
		fn from(value: &HssAuthenticationInfoRequest) -> Self {
			value.clone()
		}
	}

	/// HssAuthenticationInfoResult
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "hssAuthenticationVectors"
	///  ],
	///  "properties": {
	///    "hssAuthenticationVectors": {
	///      "$ref": "#/components/schemas/HssAuthenticationVectors"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct HssAuthenticationInfoResult {
		#[serde(rename = "hssAuthenticationVectors")]
		pub hss_authentication_vectors: HssAuthenticationVectors,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&HssAuthenticationInfoResult> for HssAuthenticationInfoResult {
		fn from(value: &HssAuthenticationInfoResult) -> Self {
			value.clone()
		}
	}

	/// HssAuthenticationVectors
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "oneOf": [
	///    {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/AvEpsAka"
	///      },
	///      "maxItems": 5,
	///      "minItems": 1
	///    },
	///    {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/AvImsGbaEapAka"
	///      },
	///      "maxItems": 5,
	///      "minItems": 1
	///    },
	///    {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/AvEapAkaPrime"
	///      },
	///      "maxItems": 5,
	///      "minItems": 1
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum HssAuthenticationVectors {
		#[default]
		Variant0(Vec<AvEpsAka>),
		Variant1(Vec<AvImsGbaEapAka>),
		Variant2(Vec<AvEapAkaPrime>),
	}

	impl From<&HssAuthenticationVectors> for HssAuthenticationVectors {
		fn from(value: &HssAuthenticationVectors) -> Self {
			value.clone()
		}
	}

	impl From<Vec<AvEpsAka>> for HssAuthenticationVectors {
		fn from(value: Vec<AvEpsAka>) -> Self {
			Self::Variant0(value)
		}
	}

	impl From<Vec<AvImsGbaEapAka>> for HssAuthenticationVectors {
		fn from(value: Vec<AvImsGbaEapAka>) -> Self {
			Self::Variant1(value)
		}
	}

	impl From<Vec<AvEapAkaPrime>> for HssAuthenticationVectors {
		fn from(value: Vec<AvEapAkaPrime>) -> Self {
			Self::Variant2(value)
		}
	}

	/// HssAvType
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "EPS_AKA",
	///    "EAP_AKA",
	///    "IMS_AKA",
	///    "GBA_AKA",
	///    "UMTS_AKA"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum HssAvType {
		#[default]
		#[serde(rename = "EPS_AKA")]
		EpsAka,
		#[serde(rename = "EAP_AKA")]
		EapAka,
		#[serde(rename = "IMS_AKA")]
		ImsAka,
		#[serde(rename = "GBA_AKA")]
		GbaAka,
		#[serde(rename = "UMTS_AKA")]
		UmtsAka,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&HssAvType> for HssAvType {
		fn from(value: &HssAvType) -> Self {
			value.clone()
		}
	}

	impl ToString for HssAvType {
		fn to_string(&self) -> String {
			match *self {
				Self::EpsAka => "EPS_AKA".to_string(),
				Self::EapAka => "EAP_AKA".to_string(),
				Self::ImsAka => "IMS_AKA".to_string(),
				Self::GbaAka => "GBA_AKA".to_string(),
				Self::UmtsAka => "UMTS_AKA".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for HssAvType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"EPS_AKA" => Ok(Self::EpsAka),
				"EAP_AKA" => Ok(Self::EapAka),
				"IMS_AKA" => Ok(Self::ImsAka),
				"GBA_AKA" => Ok(Self::GbaAka),
				"UMTS_AKA" => Ok(Self::UmtsAka),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for HssAvType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for HssAvType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for HssAvType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// IdTranslationResult
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "supi"
	///  ],
	///  "properties": {
	///    "additionalGpsis": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Gpsi"
	///      },
	///      "minItems": 1
	///    },
	///    "additionalSupis": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Supi"
	///      },
	///      "minItems": 1
	///    },
	///    "gpsi": {
	///      "$ref": "#/components/schemas/Gpsi"
	///    },
	///    "supi": {
	///      "$ref": "#/components/schemas/Supi"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct IdTranslationResult {
		#[serde(
			rename = "additionalGpsis",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub additional_gpsis: Vec<Gpsi>,
		#[serde(
			rename = "additionalSupis",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub additional_supis: Vec<Supi>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub gpsi: Option<Gpsi>,
		pub supi: Supi,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&IdTranslationResult> for IdTranslationResult {
		fn from(value: &IdTranslationResult) -> Self {
			value.clone()
		}
	}

	/// A range of GPSIs (subscriber identities), either based on a numeric
	/// range, or based on regular-expression matching
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "A range of GPSIs (subscriber identities), either based
	/// on a numeric range, or based on regular-expression matching\n",
	///  "type": "object",
	///  "properties": {
	///    "end": {
	///      "type": "string",
	///      "pattern": "^[0-9]+$"
	///    },
	///    "pattern": {
	///      "type": "string"
	///    },
	///    "start": {
	///      "type": "string",
	///      "pattern": "^[0-9]+$"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct IdentityRange {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub end: Option<IdentityRangeEnd>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub pattern: Option<String>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub start: Option<IdentityRangeStart>,
	}

	impl From<&IdentityRange> for IdentityRange {
		fn from(value: &IdentityRange) -> Self {
			value.clone()
		}
	}

	/// IdentityRangeEnd
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[0-9]+$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct IdentityRangeEnd(String);
	impl ::std::ops::Deref for IdentityRangeEnd {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<IdentityRangeEnd> for String {
		fn from(value: IdentityRangeEnd) -> Self {
			value.0
		}
	}

	impl From<&IdentityRangeEnd> for IdentityRangeEnd {
		fn from(value: &IdentityRangeEnd) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for IdentityRangeEnd {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9]+$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9]+$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for IdentityRangeEnd {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for IdentityRangeEnd {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for IdentityRangeEnd {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for IdentityRangeEnd {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// IdentityRangeStart
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[0-9]+$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct IdentityRangeStart(String);
	impl ::std::ops::Deref for IdentityRangeStart {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<IdentityRangeStart> for String {
		fn from(value: IdentityRangeStart) -> Self {
			value.0
		}
	}

	impl From<&IdentityRangeStart> for IdentityRangeStart {
		fn from(value: &IdentityRangeStart) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for IdentityRangeStart {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9]+$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9]+$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for IdentityRangeStart {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for IdentityRangeStart {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for IdentityRangeStart {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for IdentityRangeStart {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Represents the idle status indication.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents the idle status indication.",
	///  "type": "object",
	///  "properties": {
	///    "activeTime": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "edrxCycleLength": {
	///      "type": "integer"
	///    },
	///    "subsRegTimer": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "suggestedNumOfDlPackets": {
	///      "type": "integer"
	///    },
	///    "timeStamp": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct IdleStatusIndication {
		#[serde(
			rename = "activeTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub active_time: Option<DurationSec>,
		#[serde(
			rename = "edrxCycleLength",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub edrx_cycle_length: Option<i64>,
		#[serde(
			rename = "subsRegTimer",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub subs_reg_timer: Option<DurationSec>,
		#[serde(
			rename = "suggestedNumOfDlPackets",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub suggested_num_of_dl_packets: Option<i64>,
		#[serde(rename = "timeStamp", default, skip_serializing_if = "Option::is_none")]
		pub time_stamp: Option<DateTime>,
	}

	impl From<&IdleStatusIndication> for IdleStatusIndication {
		fn from(value: &IdleStatusIndication) -> Self {
			value.clone()
		}
	}

	/// IkPrime
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{32}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct IkPrime(String);
	impl ::std::ops::Deref for IkPrime {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<IkPrime> for String {
		fn from(value: IkPrime) -> Self {
			value.0
		}
	}

	impl From<&IkPrime> for IkPrime {
		fn from(value: &IkPrime) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for IkPrime {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{32}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{32}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for IkPrime {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for IkPrime {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for IkPrime {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for IkPrime {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// ImmediateReport
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "oneOf": [
	///    {
	///      "$ref": "#/components/schemas/SubscriptionDataSets"
	///    },
	///    {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/SharedData"
	///      },
	///      "minItems": 0
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum ImmediateReport {
		#[default]
		Variant0(SubscriptionDataSets),
		Variant1(Vec<SharedData>),
	}

	impl From<&ImmediateReport> for ImmediateReport {
		fn from(value: &ImmediateReport) -> Self {
			value.clone()
		}
	}

	impl From<SubscriptionDataSets> for ImmediateReport {
		fn from(value: SubscriptionDataSets) -> Self {
			Self::Variant0(value)
		}
	}

	impl From<Vec<SharedData>> for ImmediateReport {
		fn from(value: Vec<SharedData>) -> Self {
			Self::Variant1(value)
		}
	}

	/// ImsVoPs
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "HOMOGENEOUS_SUPPORT",
	///    "HOMOGENEOUS_NON_SUPPORT",
	///    "NON_HOMOGENEOUS_OR_UNKNOWN"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum ImsVoPs {
		#[default]
		#[serde(rename = "HOMOGENEOUS_SUPPORT")]
		HomogeneousSupport,
		#[serde(rename = "HOMOGENEOUS_NON_SUPPORT")]
		HomogeneousNonSupport,
		#[serde(rename = "NON_HOMOGENEOUS_OR_UNKNOWN")]
		NonHomogeneousOrUnknown,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&ImsVoPs> for ImsVoPs {
		fn from(value: &ImsVoPs) -> Self {
			value.clone()
		}
	}

	impl ToString for ImsVoPs {
		fn to_string(&self) -> String {
			match *self {
				Self::HomogeneousSupport => "HOMOGENEOUS_SUPPORT".to_string(),
				Self::HomogeneousNonSupport => "HOMOGENEOUS_NON_SUPPORT".to_string(),
				Self::NonHomogeneousOrUnknown => "NON_HOMOGENEOUS_OR_UNKNOWN".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for ImsVoPs {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"HOMOGENEOUS_SUPPORT" => Ok(Self::HomogeneousSupport),
				"HOMOGENEOUS_NON_SUPPORT" => Ok(Self::HomogeneousNonSupport),
				"NON_HOMOGENEOUS_OR_UNKNOWN" => Ok(Self::NonHomogeneousOrUnknown),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for ImsVoPs {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for ImsVoPs {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for ImsVoPs {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Indicates value of the inner radius.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates value of the inner radius.",
	///  "type": "integer",
	///  "format": "int32",
	///  "maximum": 327675.0,
	///  "minimum": 0.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct InnerRadius(pub i64);
	impl ::std::ops::Deref for InnerRadius {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<InnerRadius> for i64 {
		fn from(value: InnerRadius) -> Self {
			value.0
		}
	}

	impl From<&InnerRadius> for InnerRadius {
		fn from(value: &InnerRadius) -> Self {
			value.clone()
		}
	}

	impl From<i64> for InnerRadius {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for InnerRadius {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for InnerRadius {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for InnerRadius {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for InnerRadius {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for InnerRadius {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// IntegrityKey
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{32}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct IntegrityKey(String);
	impl ::std::ops::Deref for IntegrityKey {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<IntegrityKey> for String {
		fn from(value: IntegrityKey) -> Self {
			value.0
		}
	}

	impl From<&IntegrityKey> for IntegrityKey {
		fn from(value: &IntegrityKey) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for IntegrityKey {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{32}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{32}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for IntegrityKey {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for IntegrityKey {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for IntegrityKey {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for IntegrityKey {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Indicates the Inter Frequency Target information.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates the Inter Frequency Target information.",
	///  "type": "object",
	///  "required": [
	///    "dlCarrierFreq"
	///  ],
	///  "properties": {
	///    "cellIdList": {
	///      "description": "When present, this IE shall contain a list of the
	/// physical cell identities where the UE is requested to perform
	/// measurement logging for the indicated frequency.\n",
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/PhysCellId"
	///      },
	///      "maxItems": 32,
	///      "minItems": 1
	///    },
	///    "dlCarrierFreq": {
	///      "$ref": "#/components/schemas/ArfcnValueNR"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct InterFreqTargetInfo {
		/// When present, this IE shall contain a list of the physical cell
		/// identities where the UE is requested to perform measurement logging
		/// for the indicated frequency.
		#[serde(rename = "cellIdList", default, skip_serializing_if = "Vec::is_empty")]
		pub cell_id_list: Vec<PhysCellId>,
		#[serde(rename = "dlCarrierFreq")]
		pub dl_carrier_freq: ArfcnValueNr,
	}

	impl From<&InterFreqTargetInfo> for InterFreqTargetInfo {
		fn from(value: &InterFreqTargetInfo) -> Self {
			value.clone()
		}
	}

	/// Possible values are - SUBSRIPTION_WITHDRAWAL - DNN_REMOVED -
	/// SLICE_REMOVED - AUTHORIZATION_REVOKED
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Possible values are - SUBSRIPTION_WITHDRAWAL -
	/// DNN_REMOVED - SLICE_REMOVED - AUTHORIZATION_REVOKED\n",
	///  "type": "string",
	///  "enum": [
	///    "SUBSRIPTION_WITHDRAWAL",
	///    "DNN_REMOVED",
	///    "SLICE_REMOVED",
	///    "AUTHORIZATION_REVOKED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum InvalidCause {
		#[default]
		#[serde(rename = "SUBSRIPTION_WITHDRAWAL")]
		SubsriptionWithdrawal,
		#[serde(rename = "DNN_REMOVED")]
		DnnRemoved,
		#[serde(rename = "SLICE_REMOVED")]
		SliceRemoved,
		#[serde(rename = "AUTHORIZATION_REVOKED")]
		AuthorizationRevoked,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&InvalidCause> for InvalidCause {
		fn from(value: &InvalidCause) -> Self {
			value.clone()
		}
	}

	impl ToString for InvalidCause {
		fn to_string(&self) -> String {
			match *self {
				Self::SubsriptionWithdrawal => "SUBSRIPTION_WITHDRAWAL".to_string(),
				Self::DnnRemoved => "DNN_REMOVED".to_string(),
				Self::SliceRemoved => "SLICE_REMOVED".to_string(),
				Self::AuthorizationRevoked => "AUTHORIZATION_REVOKED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for InvalidCause {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"SUBSRIPTION_WITHDRAWAL" => Ok(Self::SubsriptionWithdrawal),
				"DNN_REMOVED" => Ok(Self::DnnRemoved),
				"SLICE_REMOVED" => Ok(Self::SliceRemoved),
				"AUTHORIZATION_REVOKED" => Ok(Self::AuthorizationRevoked),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for InvalidCause {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for InvalidCause {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for InvalidCause {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// It contains an invalid parameter and a related description.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "It contains an invalid parameter and a related
	/// description.",
	///  "type": "object",
	///  "required": [
	///    "param"
	///  ],
	///  "properties": {
	///    "param": {
	///      "description": "If the invalid parameter is an attribute in a JSON
	/// body, this IE shall contain the  attribute's name and shall be encoded
	/// as a JSON Pointer. If the invalid parameter is  an HTTP header, this IE
	/// shall be formatted as the concatenation of the string \"header \"  plus
	/// the name of such header. If the invalid parameter is a query parameter,
	/// this IE  shall be formatted as the concatenation of the string \"query
	/// \" plus the name of such  query parameter. If the invalid parameter is a
	/// variable part in the path of a resource  URI, this IE shall contain the
	/// name of the variable, including the symbols \"{\" and \"}\"  used in
	/// OpenAPI specification as the notation to represent variable path
	/// segments.\n",
	///      "type": "string"
	///    },
	///    "reason": {
	///      "description": "A human-readable reason, e.g. \"must be a positive
	/// integer\". In cases involving failed  operations in a PATCH request, the
	/// reason string should identify the operation that  failed using the
	/// operation's array index to assist in correlation of the invalid
	/// parameter with the failed operation, e.g.\" Replacement value invalid
	/// for attribute  (failed operation index= 4)\"\n",
	///      "type": "string"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct InvalidParam {
		/// If the invalid parameter is an attribute in a JSON body, this IE
		/// shall contain the  attribute's name and shall be encoded as a JSON
		/// Pointer. If the invalid parameter is  an HTTP header, this IE shall
		/// be formatted as the concatenation of the string "header "  plus the
		/// name of such header. If the invalid parameter is a query parameter,
		/// this IE  shall be formatted as the concatenation of the string
		/// "query " plus the name of such  query parameter. If the invalid
		/// parameter is a variable part in the path of a resource  URI, this IE
		/// shall contain the name of the variable, including the symbols "{"
		/// and "}"  used in OpenAPI specification as the notation to represent
		/// variable path segments.
		pub param: String,
		/// A human-readable reason, e.g. "must be a positive integer". In cases
		/// involving failed  operations in a PATCH request, the reason string
		/// should identify the operation that  failed using the operation's
		/// array index to assist in correlation of the invalid  parameter with
		/// the failed operation, e.g." Replacement value invalid for attribute
		/// (failed operation index= 4)"
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub reason: Option<String>,
	}

	impl From<&InvalidParam> for InvalidParam {
		fn from(value: &InvalidParam) -> Self {
			value.clone()
		}
	}

	/// Contains an IP adresse.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains an IP adresse.",
	///  "type": "object",
	///  "oneOf": [
	///    {
	///      "required": [
	///        "ipv4Addr"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "ipv6Addr"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "ipv6Prefix"
	///      ]
	///    }
	///  ],
	///  "properties": {
	///    "ipv4Addr": {
	///      "$ref": "#/components/schemas/Ipv4Addr"
	///    },
	///    "ipv6Addr": {
	///      "$ref": "#/components/schemas/Ipv6Addr"
	///    },
	///    "ipv6Prefix": {
	///      "$ref": "#/components/schemas/Ipv6Prefix"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum IpAddr {
		#[default]
		Variant0 {
			#[serde(rename = "ipv4Addr")]
			ipv4_addr: Ipv4Addr,
		},
		Variant1 {
			#[serde(rename = "ipv6Addr")]
			ipv6_addr: Ipv6Addr,
		},
		Variant2 {
			#[serde(rename = "ipv6Prefix")]
			ipv6_prefix: Ipv6Prefix,
		},
	}

	impl From<&IpAddr> for IpAddr {
		fn from(value: &IpAddr) -> Self {
			value.clone()
		}
	}

	/// IpAddress
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "oneOf": [
	///    {
	///      "required": [
	///        "ipv4Addr"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "ipv6Addr"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "ipv6Prefix"
	///      ]
	///    }
	///  ],
	///  "properties": {
	///    "ipv4Addr": {
	///      "$ref": "#/components/schemas/Ipv4Addr"
	///    },
	///    "ipv6Addr": {
	///      "$ref": "#/components/schemas/Ipv6Addr"
	///    },
	///    "ipv6Prefix": {
	///      "$ref": "#/components/schemas/Ipv6Prefix"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum IpAddress {
		#[default]
		Variant0 {
			#[serde(rename = "ipv4Addr")]
			ipv4_addr: Ipv4Addr,
		},
		Variant1 {
			#[serde(rename = "ipv6Addr")]
			ipv6_addr: Ipv6Addr,
		},
		Variant2 {
			#[serde(rename = "ipv6Prefix")]
			ipv6_prefix: Ipv6Prefix,
		},
	}

	impl From<&IpAddress> for IpAddress {
		fn from(value: &IpAddress) -> Self {
			value.clone()
		}
	}

	/// Represents the IP Index to be sent from UDM to the SMF (its value can be
	/// either an integer or a string)
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents the IP Index to be sent from UDM to the SMF
	/// (its value can be either an integer or a string)",
	///  "anyOf": [
	///    {
	///      "type": "integer"
	///    },
	///    {
	///      "type": "string"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum IpIndex {
		#[default]
		Variant0(i64),
		Variant1(String),
	}

	impl From<&IpIndex> for IpIndex {
		fn from(value: &IpIndex) -> Self {
			value.clone()
		}
	}

	impl std::str::FromStr for IpIndex {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if let Ok(v) = value.parse() {
				Ok(Self::Variant0(v))
			} else if let Ok(v) = value.parse() {
				Ok(Self::Variant1(v))
			} else {
				Err("string conversion failed for all variants".into())
			}
		}
	}

	impl std::convert::TryFrom<&str> for IpIndex {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for IpIndex {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for IpIndex {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ToString for IpIndex {
		fn to_string(&self) -> String {
			match self {
				Self::Variant0(x) => x.to_string(),
				Self::Variant1(x) => x.to_string(),
			}
		}
	}

	impl From<i64> for IpIndex {
		fn from(value: i64) -> Self {
			Self::Variant0(value)
		}
	}

	/// Contains guidance information (e.g. minimum and recommended delivery
	/// times) of the IP-SM-GW
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains guidance information (e.g. minimum and
	/// recommended delivery times) of the IP-SM-GW\n",
	///  "type": "object",
	///  "required": [
	///    "minDeliveryTime",
	///    "recommDeliveryTime"
	///  ],
	///  "properties": {
	///    "minDeliveryTime": {
	///      "type": "integer",
	///      "maximum": 600.0,
	///      "minimum": 30.0
	///    },
	///    "recommDeliveryTime": {
	///      "type": "integer",
	///      "maximum": 600.0,
	///      "minimum": 30.0
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct IpSmGwGuidance {
		#[serde(rename = "minDeliveryTime")]
		pub min_delivery_time: i64,
		#[serde(rename = "recommDeliveryTime")]
		pub recomm_delivery_time: i64,
	}

	impl From<&IpSmGwGuidance> for IpSmGwGuidance {
		fn from(value: &IpSmGwGuidance) -> Self {
			value.clone()
		}
	}

	/// Contains the IP-SM-GW Information
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the IP-SM-GW Information",
	///  "type": "object",
	///  "properties": {
	///    "ipSmGwGuidance": {
	///      "$ref": "#/components/schemas/IpSmGwGuidance"
	///    },
	///    "ipSmGwRegistration": {
	///      "$ref": "#/components/schemas/IpSmGwRegistration"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct IpSmGwInfo {
		#[serde(
			rename = "ipSmGwGuidance",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ip_sm_gw_guidance: Option<IpSmGwGuidance>,
		#[serde(
			rename = "ipSmGwRegistration",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ip_sm_gw_registration: Option<IpSmGwRegistration>,
	}

	impl From<&IpSmGwInfo> for IpSmGwInfo {
		fn from(value: &IpSmGwInfo) -> Self {
			value.clone()
		}
	}

	/// IpSmGwRegistration
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "anyOf": [
	///    {
	///      "required": [
	///        "ipSmGwMapAddress"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "ipSmGwDiameterAddress"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "ipsmgwIpv4"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "ipsmgwIpv6"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "ipsmgwFqdn"
	///      ]
	///    }
	///  ],
	///  "properties": {
	///    "ipSmGwDiameterAddress": {
	///      "$ref": "#/components/schemas/NetworkNodeDiameterAddress"
	///    },
	///    "ipSmGwMapAddress": {
	///      "$ref": "#/components/schemas/E164Number"
	///    },
	///    "ipSmGwSbiSupInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "ipsmgwFqdn": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "ipsmgwIpv4": {
	///      "$ref": "#/components/schemas/Ipv4Addr"
	///    },
	///    "ipsmgwIpv6": {
	///      "$ref": "#/components/schemas/Ipv6Addr"
	///    },
	///    "nfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "resetIds": {
	///      "type": "array",
	///      "items": {
	///        "type": "string"
	///      },
	///      "minItems": 1
	///    },
	///    "unriIndicator": {
	///      "default": false,
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum IpSmGwRegistration {
		#[default]
		Variant0 {
			#[serde(rename = "ipSmGwMapAddress")]
			ip_sm_gw_map_address: E164Number,
			#[serde(rename = "ipSmGwSbiSupInd", default)]
			ip_sm_gw_sbi_sup_ind: bool,
			#[serde(
				rename = "nfInstanceId",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			nf_instance_id: Option<NfInstanceId>,
			#[serde(rename = "resetIds", default, skip_serializing_if = "Vec::is_empty")]
			reset_ids: Vec<String>,
			#[serde(rename = "unriIndicator", default)]
			unri_indicator: bool,
		},
		Variant1 {
			#[serde(rename = "ipSmGwDiameterAddress")]
			ip_sm_gw_diameter_address: NetworkNodeDiameterAddress,
			#[serde(rename = "ipSmGwSbiSupInd", default)]
			ip_sm_gw_sbi_sup_ind: bool,
			#[serde(
				rename = "nfInstanceId",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			nf_instance_id: Option<NfInstanceId>,
			#[serde(rename = "resetIds", default, skip_serializing_if = "Vec::is_empty")]
			reset_ids: Vec<String>,
			#[serde(rename = "unriIndicator", default)]
			unri_indicator: bool,
		},
		Variant2 {
			#[serde(rename = "ipSmGwSbiSupInd", default)]
			ip_sm_gw_sbi_sup_ind: bool,
			#[serde(rename = "ipsmgwIpv4")]
			ipsmgw_ipv4: Ipv4Addr,
			#[serde(
				rename = "nfInstanceId",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			nf_instance_id: Option<NfInstanceId>,
			#[serde(rename = "resetIds", default, skip_serializing_if = "Vec::is_empty")]
			reset_ids: Vec<String>,
			#[serde(rename = "unriIndicator", default)]
			unri_indicator: bool,
		},
		Variant3 {
			#[serde(rename = "ipSmGwSbiSupInd", default)]
			ip_sm_gw_sbi_sup_ind: bool,
			#[serde(rename = "ipsmgwIpv6")]
			ipsmgw_ipv6: Ipv6Addr,
			#[serde(
				rename = "nfInstanceId",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			nf_instance_id: Option<NfInstanceId>,
			#[serde(rename = "resetIds", default, skip_serializing_if = "Vec::is_empty")]
			reset_ids: Vec<String>,
			#[serde(rename = "unriIndicator", default)]
			unri_indicator: bool,
		},
		Variant4 {
			#[serde(rename = "ipSmGwSbiSupInd", default)]
			ip_sm_gw_sbi_sup_ind: bool,
			#[serde(rename = "ipsmgwFqdn")]
			ipsmgw_fqdn: Fqdn,
			#[serde(
				rename = "nfInstanceId",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			nf_instance_id: Option<NfInstanceId>,
			#[serde(rename = "resetIds", default, skip_serializing_if = "Vec::is_empty")]
			reset_ids: Vec<String>,
			#[serde(rename = "unriIndicator", default)]
			unri_indicator: bool,
		},
	}

	impl From<&IpSmGwRegistration> for IpSmGwRegistration {
		fn from(value: &IpSmGwRegistration) -> Self {
			value.clone()
		}
	}

	/// String identifying a IPv4 address formatted in the 'dotted decimal'
	/// notation as defined in RFC 1166.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String identifying a IPv4 address formatted in the
	/// 'dotted decimal' notation as defined in RFC 1166.\n",
	///  "examples": [
	///    "198.51.100.1"
	///  ],
	///  "type": "string",
	///  "pattern":
	/// "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.
	/// ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Ipv4Addr(String);
	impl ::std::ops::Deref for Ipv4Addr {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Ipv4Addr> for String {
		fn from(value: Ipv4Addr) -> Self {
			value.0
		}
	}

	impl From<&Ipv4Addr> for Ipv4Addr {
		fn from(value: &Ipv4Addr) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Ipv4Addr {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new(
				"^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.\
				 ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$",
			)
			.unwrap()
			.find(value)
			.is_none()
			{
				return Err("doesn't match pattern \
				            \"^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.\
				            ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$\""
					.into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Ipv4Addr {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Ipv4Addr {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Ipv4Addr {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Ipv4Addr {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// "String identifying a IPv4 address mask formatted in the 'dotted
	/// decimal' notation as defined in RFC 1166."
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "\"String identifying a IPv4 address mask formatted in
	/// the 'dotted decimal' notation as defined in RFC 1166.\"\n",
	///  "examples": [
	///    "198.51.0.0/16"
	///  ],
	///  "type": "string",
	///  "pattern":
	/// "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.
	/// ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\/
	/// ([0-9]|[1-2][0-9]|3[0-2]))$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Ipv4AddrMask(String);
	impl ::std::ops::Deref for Ipv4AddrMask {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Ipv4AddrMask> for String {
		fn from(value: Ipv4AddrMask) -> Self {
			value.0
		}
	}

	impl From<&Ipv4AddrMask> for Ipv4AddrMask {
		fn from(value: &Ipv4AddrMask) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Ipv4AddrMask {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new(
				"^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.\
				 ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\/\
				 ([0-9]|[1-2][0-9]|3[0-2]))$",
			)
			.unwrap()
			.find(value)
			.is_none()
			{
				return Err("doesn't match pattern \
				            \"^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.\
				            ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\/\
				            ([0-9]|[1-2][0-9]|3[0-2]))$\""
					.into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Ipv4AddrMask {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Ipv4AddrMask {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Ipv4AddrMask {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Ipv4AddrMask {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// String identifying an IPv6 address formatted according to clause 4 of
	/// RFC5952. The mixed IPv4 IPv6 notation according to clause 5 of RFC5952
	/// shall not be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String identifying an IPv6 address formatted according
	/// to clause 4 of RFC5952. The mixed IPv4 IPv6 notation according to clause
	/// 5 of RFC5952 shall not be used.\n",
	///  "examples": [
	///    "2001:db8:85a3::8a2e:370:7334"
	///  ],
	///  "type": "string",
	///  "pattern":
	/// "(?=.*^((:|(0?|([1-9a-f][0-9a-f]{0,3}))):)((0?|([1-9a-f][0-9a-f]{0,3})):
	/// ){0,6}(:|(0?|([1-9a-f][0-9a-f]{0,3})))$)(?=.*^((([^:]+:){7}([^:
	/// ]+))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?))$)"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Ipv6Addr(String);
	impl ::std::ops::Deref for Ipv6Addr {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Ipv6Addr> for String {
		fn from(value: Ipv6Addr) -> Self {
			value.0
		}
	}

	impl From<&Ipv6Addr> for Ipv6Addr {
		fn from(value: &Ipv6Addr) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Ipv6Addr {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new(
				"(?=.*^((:|(0?|([1-9a-f][0-9a-f]{0,3}))):)((0?|([1-9a-f][0-9a-f]{0,3})):){0,6}(:\
				 |(0?|([1-9a-f][0-9a-f]{0,3})))$)(?=.*^((([^:]+:){7}([^:]+))|((([^:]+:)*[^:]+)?\
				 ::(([^:]+:)*[^:]+)?))$)",
			)
			.unwrap()
			.find(value)
			.is_none()
			{
				return Err("doesn't match pattern \
				            \"(?=.*^((:|(0?|([1-9a-f][0-9a-f]{0,3}))):)((0?|([1-9a-f][0-9a-f]{0,\
				            3})):){0,6}(:|(0?|([1-9a-f][0-9a-f]{0,3})))$)(?=.*^((([^:]+:){7}([^:\
				            ]+))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?))$)\""
					.into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Ipv6Addr {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Ipv6Addr {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Ipv6Addr {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Ipv6Addr {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// String identifying an IPv6 address prefix formatted according to clause
	/// 4 of RFC 5952. IPv6Prefix data type may contain an individual /128 IPv6
	/// address.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String identifying an IPv6 address prefix formatted
	/// according to clause 4 of RFC 5952. IPv6Prefix data type may contain an
	/// individual /128 IPv6 address.\n",
	///  "examples": [
	///    "2001:db8:abcd:12::0/64"
	///  ],
	///  "type": "string",
	///  "pattern":
	/// "(?=.*^((:|(0?|([1-9a-f][0-9a-f]{0,3}))):)((0?|([1-9a-f][0-9a-f]{0,3})):
	/// ){0,6}(:|(0?|([1-9a-f][0-9a-f]{0,3})))(\\/
	/// (([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))$)(?=.*^((([^:]+:){7}([^:
	/// ]+))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?))(\\/.+)$)"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Ipv6Prefix(String);
	impl ::std::ops::Deref for Ipv6Prefix {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Ipv6Prefix> for String {
		fn from(value: Ipv6Prefix) -> Self {
			value.0
		}
	}

	impl From<&Ipv6Prefix> for Ipv6Prefix {
		fn from(value: &Ipv6Prefix) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Ipv6Prefix {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new(
				"(?=.*^((:|(0?|([1-9a-f][0-9a-f]{0,3}))):)((0?|([1-9a-f][0-9a-f]{0,3})):){0,6}(:\
				 |(0?|([1-9a-f][0-9a-f]{0,3})))(\\/\
				 (([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))$)(?=.*^((([^:]+:){7}([^:]+))|((([^:\
				 ]+:)*[^:]+)?::(([^:]+:)*[^:]+)?))(\\/.+)$)",
			)
			.unwrap()
			.find(value)
			.is_none()
			{
				return Err("doesn't match pattern \
				            \"(?=.*^((:|(0?|([1-9a-f][0-9a-f]{0,3}))):)((0?|([1-9a-f][0-9a-f]{0,\
				            3})):){0,6}(:|(0?|([1-9a-f][0-9a-f]{0,3})))(\\/\
				            (([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))$)(?=.*^((([^:]+:\
				            ){7}([^:]+))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?))(\\/.+)$)\""
					.into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Ipv6Prefix {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Ipv6Prefix {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Ipv6Prefix {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Ipv6Prefix {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// IwkEpsInd
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "boolean"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct IwkEpsInd(pub bool);
	impl ::std::ops::Deref for IwkEpsInd {
		type Target = bool;
		fn deref(&self) -> &bool {
			&self.0
		}
	}

	impl From<IwkEpsInd> for bool {
		fn from(value: IwkEpsInd) -> Self {
			value.0
		}
	}

	impl From<&IwkEpsInd> for IwkEpsInd {
		fn from(value: &IwkEpsInd) -> Self {
			value.clone()
		}
	}

	impl From<bool> for IwkEpsInd {
		fn from(value: bool) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for IwkEpsInd {
		type Err = <bool as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for IwkEpsInd {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for IwkEpsInd {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for IwkEpsInd {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for IwkEpsInd {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// The enumeration JobType defines Job Type in the trace. See 3GPP TS
	/// 32.422 for further  description of the values. It shall comply with the
	/// provisions defined in table 5.6.3.3-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration JobType defines Job Type in the trace.
	/// See 3GPP TS 32.422 for further  description of the values. It shall
	/// comply with the provisions defined in table 5.6.3.3-1.\n",
	///  "type": "string",
	///  "enum": [
	///    "IMMEDIATE_MDT_ONLY",
	///    "LOGGED_MDT_ONLY",
	///    "TRACE_ONLY",
	///    "IMMEDIATE_MDT_AND_TRACE",
	///    "RLF_REPORTS_ONLY",
	///    "RCEF_REPORTS_ONLY",
	///    "LOGGED_MBSFN_MDT"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum JobType {
		#[default]
		#[serde(rename = "IMMEDIATE_MDT_ONLY")]
		ImmediateMdtOnly,
		#[serde(rename = "LOGGED_MDT_ONLY")]
		LoggedMdtOnly,
		#[serde(rename = "TRACE_ONLY")]
		TraceOnly,
		#[serde(rename = "IMMEDIATE_MDT_AND_TRACE")]
		ImmediateMdtAndTrace,
		#[serde(rename = "RLF_REPORTS_ONLY")]
		RlfReportsOnly,
		#[serde(rename = "RCEF_REPORTS_ONLY")]
		RcefReportsOnly,
		#[serde(rename = "LOGGED_MBSFN_MDT")]
		LoggedMbsfnMdt,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&JobType> for JobType {
		fn from(value: &JobType) -> Self {
			value.clone()
		}
	}

	impl ToString for JobType {
		fn to_string(&self) -> String {
			match *self {
				Self::ImmediateMdtOnly => "IMMEDIATE_MDT_ONLY".to_string(),
				Self::LoggedMdtOnly => "LOGGED_MDT_ONLY".to_string(),
				Self::TraceOnly => "TRACE_ONLY".to_string(),
				Self::ImmediateMdtAndTrace => "IMMEDIATE_MDT_AND_TRACE".to_string(),
				Self::RlfReportsOnly => "RLF_REPORTS_ONLY".to_string(),
				Self::RcefReportsOnly => "RCEF_REPORTS_ONLY".to_string(),
				Self::LoggedMbsfnMdt => "LOGGED_MBSFN_MDT".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for JobType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"IMMEDIATE_MDT_ONLY" => Ok(Self::ImmediateMdtOnly),
				"LOGGED_MDT_ONLY" => Ok(Self::LoggedMdtOnly),
				"TRACE_ONLY" => Ok(Self::TraceOnly),
				"IMMEDIATE_MDT_AND_TRACE" => Ok(Self::ImmediateMdtAndTrace),
				"RLF_REPORTS_ONLY" => Ok(Self::RlfReportsOnly),
				"RCEF_REPORTS_ONLY" => Ok(Self::RcefReportsOnly),
				"LOGGED_MBSFN_MDT" => Ok(Self::LoggedMbsfnMdt),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for JobType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for JobType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for JobType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Kasme
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{64}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Kasme(String);
	impl ::std::ops::Deref for Kasme {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Kasme> for String {
		fn from(value: Kasme) -> Self {
			value.0
		}
	}

	impl From<&Kasme> for Kasme {
		fn from(value: &Kasme) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Kasme {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{64}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{64}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Kasme {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Kasme {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Kasme {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Kasme {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Kausf
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{64}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Kausf(String);
	impl ::std::ops::Deref for Kausf {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Kausf> for String {
		fn from(value: Kausf) -> Self {
			value.0
		}
	}

	impl From<&Kausf> for Kausf {
		fn from(value: &Kausf) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Kausf {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{64}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{64}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Kausf {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Kausf {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Kausf {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Kausf {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// LboRoamingAllowed
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "boolean"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LboRoamingAllowed(pub bool);
	impl ::std::ops::Deref for LboRoamingAllowed {
		type Target = bool;
		fn deref(&self) -> &bool {
			&self.0
		}
	}

	impl From<LboRoamingAllowed> for bool {
		fn from(value: LboRoamingAllowed) -> Self {
			value.0
		}
	}

	impl From<&LboRoamingAllowed> for LboRoamingAllowed {
		fn from(value: &LboRoamingAllowed) -> Self {
			value.clone()
		}
	}

	impl From<bool> for LboRoamingAllowed {
		fn from(value: bool) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for LboRoamingAllowed {
		type Err = <bool as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for LboRoamingAllowed {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for LboRoamingAllowed {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for LboRoamingAllowed {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for LboRoamingAllowed {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// LcsBroadcastAssistanceTypesData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "locationAssistanceType"
	///  ],
	///  "properties": {
	///    "locationAssistanceType": {
	///      "$ref": "#/components/schemas/Binary"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LcsBroadcastAssistanceTypesData {
		#[serde(rename = "locationAssistanceType")]
		pub location_assistance_type: Binary,
	}

	impl From<&LcsBroadcastAssistanceTypesData> for LcsBroadcastAssistanceTypesData {
		fn from(value: &LcsBroadcastAssistanceTypesData) -> Self {
			value.clone()
		}
	}

	/// LcsClientClass
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "BROADCAST_SERVICE",
	///    "OM_IN_HPLMN",
	///    "OM_IN_VPLMN",
	///    "ANONYMOUS_LOCATION_SERVICE",
	///    "SPECIFIC_SERVICE"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum LcsClientClass {
		#[default]
		#[serde(rename = "BROADCAST_SERVICE")]
		BroadcastService,
		#[serde(rename = "OM_IN_HPLMN")]
		OmInHplmn,
		#[serde(rename = "OM_IN_VPLMN")]
		OmInVplmn,
		#[serde(rename = "ANONYMOUS_LOCATION_SERVICE")]
		AnonymousLocationService,
		#[serde(rename = "SPECIFIC_SERVICE")]
		SpecificService,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&LcsClientClass> for LcsClientClass {
		fn from(value: &LcsClientClass) -> Self {
			value.clone()
		}
	}

	impl ToString for LcsClientClass {
		fn to_string(&self) -> String {
			match *self {
				Self::BroadcastService => "BROADCAST_SERVICE".to_string(),
				Self::OmInHplmn => "OM_IN_HPLMN".to_string(),
				Self::OmInVplmn => "OM_IN_VPLMN".to_string(),
				Self::AnonymousLocationService => "ANONYMOUS_LOCATION_SERVICE".to_string(),
				Self::SpecificService => "SPECIFIC_SERVICE".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for LcsClientClass {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"BROADCAST_SERVICE" => Ok(Self::BroadcastService),
				"OM_IN_HPLMN" => Ok(Self::OmInHplmn),
				"OM_IN_VPLMN" => Ok(Self::OmInVplmn),
				"ANONYMOUS_LOCATION_SERVICE" => Ok(Self::AnonymousLocationService),
				"SPECIFIC_SERVICE" => Ok(Self::SpecificService),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for LcsClientClass {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for LcsClientClass {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for LcsClientClass {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// LcsClientExternal
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "allowedGeographicArea": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/GeographicArea"
	///      },
	///      "minItems": 1
	///    },
	///    "privacyCheckRelatedAction": {
	///      "$ref": "#/components/schemas/PrivacyCheckRelatedAction"
	///    },
	///    "validTimePeriod": {
	///      "$ref": "#/components/schemas/ValidTimePeriod"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LcsClientExternal {
		#[serde(
			rename = "allowedGeographicArea",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub allowed_geographic_area: Vec<GeographicArea>,
		#[serde(
			rename = "privacyCheckRelatedAction",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub privacy_check_related_action: Option<PrivacyCheckRelatedAction>,
		#[serde(
			rename = "validTimePeriod",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub valid_time_period: Option<ValidTimePeriod>,
	}

	impl From<&LcsClientExternal> for LcsClientExternal {
		fn from(value: &LcsClientExternal) -> Self {
			value.clone()
		}
	}

	/// LcsClientGroupExternal
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "allowedGeographicArea": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/GeographicArea"
	///      },
	///      "minItems": 1
	///    },
	///    "lcsClientGroupId": {
	///      "$ref": "#/components/schemas/ExtGroupId"
	///    },
	///    "privacyCheckRelatedAction": {
	///      "$ref": "#/components/schemas/PrivacyCheckRelatedAction"
	///    },
	///    "validTimePeriod": {
	///      "$ref": "#/components/schemas/ValidTimePeriod"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LcsClientGroupExternal {
		#[serde(
			rename = "allowedGeographicArea",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub allowed_geographic_area: Vec<GeographicArea>,
		#[serde(
			rename = "lcsClientGroupId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub lcs_client_group_id: Option<ExtGroupId>,
		#[serde(
			rename = "privacyCheckRelatedAction",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub privacy_check_related_action: Option<PrivacyCheckRelatedAction>,
		#[serde(
			rename = "validTimePeriod",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub valid_time_period: Option<ValidTimePeriod>,
	}

	impl From<&LcsClientGroupExternal> for LcsClientGroupExternal {
		fn from(value: &LcsClientGroupExternal) -> Self {
			value.clone()
		}
	}

	/// LcsClientId
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct LcsClientId(pub String);
	impl ::std::ops::Deref for LcsClientId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<LcsClientId> for String {
		fn from(value: LcsClientId) -> Self {
			value.0
		}
	}

	impl From<&LcsClientId> for LcsClientId {
		fn from(value: &LcsClientId) -> Self {
			value.clone()
		}
	}

	impl From<String> for LcsClientId {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for LcsClientId {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for LcsClientId {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// LcsMoData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "allowedServiceClasses"
	///  ],
	///  "properties": {
	///    "allowedServiceClasses": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/LcsMoServiceClass"
	///      },
	///      "minItems": 1
	///    },
	///    "moAssistanceDataTypes": {
	///      "$ref": "#/components/schemas/LcsBroadcastAssistanceTypesData"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LcsMoData {
		#[serde(rename = "allowedServiceClasses")]
		pub allowed_service_classes: Vec<LcsMoServiceClass>,
		#[serde(
			rename = "moAssistanceDataTypes",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mo_assistance_data_types: Option<LcsBroadcastAssistanceTypesData>,
	}

	impl From<&LcsMoData> for LcsMoData {
		fn from(value: &LcsMoData) -> Self {
			value.clone()
		}
	}

	/// LcsMoServiceClass
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "BASIC_SELF_LOCATION",
	///    "AUTONOMOUS_SELF_LOCATION",
	///    "TRANSFER_TO_THIRD_PARTY"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum LcsMoServiceClass {
		#[default]
		#[serde(rename = "BASIC_SELF_LOCATION")]
		BasicSelfLocation,
		#[serde(rename = "AUTONOMOUS_SELF_LOCATION")]
		AutonomousSelfLocation,
		#[serde(rename = "TRANSFER_TO_THIRD_PARTY")]
		TransferToThirdParty,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&LcsMoServiceClass> for LcsMoServiceClass {
		fn from(value: &LcsMoServiceClass) -> Self {
			value.clone()
		}
	}

	impl ToString for LcsMoServiceClass {
		fn to_string(&self) -> String {
			match *self {
				Self::BasicSelfLocation => "BASIC_SELF_LOCATION".to_string(),
				Self::AutonomousSelfLocation => "AUTONOMOUS_SELF_LOCATION".to_string(),
				Self::TransferToThirdParty => "TRANSFER_TO_THIRD_PARTY".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for LcsMoServiceClass {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"BASIC_SELF_LOCATION" => Ok(Self::BasicSelfLocation),
				"AUTONOMOUS_SELF_LOCATION" => Ok(Self::AutonomousSelfLocation),
				"TRANSFER_TO_THIRD_PARTY" => Ok(Self::TransferToThirdParty),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for LcsMoServiceClass {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for LcsMoServiceClass {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for LcsMoServiceClass {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// LcsPrivacy
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "properties": {
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "lpi": {
	///      "$ref": "#/components/schemas/schemas-Lpi"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LcsPrivacy(pub Option<LcsPrivacyInner>);
	impl ::std::ops::Deref for LcsPrivacy {
		type Target = Option<LcsPrivacyInner>;
		fn deref(&self) -> &Option<LcsPrivacyInner> {
			&self.0
		}
	}

	impl From<LcsPrivacy> for Option<LcsPrivacyInner> {
		fn from(value: LcsPrivacy) -> Self {
			value.0
		}
	}

	impl From<&LcsPrivacy> for LcsPrivacy {
		fn from(value: &LcsPrivacy) -> Self {
			value.clone()
		}
	}

	impl From<Option<LcsPrivacyInner>> for LcsPrivacy {
		fn from(value: Option<LcsPrivacyInner>) -> Self {
			Self(value)
		}
	}

	/// LcsPrivacyData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "lpi": {
	///      "$ref": "#/components/schemas/Lpi"
	///    },
	///    "plmnOperatorClasses": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/PlmnOperatorClass"
	///      },
	///      "minItems": 1
	///    },
	///    "unrelatedClass": {
	///      "$ref": "#/components/schemas/UnrelatedClass"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LcsPrivacyData {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub lpi: Option<Lpi>,
		#[serde(
			rename = "plmnOperatorClasses",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub plmn_operator_classes: Vec<PlmnOperatorClass>,
		#[serde(
			rename = "unrelatedClass",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub unrelated_class: Option<UnrelatedClass>,
	}

	impl From<&LcsPrivacyData> for LcsPrivacyData {
		fn from(value: &LcsPrivacyData) -> Self {
			value.clone()
		}
	}

	/// LcsPrivacyInner
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "lpi": {
	///      "$ref": "#/components/schemas/schemas-Lpi"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LcsPrivacyInner {
		#[serde(
			rename = "afInstanceId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub af_instance_id: Option<String>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub lpi: Option<SchemasLpi>,
		#[serde(
			rename = "mtcProviderInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mtc_provider_information: Option<MtcProviderInformation>,
		#[serde(
			rename = "referenceId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub reference_id: Option<ReferenceId>,
	}

	impl From<&LcsPrivacyInner> for LcsPrivacyInner {
		fn from(value: &LcsPrivacyInner) -> Self {
			value.clone()
		}
	}

	/// LCS service type.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "LCS service type.",
	///  "type": "integer",
	///  "maximum": 127.0,
	///  "minimum": 0.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LcsServiceType(pub i64);
	impl ::std::ops::Deref for LcsServiceType {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<LcsServiceType> for i64 {
		fn from(value: LcsServiceType) -> Self {
			value.0
		}
	}

	impl From<&LcsServiceType> for LcsServiceType {
		fn from(value: &LcsServiceType) -> Self {
			value.clone()
		}
	}

	impl From<i64> for LcsServiceType {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for LcsServiceType {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for LcsServiceType {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for LcsServiceType {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for LcsServiceType {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for LcsServiceType {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Possible values are:
	/// - DSL: Identifies a DSL line
	/// - PON: Identifies a PON line
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Possible values are:\n- DSL: Identifies a DSL line\n-
	/// PON: Identifies a PON line\n",
	///  "type": "string",
	///  "enum": [
	///    "DSL",
	///    "PON"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum LineType {
		#[default]
		#[serde(rename = "DSL")]
		Dsl,
		#[serde(rename = "PON")]
		Pon,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&LineType> for LineType {
		fn from(value: &LineType) -> Self {
			value.clone()
		}
	}

	impl ToString for LineType {
		fn to_string(&self) -> String {
			match *self {
				Self::Dsl => "DSL".to_string(),
				Self::Pon => "PON".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for LineType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"DSL" => Ok(Self::Dsl),
				"PON" => Ok(Self::Pon),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for LineType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for LineType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for LineType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Local 2D point with uncertainty ellipse
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Local 2D point with uncertainty ellipse",
	///  "allOf": [
	///    {
	///      "$ref": "#/components/schemas/GADShape"
	///    },
	///    {
	///      "type": "object",
	///      "required": [
	///        "confidence",
	///        "localOrigin",
	///        "point",
	///        "uncertaintyEllipse"
	///      ],
	///      "properties": {
	///        "confidence": {
	///          "$ref": "#/components/schemas/Confidence"
	///        },
	///        "localOrigin": {
	///          "$ref": "#/components/schemas/LocalOrigin"
	///        },
	///        "point": {
	///          "$ref": "#/components/schemas/RelativeCartesianLocation"
	///        },
	///        "uncertaintyEllipse": {
	///          "$ref": "#/components/schemas/UncertaintyEllipse"
	///        }
	///      }
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Local2dPointUncertaintyEllipse {
		pub confidence: Confidence,
		#[serde(rename = "localOrigin")]
		pub local_origin: LocalOrigin,
		pub point: RelativeCartesianLocation,
		pub shape: SupportedGadShapes,
		#[serde(rename = "uncertaintyEllipse")]
		pub uncertainty_ellipse: UncertaintyEllipse,
	}

	impl From<&Local2dPointUncertaintyEllipse> for Local2dPointUncertaintyEllipse {
		fn from(value: &Local2dPointUncertaintyEllipse) -> Self {
			value.clone()
		}
	}

	/// Local 3D point with uncertainty ellipsoid
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Local 3D point with uncertainty ellipsoid",
	///  "allOf": [
	///    {
	///      "$ref": "#/components/schemas/GADShape"
	///    },
	///    {
	///      "type": "object",
	///      "required": [
	///        "confidence",
	///        "localOrigin",
	///        "point",
	///        "uncertaintyEllipsoid"
	///      ],
	///      "properties": {
	///        "confidence": {
	///          "$ref": "#/components/schemas/Confidence"
	///        },
	///        "localOrigin": {
	///          "$ref": "#/components/schemas/LocalOrigin"
	///        },
	///        "point": {
	///          "$ref": "#/components/schemas/RelativeCartesianLocation"
	///        },
	///        "uncertaintyEllipsoid": {
	///          "$ref": "#/components/schemas/UncertaintyEllipsoid"
	///        }
	///      }
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Local3dPointUncertaintyEllipsoid {
		pub confidence: Confidence,
		#[serde(rename = "localOrigin")]
		pub local_origin: LocalOrigin,
		pub point: RelativeCartesianLocation,
		pub shape: SupportedGadShapes,
		#[serde(rename = "uncertaintyEllipsoid")]
		pub uncertainty_ellipsoid: UncertaintyEllipsoid,
	}

	impl From<&Local3dPointUncertaintyEllipsoid> for Local3dPointUncertaintyEllipsoid {
		fn from(value: &Local3dPointUncertaintyEllipsoid) -> Self {
			value.clone()
		}
	}

	/// Indicates a Local origin in a reference system
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates a Local origin in a reference system",
	///  "type": "object",
	///  "properties": {
	///    "coordinateId": {
	///      "type": "string"
	///    },
	///    "point": {
	///      "$ref": "#/components/schemas/GeographicalCoordinates"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LocalOrigin {
		#[serde(
			rename = "coordinateId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub coordinate_id: Option<String>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub point: Option<GeographicalCoordinates>,
	}

	impl From<&LocalOrigin> for LocalOrigin {
		fn from(value: &LocalOrigin) -> Self {
			value.clone()
		}
	}

	/// LocationAccuracy
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "CELL_LEVEL",
	///    "RAN_NODE_LEVEL",
	///    "TA_LEVEL",
	///    "N3IWF_LEVEL",
	///    "UE_IP",
	///    "UE_PORT"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum LocationAccuracy {
		#[default]
		#[serde(rename = "CELL_LEVEL")]
		CellLevel,
		#[serde(rename = "RAN_NODE_LEVEL")]
		RanNodeLevel,
		#[serde(rename = "TA_LEVEL")]
		TaLevel,
		#[serde(rename = "N3IWF_LEVEL")]
		N3iwfLevel,
		#[serde(rename = "UE_IP")]
		UeIp,
		#[serde(rename = "UE_PORT")]
		UePort,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&LocationAccuracy> for LocationAccuracy {
		fn from(value: &LocationAccuracy) -> Self {
			value.clone()
		}
	}

	impl ToString for LocationAccuracy {
		fn to_string(&self) -> String {
			match *self {
				Self::CellLevel => "CELL_LEVEL".to_string(),
				Self::RanNodeLevel => "RAN_NODE_LEVEL".to_string(),
				Self::TaLevel => "TA_LEVEL".to_string(),
				Self::N3iwfLevel => "N3IWF_LEVEL".to_string(),
				Self::UeIp => "UE_IP".to_string(),
				Self::UePort => "UE_PORT".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for LocationAccuracy {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"CELL_LEVEL" => Ok(Self::CellLevel),
				"RAN_NODE_LEVEL" => Ok(Self::RanNodeLevel),
				"TA_LEVEL" => Ok(Self::TaLevel),
				"N3IWF_LEVEL" => Ok(Self::N3iwfLevel),
				"UE_IP" => Ok(Self::UeIp),
				"UE_PORT" => Ok(Self::UePort),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for LocationAccuracy {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for LocationAccuracy {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for LocationAccuracy {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// LocationArea
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "civicAddresses": {
	///      "description": "Identifies a list of civic addresses of the user
	/// where the UE is located.",
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/CivicAddress"
	///      },
	///      "minItems": 0
	///    },
	///    "geographicAreas": {
	///      "description": "Identifies a list of geographic area of the user
	/// where the UE is located.",
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/GeographicArea"
	///      },
	///      "minItems": 0
	///    },
	///    "nwAreaInfo": {
	///      "$ref": "#/components/schemas/NetworkAreaInfo"
	///    },
	///    "umtTime": {
	///      "$ref": "#/components/schemas/UmtTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LocationArea {
		/// Identifies a list of civic addresses of the user where the UE is
		/// located.
		#[serde(
			rename = "civicAddresses",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub civic_addresses: Vec<CivicAddress>,
		/// Identifies a list of geographic area of the user where the UE is
		/// located.
		#[serde(
			rename = "geographicAreas",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub geographic_areas: Vec<GeographicArea>,
		#[serde(
			rename = "nwAreaInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub nw_area_info: Option<NetworkAreaInfo>,
		#[serde(rename = "umtTime", default, skip_serializing_if = "Option::is_none")]
		pub umt_time: Option<UmtTime>,
	}

	impl From<&LocationArea> for LocationArea {
		fn from(value: &LocationArea) -> Self {
			value.clone()
		}
	}

	/// Contains a Location area identification as defined in 3GPP TS 23.003,
	/// clause 4.1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains a Location area identification as defined in
	/// 3GPP TS 23.003, clause 4.1.",
	///  "type": "object",
	///  "required": [
	///    "lac",
	///    "plmnId"
	///  ],
	///  "properties": {
	///    "lac": {
	///      "description": "Location Area Code.",
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]{4}$"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LocationAreaId {
		/// Location Area Code.
		pub lac: LocationAreaIdLac,
		#[serde(rename = "plmnId")]
		pub plmn_id: PlmnId,
	}

	impl From<&LocationAreaId> for LocationAreaId {
		fn from(value: &LocationAreaId) -> Self {
			value.clone()
		}
	}

	/// Location Area Code.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Location Area Code.",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{4}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct LocationAreaIdLac(String);
	impl ::std::ops::Deref for LocationAreaIdLac {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<LocationAreaIdLac> for String {
		fn from(value: LocationAreaIdLac) -> Self {
			value.0
		}
	}

	impl From<&LocationAreaIdLac> for LocationAreaIdLac {
		fn from(value: &LocationAreaIdLac) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for LocationAreaIdLac {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{4}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{4}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for LocationAreaIdLac {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for LocationAreaIdLac {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for LocationAreaIdLac {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for LocationAreaIdLac {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// LocationInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "registrationLocationInfoList"
	///  ],
	///  "properties": {
	///    "gpsi": {
	///      "$ref": "#/components/schemas/Gpsi"
	///    },
	///    "registrationLocationInfoList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/RegistrationLocationInfo"
	///      },
	///      "maxItems": 2,
	///      "minItems": 1
	///    },
	///    "supi": {
	///      "$ref": "#/components/schemas/Supi"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LocationInfo {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub gpsi: Option<Gpsi>,
		#[serde(rename = "registrationLocationInfoList")]
		pub registration_location_info_list: Vec<RegistrationLocationInfo>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub supi: Option<Supi>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&LocationInfo> for LocationInfo {
		fn from(value: &LocationInfo) -> Self {
			value.clone()
		}
	}

	/// Represents information to be sent in a location information request. It
	/// contains the requested information, i.e. current location, local time
	/// zone, RAT type, or serving node identity only.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents information to be sent in a location information request. It contains the requested information, i.e. current location, local time zone, RAT type, or serving node identity only.",
	///  "type": "object",
	///  "properties": {
	///    "req5gsLoc": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "reqCurrentLoc": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "reqRatType": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "reqServingNode": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "reqTimeZone": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LocationInfoRequest {
		#[serde(rename = "req5gsLoc", default)]
		pub req5gs_loc: bool,
		#[serde(rename = "reqCurrentLoc", default)]
		pub req_current_loc: bool,
		#[serde(rename = "reqRatType", default)]
		pub req_rat_type: bool,
		#[serde(rename = "reqServingNode", default)]
		pub req_serving_node: bool,
		#[serde(rename = "reqTimeZone", default)]
		pub req_time_zone: bool,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&LocationInfoRequest> for LocationInfoRequest {
		fn from(value: &LocationInfoRequest) -> Self {
			value.clone()
		}
	}

	/// Represents the requested location information.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents the requested location information.",
	///  "type": "object",
	///  "properties": {
	///    "amfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "currentLoc": {
	///      "type": "boolean"
	///    },
	///    "ecgi": {
	///      "$ref": "#/components/schemas/Ecgi"
	///    },
	///    "geoInfo": {
	///      "$ref": "#/components/schemas/GeographicArea"
	///    },
	///    "locationAge": {
	///      "$ref": "#/components/schemas/AgeOfLocationEstimate"
	///    },
	///    "ncgi": {
	///      "$ref": "#/components/schemas/Ncgi"
	///    },
	///    "ratType": {
	///      "$ref": "#/components/schemas/RatType"
	///    },
	///    "smsfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "tai": {
	///      "$ref": "#/components/schemas/Tai"
	///    },
	///    "timezone": {
	///      "$ref": "#/components/schemas/TimeZone"
	///    },
	///    "vPlmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LocationInfoResult {
		#[serde(
			rename = "amfInstanceId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub amf_instance_id: Option<NfInstanceId>,
		#[serde(
			rename = "currentLoc",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub current_loc: Option<bool>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub ecgi: Option<Ecgi>,
		#[serde(rename = "geoInfo", default, skip_serializing_if = "Option::is_none")]
		pub geo_info: Option<GeographicArea>,
		#[serde(
			rename = "locationAge",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub location_age: Option<AgeOfLocationEstimate>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub ncgi: Option<Ncgi>,
		#[serde(rename = "ratType", default, skip_serializing_if = "Option::is_none")]
		pub rat_type: Option<RatType>,
		#[serde(
			rename = "smsfInstanceId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub smsf_instance_id: Option<NfInstanceId>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub tai: Option<Tai>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub timezone: Option<TimeZone>,
		#[serde(rename = "vPlmnId", default, skip_serializing_if = "Option::is_none")]
		pub v_plmn_id: Option<PlmnId>,
	}

	impl From<&LocationInfoResult> for LocationInfoResult {
		fn from(value: &LocationInfoResult) -> Self {
			value.clone()
		}
	}

	/// LocationPrivacyInd
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "LOCATION_DISALLOWED",
	///    "LOCATION_ALLOWED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum LocationPrivacyInd {
		#[default]
		#[serde(rename = "LOCATION_DISALLOWED")]
		LocationDisallowed,
		#[serde(rename = "LOCATION_ALLOWED")]
		LocationAllowed,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&LocationPrivacyInd> for LocationPrivacyInd {
		fn from(value: &LocationPrivacyInd) -> Self {
			value.clone()
		}
	}

	impl ToString for LocationPrivacyInd {
		fn to_string(&self) -> String {
			match *self {
				Self::LocationDisallowed => "LOCATION_DISALLOWED".to_string(),
				Self::LocationAllowed => "LOCATION_ALLOWED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for LocationPrivacyInd {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"LOCATION_DISALLOWED" => Ok(Self::LocationDisallowed),
				"LOCATION_ALLOWED" => Ok(Self::LocationAllowed),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for LocationPrivacyInd {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for LocationPrivacyInd {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for LocationPrivacyInd {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// LocationReport
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "location"
	///  ],
	///  "properties": {
	///    "location": {
	///      "$ref": "#/components/schemas/UserLocation"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LocationReport {
		pub location: UserLocation,
	}

	impl From<&LocationReport> for LocationReport {
		fn from(value: &LocationReport) -> Self {
			value.clone()
		}
	}

	/// LocationReportingConfiguration
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "currentLocation"
	///  ],
	///  "properties": {
	///    "accuracy": {
	///      "$ref": "#/components/schemas/LocationAccuracy"
	///    },
	///    "currentLocation": {
	///      "type": "boolean"
	///    },
	///    "n3gppAccuracy": {
	///      "$ref": "#/components/schemas/LocationAccuracy"
	///    },
	///    "oneTime": {
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LocationReportingConfiguration {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub accuracy: Option<LocationAccuracy>,
		#[serde(rename = "currentLocation")]
		pub current_location: bool,
		#[serde(
			rename = "n3gppAccuracy",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub n3gpp_accuracy: Option<LocationAccuracy>,
		#[serde(rename = "oneTime", default, skip_serializing_if = "Option::is_none")]
		pub one_time: Option<bool>,
	}

	impl From<&LocationReportingConfiguration> for LocationReportingConfiguration {
		fn from(value: &LocationReportingConfiguration) -> Self {
			value.clone()
		}
	}

	/// The enumeration LoggingIntervalMdt defines Logging Interval for MDT in
	/// the trace. See 3GPP TS 32.422 for further description of the values. It
	/// shall comply with the provisions defined in table 5.6.3.12-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration LoggingIntervalMdt defines Logging
	/// Interval for MDT in the trace. See 3GPP TS 32.422 for further
	/// description of the values. It shall comply with the provisions defined
	/// in table 5.6.3.12-1.\n",
	///  "type": "string",
	///  "enum": [
	///    600,
	///    1200,
	///    2400,
	///    3600,
	///    5400,
	///    7200
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum LoggingDurationMdt {
		#[default]
		#[serde(rename = "600")]
		NUM600,
		#[serde(rename = "1200")]
		NUM1200,
		#[serde(rename = "2400")]
		NUM2400,
		#[serde(rename = "3600")]
		NUM3600,
		#[serde(rename = "5400")]
		NUM5400,
		#[serde(rename = "7200")]
		NUM7200,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&LoggingDurationMdt> for LoggingDurationMdt {
		fn from(value: &LoggingDurationMdt) -> Self {
			value.clone()
		}
	}

	impl ToString for LoggingDurationMdt {
		fn to_string(&self) -> String {
			match *self {
				Self::NUM600 => "600".to_string(),
				Self::NUM1200 => "1200".to_string(),
				Self::NUM2400 => "2400".to_string(),
				Self::NUM3600 => "3600".to_string(),
				Self::NUM5400 => "5400".to_string(),
				Self::NUM7200 => "7200".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for LoggingDurationMdt {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"600" => Ok(Self::NUM600),
				"1200" => Ok(Self::NUM1200),
				"2400" => Ok(Self::NUM2400),
				"3600" => Ok(Self::NUM3600),
				"5400" => Ok(Self::NUM5400),
				"7200" => Ok(Self::NUM7200),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for LoggingDurationMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for LoggingDurationMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for LoggingDurationMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// The enumeration LoggingDurationMdt defines Logging Duration in NR for
	/// MDT in the trace. See 3GPP TS 32.422 for further description of the
	/// values. It shall comply with the provisions defined in table 5.6.3.20-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration LoggingDurationMdt defines Logging
	/// Duration in NR for MDT in the trace. See 3GPP TS 32.422 for further
	/// description of the values. It shall comply with the provisions defined
	/// in table 5.6.3.20-1.\n",
	///  "type": "string",
	///  "enum": [
	///    600,
	///    1200,
	///    2400,
	///    3600,
	///    5400,
	///    7200
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum LoggingDurationNrMdt {
		#[default]
		#[serde(rename = "600")]
		NUM600,
		#[serde(rename = "1200")]
		NUM1200,
		#[serde(rename = "2400")]
		NUM2400,
		#[serde(rename = "3600")]
		NUM3600,
		#[serde(rename = "5400")]
		NUM5400,
		#[serde(rename = "7200")]
		NUM7200,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&LoggingDurationNrMdt> for LoggingDurationNrMdt {
		fn from(value: &LoggingDurationNrMdt) -> Self {
			value.clone()
		}
	}

	impl ToString for LoggingDurationNrMdt {
		fn to_string(&self) -> String {
			match *self {
				Self::NUM600 => "600".to_string(),
				Self::NUM1200 => "1200".to_string(),
				Self::NUM2400 => "2400".to_string(),
				Self::NUM3600 => "3600".to_string(),
				Self::NUM5400 => "5400".to_string(),
				Self::NUM7200 => "7200".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for LoggingDurationNrMdt {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"600" => Ok(Self::NUM600),
				"1200" => Ok(Self::NUM1200),
				"2400" => Ok(Self::NUM2400),
				"3600" => Ok(Self::NUM3600),
				"5400" => Ok(Self::NUM5400),
				"7200" => Ok(Self::NUM7200),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for LoggingDurationNrMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for LoggingDurationNrMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for LoggingDurationNrMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// The enumeration LoggingIntervalMdt defines Logging Interval for MDT in
	/// the trace. See 3GPP TS 32.422 for further description of the values. It
	/// shall comply with the provisions defined in table 5.6.3.12-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration LoggingIntervalMdt defines Logging
	/// Interval for MDT in the trace. See 3GPP TS 32.422 for further
	/// description of the values. It shall comply with the provisions defined
	/// in table 5.6.3.12-1.\n",
	///  "type": "string",
	///  "enum": [
	///    128,
	///    256,
	///    512,
	///    1024,
	///    2048,
	///    3072,
	///    4096,
	///    6144
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum LoggingIntervalMdt {
		#[default]
		#[serde(rename = "128")]
		NUM128,
		#[serde(rename = "256")]
		NUM256,
		#[serde(rename = "512")]
		NUM512,
		#[serde(rename = "1024")]
		NUM1024,
		#[serde(rename = "2048")]
		NUM2048,
		#[serde(rename = "3072")]
		NUM3072,
		#[serde(rename = "4096")]
		NUM4096,
		#[serde(rename = "6144")]
		NUM6144,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&LoggingIntervalMdt> for LoggingIntervalMdt {
		fn from(value: &LoggingIntervalMdt) -> Self {
			value.clone()
		}
	}

	impl ToString for LoggingIntervalMdt {
		fn to_string(&self) -> String {
			match *self {
				Self::NUM128 => "128".to_string(),
				Self::NUM256 => "256".to_string(),
				Self::NUM512 => "512".to_string(),
				Self::NUM1024 => "1024".to_string(),
				Self::NUM2048 => "2048".to_string(),
				Self::NUM3072 => "3072".to_string(),
				Self::NUM4096 => "4096".to_string(),
				Self::NUM6144 => "6144".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for LoggingIntervalMdt {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"128" => Ok(Self::NUM128),
				"256" => Ok(Self::NUM256),
				"512" => Ok(Self::NUM512),
				"1024" => Ok(Self::NUM1024),
				"2048" => Ok(Self::NUM2048),
				"3072" => Ok(Self::NUM3072),
				"4096" => Ok(Self::NUM4096),
				"6144" => Ok(Self::NUM6144),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for LoggingIntervalMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for LoggingIntervalMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for LoggingIntervalMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// The enumeration LoggingIntervalNrMdt defines Logging Interval in NR for
	/// MDT in the trace. See 3GPP TS 32.422 for further description of the
	/// values. It shall comply with the provisions defined in table 5.6.3.18-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration LoggingIntervalNrMdt defines Logging
	/// Interval in NR for MDT in the trace. See 3GPP TS 32.422 for further
	/// description of the values. It shall comply with the provisions defined
	/// in table 5.6.3.18-1.\n",
	///  "type": "string",
	///  "enum": [
	///    128,
	///    256,
	///    512,
	///    1024,
	///    2048,
	///    3072,
	///    4096,
	///    6144,
	///    320,
	///    640,
	///    "infinity"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum LoggingIntervalNrMdt {
		#[default]
		#[serde(rename = "128")]
		NUM128,
		#[serde(rename = "256")]
		NUM256,
		#[serde(rename = "512")]
		NUM512,
		#[serde(rename = "1024")]
		NUM1024,
		#[serde(rename = "2048")]
		NUM2048,
		#[serde(rename = "3072")]
		NUM3072,
		#[serde(rename = "4096")]
		NUM4096,
		#[serde(rename = "6144")]
		NUM6144,
		#[serde(rename = "320")]
		NUM320,
		#[serde(rename = "640")]
		NUM640,
		#[serde(rename = "infinity")]
		Infinity,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&LoggingIntervalNrMdt> for LoggingIntervalNrMdt {
		fn from(value: &LoggingIntervalNrMdt) -> Self {
			value.clone()
		}
	}

	impl ToString for LoggingIntervalNrMdt {
		fn to_string(&self) -> String {
			match *self {
				Self::NUM128 => "128".to_string(),
				Self::NUM256 => "256".to_string(),
				Self::NUM512 => "512".to_string(),
				Self::NUM1024 => "1024".to_string(),
				Self::NUM2048 => "2048".to_string(),
				Self::NUM3072 => "3072".to_string(),
				Self::NUM4096 => "4096".to_string(),
				Self::NUM6144 => "6144".to_string(),
				Self::NUM320 => "320".to_string(),
				Self::NUM640 => "640".to_string(),
				Self::Infinity => "infinity".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for LoggingIntervalNrMdt {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"128" => Ok(Self::NUM128),
				"256" => Ok(Self::NUM256),
				"512" => Ok(Self::NUM512),
				"1024" => Ok(Self::NUM1024),
				"2048" => Ok(Self::NUM2048),
				"3072" => Ok(Self::NUM3072),
				"4096" => Ok(Self::NUM4096),
				"6144" => Ok(Self::NUM6144),
				"320" => Ok(Self::NUM320),
				"640" => Ok(Self::NUM640),
				"infinity" => Ok(Self::Infinity),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for LoggingIntervalNrMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for LoggingIntervalNrMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for LoggingIntervalNrMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// LossConnectivityCfg
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "maxDetectionTime": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LossConnectivityCfg {
		#[serde(
			rename = "maxDetectionTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub max_detection_time: Option<DurationSec>,
	}

	impl From<&LossConnectivityCfg> for LossConnectivityCfg {
		fn from(value: &LossConnectivityCfg) -> Self {
			value.clone()
		}
	}

	/// LossConnectivityReport
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "lossOfConnectReason"
	///  ],
	///  "properties": {
	///    "lossOfConnectReason": {
	///      "$ref": "#/components/schemas/LossOfConnectivityReason"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LossConnectivityReport {
		#[serde(rename = "lossOfConnectReason")]
		pub loss_of_connect_reason: LossOfConnectivityReason,
	}

	impl From<&LossConnectivityReport> for LossConnectivityReport {
		fn from(value: &LossConnectivityReport) -> Self {
			value.clone()
		}
	}

	/// Describes the reason for loss of connectivity
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Describes the reason for loss of connectivity",
	///  "type": "string",
	///  "enum": [
	///    "DEREGISTERED",
	///    "MAX_DETECTION_TIME_EXPIRED",
	///    "PURGED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum LossOfConnectivityReason {
		#[default]
		#[serde(rename = "DEREGISTERED")]
		Deregistered,
		#[serde(rename = "MAX_DETECTION_TIME_EXPIRED")]
		MaxDetectionTimeExpired,
		#[serde(rename = "PURGED")]
		Purged,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&LossOfConnectivityReason> for LossOfConnectivityReason {
		fn from(value: &LossOfConnectivityReason) -> Self {
			value.clone()
		}
	}

	impl ToString for LossOfConnectivityReason {
		fn to_string(&self) -> String {
			match *self {
				Self::Deregistered => "DEREGISTERED".to_string(),
				Self::MaxDetectionTimeExpired => "MAX_DETECTION_TIME_EXPIRED".to_string(),
				Self::Purged => "PURGED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for LossOfConnectivityReason {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"DEREGISTERED" => Ok(Self::Deregistered),
				"MAX_DETECTION_TIME_EXPIRED" => Ok(Self::MaxDetectionTimeExpired),
				"PURGED" => Ok(Self::Purged),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for LossOfConnectivityReason {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for LossOfConnectivityReason {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for LossOfConnectivityReason {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Lpi
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "locationPrivacyInd"
	///  ],
	///  "properties": {
	///    "locationPrivacyInd": {
	///      "$ref": "#/components/schemas/LocationPrivacyInd"
	///    },
	///    "validTimePeriod": {
	///      "$ref": "#/components/schemas/ValidTimePeriod"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Lpi {
		#[serde(rename = "locationPrivacyInd")]
		pub location_privacy_ind: LocationPrivacyInd,
		#[serde(
			rename = "validTimePeriod",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub valid_time_period: Option<ValidTimePeriod>,
	}

	impl From<&Lpi> for Lpi {
		fn from(value: &Lpi) -> Self {
			value.clone()
		}
	}

	/// Contains LTE V2X services authorized information.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains LTE V2X services authorized information.",
	///  "type": "object",
	///  "properties": {
	///    "pedestrianUeAuth": {
	///      "$ref": "#/components/schemas/UeAuth"
	///    },
	///    "vehicleUeAuth": {
	///      "$ref": "#/components/schemas/UeAuth"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct LteV2xAuth {
		#[serde(
			rename = "pedestrianUeAuth",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pedestrian_ue_auth: Option<UeAuth>,
		#[serde(
			rename = "vehicleUeAuth",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub vehicle_ue_auth: Option<UeAuth>,
	}

	impl From<&LteV2xAuth> for LteV2xAuth {
		fn from(value: &LteV2xAuth) -> Self {
			value.clone()
		}
	}

	/// String identifying a MAC address formatted in the hexadecimal notation
	/// according to clause 1.1 and clause 2.1 of RFC 7042.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String identifying a MAC address formatted in the
	/// hexadecimal notation according to clause 1.1 and clause 2.1 of RFC
	/// 7042.\n",
	///  "type": "string",
	///  "pattern": "^([0-9a-fA-F]{2})((-[0-9a-fA-F]{2}){5})$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct MacAddr48(String);
	impl ::std::ops::Deref for MacAddr48 {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<MacAddr48> for String {
		fn from(value: MacAddr48) -> Self {
			value.0
		}
	}

	impl From<&MacAddr48> for MacAddr48 {
		fn from(value: &MacAddr48) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for MacAddr48 {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^([0-9a-fA-F]{2})((-[0-9a-fA-F]{2}){5})$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err(
					"doesn't match pattern \"^([0-9a-fA-F]{2})((-[0-9a-fA-F]{2}){5})$\"".into(),
				);
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for MacAddr48 {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for MacAddr48 {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for MacAddr48 {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for MacAddr48 {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// MaxNumOfReports
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "integer"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct MaxNumOfReports(pub i64);
	impl ::std::ops::Deref for MaxNumOfReports {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<MaxNumOfReports> for i64 {
		fn from(value: MaxNumOfReports) -> Self {
			value.0
		}
	}

	impl From<&MaxNumOfReports> for MaxNumOfReports {
		fn from(value: &MaxNumOfReports) -> Self {
			value.clone()
		}
	}

	impl From<i64> for MaxNumOfReports {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for MaxNumOfReports {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for MaxNumOfReports {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for MaxNumOfReports {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for MaxNumOfReports {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for MaxNumOfReports {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// MBS Session Identifier
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "MBS Session Identifier",
	///  "type": "object",
	///  "anyOf": [
	///    {
	///      "required": [
	///        "tmgi"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "ssm"
	///      ]
	///    }
	///  ],
	///  "properties": {
	///    "nid": {
	///      "$ref": "#/components/schemas/Nid"
	///    },
	///    "ssm": {
	///      "$ref": "#/components/schemas/Ssm"
	///    },
	///    "tmgi": {
	///      "$ref": "#/components/schemas/Tmgi"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum MbsSessionId {
		#[default]
		Variant0 {
			#[serde(default, skip_serializing_if = "Option::is_none")]
			nid: Option<Nid>,
			tmgi: Tmgi,
		},
		Variant1 {
			#[serde(default, skip_serializing_if = "Option::is_none")]
			nid: Option<Nid>,
			ssm: Ssm,
		},
	}

	impl From<&MbsSessionId> for MbsSessionId {
		fn from(value: &MbsSessionId) -> Self {
			value.clone()
		}
	}

	/// Contains the 5MBS Subscription Data.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the 5MBS Subscription Data.",
	///  "type": "object",
	///  "properties": {
	///    "mbsAllowed": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "mbsSessionIdList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/MbsSessionId"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct MbsSubscriptionData {
		#[serde(rename = "mbsAllowed", default)]
		pub mbs_allowed: bool,
		#[serde(
			rename = "mbsSessionIdList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub mbs_session_id_list: Vec<MbsSessionId>,
	}

	impl From<&MbsSubscriptionData> for MbsSubscriptionData {
		fn from(value: &MbsSubscriptionData) -> Self {
			value.clone()
		}
	}

	/// Contains an MBSFN area information.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains an MBSFN area information.",
	///  "type": "object",
	///  "properties": {
	///    "carrierFrequency": {
	///      "description": "When present, this IE shall contain the Carrier
	/// Frequency (EARFCN).",
	///      "type": "integer",
	///      "maximum": 262143.0,
	///      "minimum": 0.0
	///    },
	///    "mbsfnAreaId": {
	///      "description": "This IE shall contain the MBSFN Area ID.",
	///      "type": "integer",
	///      "maximum": 255.0,
	///      "minimum": 0.0
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct MbsfnArea {
		/// When present, this IE shall contain the Carrier Frequency (EARFCN).
		#[serde(
			rename = "carrierFrequency",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub carrier_frequency: Option<i64>,
		/// This IE shall contain the MBSFN Area ID.
		#[serde(
			rename = "mbsfnAreaId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mbsfn_area_id: Option<u8>,
	}

	impl From<&MbsfnArea> for MbsfnArea {
		fn from(value: &MbsfnArea) -> Self {
			value.clone()
		}
	}

	/// Mobile Country Code part of the PLMN, comprising 3 digits, as defined in
	/// clause 9.3.3.5 of 3GPP TS 38.413.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Mobile Country Code part of the PLMN, comprising 3
	/// digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413. \n",
	///  "type": "string",
	///  "pattern": "^\\d{3}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Mcc(String);
	impl ::std::ops::Deref for Mcc {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Mcc> for String {
		fn from(value: Mcc) -> Self {
			value.0
		}
	}

	impl From<&Mcc> for Mcc {
		fn from(value: &Mcc) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Mcc {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^\\d{3}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^\\d{3}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Mcc {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Mcc {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Mcc {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Mcc {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// McsPriorityIndicator
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "boolean"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct McsPriorityIndicator(pub bool);
	impl ::std::ops::Deref for McsPriorityIndicator {
		type Target = bool;
		fn deref(&self) -> &bool {
			&self.0
		}
	}

	impl From<McsPriorityIndicator> for bool {
		fn from(value: McsPriorityIndicator) -> Self {
			value.0
		}
	}

	impl From<&McsPriorityIndicator> for McsPriorityIndicator {
		fn from(value: &McsPriorityIndicator) -> Self {
			value.clone()
		}
	}

	impl From<bool> for McsPriorityIndicator {
		fn from(value: bool) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for McsPriorityIndicator {
		type Err = <bool as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for McsPriorityIndicator {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for McsPriorityIndicator {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for McsPriorityIndicator {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for McsPriorityIndicator {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// contains contain MDT configuration data.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "contains contain MDT configuration data.",
	///  "type": "object",
	///  "required": [
	///    "jobType"
	///  ],
	///  "properties": {
	///    "addPositioningMethodList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/PositioningMethodMdt"
	///      },
	///      "minItems": 1
	///    },
	///    "areaScope": {
	///      "$ref": "#/components/schemas/AreaScope"
	///    },
	///    "collectionPeriodRmmLte": {
	///      "$ref": "#/components/schemas/CollectionPeriodRmmLteMdt"
	///    },
	///    "collectionPeriodRmmNr": {
	///      "$ref": "#/components/schemas/CollectionPeriodRmmNrMdt"
	///    },
	///    "eventList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/EventForMdt"
	///      },
	///      "minItems": 1
	///    },
	///    "eventThresholdRsrp": {
	///      "description": "This IE shall be present if the report trigger
	/// parameter is configured for A2 event reporting or A2 event triggered
	/// periodic reporting and the job type parameter is configured for
	/// Immediate MDT or combined Immediate MDT and Trace in LTE. When present,
	/// this IE shall indicate the Event Threshold for RSRP, and the value shall
	/// be between 0-97.\n",
	///      "type": "integer",
	///      "maximum": 97.0,
	///      "minimum": 0.0
	///    },
	///    "eventThresholdRsrpNr": {
	///      "description": "This IE shall be present if the report trigger
	/// parameter is configured for A2 event reporting or A2 event triggered
	/// periodic reporting and the job type parameter is configured for
	/// Immediate MDT or combined Immediate MDT and Trace in NR. When present,
	/// this IE shall indicate the Event Threshold for RSRP, and the value shall
	/// be between 0-127.\n",
	///      "type": "integer",
	///      "maximum": 127.0,
	///      "minimum": 0.0
	///    },
	///    "eventThresholdRsrq": {
	///      "description": "This IE shall be present if the report trigger
	/// parameter is configured for A2 event reporting or A2 event triggered
	/// periodic reporting and the job type parameter is configured for
	/// Immediate MDT or combined Immediate MDT and Trace in LTE.When present,
	/// this IE shall indicate the Event Threshold for RSRQ, and the value shall
	/// be between 0-34.\n",
	///      "type": "integer",
	///      "maximum": 34.0,
	///      "minimum": 0.0
	///    },
	///    "eventThresholdRsrqNr": {
	///      "description": "This IE shall be present if the report trigger
	/// parameter is configured for A2 event reporting or A2 event triggered
	/// periodic reporting and the job type parameter is configured for
	/// Immediate MDT or combined Immediate MDT and Trace in NR.When present,
	/// this IE shall indicate the Event Threshold for RSRQ, and the value shall
	/// be between 0-127.\n",
	///      "type": "integer",
	///      "maximum": 127.0,
	///      "minimum": 0.0
	///    },
	///    "interFreqTargetList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/InterFreqTargetInfo"
	///      },
	///      "maxItems": 8,
	///      "minItems": 1
	///    },
	///    "jobType": {
	///      "$ref": "#/components/schemas/JobType"
	///    },
	///    "loggingDuration": {
	///      "$ref": "#/components/schemas/LoggingDurationMdt"
	///    },
	///    "loggingDurationNr": {
	///      "$ref": "#/components/schemas/LoggingDurationNrMdt"
	///    },
	///    "loggingInterval": {
	///      "$ref": "#/components/schemas/LoggingIntervalMdt"
	///    },
	///    "loggingIntervalNr": {
	///      "$ref": "#/components/schemas/LoggingIntervalNrMdt"
	///    },
	///    "mbsfnAreaList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/MbsfnArea"
	///      },
	///      "maxItems": 8,
	///      "minItems": 1
	///    },
	///    "mdtAllowedPlmnIdList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/PlmnId"
	///      },
	///      "maxItems": 16,
	///      "minItems": 1
	///    },
	///    "measurementLteList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/MeasurementLteForMdt"
	///      }
	///    },
	///    "measurementNrList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/MeasurementNrForMdt"
	///      },
	///      "minItems": 1
	///    },
	///    "measurementPeriodLte": {
	///      "$ref": "#/components/schemas/MeasurementPeriodLteMdt"
	///    },
	///    "positioningMethod": {
	///      "$ref": "#/components/schemas/PositioningMethodMdt"
	///    },
	///    "reportAmount": {
	///      "$ref": "#/components/schemas/ReportAmountMdt"
	///    },
	///    "reportInterval": {
	///      "$ref": "#/components/schemas/ReportIntervalMdt"
	///    },
	///    "reportIntervalNr": {
	///      "$ref": "#/components/schemas/ReportIntervalNrMdt"
	///    },
	///    "reportType": {
	///      "$ref": "#/components/schemas/ReportTypeMdt"
	///    },
	///    "reportingTriggerList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/ReportingTrigger"
	///      },
	///      "minItems": 1
	///    },
	///    "sensorMeasurementList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/SensorMeasurement"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct MdtConfiguration {
		#[serde(
			rename = "addPositioningMethodList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub add_positioning_method_list: Vec<PositioningMethodMdt>,
		#[serde(rename = "areaScope", default, skip_serializing_if = "Option::is_none")]
		pub area_scope: Option<AreaScope>,
		#[serde(
			rename = "collectionPeriodRmmLte",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub collection_period_rmm_lte: Option<CollectionPeriodRmmLteMdt>,
		#[serde(
			rename = "collectionPeriodRmmNr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub collection_period_rmm_nr: Option<CollectionPeriodRmmNrMdt>,
		#[serde(rename = "eventList", default, skip_serializing_if = "Vec::is_empty")]
		pub event_list: Vec<EventForMdt>,
		/// This IE shall be present if the report trigger parameter is
		/// configured for A2 event reporting or A2 event triggered periodic
		/// reporting and the job type parameter is configured for Immediate MDT
		/// or combined Immediate MDT and Trace in LTE. When present, this IE
		/// shall indicate the Event Threshold for RSRP, and the value shall be
		/// between 0-97.
		#[serde(
			rename = "eventThresholdRsrp",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub event_threshold_rsrp: Option<i64>,
		/// This IE shall be present if the report trigger parameter is
		/// configured for A2 event reporting or A2 event triggered periodic
		/// reporting and the job type parameter is configured for Immediate MDT
		/// or combined Immediate MDT and Trace in NR. When present, this IE
		/// shall indicate the Event Threshold for RSRP, and the value shall be
		/// between 0-127.
		#[serde(
			rename = "eventThresholdRsrpNr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub event_threshold_rsrp_nr: Option<i64>,
		/// This IE shall be present if the report trigger parameter is
		/// configured for A2 event reporting or A2 event triggered periodic
		/// reporting and the job type parameter is configured for Immediate MDT
		/// or combined Immediate MDT and Trace in LTE.When present, this IE
		/// shall indicate the Event Threshold for RSRQ, and the value shall be
		/// between 0-34.
		#[serde(
			rename = "eventThresholdRsrq",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub event_threshold_rsrq: Option<i64>,
		/// This IE shall be present if the report trigger parameter is
		/// configured for A2 event reporting or A2 event triggered periodic
		/// reporting and the job type parameter is configured for Immediate MDT
		/// or combined Immediate MDT and Trace in NR.When present, this IE
		/// shall indicate the Event Threshold for RSRQ, and the value shall be
		/// between 0-127.
		#[serde(
			rename = "eventThresholdRsrqNr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub event_threshold_rsrq_nr: Option<i64>,
		#[serde(
			rename = "interFreqTargetList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub inter_freq_target_list: Vec<InterFreqTargetInfo>,
		#[serde(rename = "jobType")]
		pub job_type: JobType,
		#[serde(
			rename = "loggingDuration",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub logging_duration: Option<LoggingDurationMdt>,
		#[serde(
			rename = "loggingDurationNr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub logging_duration_nr: Option<LoggingDurationNrMdt>,
		#[serde(
			rename = "loggingInterval",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub logging_interval: Option<LoggingIntervalMdt>,
		#[serde(
			rename = "loggingIntervalNr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub logging_interval_nr: Option<LoggingIntervalNrMdt>,
		#[serde(
			rename = "mbsfnAreaList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub mbsfn_area_list: Vec<MbsfnArea>,
		#[serde(
			rename = "mdtAllowedPlmnIdList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub mdt_allowed_plmn_id_list: Vec<PlmnId>,
		#[serde(
			rename = "measurementLteList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub measurement_lte_list: Vec<MeasurementLteForMdt>,
		#[serde(
			rename = "measurementNrList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub measurement_nr_list: Vec<MeasurementNrForMdt>,
		#[serde(
			rename = "measurementPeriodLte",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub measurement_period_lte: Option<MeasurementPeriodLteMdt>,
		#[serde(
			rename = "positioningMethod",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub positioning_method: Option<PositioningMethodMdt>,
		#[serde(
			rename = "reportAmount",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub report_amount: Option<ReportAmountMdt>,
		#[serde(
			rename = "reportInterval",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub report_interval: Option<ReportIntervalMdt>,
		#[serde(
			rename = "reportIntervalNr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub report_interval_nr: Option<ReportIntervalNrMdt>,
		#[serde(
			rename = "reportType",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub report_type: Option<ReportTypeMdt>,
		#[serde(
			rename = "reportingTriggerList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub reporting_trigger_list: Vec<ReportingTrigger>,
		#[serde(
			rename = "sensorMeasurementList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub sensor_measurement_list: Vec<SensorMeasurement>,
	}

	impl From<&MdtConfiguration> for MdtConfiguration {
		fn from(value: &MdtConfiguration) -> Self {
			value.clone()
		}
	}

	/// MdtUserConsent
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "CONSENT_NOT_GIVEN",
	///    "CONSENT_GIVEN"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum MdtUserConsent {
		#[default]
		#[serde(rename = "CONSENT_NOT_GIVEN")]
		ConsentNotGiven,
		#[serde(rename = "CONSENT_GIVEN")]
		ConsentGiven,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&MdtUserConsent> for MdtUserConsent {
		fn from(value: &MdtUserConsent) -> Self {
			value.clone()
		}
	}

	impl ToString for MdtUserConsent {
		fn to_string(&self) -> String {
			match *self {
				Self::ConsentNotGiven => "CONSENT_NOT_GIVEN".to_string(),
				Self::ConsentGiven => "CONSENT_GIVEN".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for MdtUserConsent {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"CONSENT_NOT_GIVEN" => Ok(Self::ConsentNotGiven),
				"CONSENT_GIVEN" => Ok(Self::ConsentGiven),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for MdtUserConsent {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for MdtUserConsent {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for MdtUserConsent {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// The enumeration MeasurementLteForMdt defines Measurements used for MDT
	/// in LTE in the trace. See 3GPP TS 32.422 for further description of the
	/// values. It shall comply with the provisions defined in table 5.6.3.5-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration MeasurementLteForMdt defines
	/// Measurements used for MDT in LTE in the trace. See 3GPP TS 32.422 for
	/// further description of the values. It shall comply with the provisions
	/// defined in table 5.6.3.5-1.\n",
	///  "type": "string",
	///  "enum": [
	///    "M1",
	///    "M2",
	///    "M3",
	///    "M4_DL",
	///    "M4_UL",
	///    "M5_DL",
	///    "M5_UL",
	///    "M6_DL",
	///    "M6_UL",
	///    "M7_DL",
	///    "M7_UL",
	///    "M8",
	///    "M9"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum MeasurementLteForMdt {
		#[default]
		M1,
		M2,
		M3,
		#[serde(rename = "M4_DL")]
		M4Dl,
		#[serde(rename = "M4_UL")]
		M4Ul,
		#[serde(rename = "M5_DL")]
		M5Dl,
		#[serde(rename = "M5_UL")]
		M5Ul,
		#[serde(rename = "M6_DL")]
		M6Dl,
		#[serde(rename = "M6_UL")]
		M6Ul,
		#[serde(rename = "M7_DL")]
		M7Dl,
		#[serde(rename = "M7_UL")]
		M7Ul,
		M8,
		M9,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&MeasurementLteForMdt> for MeasurementLteForMdt {
		fn from(value: &MeasurementLteForMdt) -> Self {
			value.clone()
		}
	}

	impl ToString for MeasurementLteForMdt {
		fn to_string(&self) -> String {
			match *self {
				Self::M1 => "M1".to_string(),
				Self::M2 => "M2".to_string(),
				Self::M3 => "M3".to_string(),
				Self::M4Dl => "M4_DL".to_string(),
				Self::M4Ul => "M4_UL".to_string(),
				Self::M5Dl => "M5_DL".to_string(),
				Self::M5Ul => "M5_UL".to_string(),
				Self::M6Dl => "M6_DL".to_string(),
				Self::M6Ul => "M6_UL".to_string(),
				Self::M7Dl => "M7_DL".to_string(),
				Self::M7Ul => "M7_UL".to_string(),
				Self::M8 => "M8".to_string(),
				Self::M9 => "M9".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for MeasurementLteForMdt {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"M1" => Ok(Self::M1),
				"M2" => Ok(Self::M2),
				"M3" => Ok(Self::M3),
				"M4_DL" => Ok(Self::M4Dl),
				"M4_UL" => Ok(Self::M4Ul),
				"M5_DL" => Ok(Self::M5Dl),
				"M5_UL" => Ok(Self::M5Ul),
				"M6_DL" => Ok(Self::M6Dl),
				"M6_UL" => Ok(Self::M6Ul),
				"M7_DL" => Ok(Self::M7Dl),
				"M7_UL" => Ok(Self::M7Ul),
				"M8" => Ok(Self::M8),
				"M9" => Ok(Self::M9),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for MeasurementLteForMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for MeasurementLteForMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for MeasurementLteForMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// The enumeration MeasurementNrForMdt defines Measurements used for MDT in
	/// NR in the trace. See 3GPP TS 32.422 for further description of the
	/// values. It shall comply with the provisions defined in table 5.6.3.6-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration MeasurementNrForMdt defines
	/// Measurements used for MDT in NR in the trace. See 3GPP TS 32.422 for
	/// further description of the values. It shall comply with the provisions
	/// defined in table 5.6.3.6-1.\n",
	///  "type": "string",
	///  "enum": [
	///    "M1",
	///    "M2",
	///    "M3",
	///    "M4_DL",
	///    "M4_UL",
	///    "M5_DL",
	///    "M5_UL",
	///    "M6_DL",
	///    "M6_UL",
	///    "M7_DL",
	///    "M7_UL",
	///    "M8",
	///    "M9"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum MeasurementNrForMdt {
		#[default]
		M1,
		M2,
		M3,
		#[serde(rename = "M4_DL")]
		M4Dl,
		#[serde(rename = "M4_UL")]
		M4Ul,
		#[serde(rename = "M5_DL")]
		M5Dl,
		#[serde(rename = "M5_UL")]
		M5Ul,
		#[serde(rename = "M6_DL")]
		M6Dl,
		#[serde(rename = "M6_UL")]
		M6Ul,
		#[serde(rename = "M7_DL")]
		M7Dl,
		#[serde(rename = "M7_UL")]
		M7Ul,
		M8,
		M9,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&MeasurementNrForMdt> for MeasurementNrForMdt {
		fn from(value: &MeasurementNrForMdt) -> Self {
			value.clone()
		}
	}

	impl ToString for MeasurementNrForMdt {
		fn to_string(&self) -> String {
			match *self {
				Self::M1 => "M1".to_string(),
				Self::M2 => "M2".to_string(),
				Self::M3 => "M3".to_string(),
				Self::M4Dl => "M4_DL".to_string(),
				Self::M4Ul => "M4_UL".to_string(),
				Self::M5Dl => "M5_DL".to_string(),
				Self::M5Ul => "M5_UL".to_string(),
				Self::M6Dl => "M6_DL".to_string(),
				Self::M6Ul => "M6_UL".to_string(),
				Self::M7Dl => "M7_DL".to_string(),
				Self::M7Ul => "M7_UL".to_string(),
				Self::M8 => "M8".to_string(),
				Self::M9 => "M9".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for MeasurementNrForMdt {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"M1" => Ok(Self::M1),
				"M2" => Ok(Self::M2),
				"M3" => Ok(Self::M3),
				"M4_DL" => Ok(Self::M4Dl),
				"M4_UL" => Ok(Self::M4Ul),
				"M5_DL" => Ok(Self::M5Dl),
				"M5_UL" => Ok(Self::M5Ul),
				"M6_DL" => Ok(Self::M6Dl),
				"M6_UL" => Ok(Self::M6Ul),
				"M7_DL" => Ok(Self::M7Dl),
				"M7_UL" => Ok(Self::M7Ul),
				"M8" => Ok(Self::M8),
				"M9" => Ok(Self::M9),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for MeasurementNrForMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for MeasurementNrForMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for MeasurementNrForMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// The enumeration MeasurementPeriodLteMdt defines Measurement period LTE
	/// for MDT in the trace.  See 3GPP TS 32.422 for further description of the
	/// values. It shall comply with the provisions defined in table 5.6.3.16-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration MeasurementPeriodLteMdt defines
	/// Measurement period LTE for MDT in the trace.  See 3GPP TS 32.422 for
	/// further description of the values. It shall comply with the provisions
	/// defined in table 5.6.3.16-1.\n",
	///  "type": "string",
	///  "enum": [
	///    1024,
	///    1280,
	///    2048,
	///    2560,
	///    5120,
	///    10240,
	///    60000
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum MeasurementPeriodLteMdt {
		#[default]
		#[serde(rename = "1024")]
		NUM1024,
		#[serde(rename = "1280")]
		NUM1280,
		#[serde(rename = "2048")]
		NUM2048,
		#[serde(rename = "2560")]
		NUM2560,
		#[serde(rename = "5120")]
		NUM5120,
		#[serde(rename = "10240")]
		NUM10240,
		#[serde(rename = "60000")]
		NUM60000,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&MeasurementPeriodLteMdt> for MeasurementPeriodLteMdt {
		fn from(value: &MeasurementPeriodLteMdt) -> Self {
			value.clone()
		}
	}

	impl ToString for MeasurementPeriodLteMdt {
		fn to_string(&self) -> String {
			match *self {
				Self::NUM1024 => "1024".to_string(),
				Self::NUM1280 => "1280".to_string(),
				Self::NUM2048 => "2048".to_string(),
				Self::NUM2560 => "2560".to_string(),
				Self::NUM5120 => "5120".to_string(),
				Self::NUM10240 => "10240".to_string(),
				Self::NUM60000 => "60000".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for MeasurementPeriodLteMdt {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"1024" => Ok(Self::NUM1024),
				"1280" => Ok(Self::NUM1280),
				"2048" => Ok(Self::NUM2048),
				"2560" => Ok(Self::NUM2560),
				"5120" => Ok(Self::NUM5120),
				"10240" => Ok(Self::NUM10240),
				"60000" => Ok(Self::NUM60000),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for MeasurementPeriodLteMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for MeasurementPeriodLteMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for MeasurementPeriodLteMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// MicoAllowed
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "boolean"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct MicoAllowed(pub bool);
	impl ::std::ops::Deref for MicoAllowed {
		type Target = bool;
		fn deref(&self) -> &bool {
			&self.0
		}
	}

	impl From<MicoAllowed> for bool {
		fn from(value: MicoAllowed) -> Self {
			value.0
		}
	}

	impl From<&MicoAllowed> for MicoAllowed {
		fn from(value: &MicoAllowed) -> Self {
			value.clone()
		}
	}

	impl From<bool> for MicoAllowed {
		fn from(value: bool) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for MicoAllowed {
		type Err = <bool as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for MicoAllowed {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for MicoAllowed {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for MicoAllowed {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for MicoAllowed {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Mobile Network Code part of the PLMN, comprising 2 or 3 digits, as
	/// defined in clause 9.3.3.5 of 3GPP TS 38.413.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Mobile Network Code part of the PLMN, comprising 2 or 3
	/// digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.",
	///  "type": "string",
	///  "pattern": "^\\d{2,3}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Mnc(String);
	impl ::std::ops::Deref for Mnc {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Mnc> for String {
		fn from(value: Mnc) -> Self {
			value.0
		}
	}

	impl From<&Mnc> for Mnc {
		fn from(value: &Mnc) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Mnc {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^\\d{2,3}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^\\d{2,3}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Mnc {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Mnc {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Mnc {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Mnc {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// ModificationNotification
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "notifyItems"
	///  ],
	///  "properties": {
	///    "notifyItems": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/NotifyItem"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ModificationNotification {
		#[serde(rename = "notifyItems")]
		pub notify_items: Vec<NotifyItem>,
	}

	impl From<&ModificationNotification> for ModificationNotification {
		fn from(value: &ModificationNotification) -> Self {
			value.clone()
		}
	}

	/// MonitoringConfiguration
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "eventType"
	///  ],
	///  "properties": {
	///    "afId": {
	///      "type": "string"
	///    },
	///    "associationType": {
	///      "$ref": "#/components/schemas/AssociationType"
	///    },
	///    "datalinkReportCfg": {
	///      "$ref": "#/components/schemas/DatalinkReportingConfiguration"
	///    },
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "eventType": {
	///      "$ref": "#/components/schemas/EventType"
	///    },
	///    "idleStatusInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "immediateFlag": {
	///      "type": "boolean"
	///    },
	///    "locationReportingConfiguration": {
	///      "$ref": "#/components/schemas/LocationReportingConfiguration"
	///    },
	///    "lossConnectivityCfg": {
	///      "$ref": "#/components/schemas/LossConnectivityCfg"
	///    },
	///    "maximumLatency": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "maximumResponseTime": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "pduSessionStatusCfg": {
	///      "$ref": "#/components/schemas/PduSessionStatusCfg"
	///    },
	///    "reachabilityForDataCfg": {
	///      "$ref": "#/components/schemas/ReachabilityForDataConfiguration"
	///    },
	///    "reachabilityForSmsCfg": {
	///      "$ref": "#/components/schemas/ReachabilityForSmsConfiguration"
	///    },
	///    "singleNssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    },
	///    "suggestedPacketNumDl": {
	///      "type": "integer",
	///      "minimum": 1.0
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct MonitoringConfiguration {
		#[serde(rename = "afId", default, skip_serializing_if = "Option::is_none")]
		pub af_id: Option<String>,
		#[serde(
			rename = "associationType",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub association_type: Option<AssociationType>,
		#[serde(
			rename = "datalinkReportCfg",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub datalink_report_cfg: Option<DatalinkReportingConfiguration>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub dnn: Option<Dnn>,
		#[serde(rename = "eventType")]
		pub event_type: EventType,
		#[serde(rename = "idleStatusInd", default)]
		pub idle_status_ind: bool,
		#[serde(
			rename = "immediateFlag",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub immediate_flag: Option<bool>,
		#[serde(
			rename = "locationReportingConfiguration",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub location_reporting_configuration: Option<LocationReportingConfiguration>,
		#[serde(
			rename = "lossConnectivityCfg",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub loss_connectivity_cfg: Option<LossConnectivityCfg>,
		#[serde(
			rename = "maximumLatency",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub maximum_latency: Option<DurationSec>,
		#[serde(
			rename = "maximumResponseTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub maximum_response_time: Option<DurationSec>,
		#[serde(
			rename = "mtcProviderInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mtc_provider_information: Option<MtcProviderInformation>,
		#[serde(
			rename = "pduSessionStatusCfg",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pdu_session_status_cfg: Option<PduSessionStatusCfg>,
		#[serde(
			rename = "reachabilityForDataCfg",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub reachability_for_data_cfg: Option<ReachabilityForDataConfiguration>,
		#[serde(
			rename = "reachabilityForSmsCfg",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub reachability_for_sms_cfg: Option<ReachabilityForSmsConfiguration>,
		#[serde(
			rename = "singleNssai",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub single_nssai: Option<Snssai>,
		#[serde(
			rename = "suggestedPacketNumDl",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub suggested_packet_num_dl: Option<std::num::NonZeroU64>,
	}

	impl From<&MonitoringConfiguration> for MonitoringConfiguration {
		fn from(value: &MonitoringConfiguration) -> Self {
			value.clone()
		}
	}

	/// MonitoringEvent
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "eventType"
	///  ],
	///  "properties": {
	///    "eventType": {
	///      "$ref": "#/components/schemas/EventType"
	///    },
	///    "revokedCause": {
	///      "$ref": "#/components/schemas/RevokedCause"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct MonitoringEvent {
		#[serde(rename = "eventType")]
		pub event_type: EventType,
		#[serde(
			rename = "revokedCause",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub revoked_cause: Option<RevokedCause>,
	}

	impl From<&MonitoringEvent> for MonitoringEvent {
		fn from(value: &MonitoringEvent) -> Self {
			value.clone()
		}
	}

	/// MonitoringReport
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "eventType",
	///    "referenceId",
	///    "timeStamp"
	///  ],
	///  "properties": {
	///    "eventType": {
	///      "$ref": "#/components/schemas/EventType"
	///    },
	///    "gpsi": {
	///      "$ref": "#/components/schemas/Gpsi"
	///    },
	///    "reachabilityForSmsReport": {
	///      "$ref": "#/components/schemas/ReachabilityForSmsReport"
	///    },
	///    "reachabilityReport": {
	///      "$ref": "#/components/schemas/ReachabilityReport"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    },
	///    "report": {
	///      "$ref": "#/components/schemas/Report"
	///    },
	///    "timeStamp": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct MonitoringReport {
		#[serde(rename = "eventType")]
		pub event_type: EventType,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub gpsi: Option<Gpsi>,
		#[serde(
			rename = "reachabilityForSmsReport",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub reachability_for_sms_report: Option<ReachabilityForSmsReport>,
		#[serde(
			rename = "reachabilityReport",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub reachability_report: Option<ReachabilityReport>,
		#[serde(rename = "referenceId")]
		pub reference_id: ReferenceId,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub report: Option<Report>,
		#[serde(rename = "timeStamp")]
		pub time_stamp: DateTime,
	}

	impl From<&MonitoringReport> for MonitoringReport {
		fn from(value: &MonitoringReport) -> Self {
			value.clone()
		}
	}

	/// MpsPriorityIndicator
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "boolean"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct MpsPriorityIndicator(pub bool);
	impl ::std::ops::Deref for MpsPriorityIndicator {
		type Target = bool;
		fn deref(&self) -> &bool {
			&self.0
		}
	}

	impl From<MpsPriorityIndicator> for bool {
		fn from(value: MpsPriorityIndicator) -> Self {
			value.0
		}
	}

	impl From<&MpsPriorityIndicator> for MpsPriorityIndicator {
		fn from(value: &MpsPriorityIndicator) -> Self {
			value.clone()
		}
	}

	impl From<bool> for MpsPriorityIndicator {
		fn from(value: bool) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for MpsPriorityIndicator {
		type Err = <bool as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for MpsPriorityIndicator {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for MpsPriorityIndicator {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for MpsPriorityIndicator {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for MpsPriorityIndicator {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// String uniquely identifying MTC provider information.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String uniquely identifying MTC provider information.",
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct MtcProviderInformation(pub String);
	impl ::std::ops::Deref for MtcProviderInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<MtcProviderInformation> for String {
		fn from(value: MtcProviderInformation) -> Self {
			value.0
		}
	}

	impl From<&MtcProviderInformation> for MtcProviderInformation {
		fn from(value: &MtcProviderInformation) -> Self {
			value.clone()
		}
	}

	impl From<String> for MtcProviderInformation {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for MtcProviderInformation {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for MtcProviderInformation {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// MulticastMbsGroupMemb
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "multicastGroupMemb"
	///  ],
	///  "properties": {
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "internalGroupIdentifier": {
	///      "$ref": "#/components/schemas/GroupId"
	///    },
	///    "multicastGroupMemb": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Gpsi"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct MulticastMbsGroupMemb {
		#[serde(
			rename = "afInstanceId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub af_instance_id: Option<String>,
		#[serde(
			rename = "internalGroupIdentifier",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub internal_group_identifier: Option<GroupId>,
		#[serde(rename = "multicastGroupMemb")]
		pub multicast_group_memb: Vec<Gpsi>,
	}

	impl From<&MulticastMbsGroupMemb> for MulticastMbsGroupMemb {
		fn from(value: &MulticastMbsGroupMemb) -> Self {
			value.clone()
		}
	}

	/// This represents the identifier of the N3IWF ID as specified in clause
	/// 9.3.1.57 of  3GPP TS 38.413 in hexadecimal representation. Each
	/// character in the string shall take a value  of "0" to "9", "a" to "f" or
	/// "A" to "F" and shall represent 4 bits. The most significant  character
	/// representing the 4 most significant bits of the N3IWF ID shall appear
	/// first in the  string, and the character representing the 4 least
	/// significant bit of the N3IWF ID shall  appear last in the string.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This represents the identifier of the N3IWF ID as
	/// specified in clause 9.3.1.57 of  3GPP TS 38.413 in hexadecimal
	/// representation. Each character in the string shall take a value  of
	/// \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4
	/// bits. The most significant  character representing the 4 most
	/// significant bits of the N3IWF ID shall appear first in the  string, and
	/// the character representing the 4 least significant bit of the N3IWF ID
	/// shall  appear last in the string. \n",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]+$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct N3IwfId(String);
	impl ::std::ops::Deref for N3IwfId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<N3IwfId> for String {
		fn from(value: N3IwfId) -> Self {
			value.0
		}
	}

	impl From<&N3IwfId> for N3IwfId {
		fn from(value: &N3IwfId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for N3IwfId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]+$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]+$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for N3IwfId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for N3IwfId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for N3IwfId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for N3IwfId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Contains the Non-3GPP access user location.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the Non-3GPP access user location.",
	///  "type": "object",
	///  "properties": {
	///    "gci": {
	///      "$ref": "#/components/schemas/Gci"
	///    },
	///    "gli": {
	///      "$ref": "#/components/schemas/Bytes"
	///    },
	///    "hfcNodeId": {
	///      "$ref": "#/components/schemas/HfcNodeId"
	///    },
	///    "n3IwfId": {
	///      "description": "This IE shall contain the N3IWF identifier received
	/// over NGAP and shall be encoded as a  string of hexadecimal characters.
	/// Each character in the string shall take a value of \"0\"  to \"9\",
	/// \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most
	/// significant  character representing the 4 most significant bits of the
	/// N3IWF ID shall appear first in  the string, and the character
	/// representing the 4 least significant bit of the N3IWF ID  shall appear
	/// last in the string. \n",
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]+$"
	///    },
	///    "n3gppTai": {
	///      "$ref": "#/components/schemas/Tai"
	///    },
	///    "portNumber": {
	///      "$ref": "#/components/schemas/Uinteger"
	///    },
	///    "protocol": {
	///      "$ref": "#/components/schemas/TransportProtocol"
	///    },
	///    "tnapId": {
	///      "$ref": "#/components/schemas/TnapId"
	///    },
	///    "twapId": {
	///      "$ref": "#/components/schemas/TwapId"
	///    },
	///    "ueIpv4Addr": {
	///      "$ref": "#/components/schemas/Ipv4Addr"
	///    },
	///    "ueIpv6Addr": {
	///      "$ref": "#/components/schemas/Ipv6Addr"
	///    },
	///    "w5gbanLineType": {
	///      "$ref": "#/components/schemas/LineType"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct N3gaLocation {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub gci: Option<Gci>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub gli: Option<Bytes>,
		#[serde(rename = "hfcNodeId", default, skip_serializing_if = "Option::is_none")]
		pub hfc_node_id: Option<HfcNodeId>,
		/// This IE shall contain the N3IWF identifier received over NGAP and
		/// shall be encoded as a  string of hexadecimal characters. Each
		/// character in the string shall take a value of "0"  to "9", "a" to
		/// "f" or "A" to "F" and shall represent 4 bits. The most significant
		/// character representing the 4 most significant bits of the N3IWF ID
		/// shall appear first in  the string, and the character representing
		/// the 4 least significant bit of the N3IWF ID  shall appear last in
		/// the string.
		#[serde(rename = "n3IwfId", default, skip_serializing_if = "Option::is_none")]
		pub n3_iwf_id: Option<N3gaLocationN3IwfId>,
		#[serde(rename = "n3gppTai", default, skip_serializing_if = "Option::is_none")]
		pub n3gpp_tai: Option<Tai>,
		#[serde(
			rename = "portNumber",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub port_number: Option<Uinteger>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub protocol: Option<TransportProtocol>,
		#[serde(rename = "tnapId", default, skip_serializing_if = "Option::is_none")]
		pub tnap_id: Option<TnapId>,
		#[serde(rename = "twapId", default, skip_serializing_if = "Option::is_none")]
		pub twap_id: Option<TwapId>,
		#[serde(
			rename = "ueIpv4Addr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ue_ipv4_addr: Option<Ipv4Addr>,
		#[serde(
			rename = "ueIpv6Addr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ue_ipv6_addr: Option<Ipv6Addr>,
		#[serde(
			rename = "w5gbanLineType",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub w5gban_line_type: Option<LineType>,
	}

	impl From<&N3gaLocation> for N3gaLocation {
		fn from(value: &N3gaLocation) -> Self {
			value.clone()
		}
	}

	/// This IE shall contain the N3IWF identifier received over NGAP and shall
	/// be encoded as a  string of hexadecimal characters. Each character in the
	/// string shall take a value of "0"  to "9", "a" to "f" or "A" to "F" and
	/// shall represent 4 bits. The most significant  character representing the
	/// 4 most significant bits of the N3IWF ID shall appear first in  the
	/// string, and the character representing the 4 least significant bit of
	/// the N3IWF ID  shall appear last in the string.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This IE shall contain the N3IWF identifier received
	/// over NGAP and shall be encoded as a  string of hexadecimal characters.
	/// Each character in the string shall take a value of \"0\"  to \"9\",
	/// \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most
	/// significant  character representing the 4 most significant bits of the
	/// N3IWF ID shall appear first in  the string, and the character
	/// representing the 4 least significant bit of the N3IWF ID  shall appear
	/// last in the string. \n",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]+$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct N3gaLocationN3IwfId(String);
	impl ::std::ops::Deref for N3gaLocationN3IwfId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<N3gaLocationN3IwfId> for String {
		fn from(value: N3gaLocationN3IwfId) -> Self {
			value.0
		}
	}

	impl From<&N3gaLocationN3IwfId> for N3gaLocationN3IwfId {
		fn from(value: &N3gaLocationN3IwfId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for N3gaLocationN3IwfId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]+$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]+$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for N3gaLocationN3IwfId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for N3gaLocationN3IwfId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for N3gaLocationN3IwfId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for N3gaLocationN3IwfId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// NbIoTUePriority
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "integer",
	///  "maximum": 255.0,
	///  "minimum": 0.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NbIoTUePriority(pub u8);
	impl ::std::ops::Deref for NbIoTUePriority {
		type Target = u8;
		fn deref(&self) -> &u8 {
			&self.0
		}
	}

	impl From<NbIoTUePriority> for u8 {
		fn from(value: NbIoTUePriority) -> Self {
			value.0
		}
	}

	impl From<&NbIoTUePriority> for NbIoTUePriority {
		fn from(value: &NbIoTUePriority) -> Self {
			value.clone()
		}
	}

	impl From<u8> for NbIoTUePriority {
		fn from(value: u8) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for NbIoTUePriority {
		type Err = <u8 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for NbIoTUePriority {
		type Error = <u8 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for NbIoTUePriority {
		type Error = <u8 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for NbIoTUePriority {
		type Error = <u8 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for NbIoTUePriority {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Contains the NCGI (NR Cell Global Identity), as described in 3GPP 23.003
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the NCGI (NR Cell Global Identity), as
	/// described in 3GPP 23.003",
	///  "type": "object",
	///  "required": [
	///    "nrCellId",
	///    "plmnId"
	///  ],
	///  "properties": {
	///    "nid": {
	///      "$ref": "#/components/schemas/Nid"
	///    },
	///    "nrCellId": {
	///      "$ref": "#/components/schemas/NrCellId"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Ncgi {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub nid: Option<Nid>,
		#[serde(rename = "nrCellId")]
		pub nr_cell_id: NrCellId,
		#[serde(rename = "plmnId")]
		pub plmn_id: PlmnId,
	}

	impl From<&Ncgi> for Ncgi {
		fn from(value: &Ncgi) -> Self {
			value.clone()
		}
	}

	/// Identity of the NEF
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Identity of the NEF",
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct NefId(pub String);
	impl ::std::ops::Deref for NefId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<NefId> for String {
		fn from(value: NefId) -> Self {
			value.0
		}
	}

	impl From<&NefId> for NefId {
		fn from(value: &NefId) -> Self {
			value.clone()
		}
	}

	impl From<String> for NefId {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for NefId {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for NefId {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Describes a network area information in which the NF service consumer
	/// requests the number of UEs.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Describes a network area information in which the NF
	/// service consumer requests the number of UEs.",
	///  "type": "object",
	///  "properties": {
	///    "ecgis": {
	///      "description": "Contains a list of E-UTRA cell identities.",
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Ecgi"
	///      },
	///      "minItems": 1
	///    },
	///    "gRanNodeIds": {
	///      "description": "Contains a list of NG RAN nodes.",
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/GlobalRanNodeId"
	///      },
	///      "minItems": 1
	///    },
	///    "ncgis": {
	///      "description": "Contains a list of NR cell identities.",
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Ncgi"
	///      },
	///      "minItems": 1
	///    },
	///    "tais": {
	///      "description": "Contains a list of tracking area identities.",
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Tai"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NetworkAreaInfo {
		/// Contains a list of E-UTRA cell identities.
		#[serde(default, skip_serializing_if = "Vec::is_empty")]
		pub ecgis: Vec<Ecgi>,
		/// Contains a list of NG RAN nodes.
		#[serde(rename = "gRanNodeIds", default, skip_serializing_if = "Vec::is_empty")]
		pub g_ran_node_ids: Vec<GlobalRanNodeId>,
		/// Contains a list of NR cell identities.
		#[serde(default, skip_serializing_if = "Vec::is_empty")]
		pub ncgis: Vec<Ncgi>,
		/// Contains a list of tracking area identities.
		#[serde(default, skip_serializing_if = "Vec::is_empty")]
		pub tais: Vec<Tai>,
	}

	impl From<&NetworkAreaInfo> for NetworkAreaInfo {
		fn from(value: &NetworkAreaInfo) -> Self {
			value.clone()
		}
	}

	/// NetworkNodeDiameterAddress
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "name",
	///    "realm"
	///  ],
	///  "properties": {
	///    "name": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "realm": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NetworkNodeDiameterAddress {
		pub name: Fqdn,
		pub realm: Fqdn,
	}

	impl From<&NetworkNodeDiameterAddress> for NetworkNodeDiameterAddress {
		fn from(value: &NetworkNodeDiameterAddress) -> Self {
			value.clone()
		}
	}

	/// Identifier of a group of NFs.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Identifier of a group of NFs.",
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct NfGroupId(pub String);
	impl ::std::ops::Deref for NfGroupId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<NfGroupId> for String {
		fn from(value: NfGroupId) -> Self {
			value.0
		}
	}

	impl From<&NfGroupId> for NfGroupId {
		fn from(value: &NfGroupId) -> Self {
			value.clone()
		}
	}

	impl From<String> for NfGroupId {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for NfGroupId {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for NfGroupId {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// String uniquely identifying a NF instance. The format of the NF Instance
	/// ID shall be a  Universally Unique Identifier (UUID) version 4, as
	/// described in IETF RFC 4122.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String uniquely identifying a NF instance. The format
	/// of the NF Instance ID shall be a  Universally Unique Identifier (UUID)
	/// version 4, as described in IETF RFC 4122. \n",
	///  "type": "string",
	///  "format": "uuid"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NfInstanceId(pub uuid::Uuid);
	impl ::std::ops::Deref for NfInstanceId {
		type Target = uuid::Uuid;
		fn deref(&self) -> &uuid::Uuid {
			&self.0
		}
	}

	impl From<NfInstanceId> for uuid::Uuid {
		fn from(value: NfInstanceId) -> Self {
			value.0
		}
	}

	impl From<&NfInstanceId> for NfInstanceId {
		fn from(value: &NfInstanceId) -> Self {
			value.clone()
		}
	}

	impl From<uuid::Uuid> for NfInstanceId {
		fn from(value: uuid::Uuid) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for NfInstanceId {
		type Err = <uuid::Uuid as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for NfInstanceId {
		type Error = <uuid::Uuid as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for NfInstanceId {
		type Error = <uuid::Uuid as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for NfInstanceId {
		type Error = <uuid::Uuid as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for NfInstanceId {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// NF Service Set Identifier (see clause 28.12 of 3GPP TS 23.003) formatted
	/// as the following  string "set<Set ID>.sn<Service Name>.nfi<NF Instance
	/// ID>.5gc.mnc<MNC>.mcc<MCC>", or
	/// "set<SetID>.sn<ServiceName>.nfi<NFInstanceID>.5gc.nid<NID>.mnc<MNC>.
	/// mcc<MCC>" with  <MCC> encoded as defined in clause 5.4.2 ("Mcc" data
	/// type definition)   <MNC> encoding the Mobile Network Code part of the
	/// PLMN, comprising 3 digits.  If there are only 2 significant digits
	/// in the MNC, one "0" digit shall be inserted  at the left side to
	/// fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$'
	/// <NID> encoded as defined in clause 5.4.2 ("Nid" data type definition)
	/// <NFInstanceId> encoded as defined in clause 5.3.2  <ServiceName> encoded
	/// as defined in 3GPP TS 29.510  <Set ID> encoded as a string of characters
	/// consisting of alphabetic  characters (A-Z and a-z), digits (0-9)
	/// and/or the hyphen (-) and that shall end  with either an alphabetic
	/// character or a digit.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "NF Service Set Identifier (see clause 28.12 of 3GPP TS
	/// 23.003) formatted as the following  string \"set<Set ID>.sn<Service
	/// Name>.nfi<NF Instance ID>.5gc.mnc<MNC>.mcc<MCC>\", or
	/// \"set<SetID>.sn<ServiceName>.nfi<NFInstanceID>.5gc.nid<NID>.mnc<MNC>.
	/// mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data
	/// type definition)   <MNC> encoding the Mobile Network Code part of the
	/// PLMN, comprising 3 digits. \n  If there are only 2 significant digits in
	/// the MNC, one \"0\" digit shall be inserted \n  at the left side to fill
	/// the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$'\n<NID> encoded as
	/// defined in clause 5.4.2 (\"Nid\" data type definition)  <NFInstanceId>
	/// encoded as defined in clause 5.3.2  <ServiceName> encoded as defined in
	/// 3GPP TS 29.510  <Set ID> encoded as a string of characters consisting of
	/// alphabetic \n  characters (A-Z and a-z), digits (0-9) and/or the hyphen
	/// (-) and that shall end \n  with either an alphabetic character or a
	/// digit.\n",
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct NfServiceSetId(pub String);
	impl ::std::ops::Deref for NfServiceSetId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<NfServiceSetId> for String {
		fn from(value: NfServiceSetId) -> Self {
			value.0
		}
	}

	impl From<&NfServiceSetId> for NfServiceSetId {
		fn from(value: &NfServiceSetId) -> Self {
			value.clone()
		}
	}

	impl From<String> for NfServiceSetId {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for NfServiceSetId {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for NfServiceSetId {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the
	/// following string "set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>", or
	/// "set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>" with  <MCC>
	/// encoded as defined in clause 5.4.2 ("Mcc" data type definition)  <MNC>
	/// encoding the Mobile Network Code part of the PLMN, comprising 3 digits.
	///  If there are only 2 significant digits in the MNC, one "0" digit shall
	/// be inserted  at the left side to fill the 3 digits coding of MNC.
	/// Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table
	/// 6.1.6.3.3-1 of 3GPP TS 29.510 but  with lower case characters <Set
	/// ID> encoded as a string of characters consisting of  alphabetic
	/// characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that
	///  shall end with either an alphabetic character or a digit.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "NF Set Identifier (see clause 28.12 of 3GPP TS 23.003),
	/// formatted as the following string \"set<Set
	/// ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or
	/// \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC>
	/// encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC>
	/// encoding the Mobile Network Code part of the PLMN, comprising 3 digits.
	/// \n  If there are only 2 significant digits in the MNC, one \"0\" digit
	/// shall be inserted \n  at the left side to fill the 3 digits coding of
	/// MNC.  Pattern: '^[0-9]{3}$'\n<NFType> encoded as a value defined in
	/// Table 6.1.6.3.3-1 of 3GPP TS 29.510 but \n  with lower case characters
	/// <Set ID> encoded as a string of characters consisting of \n  alphabetic
	/// characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that \n
	/// shall end with either an alphabetic character or a digit. \n",
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct NfSetId(pub String);
	impl ::std::ops::Deref for NfSetId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<NfSetId> for String {
		fn from(value: NfSetId) -> Self {
			value.0
		}
	}

	impl From<&NfSetId> for NfSetId {
		fn from(value: &NfSetId) -> Self {
			value.clone()
		}
	}

	impl From<String> for NfSetId {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for NfSetId {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for NfSetId {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// NF types known to NRF
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "NF types known to NRF",
	///  "type": "string",
	///  "enum": [
	///    "NRF",
	///    "UDM",
	///    "AMF",
	///    "SMF",
	///    "AUSF",
	///    "NEF",
	///    "PCF",
	///    "SMSF",
	///    "NSSF",
	///    "UDR",
	///    "LMF",
	///    "GMLC",
	///    "5G_EIR",
	///    "SEPP",
	///    "UPF",
	///    "N3IWF",
	///    "AF",
	///    "UDSF",
	///    "BSF",
	///    "CHF",
	///    "NWDAF",
	///    "PCSCF",
	///    "CBCF",
	///    "HSS",
	///    "UCMF",
	///    "SOR_AF",
	///    "SPAF",
	///    "MME",
	///    "SCSAS",
	///    "SCEF",
	///    "SCP",
	///    "NSSAAF",
	///    "ICSCF",
	///    "SCSCF",
	///    "DRA",
	///    "IMS_AS",
	///    "AANF",
	///    "5G_DDNMF",
	///    "NSACF",
	///    "MFAF",
	///    "EASDF",
	///    "DCCF",
	///    "MB_SMF",
	///    "TSCTSF",
	///    "ADRF",
	///    "GBA_BSF",
	///    "CEF",
	///    "MB_UPF",
	///    "NSWOF",
	///    "PKMF",
	///    "MNPF",
	///    "SMS_GMSC",
	///    "SMS_IWMSC",
	///    "MBSF",
	///    "MBSTF",
	///    "PANF",
	///    "IP_SM_GW",
	///    "SMS_ROUTER"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum NfType {
		#[default]
		#[serde(rename = "NRF")]
		Nrf,
		#[serde(rename = "UDM")]
		Udm,
		#[serde(rename = "AMF")]
		Amf,
		#[serde(rename = "SMF")]
		Smf,
		#[serde(rename = "AUSF")]
		Ausf,
		#[serde(rename = "NEF")]
		Nef,
		#[serde(rename = "PCF")]
		Pcf,
		#[serde(rename = "SMSF")]
		Smsf,
		#[serde(rename = "NSSF")]
		Nssf,
		#[serde(rename = "UDR")]
		Udr,
		#[serde(rename = "LMF")]
		Lmf,
		#[serde(rename = "GMLC")]
		Gmlc,
		#[serde(rename = "5G_EIR")]
		FiveGEir,
		#[serde(rename = "SEPP")]
		Sepp,
		#[serde(rename = "UPF")]
		Upf,
		#[serde(rename = "N3IWF")]
		N3iwf,
		#[serde(rename = "AF")]
		Af,
		#[serde(rename = "UDSF")]
		Udsf,
		#[serde(rename = "BSF")]
		Bsf,
		#[serde(rename = "CHF")]
		Chf,
		#[serde(rename = "NWDAF")]
		Nwdaf,
		#[serde(rename = "PCSCF")]
		Pcscf,
		#[serde(rename = "CBCF")]
		Cbcf,
		#[serde(rename = "HSS")]
		Hss,
		#[serde(rename = "UCMF")]
		Ucmf,
		#[serde(rename = "SOR_AF")]
		SorAf,
		#[serde(rename = "SPAF")]
		Spaf,
		#[serde(rename = "MME")]
		Mme,
		#[serde(rename = "SCSAS")]
		Scsas,
		#[serde(rename = "SCEF")]
		Scef,
		#[serde(rename = "SCP")]
		Scp,
		#[serde(rename = "NSSAAF")]
		Nssaaf,
		#[serde(rename = "ICSCF")]
		Icscf,
		#[serde(rename = "SCSCF")]
		Scscf,
		#[serde(rename = "DRA")]
		Dra,
		#[serde(rename = "IMS_AS")]
		ImsAs,
		#[serde(rename = "AANF")]
		Aanf,
		#[serde(rename = "5G_DDNMF")]
		FiveGDdnmf,
		#[serde(rename = "NSACF")]
		Nsacf,
		#[serde(rename = "MFAF")]
		Mfaf,
		#[serde(rename = "EASDF")]
		Easdf,
		#[serde(rename = "DCCF")]
		Dccf,
		#[serde(rename = "MB_SMF")]
		MbSmf,
		#[serde(rename = "TSCTSF")]
		Tsctsf,
		#[serde(rename = "ADRF")]
		Adrf,
		#[serde(rename = "GBA_BSF")]
		GbaBsf,
		#[serde(rename = "CEF")]
		Cef,
		#[serde(rename = "MB_UPF")]
		MbUpf,
		#[serde(rename = "NSWOF")]
		Nswof,
		#[serde(rename = "PKMF")]
		Pkmf,
		#[serde(rename = "MNPF")]
		Mnpf,
		#[serde(rename = "SMS_GMSC")]
		SmsGmsc,
		#[serde(rename = "SMS_IWMSC")]
		SmsIwmsc,
		#[serde(rename = "MBSF")]
		Mbsf,
		#[serde(rename = "MBSTF")]
		Mbstf,
		#[serde(rename = "PANF")]
		Panf,
		#[serde(rename = "IP_SM_GW")]
		IpSmGw,
		#[serde(rename = "SMS_ROUTER")]
		SmsRouter,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&NfType> for NfType {
		fn from(value: &NfType) -> Self {
			value.clone()
		}
	}

	impl ToString for NfType {
		fn to_string(&self) -> String {
			match *self {
				Self::Nrf => "NRF".to_string(),
				Self::Udm => "UDM".to_string(),
				Self::Amf => "AMF".to_string(),
				Self::Smf => "SMF".to_string(),
				Self::Ausf => "AUSF".to_string(),
				Self::Nef => "NEF".to_string(),
				Self::Pcf => "PCF".to_string(),
				Self::Smsf => "SMSF".to_string(),
				Self::Nssf => "NSSF".to_string(),
				Self::Udr => "UDR".to_string(),
				Self::Lmf => "LMF".to_string(),
				Self::Gmlc => "GMLC".to_string(),
				Self::FiveGEir => "5G_EIR".to_string(),
				Self::Sepp => "SEPP".to_string(),
				Self::Upf => "UPF".to_string(),
				Self::N3iwf => "N3IWF".to_string(),
				Self::Af => "AF".to_string(),
				Self::Udsf => "UDSF".to_string(),
				Self::Bsf => "BSF".to_string(),
				Self::Chf => "CHF".to_string(),
				Self::Nwdaf => "NWDAF".to_string(),
				Self::Pcscf => "PCSCF".to_string(),
				Self::Cbcf => "CBCF".to_string(),
				Self::Hss => "HSS".to_string(),
				Self::Ucmf => "UCMF".to_string(),
				Self::SorAf => "SOR_AF".to_string(),
				Self::Spaf => "SPAF".to_string(),
				Self::Mme => "MME".to_string(),
				Self::Scsas => "SCSAS".to_string(),
				Self::Scef => "SCEF".to_string(),
				Self::Scp => "SCP".to_string(),
				Self::Nssaaf => "NSSAAF".to_string(),
				Self::Icscf => "ICSCF".to_string(),
				Self::Scscf => "SCSCF".to_string(),
				Self::Dra => "DRA".to_string(),
				Self::ImsAs => "IMS_AS".to_string(),
				Self::Aanf => "AANF".to_string(),
				Self::FiveGDdnmf => "5G_DDNMF".to_string(),
				Self::Nsacf => "NSACF".to_string(),
				Self::Mfaf => "MFAF".to_string(),
				Self::Easdf => "EASDF".to_string(),
				Self::Dccf => "DCCF".to_string(),
				Self::MbSmf => "MB_SMF".to_string(),
				Self::Tsctsf => "TSCTSF".to_string(),
				Self::Adrf => "ADRF".to_string(),
				Self::GbaBsf => "GBA_BSF".to_string(),
				Self::Cef => "CEF".to_string(),
				Self::MbUpf => "MB_UPF".to_string(),
				Self::Nswof => "NSWOF".to_string(),
				Self::Pkmf => "PKMF".to_string(),
				Self::Mnpf => "MNPF".to_string(),
				Self::SmsGmsc => "SMS_GMSC".to_string(),
				Self::SmsIwmsc => "SMS_IWMSC".to_string(),
				Self::Mbsf => "MBSF".to_string(),
				Self::Mbstf => "MBSTF".to_string(),
				Self::Panf => "PANF".to_string(),
				Self::IpSmGw => "IP_SM_GW".to_string(),
				Self::SmsRouter => "SMS_ROUTER".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for NfType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"NRF" => Ok(Self::Nrf),
				"UDM" => Ok(Self::Udm),
				"AMF" => Ok(Self::Amf),
				"SMF" => Ok(Self::Smf),
				"AUSF" => Ok(Self::Ausf),
				"NEF" => Ok(Self::Nef),
				"PCF" => Ok(Self::Pcf),
				"SMSF" => Ok(Self::Smsf),
				"NSSF" => Ok(Self::Nssf),
				"UDR" => Ok(Self::Udr),
				"LMF" => Ok(Self::Lmf),
				"GMLC" => Ok(Self::Gmlc),
				"5G_EIR" => Ok(Self::FiveGEir),
				"SEPP" => Ok(Self::Sepp),
				"UPF" => Ok(Self::Upf),
				"N3IWF" => Ok(Self::N3iwf),
				"AF" => Ok(Self::Af),
				"UDSF" => Ok(Self::Udsf),
				"BSF" => Ok(Self::Bsf),
				"CHF" => Ok(Self::Chf),
				"NWDAF" => Ok(Self::Nwdaf),
				"PCSCF" => Ok(Self::Pcscf),
				"CBCF" => Ok(Self::Cbcf),
				"HSS" => Ok(Self::Hss),
				"UCMF" => Ok(Self::Ucmf),
				"SOR_AF" => Ok(Self::SorAf),
				"SPAF" => Ok(Self::Spaf),
				"MME" => Ok(Self::Mme),
				"SCSAS" => Ok(Self::Scsas),
				"SCEF" => Ok(Self::Scef),
				"SCP" => Ok(Self::Scp),
				"NSSAAF" => Ok(Self::Nssaaf),
				"ICSCF" => Ok(Self::Icscf),
				"SCSCF" => Ok(Self::Scscf),
				"DRA" => Ok(Self::Dra),
				"IMS_AS" => Ok(Self::ImsAs),
				"AANF" => Ok(Self::Aanf),
				"5G_DDNMF" => Ok(Self::FiveGDdnmf),
				"NSACF" => Ok(Self::Nsacf),
				"MFAF" => Ok(Self::Mfaf),
				"EASDF" => Ok(Self::Easdf),
				"DCCF" => Ok(Self::Dccf),
				"MB_SMF" => Ok(Self::MbSmf),
				"TSCTSF" => Ok(Self::Tsctsf),
				"ADRF" => Ok(Self::Adrf),
				"GBA_BSF" => Ok(Self::GbaBsf),
				"CEF" => Ok(Self::Cef),
				"MB_UPF" => Ok(Self::MbUpf),
				"NSWOF" => Ok(Self::Nswof),
				"PKMF" => Ok(Self::Pkmf),
				"MNPF" => Ok(Self::Mnpf),
				"SMS_GMSC" => Ok(Self::SmsGmsc),
				"SMS_IWMSC" => Ok(Self::SmsIwmsc),
				"MBSF" => Ok(Self::Mbsf),
				"MBSTF" => Ok(Self::Mbstf),
				"PANF" => Ok(Self::Panf),
				"IP_SM_GW" => Ok(Self::IpSmGw),
				"SMS_ROUTER" => Ok(Self::SmsRouter),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for NfType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for NfType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for NfType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// This represents the identifier of the ng-eNB ID as specified in clause
	/// 9.3.1.8 of  3GPP TS 38.413. The value of the ng-eNB ID shall be encoded
	/// in hexadecimal representation.  Each character in the string shall take
	/// a value of "0" to "9", "a" to "f" or "A" to "F" and  shall represent 4
	/// bits. The padding 0 shall be added to make multiple nibbles, so the most
	/// significant character representing the padding 0 if required together
	/// with the 4 most  significant bits of the ng-eNB ID shall appear first in
	/// the string, and the character  representing the 4 least significant bit
	/// of the ng-eNB ID (to form a nibble) shall appear last  in the string.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This represents the identifier of the ng-eNB ID as
	/// specified in clause 9.3.1.8 of  3GPP TS 38.413. The value of the ng-eNB
	/// ID shall be encoded in hexadecimal representation.  Each character in
	/// the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\"
	/// to \"F\" and  shall represent 4 bits. The padding 0 shall be added to
	/// make multiple nibbles, so the most  significant character representing
	/// the padding 0 if required together with the 4 most  significant bits of
	/// the ng-eNB ID shall appear first in the string, and the character
	/// representing the 4 least significant bit of the ng-eNB ID (to form a
	/// nibble) shall appear last  in the string. \n",
	///  "examples": [
	///    "SMacroNGeNB-34B89"
	///  ],
	///  "type": "string",
	///  "pattern":
	/// "^(MacroNGeNB-[A-Fa-f0-9]{5}|LMacroNGeNB-[A-Fa-f0-9]{6}|SMacroNGeNB-[A-Fa-f0-9]{5})$"
	///
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct NgeNbId(String);
	impl ::std::ops::Deref for NgeNbId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<NgeNbId> for String {
		fn from(value: NgeNbId) -> Self {
			value.0
		}
	}

	impl From<&NgeNbId> for NgeNbId {
		fn from(value: &NgeNbId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for NgeNbId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress :: Regex :: new ("^(MacroNGeNB-[A-Fa-f0-9]{5}|LMacroNGeNB-[A-Fa-f0-9]{6}|SMacroNGeNB-[A-Fa-f0-9]{5})$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(MacroNGeNB-[A-Fa-f0-9]{5}|LMacroNGeNB-[A-Fa-f0-9]{6}|SMacroNGeNB-[A-Fa-f0-9]{5})$\"" . into ()) ; }
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for NgeNbId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for NgeNbId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for NgeNbId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for NgeNbId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// This represents the Network Identifier, which together with a PLMN ID is
	/// used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause
	/// 5.30.2.1).
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This represents the Network Identifier, which together
	/// with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP
	/// TS 23.501 clause 5.30.2.1). \n",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{11}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Nid(String);
	impl ::std::ops::Deref for Nid {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Nid> for String {
		fn from(value: Nid) -> Self {
			value.0
		}
	}

	impl From<&Nid> for Nid {
		fn from(value: &Nid) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Nid {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{11}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{11}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Nid {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Nid {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Nid {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Nid {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Represents NIDD authorization update information.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents NIDD authorization update information.",
	///  "type": "object",
	///  "required": [
	///    "authorizationData"
	///  ],
	///  "properties": {
	///    "authorizationData": {
	///      "$ref": "#/components/schemas/AuthorizationData"
	///    },
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "invalidityInd": {
	///      "type": "boolean"
	///    },
	///    "niddCause": {
	///      "$ref": "#/components/schemas/NiddCause"
	///    },
	///    "snssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NiddAuthUpdateInfo {
		#[serde(rename = "authorizationData")]
		pub authorization_data: AuthorizationData,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub dnn: Option<Dnn>,
		#[serde(
			rename = "invalidityInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub invalidity_ind: Option<bool>,
		#[serde(rename = "niddCause", default, skip_serializing_if = "Option::is_none")]
		pub nidd_cause: Option<NiddCause>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub snssai: Option<Snssai>,
	}

	impl From<&NiddAuthUpdateInfo> for NiddAuthUpdateInfo {
		fn from(value: &NiddAuthUpdateInfo) -> Self {
			value.clone()
		}
	}

	/// Represents a NIDD authorization update notification.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents a NIDD authorization update notification.",
	///  "type": "object",
	///  "required": [
	///    "niddAuthUpdateInfoList"
	///  ],
	///  "properties": {
	///    "niddAuthUpdateInfoList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/NiddAuthUpdateInfo"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NiddAuthUpdateNotification {
		#[serde(rename = "niddAuthUpdateInfoList")]
		pub nidd_auth_update_info_list: Vec<NiddAuthUpdateInfo>,
	}

	impl From<&NiddAuthUpdateNotification> for NiddAuthUpdateNotification {
		fn from(value: &NiddAuthUpdateNotification) -> Self {
			value.clone()
		}
	}

	/// NiddCause
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "SUBSCRIPTION_WITHDRAWAL",
	///    "DNN_REMOVED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum NiddCause {
		#[default]
		#[serde(rename = "SUBSCRIPTION_WITHDRAWAL")]
		SubscriptionWithdrawal,
		#[serde(rename = "DNN_REMOVED")]
		DnnRemoved,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&NiddCause> for NiddCause {
		fn from(value: &NiddCause) -> Self {
			value.clone()
		}
	}

	impl ToString for NiddCause {
		fn to_string(&self) -> String {
			match *self {
				Self::SubscriptionWithdrawal => "SUBSCRIPTION_WITHDRAWAL".to_string(),
				Self::DnnRemoved => "DNN_REMOVED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for NiddCause {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"SUBSCRIPTION_WITHDRAWAL" => Ok(Self::SubscriptionWithdrawal),
				"DNN_REMOVED" => Ok(Self::DnnRemoved),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for NiddCause {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for NiddCause {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for NiddCause {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// NiddInformation
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "afId"
	///  ],
	///  "properties": {
	///    "afId": {
	///      "type": "string"
	///    },
	///    "extGroupId": {
	///      "$ref": "#/components/schemas/ExternalGroupId"
	///    },
	///    "gpsi": {
	///      "$ref": "#/components/schemas/Gpsi"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NiddInformation {
		#[serde(rename = "afId")]
		pub af_id: String,
		#[serde(
			rename = "extGroupId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ext_group_id: Option<ExternalGroupId>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub gpsi: Option<Gpsi>,
	}

	impl From<&NiddInformation> for NiddInformation {
		fn from(value: &NiddInformation) -> Self {
			value.clone()
		}
	}

	/// NodeType
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "AUSF",
	///    "VLR",
	///    "SGSN",
	///    "S_CSCF",
	///    "BSF",
	///    "GAN_AAA_SERVER",
	///    "WLAN_AAA_SERVER",
	///    "MME"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum NodeType {
		#[default]
		#[serde(rename = "AUSF")]
		Ausf,
		#[serde(rename = "VLR")]
		Vlr,
		#[serde(rename = "SGSN")]
		Sgsn,
		#[serde(rename = "S_CSCF")]
		SCscf,
		#[serde(rename = "BSF")]
		Bsf,
		#[serde(rename = "GAN_AAA_SERVER")]
		GanAaaServer,
		#[serde(rename = "WLAN_AAA_SERVER")]
		WlanAaaServer,
		#[serde(rename = "MME")]
		Mme,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&NodeType> for NodeType {
		fn from(value: &NodeType) -> Self {
			value.clone()
		}
	}

	impl ToString for NodeType {
		fn to_string(&self) -> String {
			match *self {
				Self::Ausf => "AUSF".to_string(),
				Self::Vlr => "VLR".to_string(),
				Self::Sgsn => "SGSN".to_string(),
				Self::SCscf => "S_CSCF".to_string(),
				Self::Bsf => "BSF".to_string(),
				Self::GanAaaServer => "GAN_AAA_SERVER".to_string(),
				Self::WlanAaaServer => "WLAN_AAA_SERVER".to_string(),
				Self::Mme => "MME".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for NodeType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"AUSF" => Ok(Self::Ausf),
				"VLR" => Ok(Self::Vlr),
				"SGSN" => Ok(Self::Sgsn),
				"S_CSCF" => Ok(Self::SCscf),
				"BSF" => Ok(Self::Bsf),
				"GAN_AAA_SERVER" => Ok(Self::GanAaaServer),
				"WLAN_AAA_SERVER" => Ok(Self::WlanAaaServer),
				"MME" => Ok(Self::Mme),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for NodeType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for NodeType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for NodeType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Possible values are:
	/// - ACTIVATE: The event notification is activated.
	/// - DEACTIVATE: The event notification is deactivated and shall be muted.
	///   The available event(s) shall be stored.
	/// - RETRIEVAL: The event notification shall be sent to the NF service
	///   consumer(s),
	///  after that, is muted again.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Possible values are:\n- ACTIVATE: The event
	/// notification is activated.\n- DEACTIVATE: The event notification is
	/// deactivated and shall be muted. The available\n   event(s) shall be
	/// stored.\n- RETRIEVAL: The event notification shall be sent to the NF
	/// service consumer(s),\n  after that, is muted again. \n",
	///  "type": "string",
	///  "enum": [
	///    "ACTIVATE",
	///    "DEACTIVATE",
	///    "RETRIEVAL"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum NotificationFlag {
		#[default]
		#[serde(rename = "ACTIVATE")]
		Activate,
		#[serde(rename = "DEACTIVATE")]
		Deactivate,
		#[serde(rename = "RETRIEVAL")]
		Retrieval,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&NotificationFlag> for NotificationFlag {
		fn from(value: &NotificationFlag) -> Self {
			value.clone()
		}
	}

	impl ToString for NotificationFlag {
		fn to_string(&self) -> String {
			match *self {
				Self::Activate => "ACTIVATE".to_string(),
				Self::Deactivate => "DEACTIVATE".to_string(),
				Self::Retrieval => "RETRIEVAL".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for NotificationFlag {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"ACTIVATE" => Ok(Self::Activate),
				"DEACTIVATE" => Ok(Self::Deactivate),
				"RETRIEVAL" => Ok(Self::Retrieval),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for NotificationFlag {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for NotificationFlag {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for NotificationFlag {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Indicates changes on a resource.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates changes on a resource.",
	///  "type": "object",
	///  "required": [
	///    "changes",
	///    "resourceId"
	///  ],
	///  "properties": {
	///    "changes": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/ChangeItem"
	///      },
	///      "minItems": 1
	///    },
	///    "resourceId": {
	///      "$ref": "#/components/schemas/Uri"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NotifyItem {
		pub changes: Vec<ChangeItem>,
		#[serde(rename = "resourceId")]
		pub resource_id: Uri,
	}

	impl From<&NotifyItem> for NotifyItem {
		fn from(value: &NotifyItem) -> Self {
			value.clone()
		}
	}

	/// 36-bit string identifying an NR Cell Id as specified in clause 9.3.1.7
	/// of 3GPP TS 38.413,  in hexadecimal representation. Each character in the
	/// string shall take a value of "0" to "9",  "a" to "f" or "A" to "F" and
	/// shall represent 4 bits. The most significant character  representing the
	/// 4 most significant bits of the Cell Id shall appear first in the string,
	/// and  the character representing the 4 least significant bit of the Cell
	/// Id shall appear last in the  string.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "36-bit string identifying an NR Cell Id as specified in clause 9.3.1.7 of 3GPP TS 38.413,  in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character  representing the 4 most significant bits of the Cell Id shall appear first in the string, and  the character representing the 4 least significant bit of the Cell Id shall appear last in the  string. \n",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{9}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct NrCellId(String);
	impl ::std::ops::Deref for NrCellId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<NrCellId> for String {
		fn from(value: NrCellId) -> Self {
			value.0
		}
	}

	impl From<&NrCellId> for NrCellId {
		fn from(value: &NrCellId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for NrCellId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{9}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{9}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for NrCellId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for NrCellId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for NrCellId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for NrCellId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Contains the NR user location.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the NR user location.",
	///  "type": "object",
	///  "required": [
	///    "ncgi",
	///    "tai"
	///  ],
	///  "properties": {
	///    "ageOfLocationInformation": {
	///      "description": "The value represents the elapsed time in minutes
	/// since the last network contact of the mobile station. Value \"0\"
	/// indicates that the location information was obtained after a successful
	/// paging procedure for Active Location Retrieval when the UE is in idle
	/// mode or after a successful  NG-RAN location reporting procedure with the
	/// eNB when the UE is in connected mode. Any other value than \"0\"
	/// indicates that the location information is the last known one. See 3GPP
	/// TS 29.002 clause 17.7.8.\n",
	///      "type": "integer",
	///      "maximum": 32767.0,
	///      "minimum": 0.0
	///    },
	///    "geodeticInformation": {
	///      "description": "Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763 (1999) [24] clause 3.88.2. Only the description of an ellipsoid point with uncertainty circle is allowed to be used.\n",
	///      "type": "string",
	///      "pattern": "^[0-9A-F]{20}$"
	///    },
	///    "geographicalInformation": {
	///      "description": "Refer to geographical Information. See 3GPP TS
	/// 23.032 clause 7.3.2. Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.\n",
	///      "type": "string",
	///      "pattern": "^[0-9A-F]{16}$"
	///    },
	///    "globalGnbId": {
	///      "$ref": "#/components/schemas/GlobalRanNodeId"
	///    },
	///    "ignoreNcgi": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "ncgi": {
	///      "$ref": "#/components/schemas/Ncgi"
	///    },
	///    "tai": {
	///      "$ref": "#/components/schemas/Tai"
	///    },
	///    "ueLocationTimestamp": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NrLocation {
		/// The value represents the elapsed time in minutes since the last
		/// network contact of the mobile station. Value "0" indicates that the
		/// location information was obtained after a successful paging
		/// procedure for Active Location Retrieval when the UE is in idle mode
		/// or after a successful  NG-RAN location reporting procedure with the
		/// eNB when the UE is in connected mode. Any other value than "0"
		/// indicates that the location information is the last known one. See
		/// 3GPP TS 29.002 clause 17.7.8.
		#[serde(
			rename = "ageOfLocationInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub age_of_location_information: Option<i64>,
		/// Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763
		/// (1999) [24] clause 3.88.2. Only the description of an ellipsoid
		/// point with uncertainty circle is allowed to be used.
		#[serde(
			rename = "geodeticInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub geodetic_information: Option<NrLocationGeodeticInformation>,
		/// Refer to geographical Information. See 3GPP TS 23.032 clause 7.3.2.
		/// Only the description of an ellipsoid point with uncertainty circle
		/// is allowed to be used.
		#[serde(
			rename = "geographicalInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub geographical_information: Option<NrLocationGeographicalInformation>,
		#[serde(
			rename = "globalGnbId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub global_gnb_id: Option<GlobalRanNodeId>,
		#[serde(rename = "ignoreNcgi", default)]
		pub ignore_ncgi: bool,
		pub ncgi: Ncgi,
		pub tai: Tai,
		#[serde(
			rename = "ueLocationTimestamp",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ue_location_timestamp: Option<DateTime>,
	}

	impl From<&NrLocation> for NrLocation {
		fn from(value: &NrLocation) -> Self {
			value.clone()
		}
	}

	/// Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763
	/// (1999) [24] clause 3.88.2. Only the description of an ellipsoid point
	/// with uncertainty circle is allowed to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763 (1999) [24] clause 3.88.2. Only the description of an ellipsoid point with uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{20}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct NrLocationGeodeticInformation(String);
	impl ::std::ops::Deref for NrLocationGeodeticInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<NrLocationGeodeticInformation> for String {
		fn from(value: NrLocationGeodeticInformation) -> Self {
			value.0
		}
	}

	impl From<&NrLocationGeodeticInformation> for NrLocationGeodeticInformation {
		fn from(value: &NrLocationGeodeticInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for NrLocationGeodeticInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{20}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for NrLocationGeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for NrLocationGeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for NrLocationGeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for NrLocationGeodeticInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Refer to geographical Information. See 3GPP TS 23.032 clause 7.3.2. Only
	/// the description of an ellipsoid point with uncertainty circle is allowed
	/// to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refer to geographical Information. See 3GPP TS 23.032
	/// clause 7.3.2. Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{16}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct NrLocationGeographicalInformation(String);
	impl ::std::ops::Deref for NrLocationGeographicalInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<NrLocationGeographicalInformation> for String {
		fn from(value: NrLocationGeographicalInformation) -> Self {
			value.0
		}
	}

	impl From<&NrLocationGeographicalInformation> for NrLocationGeographicalInformation {
		fn from(value: &NrLocationGeographicalInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for NrLocationGeographicalInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{16}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for NrLocationGeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for NrLocationGeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for NrLocationGeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for NrLocationGeographicalInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Contains NR V2X services authorized information.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains NR V2X services authorized information.",
	///  "type": "object",
	///  "properties": {
	///    "pedestrianUeAuth": {
	///      "$ref": "#/components/schemas/UeAuth"
	///    },
	///    "vehicleUeAuth": {
	///      "$ref": "#/components/schemas/UeAuth"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NrV2xAuth {
		#[serde(
			rename = "pedestrianUeAuth",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pedestrian_ue_auth: Option<UeAuth>,
		#[serde(
			rename = "vehicleUeAuth",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub vehicle_ue_auth: Option<UeAuth>,
	}

	impl From<&NrV2xAuth> for NrV2xAuth {
		fn from(value: &NrV2xAuth) -> Self {
			value.clone()
		}
	}

	/// String providing a Network Slice Simultaneous Registration Group. See
	/// clause 5.15.12 of  3GPP TS 23.501
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String providing a Network Slice Simultaneous
	/// Registration Group. See clause 5.15.12 of  3GPP TS 23.501\n",
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct NsSrg(pub String);
	impl ::std::ops::Deref for NsSrg {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<NsSrg> for String {
		fn from(value: NsSrg) -> Self {
			value.0
		}
	}

	impl From<&NsSrg> for NsSrg {
		fn from(value: &NsSrg) -> Self {
			value.clone()
		}
	}

	impl From<String> for NsSrg {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for NsSrg {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for NsSrg {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Nssai
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "required": [
	///    "defaultSingleNssais"
	///  ],
	///  "properties": {
	///    "additionalSnssaiData": {
	///      "description": "A map(list of key-value pairs) where singleNssai
	/// serves as key of AdditionalSnssaiData",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/AdditionalSnssaiData"
	///      }
	///    },
	///    "defaultSingleNssais": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Snssai"
	///      },
	///      "minItems": 1
	///    },
	///    "provisioningTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "singleNssais": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Snssai"
	///      },
	///      "minItems": 1
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "suppressNssrgInd": {
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Nssai(pub Option<NssaiInner>);
	impl ::std::ops::Deref for Nssai {
		type Target = Option<NssaiInner>;
		fn deref(&self) -> &Option<NssaiInner> {
			&self.0
		}
	}

	impl From<Nssai> for Option<NssaiInner> {
		fn from(value: Nssai) -> Self {
			value.0
		}
	}

	impl From<&Nssai> for Nssai {
		fn from(value: &Nssai) -> Self {
			value.clone()
		}
	}

	impl From<Option<NssaiInner>> for Nssai {
		fn from(value: Option<NssaiInner>) -> Self {
			Self(value)
		}
	}

	/// NssaiInner
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "defaultSingleNssais"
	///  ],
	///  "properties": {
	///    "additionalSnssaiData": {
	///      "description": "A map(list of key-value pairs) where singleNssai
	/// serves as key of AdditionalSnssaiData",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/AdditionalSnssaiData"
	///      }
	///    },
	///    "defaultSingleNssais": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Snssai"
	///      },
	///      "minItems": 1
	///    },
	///    "provisioningTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "singleNssais": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Snssai"
	///      },
	///      "minItems": 1
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "suppressNssrgInd": {
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NssaiInner {
		/// A map(list of key-value pairs) where singleNssai serves as key of
		/// AdditionalSnssaiData
		#[serde(
			rename = "additionalSnssaiData",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub additional_snssai_data: ::std::collections::HashMap<String, AdditionalSnssaiData>,
		#[serde(rename = "defaultSingleNssais")]
		pub default_single_nssais: Vec<Snssai>,
		#[serde(
			rename = "provisioningTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub provisioning_time: Option<DateTime>,
		#[serde(
			rename = "singleNssais",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub single_nssais: Vec<Snssai>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
		#[serde(
			rename = "suppressNssrgInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub suppress_nssrg_ind: Option<bool>,
	}

	impl From<&NssaiInner> for NssaiInner {
		fn from(value: &NssaiInner) -> Self {
			value.clone()
		}
	}

	/// JSON's null value.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "JSON's null value.",
	///  "type": "null"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NullValue(pub ());
	impl ::std::ops::Deref for NullValue {
		type Target = ();
		fn deref(&self) -> &() {
			&self.0
		}
	}

	impl From<NullValue> for () {
		fn from(value: NullValue) -> Self {
			value.0
		}
	}

	impl From<&NullValue> for NullValue {
		fn from(value: &NullValue) -> Self {
			value.clone()
		}
	}

	impl From<()> for NullValue {
		fn from(value: ()) -> Self {
			Self(value)
		}
	}

	/// NumOfRequestedVectors
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "integer",
	///  "maximum": 5.0,
	///  "minimum": 1.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NumOfRequestedVectors(pub i64);
	impl ::std::ops::Deref for NumOfRequestedVectors {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<NumOfRequestedVectors> for i64 {
		fn from(value: NumOfRequestedVectors) -> Self {
			value.0
		}
	}

	impl From<&NumOfRequestedVectors> for NumOfRequestedVectors {
		fn from(value: &NumOfRequestedVectors) -> Self {
			value.clone()
		}
	}

	impl From<i64> for NumOfRequestedVectors {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for NumOfRequestedVectors {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for NumOfRequestedVectors {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for NumOfRequestedVectors {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for NumOfRequestedVectors {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for NumOfRequestedVectors {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// The complete set of information relevant to an NWDAF serving the UE
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The complete set of information relevant to an NWDAF
	/// serving the UE",
	///  "type": "object",
	///  "required": [
	///    "analyticsIds",
	///    "nwdafInstanceId"
	///  ],
	///  "properties": {
	///    "analyticsIds": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/EventId"
	///      },
	///      "minItems": 1
	///    },
	///    "contextInfo": {
	///      "$ref": "#/components/schemas/ContextInfo"
	///    },
	///    "nwdafInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "nwdafSetId": {
	///      "$ref": "#/components/schemas/NfSetId"
	///    },
	///    "registrationTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "resetIds": {
	///      "type": "array",
	///      "items": {
	///        "type": "string"
	///      },
	///      "minItems": 1
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NwdafRegistration {
		#[serde(rename = "analyticsIds")]
		pub analytics_ids: Vec<EventId>,
		#[serde(
			rename = "contextInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub context_info: Option<ContextInfo>,
		#[serde(rename = "nwdafInstanceId")]
		pub nwdaf_instance_id: NfInstanceId,
		#[serde(
			rename = "nwdafSetId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub nwdaf_set_id: Option<NfSetId>,
		#[serde(
			rename = "registrationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub registration_time: Option<DateTime>,
		#[serde(rename = "resetIds", default, skip_serializing_if = "Vec::is_empty")]
		pub reset_ids: Vec<String>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&NwdafRegistration> for NwdafRegistration {
		fn from(value: &NwdafRegistration) -> Self {
			value.clone()
		}
	}

	/// List of NwdafRegistration
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "List of NwdafRegistration",
	///  "type": "object",
	///  "required": [
	///    "nwdafRegistrationList"
	///  ],
	///  "properties": {
	///    "nwdafRegistrationList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/NwdafRegistration"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NwdafRegistrationInfo {
		#[serde(rename = "nwdafRegistrationList")]
		pub nwdaf_registration_list: Vec<NwdafRegistration>,
	}

	impl From<&NwdafRegistrationInfo> for NwdafRegistrationInfo {
		fn from(value: &NwdafRegistrationInfo) -> Self {
			value.clone()
		}
	}

	/// Contains attributes of NwdafRegistration that can be modified using
	/// PATCH
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains attributes of NwdafRegistration that can be
	/// modified using PATCH",
	///  "type": "object",
	///  "required": [
	///    "nwdafInstanceId"
	///  ],
	///  "properties": {
	///    "analyticsIds": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/EventId"
	///      }
	///    },
	///    "nwdafInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "nwdafSetId": {
	///      "$ref": "#/components/schemas/NfSetId"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct NwdafRegistrationModification {
		#[serde(
			rename = "analyticsIds",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub analytics_ids: Vec<EventId>,
		#[serde(rename = "nwdafInstanceId")]
		pub nwdaf_instance_id: NfInstanceId,
		#[serde(
			rename = "nwdafSetId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub nwdaf_set_id: Option<NfSetId>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&NwdafRegistrationModification> for NwdafRegistrationModification {
		fn from(value: &NwdafRegistrationModification) -> Self {
			value.clone()
		}
	}

	/// The enumeration OdbPacketServices defines the Barring of Packet Oriented
	/// Services. See 3GPP TS 23.015 for further description. It shall comply
	/// with the provisions defined in table 5.7.3.2-1
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration OdbPacketServices defines the Barring
	/// of Packet Oriented Services. See 3GPP TS 23.015 for further description.
	/// It shall comply with the provisions defined in table 5.7.3.2-1\n",
	///  "anyOf": [
	///    {
	///      "type": "string",
	///      "enum": [
	///        "ALL_PACKET_SERVICES",
	///        "ROAMER_ACCESS_HPLMN_AP",
	///        "ROAMER_ACCESS_VPLMN_AP"
	///      ],
	///      "x-allow-unknown": true
	///    },
	///    {
	///      "$ref": "#/components/schemas/NullValue"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum OdbPacketServices {
		#[default]
		Variant0(OdbPacketServicesVariant0),
		Variant1(NullValue),
	}

	impl From<&OdbPacketServices> for OdbPacketServices {
		fn from(value: &OdbPacketServices) -> Self {
			value.clone()
		}
	}

	impl From<OdbPacketServicesVariant0> for OdbPacketServices {
		fn from(value: OdbPacketServicesVariant0) -> Self {
			Self::Variant0(value)
		}
	}

	impl From<NullValue> for OdbPacketServices {
		fn from(value: NullValue) -> Self {
			Self::Variant1(value)
		}
	}

	/// OdbPacketServicesVariant0
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "ALL_PACKET_SERVICES",
	///    "ROAMER_ACCESS_HPLMN_AP",
	///    "ROAMER_ACCESS_VPLMN_AP"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum OdbPacketServicesVariant0 {
		#[default]
		#[serde(rename = "ALL_PACKET_SERVICES")]
		AllPacketServices,
		#[serde(rename = "ROAMER_ACCESS_HPLMN_AP")]
		RoamerAccessHplmnAp,
		#[serde(rename = "ROAMER_ACCESS_VPLMN_AP")]
		RoamerAccessVplmnAp,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&OdbPacketServicesVariant0> for OdbPacketServicesVariant0 {
		fn from(value: &OdbPacketServicesVariant0) -> Self {
			value.clone()
		}
	}

	impl ToString for OdbPacketServicesVariant0 {
		fn to_string(&self) -> String {
			match *self {
				Self::AllPacketServices => "ALL_PACKET_SERVICES".to_string(),
				Self::RoamerAccessHplmnAp => "ROAMER_ACCESS_HPLMN_AP".to_string(),
				Self::RoamerAccessVplmnAp => "ROAMER_ACCESS_VPLMN_AP".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for OdbPacketServicesVariant0 {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"ALL_PACKET_SERVICES" => Ok(Self::AllPacketServices),
				"ROAMER_ACCESS_HPLMN_AP" => Ok(Self::RoamerAccessHplmnAp),
				"ROAMER_ACCESS_VPLMN_AP" => Ok(Self::RoamerAccessVplmnAp),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for OdbPacketServicesVariant0 {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for OdbPacketServicesVariant0 {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for OdbPacketServicesVariant0 {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// OperationMode
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "WB_S1",
	///    "NB_S1",
	///    "WB_N1",
	///    "NB_N1",
	///    "NR_N1"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum OperationMode {
		#[default]
		#[serde(rename = "WB_S1")]
		WbS1,
		#[serde(rename = "NB_S1")]
		NbS1,
		#[serde(rename = "WB_N1")]
		WbN1,
		#[serde(rename = "NB_N1")]
		NbN1,
		#[serde(rename = "NR_N1")]
		NrN1,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&OperationMode> for OperationMode {
		fn from(value: &OperationMode) -> Self {
			value.clone()
		}
	}

	impl ToString for OperationMode {
		fn to_string(&self) -> String {
			match *self {
				Self::WbS1 => "WB_S1".to_string(),
				Self::NbS1 => "NB_S1".to_string(),
				Self::WbN1 => "WB_N1".to_string(),
				Self::NbN1 => "NB_N1".to_string(),
				Self::NrN1 => "NR_N1".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for OperationMode {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"WB_S1" => Ok(Self::WbS1),
				"NB_S1" => Ok(Self::NbS1),
				"WB_N1" => Ok(Self::WbN1),
				"NB_N1" => Ok(Self::NbN1),
				"NR_N1" => Ok(Self::NrN1),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for OperationMode {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for OperationMode {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for OperationMode {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Indicates value of orientation angle.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates value of orientation angle.",
	///  "type": "integer",
	///  "maximum": 180.0,
	///  "minimum": 0.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Orientation(pub i64);
	impl ::std::ops::Deref for Orientation {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<Orientation> for i64 {
		fn from(value: Orientation) -> Self {
			value.0
		}
	}

	impl From<&Orientation> for Orientation {
		fn from(value: &Orientation) -> Self {
			value.clone()
		}
	}

	impl From<i64> for Orientation {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for Orientation {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for Orientation {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for Orientation {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for Orientation {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for Orientation {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Represents the Operating System of the served UE.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents the Operating System of the served UE.",
	///  "type": "string",
	///  "format": "uuid"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct OsId(pub uuid::Uuid);
	impl ::std::ops::Deref for OsId {
		type Target = uuid::Uuid;
		fn deref(&self) -> &uuid::Uuid {
			&self.0
		}
	}

	impl From<OsId> for uuid::Uuid {
		fn from(value: OsId) -> Self {
			value.0
		}
	}

	impl From<&OsId> for OsId {
		fn from(value: &OsId) -> Self {
			value.clone()
		}
	}

	impl From<uuid::Uuid> for OsId {
		fn from(value: uuid::Uuid) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for OsId {
		type Err = <uuid::Uuid as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for OsId {
		type Error = <uuid::Uuid as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for OsId {
		type Error = <uuid::Uuid as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for OsId {
		type Error = <uuid::Uuid as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for OsId {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// it contains information on data to be changed.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "it contains information on data to be changed.",
	///  "type": "object",
	///  "required": [
	///    "op",
	///    "path"
	///  ],
	///  "properties": {
	///    "from": {
	///      "description": "indicates the path of the source JSON element
	/// (according to JSON Pointer syntax) being moved or copied to the location
	/// indicated by the \"path\" attribute.\n",
	///      "type": "string"
	///    },
	///    "op": {
	///      "$ref": "#/components/schemas/PatchOperation"
	///    },
	///    "path": {
	///      "description": "contains a JSON pointer value (as defined in IETF
	/// RFC 6901) that references a location of a resource on which the patch
	/// operation shall be performed.\n",
	///      "type": "string"
	///    },
	///    "value": {}
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PatchItem {
		/// indicates the path of the source JSON element (according to JSON
		/// Pointer syntax) being moved or copied to the location indicated by
		/// the "path" attribute.
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub from: Option<String>,
		pub op: PatchOperation,
		/// contains a JSON pointer value (as defined in IETF RFC 6901) that
		/// references a location of a resource on which the patch operation
		/// shall be performed.
		pub path: String,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub value: Option<::serde_json::Value>,
	}

	impl From<&PatchItem> for PatchItem {
		fn from(value: &PatchItem) -> Self {
			value.clone()
		}
	}

	/// Operations as defined in IETF RFC 6902.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Operations as defined in IETF RFC 6902.",
	///  "type": "string",
	///  "enum": [
	///    "add",
	///    "copy",
	///    "move",
	///    "remove",
	///    "replace",
	///    "test"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum PatchOperation {
		#[default]
		#[serde(rename = "add")]
		Add,
		#[serde(rename = "copy")]
		Copy,
		#[serde(rename = "move")]
		Move,
		#[serde(rename = "remove")]
		Remove,
		#[serde(rename = "replace")]
		Replace,
		#[serde(rename = "test")]
		Test,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&PatchOperation> for PatchOperation {
		fn from(value: &PatchOperation) -> Self {
			value.clone()
		}
	}

	impl ToString for PatchOperation {
		fn to_string(&self) -> String {
			match *self {
				Self::Add => "add".to_string(),
				Self::Copy => "copy".to_string(),
				Self::Move => "move".to_string(),
				Self::Remove => "remove".to_string(),
				Self::Replace => "replace".to_string(),
				Self::Test => "test".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for PatchOperation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"add" => Ok(Self::Add),
				"copy" => Ok(Self::Copy),
				"move" => Ok(Self::Move),
				"remove" => Ok(Self::Remove),
				"replace" => Ok(Self::Replace),
				"test" => Ok(Self::Test),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for PatchOperation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for PatchOperation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for PatchOperation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// The execution report result on failed modification.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The execution report result on failed modification.",
	///  "type": "object",
	///  "required": [
	///    "report"
	///  ],
	///  "properties": {
	///    "report": {
	///      "description": "The execution report contains an array of report
	/// items. Each report item indicates one  failed modification.\n",
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/ReportItem"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PatchResult {
		/// The execution report contains an array of report items. Each report
		/// item indicates one  failed modification.
		pub report: Vec<ReportItem>,
	}

	impl From<&PatchResult> for PatchResult {
		fn from(value: &PatchResult) -> Self {
			value.clone()
		}
	}

	/// PcfSelectionAssistanceInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "dnn",
	///    "singleNssai"
	///  ],
	///  "properties": {
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "singleNssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PcfSelectionAssistanceInfo {
		pub dnn: Dnn,
		#[serde(rename = "singleNssai")]
		pub single_nssai: Snssai,
	}

	impl From<&PcfSelectionAssistanceInfo> for PcfSelectionAssistanceInfo {
		fn from(value: &PcfSelectionAssistanceInfo) -> Self {
			value.clone()
		}
	}

	/// Contains the addressing information (IP addresses and/or FQDN) of the
	/// P-CSCF
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the addressing information (IP addresses
	/// and/or FQDN) of the P-CSCF",
	///  "type": "object",
	///  "anyOf": [
	///    {
	///      "required": [
	///        "ipv4Addrs"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "ipv6Addrs"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "fqdn"
	///      ]
	///    }
	///  ],
	///  "properties": {
	///    "fqdn": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "ipv4Addrs": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Ipv4Addr"
	///      },
	///      "minItems": 1
	///    },
	///    "ipv6Addrs": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Ipv6Addr"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum PcscfAddress {
		#[default]
		Variant0 {
			#[serde(rename = "ipv4Addrs")]
			ipv4_addrs: Vec<Ipv4Addr>,
		},
		Variant1 {
			#[serde(rename = "ipv6Addrs")]
			ipv6_addrs: Vec<Ipv6Addr>,
		},
		Variant2 {
			fqdn: Fqdn,
		},
	}

	impl From<&PcscfAddress> for PcscfAddress {
		fn from(value: &PcscfAddress) -> Self {
			value.clone()
		}
	}

	/// PcscfRestorationNotification
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "supi"
	///  ],
	///  "properties": {
	///    "failedPcscf": {
	///      "$ref": "#/components/schemas/PcscfAddress"
	///    },
	///    "supi": {
	///      "$ref": "#/components/schemas/Supi"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PcscfRestorationNotification {
		#[serde(
			rename = "failedPcscf",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub failed_pcscf: Option<PcscfAddress>,
		pub supi: Supi,
	}

	impl From<&PcscfRestorationNotification> for PcscfRestorationNotification {
		fn from(value: &PcscfRestorationNotification) -> Self {
			value.clone()
		}
	}

	/// PdnConnectivityStatReport
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "pdnConnStat"
	///  ],
	///  "properties": {
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "ipv4Addr": {
	///      "$ref": "#/components/schemas/Ipv4Addr"
	///    },
	///    "ipv6Addrs": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Ipv6Addr"
	///      },
	///      "minItems": 1
	///    },
	///    "ipv6Prefixes": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Ipv6Prefix"
	///      },
	///      "minItems": 1
	///    },
	///    "pdnConnStat": {
	///      "$ref": "#/components/schemas/PdnConnectivityStatus"
	///    },
	///    "pduSeId": {
	///      "$ref": "#/components/schemas/PduSessionId"
	///    },
	///    "pduSessType": {
	///      "$ref": "#/components/schemas/PduSessionType"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PdnConnectivityStatReport {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub dnn: Option<Dnn>,
		#[serde(rename = "ipv4Addr", default, skip_serializing_if = "Option::is_none")]
		pub ipv4_addr: Option<Ipv4Addr>,
		#[serde(rename = "ipv6Addrs", default, skip_serializing_if = "Vec::is_empty")]
		pub ipv6_addrs: Vec<Ipv6Addr>,
		#[serde(
			rename = "ipv6Prefixes",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub ipv6_prefixes: Vec<Ipv6Prefix>,
		#[serde(rename = "pdnConnStat")]
		pub pdn_conn_stat: PdnConnectivityStatus,
		#[serde(rename = "pduSeId", default, skip_serializing_if = "Option::is_none")]
		pub pdu_se_id: Option<PduSessionId>,
		#[serde(
			rename = "pduSessType",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pdu_sess_type: Option<PduSessionType>,
	}

	impl From<&PdnConnectivityStatReport> for PdnConnectivityStatReport {
		fn from(value: &PdnConnectivityStatReport) -> Self {
			value.clone()
		}
	}

	/// PdnConnectivityStatus
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "ESTABLISHED",
	///    "RELEASED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum PdnConnectivityStatus {
		#[default]
		#[serde(rename = "ESTABLISHED")]
		Established,
		#[serde(rename = "RELEASED")]
		Released,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&PdnConnectivityStatus> for PdnConnectivityStatus {
		fn from(value: &PdnConnectivityStatus) -> Self {
			value.clone()
		}
	}

	impl ToString for PdnConnectivityStatus {
		fn to_string(&self) -> String {
			match *self {
				Self::Established => "ESTABLISHED".to_string(),
				Self::Released => "RELEASED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for PdnConnectivityStatus {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"ESTABLISHED" => Ok(Self::Established),
				"RELEASED" => Ok(Self::Released),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for PdnConnectivityStatus {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for PdnConnectivityStatus {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for PdnConnectivityStatus {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// PduSession
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "dnn",
	///    "plmnId",
	///    "smfInstanceId"
	///  ],
	///  "properties": {
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "singleNssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    },
	///    "smfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PduSession {
		pub dnn: Dnn,
		#[serde(rename = "plmnId")]
		pub plmn_id: PlmnId,
		#[serde(
			rename = "singleNssai",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub single_nssai: Option<Snssai>,
		#[serde(rename = "smfInstanceId")]
		pub smf_instance_id: NfInstanceId,
	}

	impl From<&PduSession> for PduSession {
		fn from(value: &PduSession) -> Self {
			value.clone()
		}
	}

	/// PduSessionContinuityInd
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "MAINTAIN_PDUSESSION",
	///    "RECONNECT_PDUSESSION",
	///    "RELEASE_PDUSESSION"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum PduSessionContinuityInd {
		#[default]
		#[serde(rename = "MAINTAIN_PDUSESSION")]
		MaintainPdusession,
		#[serde(rename = "RECONNECT_PDUSESSION")]
		ReconnectPdusession,
		#[serde(rename = "RELEASE_PDUSESSION")]
		ReleasePdusession,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&PduSessionContinuityInd> for PduSessionContinuityInd {
		fn from(value: &PduSessionContinuityInd) -> Self {
			value.clone()
		}
	}

	impl ToString for PduSessionContinuityInd {
		fn to_string(&self) -> String {
			match *self {
				Self::MaintainPdusession => "MAINTAIN_PDUSESSION".to_string(),
				Self::ReconnectPdusession => "RECONNECT_PDUSESSION".to_string(),
				Self::ReleasePdusession => "RELEASE_PDUSESSION".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for PduSessionContinuityInd {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"MAINTAIN_PDUSESSION" => Ok(Self::MaintainPdusession),
				"RECONNECT_PDUSESSION" => Ok(Self::ReconnectPdusession),
				"RELEASE_PDUSESSION" => Ok(Self::ReleasePdusession),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for PduSessionContinuityInd {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for PduSessionContinuityInd {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for PduSessionContinuityInd {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Unsigned integer identifying a PDU session, within the range 0 to 255,
	/// as specified in  clause 11.2.3.1b, bits 1 to 8, of 3GPP TS 24.007. If
	/// the PDU Session ID is allocated by the  Core Network for UEs not
	/// supporting N1 mode, reserved range 64 to 95 is used. PDU Session ID
	/// within the reserved range is only visible in the Core Network.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Unsigned integer identifying a PDU session, within the range 0 to 255, as specified in  clause 11.2.3.1b, bits 1 to 8, of 3GPP TS 24.007. If the PDU Session ID is allocated by the  Core Network for UEs not supporting N1 mode, reserved range 64 to 95 is used. PDU Session ID  within the reserved range is only visible in the Core Network. \n",
	///  "type": "integer",
	///  "maximum": 255.0,
	///  "minimum": 0.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PduSessionId(pub u8);
	impl ::std::ops::Deref for PduSessionId {
		type Target = u8;
		fn deref(&self) -> &u8 {
			&self.0
		}
	}

	impl From<PduSessionId> for u8 {
		fn from(value: PduSessionId) -> Self {
			value.0
		}
	}

	impl From<&PduSessionId> for PduSessionId {
		fn from(value: &PduSessionId) -> Self {
			value.clone()
		}
	}

	impl From<u8> for PduSessionId {
		fn from(value: u8) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for PduSessionId {
		type Err = <u8 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for PduSessionId {
		type Error = <u8 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for PduSessionId {
		type Error = <u8 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for PduSessionId {
		type Error = <u8 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for PduSessionId {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// PduSessionStatusCfg
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PduSessionStatusCfg {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub dnn: Option<Dnn>,
	}

	impl From<&PduSessionStatusCfg> for PduSessionStatusCfg {
		fn from(value: &PduSessionStatusCfg) -> Self {
			value.clone()
		}
	}

	/// PduSessionType indicates the type of a PDU session. It shall comply with
	/// the provisions defined in table 5.4.3.3-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "PduSessionType indicates the type of a PDU session. It
	/// shall comply with the provisions defined in table 5.4.3.3-1. \n",
	///  "type": "string",
	///  "enum": [
	///    "IPV4",
	///    "IPV6",
	///    "IPV4V6",
	///    "UNSTRUCTURED",
	///    "ETHERNET"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum PduSessionType {
		#[default]
		#[serde(rename = "IPV4")]
		Ipv4,
		#[serde(rename = "IPV6")]
		Ipv6,
		#[serde(rename = "IPV4V6")]
		Ipv4v6,
		#[serde(rename = "UNSTRUCTURED")]
		Unstructured,
		#[serde(rename = "ETHERNET")]
		Ethernet,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&PduSessionType> for PduSessionType {
		fn from(value: &PduSessionType) -> Self {
			value.clone()
		}
	}

	impl ToString for PduSessionType {
		fn to_string(&self) -> String {
			match *self {
				Self::Ipv4 => "IPV4".to_string(),
				Self::Ipv6 => "IPV6".to_string(),
				Self::Ipv4v6 => "IPV4V6".to_string(),
				Self::Unstructured => "UNSTRUCTURED".to_string(),
				Self::Ethernet => "ETHERNET".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for PduSessionType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"IPV4" => Ok(Self::Ipv4),
				"IPV6" => Ok(Self::Ipv6),
				"IPV4V6" => Ok(Self::Ipv4v6),
				"UNSTRUCTURED" => Ok(Self::Unstructured),
				"ETHERNET" => Ok(Self::Ethernet),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for PduSessionType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for PduSessionType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for PduSessionType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// PduSessionTypes
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "allowedSessionTypes": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/PduSessionType"
	///      },
	///      "minItems": 1
	///    },
	///    "defaultSessionType": {
	///      "$ref": "#/components/schemas/PduSessionType"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PduSessionTypes {
		#[serde(
			rename = "allowedSessionTypes",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub allowed_session_types: Vec<PduSessionType>,
		#[serde(
			rename = "defaultSessionType",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub default_session_type: Option<PduSessionType>,
	}

	impl From<&PduSessionTypes> for PduSessionTypes {
		fn from(value: &PduSessionTypes) -> Self {
			value.clone()
		}
	}

	/// String representing a Permanent Equipment Identifier that may contain -
	/// an IMEI or IMEISV, as  specified in clause 6.2 of 3GPP TS 23.003; a MAC
	/// address for a 5G-RG or FN-RG via  wireline  access, with an indication
	/// that this address cannot be trusted for regulatory purpose if this
	/// address cannot be used as an Equipment Identifier of the FN-RG, as
	/// specified in clause 4.7.7  of 3GPP TS23.316. Examples are
	/// imei-012345678901234 or imeisv-0123456789012345.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String representing a Permanent Equipment Identifier
	/// that may contain - an IMEI or IMEISV, as  specified in clause 6.2 of
	/// 3GPP TS 23.003; a MAC address for a 5G-RG or FN-RG via  wireline
	/// access, with an indication that this address cannot be trusted for
	/// regulatory purpose if this  address cannot be used as an Equipment
	/// Identifier of the FN-RG, as specified in clause 4.7.7  of 3GPP TS23.316.
	/// Examples are imei-012345678901234 or imeisv-0123456789012345. \n",
	///  "type": "string",
	///  "pattern":
	/// "^(imei-[0-9]{15}|imeisv-[0-9]{16}|mac((-[0-9a-fA-F]{2}){6})(-untrusted)?
	/// |eui((-[0-9a-fA-F]{2}){8})|.+)$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Pei(String);
	impl ::std::ops::Deref for Pei {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Pei> for String {
		fn from(value: Pei) -> Self {
			value.0
		}
	}

	impl From<&Pei> for Pei {
		fn from(value: &Pei) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Pei {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new(
				"^(imei-[0-9]{15}|imeisv-[0-9]{16}|mac((-[0-9a-fA-F]{2}){6})(-untrusted)?\
				 |eui((-[0-9a-fA-F]{2}){8})|.+)$",
			)
			.unwrap()
			.find(value)
			.is_none()
			{
				return Err("doesn't match pattern \
				            \"^(imei-[0-9]{15}|imeisv-[0-9]{16}|mac((-[0-9a-fA-F]{2}){6})(-untrusted)?\
				            |eui((-[0-9a-fA-F]{2}){8})|.+)$\""
					.into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Pei {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Pei {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Pei {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Pei {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// PeiUpdateInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "pei"
	///  ],
	///  "properties": {
	///    "pei": {
	///      "$ref": "#/components/schemas/Pei"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PeiUpdateInfo {
		pub pei: Pei,
	}

	impl From<&PeiUpdateInfo> for PeiUpdateInfo {
		fn from(value: &PeiUpdateInfo) -> Self {
			value.clone()
		}
	}

	/// PgwInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "dnn",
	///    "pgwFqdn"
	///  ],
	///  "properties": {
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "epdgInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "pcfId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "pgwFqdn": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "pgwIpAddr": {
	///      "$ref": "#/components/schemas/IpAddress"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "registrationTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PgwInfo {
		pub dnn: Dnn,
		#[serde(rename = "epdgInd", default)]
		pub epdg_ind: bool,
		#[serde(rename = "pcfId", default, skip_serializing_if = "Option::is_none")]
		pub pcf_id: Option<NfInstanceId>,
		#[serde(rename = "pgwFqdn")]
		pub pgw_fqdn: Fqdn,
		#[serde(rename = "pgwIpAddr", default, skip_serializing_if = "Option::is_none")]
		pub pgw_ip_addr: Option<IpAddress>,
		#[serde(rename = "plmnId", default, skip_serializing_if = "Option::is_none")]
		pub plmn_id: Option<PlmnId>,
		#[serde(
			rename = "registrationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub registration_time: Option<DateTime>,
	}

	impl From<&PgwInfo> for PgwInfo {
		fn from(value: &PgwInfo) -> Self {
			value.clone()
		}
	}

	/// Integer value identifying the physical cell identity (PCI), as
	/// definition of "PhysCellId" IE  in clause 6.3.2 of 3GPP TS 38.331.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Integer value identifying the physical cell identity
	/// (PCI), as definition of \"PhysCellId\" IE  in clause 6.3.2 of 3GPP TS
	/// 38.331.\n",
	///  "type": "integer",
	///  "maximum": 1007.0,
	///  "minimum": 0.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PhysCellId(pub i64);
	impl ::std::ops::Deref for PhysCellId {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<PhysCellId> for i64 {
		fn from(value: PhysCellId) -> Self {
			value.0
		}
	}

	impl From<&PhysCellId> for PhysCellId {
		fn from(value: &PhysCellId) -> Self {
			value.clone()
		}
	}

	impl From<i64> for PhysCellId {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for PhysCellId {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for PhysCellId {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for PhysCellId {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for PhysCellId {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for PhysCellId {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// PlmnEcInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "plmnId"
	///  ],
	///  "properties": {
	///    "ecRestrictionDataNb": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "ecRestrictionDataWb": {
	///      "$ref": "#/components/schemas/EcRestrictionDataWb"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PlmnEcInfo {
		#[serde(rename = "ecRestrictionDataNb", default)]
		pub ec_restriction_data_nb: bool,
		#[serde(
			rename = "ecRestrictionDataWb",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ec_restriction_data_wb: Option<EcRestrictionDataWb>,
		#[serde(rename = "plmnId")]
		pub plmn_id: PlmnId,
	}

	impl From<&PlmnEcInfo> for PlmnEcInfo {
		fn from(value: &PlmnEcInfo) -> Self {
			value.clone()
		}
	}

	/// When PlmnId needs to be converted to string (e.g. when used in maps as
	/// key), the string  shall be composed of three digits "mcc" followed by
	/// "-" and two or three digits "mnc".
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "When PlmnId needs to be converted to string (e.g. when
	/// used in maps as key), the string  shall be composed of three digits
	/// \"mcc\" followed by \"-\" and two or three digits \"mnc\".\n",
	///  "type": "object",
	///  "required": [
	///    "mcc",
	///    "mnc"
	///  ],
	///  "properties": {
	///    "mcc": {
	///      "$ref": "#/components/schemas/Mcc"
	///    },
	///    "mnc": {
	///      "$ref": "#/components/schemas/Mnc"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PlmnId {
		pub mcc: Mcc,
		pub mnc: Mnc,
	}

	impl From<&PlmnId> for PlmnId {
		fn from(value: &PlmnId) -> Self {
			value.clone()
		}
	}

	/// Contains the serving core network operator PLMN ID and, for an SNPN, the
	/// NID that together with the PLMN ID identifies the SNPN.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the serving core network operator PLMN ID and,
	/// for an SNPN, the NID that together with the PLMN ID identifies the
	/// SNPN.\n",
	///  "type": "object",
	///  "required": [
	///    "mcc",
	///    "mnc"
	///  ],
	///  "properties": {
	///    "mcc": {
	///      "$ref": "#/components/schemas/Mcc"
	///    },
	///    "mnc": {
	///      "$ref": "#/components/schemas/Mnc"
	///    },
	///    "nid": {
	///      "$ref": "#/components/schemas/Nid"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PlmnIdNid {
		pub mcc: Mcc,
		pub mnc: Mnc,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub nid: Option<Nid>,
	}

	impl From<&PlmnIdNid> for PlmnIdNid {
		fn from(value: &PlmnIdNid) -> Self {
			value.clone()
		}
	}

	/// PlmnOperatorClass
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "lcsClientClass",
	///    "lcsClientIds"
	///  ],
	///  "properties": {
	///    "lcsClientClass": {
	///      "$ref": "#/components/schemas/LcsClientClass"
	///    },
	///    "lcsClientIds": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/LcsClientId"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PlmnOperatorClass {
		#[serde(rename = "lcsClientClass")]
		pub lcs_client_class: LcsClientClass,
		#[serde(rename = "lcsClientIds")]
		pub lcs_client_ids: Vec<LcsClientId>,
	}

	impl From<&PlmnOperatorClass> for PlmnOperatorClass {
		fn from(value: &PlmnOperatorClass) -> Self {
			value.clone()
		}
	}

	/// PlmnRestriction
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "coreNetworkTypeRestrictions": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/CoreNetworkType"
	///      }
	///    },
	///    "forbiddenAreas": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Area"
	///      }
	///    },
	///    "primaryRatRestrictions": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/RatType"
	///      },
	///      "uniqueItems": true
	///    },
	///    "ratRestrictions": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/RatType"
	///      },
	///      "uniqueItems": true
	///    },
	///    "secondaryRatRestrictions": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/RatType"
	///      },
	///      "uniqueItems": true
	///    },
	///    "serviceAreaRestriction": {
	///      "$ref": "#/components/schemas/ServiceAreaRestriction"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PlmnRestriction {
		#[serde(
			rename = "coreNetworkTypeRestrictions",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub core_network_type_restrictions: Vec<CoreNetworkType>,
		#[serde(
			rename = "forbiddenAreas",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub forbidden_areas: Vec<Area>,
		#[serde(
			rename = "primaryRatRestrictions",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub primary_rat_restrictions: Option<Vec<RatType>>,
		#[serde(
			rename = "ratRestrictions",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub rat_restrictions: Option<Vec<RatType>>,
		#[serde(
			rename = "secondaryRatRestrictions",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub secondary_rat_restrictions: Option<Vec<RatType>>,
		#[serde(
			rename = "serviceAreaRestriction",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub service_area_restriction: Option<ServiceAreaRestriction>,
	}

	impl From<&PlmnRestriction> for PlmnRestriction {
		fn from(value: &PlmnRestriction) -> Self {
			value.clone()
		}
	}

	/// Ellipsoid Point.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Ellipsoid Point.",
	///  "allOf": [
	///    {
	///      "$ref": "#/components/schemas/GADShape"
	///    },
	///    {
	///      "type": "object",
	///      "required": [
	///        "point"
	///      ],
	///      "properties": {
	///        "point": {
	///          "$ref": "#/components/schemas/GeographicalCoordinates"
	///        }
	///      }
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Point {
		pub point: GeographicalCoordinates,
		pub shape: SupportedGadShapes,
	}

	impl From<&Point> for Point {
		fn from(value: &Point) -> Self {
			value.clone()
		}
	}

	/// Ellipsoid point with altitude.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Ellipsoid point with altitude.",
	///  "allOf": [
	///    {
	///      "$ref": "#/components/schemas/GADShape"
	///    },
	///    {
	///      "type": "object",
	///      "required": [
	///        "altitude",
	///        "point"
	///      ],
	///      "properties": {
	///        "altitude": {
	///          "$ref": "#/components/schemas/Altitude"
	///        },
	///        "point": {
	///          "$ref": "#/components/schemas/GeographicalCoordinates"
	///        }
	///      }
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PointAltitude {
		pub altitude: Altitude,
		pub point: GeographicalCoordinates,
		pub shape: SupportedGadShapes,
	}

	impl From<&PointAltitude> for PointAltitude {
		fn from(value: &PointAltitude) -> Self {
			value.clone()
		}
	}

	/// Ellipsoid point with altitude and uncertainty ellipsoid.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Ellipsoid point with altitude and uncertainty
	/// ellipsoid.",
	///  "allOf": [
	///    {
	///      "$ref": "#/components/schemas/GADShape"
	///    },
	///    {
	///      "type": "object",
	///      "required": [
	///        "altitude",
	///        "confidence",
	///        "point",
	///        "uncertaintyAltitude",
	///        "uncertaintyEllipse"
	///      ],
	///      "properties": {
	///        "altitude": {
	///          "$ref": "#/components/schemas/Altitude"
	///        },
	///        "confidence": {
	///          "$ref": "#/components/schemas/Confidence"
	///        },
	///        "point": {
	///          "$ref": "#/components/schemas/GeographicalCoordinates"
	///        },
	///        "uncertaintyAltitude": {
	///          "$ref": "#/components/schemas/Uncertainty"
	///        },
	///        "uncertaintyEllipse": {
	///          "$ref": "#/components/schemas/UncertaintyEllipse"
	///        },
	///        "vConfidence": {
	///          "$ref": "#/components/schemas/Confidence"
	///        }
	///      }
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PointAltitudeUncertainty {
		pub altitude: Altitude,
		pub confidence: Confidence,
		pub point: GeographicalCoordinates,
		pub shape: SupportedGadShapes,
		#[serde(rename = "uncertaintyAltitude")]
		pub uncertainty_altitude: Uncertainty,
		#[serde(rename = "uncertaintyEllipse")]
		pub uncertainty_ellipse: UncertaintyEllipse,
		#[serde(
			rename = "vConfidence",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub v_confidence: Option<Confidence>,
	}

	impl From<&PointAltitudeUncertainty> for PointAltitudeUncertainty {
		fn from(value: &PointAltitudeUncertainty) -> Self {
			value.clone()
		}
	}

	/// List of points.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "List of points.",
	///  "type": "array",
	///  "items": {
	///    "$ref": "#/components/schemas/GeographicalCoordinates"
	///  },
	///  "maxItems": 15,
	///  "minItems": 3
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PointList(pub Vec<GeographicalCoordinates>);
	impl ::std::ops::Deref for PointList {
		type Target = Vec<GeographicalCoordinates>;
		fn deref(&self) -> &Vec<GeographicalCoordinates> {
			&self.0
		}
	}

	impl From<PointList> for Vec<GeographicalCoordinates> {
		fn from(value: PointList) -> Self {
			value.0
		}
	}

	impl From<&PointList> for PointList {
		fn from(value: &PointList) -> Self {
			value.clone()
		}
	}

	impl From<Vec<GeographicalCoordinates>> for PointList {
		fn from(value: Vec<GeographicalCoordinates>) -> Self {
			Self(value)
		}
	}

	/// Ellipsoid point with uncertainty circle.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Ellipsoid point with uncertainty circle.",
	///  "allOf": [
	///    {
	///      "$ref": "#/components/schemas/GADShape"
	///    },
	///    {
	///      "type": "object",
	///      "required": [
	///        "point",
	///        "uncertainty"
	///      ],
	///      "properties": {
	///        "point": {
	///          "$ref": "#/components/schemas/GeographicalCoordinates"
	///        },
	///        "uncertainty": {
	///          "$ref": "#/components/schemas/Uncertainty"
	///        }
	///      }
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PointUncertaintyCircle {
		pub point: GeographicalCoordinates,
		pub shape: SupportedGadShapes,
		pub uncertainty: Uncertainty,
	}

	impl From<&PointUncertaintyCircle> for PointUncertaintyCircle {
		fn from(value: &PointUncertaintyCircle) -> Self {
			value.clone()
		}
	}

	/// Ellipsoid point with uncertainty ellipse.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Ellipsoid point with uncertainty ellipse.",
	///  "allOf": [
	///    {
	///      "$ref": "#/components/schemas/GADShape"
	///    },
	///    {
	///      "type": "object",
	///      "required": [
	///        "confidence",
	///        "point",
	///        "uncertaintyEllipse"
	///      ],
	///      "properties": {
	///        "confidence": {
	///          "$ref": "#/components/schemas/Confidence"
	///        },
	///        "point": {
	///          "$ref": "#/components/schemas/GeographicalCoordinates"
	///        },
	///        "uncertaintyEllipse": {
	///          "$ref": "#/components/schemas/UncertaintyEllipse"
	///        }
	///      }
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PointUncertaintyEllipse {
		pub confidence: Confidence,
		pub point: GeographicalCoordinates,
		pub shape: SupportedGadShapes,
		#[serde(rename = "uncertaintyEllipse")]
		pub uncertainty_ellipse: UncertaintyEllipse,
	}

	impl From<&PointUncertaintyEllipse> for PointUncertaintyEllipse {
		fn from(value: &PointUncertaintyEllipse) -> Self {
			value.clone()
		}
	}

	/// Polygon.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Polygon.",
	///  "allOf": [
	///    {
	///      "$ref": "#/components/schemas/GADShape"
	///    },
	///    {
	///      "type": "object",
	///      "required": [
	///        "pointList"
	///      ],
	///      "properties": {
	///        "pointList": {
	///          "$ref": "#/components/schemas/PointList"
	///        }
	///      }
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Polygon {
		#[serde(rename = "pointList")]
		pub point_list: PointList,
		pub shape: SupportedGadShapes,
	}

	impl From<&Polygon> for Polygon {
		fn from(value: &Polygon) -> Self {
			value.clone()
		}
	}

	/// The enumeration LoggingDurationMdt defines Logging Duration for MDT in
	/// the trace. See 3GPP TS 32.422 for further description of the values. It
	/// shall comply with the provisions defined in table 5.6.3.13-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration LoggingDurationMdt defines Logging
	/// Duration for MDT in the trace. See 3GPP TS 32.422 for further
	/// description of the values. It shall comply with the provisions defined
	/// in table 5.6.3.13-1.\n",
	///  "type": "string",
	///  "enum": [
	///    "GNSS",
	///    "E_CELL_ID"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum PositioningMethodMdt {
		#[default]
		#[serde(rename = "GNSS")]
		Gnss,
		#[serde(rename = "E_CELL_ID")]
		ECellId,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&PositioningMethodMdt> for PositioningMethodMdt {
		fn from(value: &PositioningMethodMdt) -> Self {
			value.clone()
		}
	}

	impl ToString for PositioningMethodMdt {
		fn to_string(&self) -> String {
			match *self {
				Self::Gnss => "GNSS".to_string(),
				Self::ECellId => "E_CELL_ID".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for PositioningMethodMdt {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"GNSS" => Ok(Self::Gnss),
				"E_CELL_ID" => Ok(Self::ECellId),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for PositioningMethodMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for PositioningMethodMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for PositioningMethodMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// PpActiveTime
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "required": [
	///    "activeTime",
	///    "afInstanceId",
	///    "referenceId"
	///  ],
	///  "properties": {
	///    "activeTime": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PpActiveTime(pub Option<PpActiveTimeInner>);
	impl ::std::ops::Deref for PpActiveTime {
		type Target = Option<PpActiveTimeInner>;
		fn deref(&self) -> &Option<PpActiveTimeInner> {
			&self.0
		}
	}

	impl From<PpActiveTime> for Option<PpActiveTimeInner> {
		fn from(value: PpActiveTime) -> Self {
			value.0
		}
	}

	impl From<&PpActiveTime> for PpActiveTime {
		fn from(value: &PpActiveTime) -> Self {
			value.clone()
		}
	}

	impl From<Option<PpActiveTimeInner>> for PpActiveTime {
		fn from(value: Option<PpActiveTimeInner>) -> Self {
			Self(value)
		}
	}

	/// PpActiveTimeInner
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "activeTime",
	///    "afInstanceId",
	///    "referenceId"
	///  ],
	///  "properties": {
	///    "activeTime": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PpActiveTimeInner {
		#[serde(rename = "activeTime")]
		pub active_time: DurationSec,
		#[serde(rename = "afInstanceId")]
		pub af_instance_id: String,
		#[serde(
			rename = "mtcProviderInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mtc_provider_information: Option<MtcProviderInformation>,
		#[serde(rename = "referenceId")]
		pub reference_id: ReferenceId,
		#[serde(
			rename = "validityTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub validity_time: Option<DateTime>,
	}

	impl From<&PpActiveTimeInner> for PpActiveTimeInner {
		fn from(value: &PpActiveTimeInner) -> Self {
			value.clone()
		}
	}

	/// PpData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "properties": {
	///    "5mbsAuthorizationInfo": {
	///      "$ref": "#/components/schemas/5MbsAuthorizationInfo"
	///    },
	///    "acsInfo": {
	///      "$ref": "#/components/schemas/AcsInfoRm"
	///    },
	///    "communicationCharacteristics": {
	///      "$ref": "#/components/schemas/CommunicationCharacteristics"
	///    },
	///    "ecRestriction": {
	///      "$ref": "#/components/schemas/EcRestriction"
	///    },
	///    "expectedUeBehaviourParameters": {
	///      "$ref": "#/components/schemas/ExpectedUeBehaviour"
	///    },
	///    "lcsPrivacy": {
	///      "$ref": "#/components/schemas/LcsPrivacy"
	///    },
	///    "sorInfo": {
	///      "$ref": "#/components/schemas/schemas-SorInfo"
	///    },
	///    "stnSr": {
	///      "$ref": "#/components/schemas/StnSrRm"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PpData(pub Option<PpDataInner>);
	impl ::std::ops::Deref for PpData {
		type Target = Option<PpDataInner>;
		fn deref(&self) -> &Option<PpDataInner> {
			&self.0
		}
	}

	impl From<PpData> for Option<PpDataInner> {
		fn from(value: PpData) -> Self {
			value.0
		}
	}

	impl From<&PpData> for PpData {
		fn from(value: &PpData) -> Self {
			value.clone()
		}
	}

	impl From<Option<PpDataInner>> for PpData {
		fn from(value: Option<PpDataInner>) -> Self {
			Self(value)
		}
	}

	/// PpDataEntry
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "properties": {
	///    "additionalEcsAddrConfigInfos": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/EcsAddrConfigInfo"
	///      },
	///      "minItems": 1
	///    },
	///    "communicationCharacteristics": {
	///      "$ref": "#/components/schemas/CommunicationCharacteristicsAF"
	///    },
	///    "ecRestriction": {
	///      "$ref": "#/components/schemas/EcRestriction"
	///    },
	///    "ecsAddrConfigInfo": {
	///      "$ref": "#/components/schemas/EcsAddrConfigInfo"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PpDataEntry(pub Option<PpDataEntryInner>);
	impl ::std::ops::Deref for PpDataEntry {
		type Target = Option<PpDataEntryInner>;
		fn deref(&self) -> &Option<PpDataEntryInner> {
			&self.0
		}
	}

	impl From<PpDataEntry> for Option<PpDataEntryInner> {
		fn from(value: PpDataEntry) -> Self {
			value.0
		}
	}

	impl From<&PpDataEntry> for PpDataEntry {
		fn from(value: &PpDataEntry) -> Self {
			value.clone()
		}
	}

	impl From<Option<PpDataEntryInner>> for PpDataEntry {
		fn from(value: Option<PpDataEntryInner>) -> Self {
			Self(value)
		}
	}

	/// PpDataEntryInner
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "additionalEcsAddrConfigInfos": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/EcsAddrConfigInfo"
	///      },
	///      "minItems": 1
	///    },
	///    "communicationCharacteristics": {
	///      "$ref": "#/components/schemas/CommunicationCharacteristicsAF"
	///    },
	///    "ecRestriction": {
	///      "$ref": "#/components/schemas/EcRestriction"
	///    },
	///    "ecsAddrConfigInfo": {
	///      "$ref": "#/components/schemas/EcsAddrConfigInfo"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PpDataEntryInner {
		#[serde(
			rename = "additionalEcsAddrConfigInfos",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub additional_ecs_addr_config_infos: Vec<EcsAddrConfigInfo>,
		#[serde(
			rename = "communicationCharacteristics",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub communication_characteristics: Option<CommunicationCharacteristicsAf>,
		#[serde(
			rename = "ecRestriction",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ec_restriction: Option<EcRestriction>,
		#[serde(
			rename = "ecsAddrConfigInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ecs_addr_config_info: Option<EcsAddrConfigInfo>,
		#[serde(
			rename = "mtcProviderInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mtc_provider_information: Option<MtcProviderInformation>,
		#[serde(
			rename = "referenceId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub reference_id: Option<ReferenceId>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
		#[serde(
			rename = "validityTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub validity_time: Option<DateTime>,
	}

	impl From<&PpDataEntryInner> for PpDataEntryInner {
		fn from(value: &PpDataEntryInner) -> Self {
			value.clone()
		}
	}

	/// PpDataInner
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "5mbsAuthorizationInfo": {
	///      "$ref": "#/components/schemas/5MbsAuthorizationInfo"
	///    },
	///    "acsInfo": {
	///      "$ref": "#/components/schemas/AcsInfoRm"
	///    },
	///    "communicationCharacteristics": {
	///      "$ref": "#/components/schemas/CommunicationCharacteristics"
	///    },
	///    "ecRestriction": {
	///      "$ref": "#/components/schemas/EcRestriction"
	///    },
	///    "expectedUeBehaviourParameters": {
	///      "$ref": "#/components/schemas/ExpectedUeBehaviour"
	///    },
	///    "lcsPrivacy": {
	///      "$ref": "#/components/schemas/LcsPrivacy"
	///    },
	///    "sorInfo": {
	///      "$ref": "#/components/schemas/schemas-SorInfo"
	///    },
	///    "stnSr": {
	///      "$ref": "#/components/schemas/StnSrRm"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PpDataInner {
		#[serde(rename = "acsInfo", default, skip_serializing_if = "Option::is_none")]
		pub acs_info: Option<AcsInfoRm>,
		#[serde(
			rename = "communicationCharacteristics",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub communication_characteristics: Option<CommunicationCharacteristics>,
		#[serde(
			rename = "ecRestriction",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ec_restriction: Option<EcRestriction>,
		#[serde(
			rename = "expectedUeBehaviourParameters",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub expected_ue_behaviour_parameters: Option<ExpectedUeBehaviour>,
		#[serde(
			rename = "5mbsAuthorizationInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub five_mbs_authorization_info: Option<_5mbsAuthorizationInfo>,
		#[serde(
			rename = "lcsPrivacy",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub lcs_privacy: Option<LcsPrivacy>,
		#[serde(rename = "sorInfo", default, skip_serializing_if = "Option::is_none")]
		pub sor_info: Option<SchemasSorInfo>,
		#[serde(rename = "stnSr", default, skip_serializing_if = "Option::is_none")]
		pub stn_sr: Option<StnSrRm>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&PpDataInner> for PpDataInner {
		fn from(value: &PpDataInner) -> Self {
			value.clone()
		}
	}

	/// PpDlPacketCount
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "integer",
	///    "null"
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PpDlPacketCount(pub Option<i64>);
	impl ::std::ops::Deref for PpDlPacketCount {
		type Target = Option<i64>;
		fn deref(&self) -> &Option<i64> {
			&self.0
		}
	}

	impl From<PpDlPacketCount> for Option<i64> {
		fn from(value: PpDlPacketCount) -> Self {
			value.0
		}
	}

	impl From<&PpDlPacketCount> for PpDlPacketCount {
		fn from(value: &PpDlPacketCount) -> Self {
			value.clone()
		}
	}

	impl From<Option<i64>> for PpDlPacketCount {
		fn from(value: Option<i64>) -> Self {
			Self(value)
		}
	}

	/// PpDlPacketCountExt
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "required": [
	///    "afInstanceId",
	///    "referenceId"
	///  ],
	///  "properties": {
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    },
	///    "singleNssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PpDlPacketCountExt(pub Option<PpDlPacketCountExtInner>);
	impl ::std::ops::Deref for PpDlPacketCountExt {
		type Target = Option<PpDlPacketCountExtInner>;
		fn deref(&self) -> &Option<PpDlPacketCountExtInner> {
			&self.0
		}
	}

	impl From<PpDlPacketCountExt> for Option<PpDlPacketCountExtInner> {
		fn from(value: PpDlPacketCountExt) -> Self {
			value.0
		}
	}

	impl From<&PpDlPacketCountExt> for PpDlPacketCountExt {
		fn from(value: &PpDlPacketCountExt) -> Self {
			value.clone()
		}
	}

	impl From<Option<PpDlPacketCountExtInner>> for PpDlPacketCountExt {
		fn from(value: Option<PpDlPacketCountExtInner>) -> Self {
			Self(value)
		}
	}

	/// PpDlPacketCountExtInner
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "afInstanceId",
	///    "referenceId"
	///  ],
	///  "properties": {
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    },
	///    "singleNssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PpDlPacketCountExtInner {
		#[serde(rename = "afInstanceId")]
		pub af_instance_id: String,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub dnn: Option<Dnn>,
		#[serde(
			rename = "mtcProviderInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mtc_provider_information: Option<MtcProviderInformation>,
		#[serde(rename = "referenceId")]
		pub reference_id: ReferenceId,
		#[serde(
			rename = "singleNssai",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub single_nssai: Option<Snssai>,
		#[serde(
			rename = "validityTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub validity_time: Option<DateTime>,
	}

	impl From<&PpDlPacketCountExtInner> for PpDlPacketCountExtInner {
		fn from(value: &PpDlPacketCountExtInner) -> Self {
			value.clone()
		}
	}

	/// PpMaximumLatency
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "required": [
	///    "afInstanceId",
	///    "maximumLatency",
	///    "referenceId"
	///  ],
	///  "properties": {
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "maximumLatency": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PpMaximumLatency(pub Option<PpMaximumLatencyInner>);
	impl ::std::ops::Deref for PpMaximumLatency {
		type Target = Option<PpMaximumLatencyInner>;
		fn deref(&self) -> &Option<PpMaximumLatencyInner> {
			&self.0
		}
	}

	impl From<PpMaximumLatency> for Option<PpMaximumLatencyInner> {
		fn from(value: PpMaximumLatency) -> Self {
			value.0
		}
	}

	impl From<&PpMaximumLatency> for PpMaximumLatency {
		fn from(value: &PpMaximumLatency) -> Self {
			value.clone()
		}
	}

	impl From<Option<PpMaximumLatencyInner>> for PpMaximumLatency {
		fn from(value: Option<PpMaximumLatencyInner>) -> Self {
			Self(value)
		}
	}

	/// PpMaximumLatencyInner
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "afInstanceId",
	///    "maximumLatency",
	///    "referenceId"
	///  ],
	///  "properties": {
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "maximumLatency": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PpMaximumLatencyInner {
		#[serde(rename = "afInstanceId")]
		pub af_instance_id: String,
		#[serde(rename = "maximumLatency")]
		pub maximum_latency: DurationSec,
		#[serde(
			rename = "mtcProviderInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mtc_provider_information: Option<MtcProviderInformation>,
		#[serde(rename = "referenceId")]
		pub reference_id: ReferenceId,
		#[serde(
			rename = "validityTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub validity_time: Option<DateTime>,
	}

	impl From<&PpMaximumLatencyInner> for PpMaximumLatencyInner {
		fn from(value: &PpMaximumLatencyInner) -> Self {
			value.clone()
		}
	}

	/// PpMaximumResponseTime
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "required": [
	///    "afInstanceId",
	///    "maximumResponseTime",
	///    "referenceId"
	///  ],
	///  "properties": {
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "maximumResponseTime": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PpMaximumResponseTime(pub Option<PpMaximumResponseTimeInner>);
	impl ::std::ops::Deref for PpMaximumResponseTime {
		type Target = Option<PpMaximumResponseTimeInner>;
		fn deref(&self) -> &Option<PpMaximumResponseTimeInner> {
			&self.0
		}
	}

	impl From<PpMaximumResponseTime> for Option<PpMaximumResponseTimeInner> {
		fn from(value: PpMaximumResponseTime) -> Self {
			value.0
		}
	}

	impl From<&PpMaximumResponseTime> for PpMaximumResponseTime {
		fn from(value: &PpMaximumResponseTime) -> Self {
			value.clone()
		}
	}

	impl From<Option<PpMaximumResponseTimeInner>> for PpMaximumResponseTime {
		fn from(value: Option<PpMaximumResponseTimeInner>) -> Self {
			Self(value)
		}
	}

	/// PpMaximumResponseTimeInner
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "afInstanceId",
	///    "maximumResponseTime",
	///    "referenceId"
	///  ],
	///  "properties": {
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "maximumResponseTime": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PpMaximumResponseTimeInner {
		#[serde(rename = "afInstanceId")]
		pub af_instance_id: String,
		#[serde(rename = "maximumResponseTime")]
		pub maximum_response_time: DurationSec,
		#[serde(
			rename = "mtcProviderInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mtc_provider_information: Option<MtcProviderInformation>,
		#[serde(rename = "referenceId")]
		pub reference_id: ReferenceId,
		#[serde(
			rename = "validityTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub validity_time: Option<DateTime>,
	}

	impl From<&PpMaximumResponseTimeInner> for PpMaximumResponseTimeInner {
		fn from(value: &PpMaximumResponseTimeInner) -> Self {
			value.clone()
		}
	}

	/// PpSubsRegTimer
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "required": [
	///    "afInstanceId",
	///    "referenceId",
	///    "subsRegTimer"
	///  ],
	///  "properties": {
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    },
	///    "subsRegTimer": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PpSubsRegTimer(pub Option<PpSubsRegTimerInner>);
	impl ::std::ops::Deref for PpSubsRegTimer {
		type Target = Option<PpSubsRegTimerInner>;
		fn deref(&self) -> &Option<PpSubsRegTimerInner> {
			&self.0
		}
	}

	impl From<PpSubsRegTimer> for Option<PpSubsRegTimerInner> {
		fn from(value: PpSubsRegTimer) -> Self {
			value.0
		}
	}

	impl From<&PpSubsRegTimer> for PpSubsRegTimer {
		fn from(value: &PpSubsRegTimer) -> Self {
			value.clone()
		}
	}

	impl From<Option<PpSubsRegTimerInner>> for PpSubsRegTimer {
		fn from(value: Option<PpSubsRegTimerInner>) -> Self {
			Self(value)
		}
	}

	/// PpSubsRegTimerInner
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "afInstanceId",
	///    "referenceId",
	///    "subsRegTimer"
	///  ],
	///  "properties": {
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    },
	///    "subsRegTimer": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PpSubsRegTimerInner {
		#[serde(rename = "afInstanceId")]
		pub af_instance_id: String,
		#[serde(
			rename = "mtcProviderInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mtc_provider_information: Option<MtcProviderInformation>,
		#[serde(rename = "referenceId")]
		pub reference_id: ReferenceId,
		#[serde(rename = "subsRegTimer")]
		pub subs_reg_timer: DurationSec,
		#[serde(
			rename = "validityTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub validity_time: Option<DateTime>,
	}

	impl From<&PpSubsRegTimerInner> for PpSubsRegTimerInner {
		fn from(value: &PpSubsRegTimerInner) -> Self {
			value.clone()
		}
	}

	/// The enumeration PreemptionCapability indicates the pre-emption
	/// capability of a request on other QoS flows. See clause 5.7.2.2 of 3GPP
	/// TS 23.501. It shall comply with the provisions defined in table
	/// 5.5.3.1-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration PreemptionCapability indicates the
	/// pre-emption capability of a request on other QoS flows. See clause
	/// 5.7.2.2 of 3GPP TS 23.501. It shall comply with the provisions defined
	/// in table 5.5.3.1-1.\n",
	///  "type": "string",
	///  "enum": [
	///    "NOT_PREEMPT",
	///    "MAY_PREEMPT"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum PreemptionCapability {
		#[default]
		#[serde(rename = "NOT_PREEMPT")]
		NotPreempt,
		#[serde(rename = "MAY_PREEMPT")]
		MayPreempt,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&PreemptionCapability> for PreemptionCapability {
		fn from(value: &PreemptionCapability) -> Self {
			value.clone()
		}
	}

	impl ToString for PreemptionCapability {
		fn to_string(&self) -> String {
			match *self {
				Self::NotPreempt => "NOT_PREEMPT".to_string(),
				Self::MayPreempt => "MAY_PREEMPT".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for PreemptionCapability {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"NOT_PREEMPT" => Ok(Self::NotPreempt),
				"MAY_PREEMPT" => Ok(Self::MayPreempt),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for PreemptionCapability {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for PreemptionCapability {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for PreemptionCapability {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// The enumeration PreemptionVulnerability indicates the pre-emption
	/// vulnerability of the QoS flow to pre-emption from other QoS flows. See
	/// clause 5.7.2.2 of 3GPP TS 23.501. It shall comply with the provisions
	/// defined in table 5.5.3.2-1
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration PreemptionVulnerability indicates the
	/// pre-emption vulnerability of the QoS flow to pre-emption from other QoS
	/// flows. See clause 5.7.2.2 of 3GPP TS 23.501. It shall comply with the
	/// provisions defined in table 5.5.3.2-1\n",
	///  "type": "string",
	///  "enum": [
	///    "NOT_PREEMPTABLE",
	///    "PREEMPTABLE"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum PreemptionVulnerability {
		#[default]
		#[serde(rename = "NOT_PREEMPTABLE")]
		NotPreemptable,
		#[serde(rename = "PREEMPTABLE")]
		Preemptable,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&PreemptionVulnerability> for PreemptionVulnerability {
		fn from(value: &PreemptionVulnerability) -> Self {
			value.clone()
		}
	}

	impl ToString for PreemptionVulnerability {
		fn to_string(&self) -> String {
			match *self {
				Self::NotPreemptable => "NOT_PREEMPTABLE".to_string(),
				Self::Preemptable => "PREEMPTABLE".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for PreemptionVulnerability {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"NOT_PREEMPTABLE" => Ok(Self::NotPreemptable),
				"PREEMPTABLE" => Ok(Self::Preemptable),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for PreemptionVulnerability {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for PreemptionVulnerability {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for PreemptionVulnerability {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// PrivacyCheckRelatedAction
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "LOCATION_NOT_ALLOWED",
	///    "LOCATION_ALLOWED_WITH_NOTIFICATION",
	///    "LOCATION_ALLOWED_WITHOUT_NOTIFICATION",
	///    "LOCATION_ALLOWED_WITHOUT_RESPONSE",
	///    "LOCATION_RESTRICTED_WITHOUT_RESPONSE"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum PrivacyCheckRelatedAction {
		#[default]
		#[serde(rename = "LOCATION_NOT_ALLOWED")]
		LocationNotAllowed,
		#[serde(rename = "LOCATION_ALLOWED_WITH_NOTIFICATION")]
		LocationAllowedWithNotification,
		#[serde(rename = "LOCATION_ALLOWED_WITHOUT_NOTIFICATION")]
		LocationAllowedWithoutNotification,
		#[serde(rename = "LOCATION_ALLOWED_WITHOUT_RESPONSE")]
		LocationAllowedWithoutResponse,
		#[serde(rename = "LOCATION_RESTRICTED_WITHOUT_RESPONSE")]
		LocationRestrictedWithoutResponse,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&PrivacyCheckRelatedAction> for PrivacyCheckRelatedAction {
		fn from(value: &PrivacyCheckRelatedAction) -> Self {
			value.clone()
		}
	}

	impl ToString for PrivacyCheckRelatedAction {
		fn to_string(&self) -> String {
			match *self {
				Self::LocationNotAllowed => "LOCATION_NOT_ALLOWED".to_string(),
				Self::LocationAllowedWithNotification => {
					"LOCATION_ALLOWED_WITH_NOTIFICATION".to_string()
				}
				Self::LocationAllowedWithoutNotification => {
					"LOCATION_ALLOWED_WITHOUT_NOTIFICATION".to_string()
				}
				Self::LocationAllowedWithoutResponse => {
					"LOCATION_ALLOWED_WITHOUT_RESPONSE".to_string()
				}
				Self::LocationRestrictedWithoutResponse => {
					"LOCATION_RESTRICTED_WITHOUT_RESPONSE".to_string()
				}
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for PrivacyCheckRelatedAction {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"LOCATION_NOT_ALLOWED" => Ok(Self::LocationNotAllowed),
				"LOCATION_ALLOWED_WITH_NOTIFICATION" => Ok(Self::LocationAllowedWithNotification),
				"LOCATION_ALLOWED_WITHOUT_NOTIFICATION" => {
					Ok(Self::LocationAllowedWithoutNotification)
				}
				"LOCATION_ALLOWED_WITHOUT_RESPONSE" => Ok(Self::LocationAllowedWithoutResponse),
				"LOCATION_RESTRICTED_WITHOUT_RESPONSE" => {
					Ok(Self::LocationRestrictedWithoutResponse)
				}
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for PrivacyCheckRelatedAction {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for PrivacyCheckRelatedAction {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for PrivacyCheckRelatedAction {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Contains the PLMN identities where the Prose services are authorised to
	/// use and the authorised Prose services on this given PLMNs.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the PLMN identities where the Prose services
	/// are authorised to use and the authorised Prose services on this given
	/// PLMNs.",
	///  "type": "object",
	///  "required": [
	///    "visitedPlmn"
	///  ],
	///  "properties": {
	///    "proseDirectAllowed": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/ProseDirectAllowed"
	///      },
	///      "minItems": 1
	///    },
	///    "visitedPlmn": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ProSeAllowedPlmn {
		#[serde(
			rename = "proseDirectAllowed",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub prose_direct_allowed: Vec<ProseDirectAllowed>,
		#[serde(rename = "visitedPlmn")]
		pub visited_plmn: PlmnId,
	}

	impl From<&ProSeAllowedPlmn> for ProSeAllowedPlmn {
		fn from(value: &ProSeAllowedPlmn) -> Self {
			value.clone()
		}
	}

	/// ProSeAuthenticationInfoRequest
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "relayServiceCode",
	///    "servingNetworkName"
	///  ],
	///  "properties": {
	///    "relayServiceCode": {
	///      "$ref": "#/components/schemas/RelayServiceCode"
	///    },
	///    "resynchronizationInfo": {
	///      "$ref": "#/components/schemas/ResynchronizationInfo"
	///    },
	///    "servingNetworkName": {
	///      "$ref": "#/components/schemas/ServingNetworkName"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ProSeAuthenticationInfoRequest {
		#[serde(rename = "relayServiceCode")]
		pub relay_service_code: RelayServiceCode,
		#[serde(
			rename = "resynchronizationInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub resynchronization_info: Option<ResynchronizationInfo>,
		#[serde(rename = "servingNetworkName")]
		pub serving_network_name: ServingNetworkName,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&ProSeAuthenticationInfoRequest> for ProSeAuthenticationInfoRequest {
		fn from(value: &ProSeAuthenticationInfoRequest) -> Self {
			value.clone()
		}
	}

	/// ProSeAuthenticationInfoResult
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "authType"
	///  ],
	///  "properties": {
	///    "authType": {
	///      "$ref": "#/components/schemas/AuthType"
	///    },
	///    "proseAuthenticationVectors": {
	///      "$ref": "#/components/schemas/ProSeAuthenticationVectors"
	///    },
	///    "supi": {
	///      "$ref": "#/components/schemas/Supi"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ProSeAuthenticationInfoResult {
		#[serde(rename = "authType")]
		pub auth_type: AuthType,
		#[serde(
			rename = "proseAuthenticationVectors",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub prose_authentication_vectors: Option<ProSeAuthenticationVectors>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub supi: Option<Supi>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&ProSeAuthenticationInfoResult> for ProSeAuthenticationInfoResult {
		fn from(value: &ProSeAuthenticationInfoResult) -> Self {
			value.clone()
		}
	}

	/// ProSeAuthenticationVectors
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "oneOf": [
	///    {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/AvEapAkaPrime"
	///      },
	///      "maxItems": 5,
	///      "minItems": 1
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ProSeAuthenticationVectors(pub Vec<AvEapAkaPrime>);
	impl ::std::ops::Deref for ProSeAuthenticationVectors {
		type Target = Vec<AvEapAkaPrime>;
		fn deref(&self) -> &Vec<AvEapAkaPrime> {
			&self.0
		}
	}

	impl From<ProSeAuthenticationVectors> for Vec<AvEapAkaPrime> {
		fn from(value: ProSeAuthenticationVectors) -> Self {
			value.0
		}
	}

	impl From<&ProSeAuthenticationVectors> for ProSeAuthenticationVectors {
		fn from(value: &ProSeAuthenticationVectors) -> Self {
			value.clone()
		}
	}

	impl From<Vec<AvEapAkaPrime>> for ProSeAuthenticationVectors {
		fn from(value: Vec<AvEapAkaPrime>) -> Self {
			Self(value)
		}
	}

	/// Provides additional information in an error response.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Provides additional information in an error response.",
	///  "type": "object",
	///  "properties": {
	///    "accessTokenError": {
	///      "$ref": "#/components/schemas/AccessTokenErr"
	///    },
	///    "accessTokenRequest": {
	///      "$ref": "#/components/schemas/AccessTokenReq"
	///    },
	///    "cause": {
	///      "description": "A machine-readable application error cause specific
	/// to this occurrence of the problem.  This IE should be present and
	/// provide application-related error information, if available.\n",
	///      "type": "string"
	///    },
	///    "detail": {
	///      "description": "A human-readable explanation specific to this
	/// occurrence of the problem.",
	///      "type": "string"
	///    },
	///    "instance": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "invalidParams": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/InvalidParam"
	///      },
	///      "minItems": 1
	///    },
	///    "nrfId": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "status": {
	///      "type": "integer"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "title": {
	///      "type": "string"
	///    },
	///    "type": {
	///      "$ref": "#/components/schemas/Uri"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ProblemDetails {
		#[serde(
			rename = "accessTokenError",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub access_token_error: Option<AccessTokenErr>,
		#[serde(
			rename = "accessTokenRequest",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub access_token_request: Option<AccessTokenReq>,
		/// A machine-readable application error cause specific to this
		/// occurrence of the problem.  This IE should be present and provide
		/// application-related error information, if available.
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub cause: Option<String>,
		/// A human-readable explanation specific to this occurrence of the
		/// problem.
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub detail: Option<String>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub instance: Option<Uri>,
		#[serde(
			rename = "invalidParams",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub invalid_params: Vec<InvalidParam>,
		#[serde(rename = "nrfId", default, skip_serializing_if = "Option::is_none")]
		pub nrf_id: Option<Fqdn>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub status: Option<i64>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub title: Option<String>,
		#[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
		pub type_: Option<Uri>,
	}

	impl From<&ProblemDetails> for ProblemDetails {
		fn from(value: &ProblemDetails) -> Self {
			value.clone()
		}
	}

	/// Indicates the 5G ProSe Direct services that can be authorised to use in
	/// the given PLMN for the UE.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates the 5G ProSe Direct services that can be
	/// authorised to use in the given PLMN for the UE.",
	///  "type": "string",
	///  "enum": [
	///    "ANNOUNCE",
	///    "MONITOR",
	///    "RESTRICTD_ANNOUNCE",
	///    "RESTRICTD_MONITOR",
	///    "DISCOVERER",
	///    "DISCOVEREE",
	///    "BROADCAST",
	///    "GROUPCAST",
	///    "UNICAST",
	///    "LAYER2_RELAY",
	///    "LAYER3_RELAY"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum ProseDirectAllowed {
		#[default]
		#[serde(rename = "ANNOUNCE")]
		Announce,
		#[serde(rename = "MONITOR")]
		Monitor,
		#[serde(rename = "RESTRICTD_ANNOUNCE")]
		RestrictdAnnounce,
		#[serde(rename = "RESTRICTD_MONITOR")]
		RestrictdMonitor,
		#[serde(rename = "DISCOVERER")]
		Discoverer,
		#[serde(rename = "DISCOVEREE")]
		Discoveree,
		#[serde(rename = "BROADCAST")]
		Broadcast,
		#[serde(rename = "GROUPCAST")]
		Groupcast,
		#[serde(rename = "UNICAST")]
		Unicast,
		#[serde(rename = "LAYER2_RELAY")]
		Layer2Relay,
		#[serde(rename = "LAYER3_RELAY")]
		Layer3Relay,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&ProseDirectAllowed> for ProseDirectAllowed {
		fn from(value: &ProseDirectAllowed) -> Self {
			value.clone()
		}
	}

	impl ToString for ProseDirectAllowed {
		fn to_string(&self) -> String {
			match *self {
				Self::Announce => "ANNOUNCE".to_string(),
				Self::Monitor => "MONITOR".to_string(),
				Self::RestrictdAnnounce => "RESTRICTD_ANNOUNCE".to_string(),
				Self::RestrictdMonitor => "RESTRICTD_MONITOR".to_string(),
				Self::Discoverer => "DISCOVERER".to_string(),
				Self::Discoveree => "DISCOVEREE".to_string(),
				Self::Broadcast => "BROADCAST".to_string(),
				Self::Groupcast => "GROUPCAST".to_string(),
				Self::Unicast => "UNICAST".to_string(),
				Self::Layer2Relay => "LAYER2_RELAY".to_string(),
				Self::Layer3Relay => "LAYER3_RELAY".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for ProseDirectAllowed {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"ANNOUNCE" => Ok(Self::Announce),
				"MONITOR" => Ok(Self::Monitor),
				"RESTRICTD_ANNOUNCE" => Ok(Self::RestrictdAnnounce),
				"RESTRICTD_MONITOR" => Ok(Self::RestrictdMonitor),
				"DISCOVERER" => Ok(Self::Discoverer),
				"DISCOVEREE" => Ok(Self::Discoveree),
				"BROADCAST" => Ok(Self::Broadcast),
				"GROUPCAST" => Ok(Self::Groupcast),
				"UNICAST" => Ok(Self::Unicast),
				"LAYER2_RELAY" => Ok(Self::Layer2Relay),
				"LAYER3_RELAY" => Ok(Self::Layer3Relay),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for ProseDirectAllowed {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for ProseDirectAllowed {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for ProseDirectAllowed {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Indicates whether the UE is authorized to use ProSe related services.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates whether the UE is authorized to use ProSe
	/// related services.\n",
	///  "type": "object",
	///  "properties": {
	///    "proseDirectCommunicationAuth": {
	///      "$ref": "#/components/schemas/UeAuth"
	///    },
	///    "proseDirectDiscoveryAuth": {
	///      "$ref": "#/components/schemas/UeAuth"
	///    },
	///    "proseL2RelayAuth": {
	///      "$ref": "#/components/schemas/UeAuth"
	///    },
	///    "proseL2RemoteAuth": {
	///      "$ref": "#/components/schemas/UeAuth"
	///    },
	///    "proseL3RelayAuth": {
	///      "$ref": "#/components/schemas/UeAuth"
	///    },
	///    "proseL3RemoteAuth": {
	///      "$ref": "#/components/schemas/UeAuth"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ProseServiceAuth {
		#[serde(
			rename = "proseDirectCommunicationAuth",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub prose_direct_communication_auth: Option<UeAuth>,
		#[serde(
			rename = "proseDirectDiscoveryAuth",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub prose_direct_discovery_auth: Option<UeAuth>,
		#[serde(
			rename = "proseL2RelayAuth",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub prose_l2_relay_auth: Option<UeAuth>,
		#[serde(
			rename = "proseL2RemoteAuth",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub prose_l2_remote_auth: Option<UeAuth>,
		#[serde(
			rename = "proseL3RelayAuth",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub prose_l3_relay_auth: Option<UeAuth>,
		#[serde(
			rename = "proseL3RemoteAuth",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub prose_l3_remote_auth: Option<UeAuth>,
	}

	impl From<&ProseServiceAuth> for ProseServiceAuth {
		fn from(value: &ProseServiceAuth) -> Self {
			value.clone()
		}
	}

	/// Contains the ProSe Subscription Data.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the ProSe Subscription Data.",
	///  "type": "object",
	///  "properties": {
	///    "nrUePc5Ambr": {
	///      "$ref": "#/components/schemas/BitRate"
	///    },
	///    "proseAllowedPlmn": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/ProSeAllowedPlmn"
	///      },
	///      "minItems": 1
	///    },
	///    "proseServiceAuth": {
	///      "$ref": "#/components/schemas/ProseServiceAuth"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ProseSubscriptionData {
		#[serde(
			rename = "nrUePc5Ambr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub nr_ue_pc5_ambr: Option<BitRate>,
		#[serde(
			rename = "proseAllowedPlmn",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub prose_allowed_plmn: Vec<ProSeAllowedPlmn>,
		#[serde(
			rename = "proseServiceAuth",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub prose_service_auth: Option<ProseServiceAuth>,
	}

	impl From<&ProseSubscriptionData> for ProseSubscriptionData {
		fn from(value: &ProseSubscriptionData) -> Self {
			value.clone()
		}
	}

	/// PtwParameters
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "operationMode",
	///    "ptwValue"
	///  ],
	///  "properties": {
	///    "extendedPtwValue": {
	///      "type": "string",
	///      "pattern": "^([0-1]{8})$"
	///    },
	///    "operationMode": {
	///      "$ref": "#/components/schemas/OperationMode"
	///    },
	///    "ptwValue": {
	///      "type": "string",
	///      "pattern": "^([0-1]{4})$"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PtwParameters {
		#[serde(
			rename = "extendedPtwValue",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub extended_ptw_value: Option<PtwParametersExtendedPtwValue>,
		#[serde(rename = "operationMode")]
		pub operation_mode: OperationMode,
		#[serde(rename = "ptwValue")]
		pub ptw_value: PtwParametersPtwValue,
	}

	impl From<&PtwParameters> for PtwParameters {
		fn from(value: &PtwParameters) -> Self {
			value.clone()
		}
	}

	/// PtwParametersExtendedPtwValue
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^([0-1]{8})$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct PtwParametersExtendedPtwValue(String);
	impl ::std::ops::Deref for PtwParametersExtendedPtwValue {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<PtwParametersExtendedPtwValue> for String {
		fn from(value: PtwParametersExtendedPtwValue) -> Self {
			value.0
		}
	}

	impl From<&PtwParametersExtendedPtwValue> for PtwParametersExtendedPtwValue {
		fn from(value: &PtwParametersExtendedPtwValue) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for PtwParametersExtendedPtwValue {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^([0-1]{8})$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^([0-1]{8})$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for PtwParametersExtendedPtwValue {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for PtwParametersExtendedPtwValue {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for PtwParametersExtendedPtwValue {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for PtwParametersExtendedPtwValue {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// PtwParametersPtwValue
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^([0-1]{4})$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct PtwParametersPtwValue(String);
	impl ::std::ops::Deref for PtwParametersPtwValue {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<PtwParametersPtwValue> for String {
		fn from(value: PtwParametersPtwValue) -> Self {
			value.0
		}
	}

	impl From<&PtwParametersPtwValue> for PtwParametersPtwValue {
		fn from(value: &PtwParametersPtwValue) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for PtwParametersPtwValue {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^([0-1]{4})$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^([0-1]{4})$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for PtwParametersPtwValue {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for PtwParametersPtwValue {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for PtwParametersPtwValue {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for PtwParametersPtwValue {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// PurgeFlag
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "boolean"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct PurgeFlag(pub bool);
	impl ::std::ops::Deref for PurgeFlag {
		type Target = bool;
		fn deref(&self) -> &bool {
			&self.0
		}
	}

	impl From<PurgeFlag> for bool {
		fn from(value: PurgeFlag) -> Self {
			value.0
		}
	}

	impl From<&PurgeFlag> for PurgeFlag {
		fn from(value: &PurgeFlag) -> Self {
			value.clone()
		}
	}

	impl From<bool> for PurgeFlag {
		fn from(value: bool) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for PurgeFlag {
		type Err = <bool as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for PurgeFlag {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for PurgeFlag {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for PurgeFlag {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for PurgeFlag {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Rand
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{32}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Rand(String);
	impl ::std::ops::Deref for Rand {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Rand> for String {
		fn from(value: Rand) -> Self {
			value.0
		}
	}

	impl From<&Rand> for Rand {
		fn from(value: &Rand) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Rand {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{32}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{32}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Rand {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Rand {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Rand {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Rand {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Indicates the radio access used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates the radio access used.",
	///  "type": "string",
	///  "enum": [
	///    "NR",
	///    "EUTRA",
	///    "WLAN",
	///    "VIRTUAL",
	///    "NBIOT",
	///    "WIRELINE",
	///    "WIRELINE_CABLE",
	///    "WIRELINE_BBF",
	///    "LTE-M",
	///    "NR_U",
	///    "EUTRA_U",
	///    "TRUSTED_N3GA",
	///    "TRUSTED_WLAN",
	///    "UTRA",
	///    "GERA",
	///    "NR_LEO",
	///    "NR_MEO",
	///    "NR_GEO",
	///    "NR_OTHER_SAT",
	///    "NR_REDCAP",
	///    "WB_E_UTRAN_LEO",
	///    "WB_E_UTRAN_MEO",
	///    "WB_E_UTRAN_GEO",
	///    "WB_E_UTRAN_OTHERSAT",
	///    "NB_IOT_LEO",
	///    "NB_IOT_MEO",
	///    "NB_IOT_GEO",
	///    "NB_IOT_OTHERSAT",
	///    "LTE_M_LEO",
	///    "LTE_M_MEO",
	///    "LTE_M_GEO",
	///    "LTE_M_OTHERSAT"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum RatType {
		#[default]
		#[serde(rename = "NR")]
		Nr,
		#[serde(rename = "EUTRA")]
		Eutra,
		#[serde(rename = "WLAN")]
		Wlan,
		#[serde(rename = "VIRTUAL")]
		Virtual,
		#[serde(rename = "NBIOT")]
		Nbiot,
		#[serde(rename = "WIRELINE")]
		Wireline,
		#[serde(rename = "WIRELINE_CABLE")]
		WirelineCable,
		#[serde(rename = "WIRELINE_BBF")]
		WirelineBbf,
		#[serde(rename = "LTE-M")]
		LteM,
		#[serde(rename = "NR_U")]
		NrU,
		#[serde(rename = "EUTRA_U")]
		EutraU,
		#[serde(rename = "TRUSTED_N3GA")]
		TrustedN3ga,
		#[serde(rename = "TRUSTED_WLAN")]
		TrustedWlan,
		#[serde(rename = "UTRA")]
		Utra,
		#[serde(rename = "GERA")]
		Gera,
		#[serde(rename = "NR_LEO")]
		NrLeo,
		#[serde(rename = "NR_MEO")]
		NrMeo,
		#[serde(rename = "NR_GEO")]
		NrGeo,
		#[serde(rename = "NR_OTHER_SAT")]
		NrOtherSat,
		#[serde(rename = "NR_REDCAP")]
		NrRedcap,
		#[serde(rename = "WB_E_UTRAN_LEO")]
		WbEUtranLeo,
		#[serde(rename = "WB_E_UTRAN_MEO")]
		WbEUtranMeo,
		#[serde(rename = "WB_E_UTRAN_GEO")]
		WbEUtranGeo,
		#[serde(rename = "WB_E_UTRAN_OTHERSAT")]
		WbEUtranOthersat,
		#[serde(rename = "NB_IOT_LEO")]
		NbIotLeo,
		#[serde(rename = "NB_IOT_MEO")]
		NbIotMeo,
		#[serde(rename = "NB_IOT_GEO")]
		NbIotGeo,
		#[serde(rename = "NB_IOT_OTHERSAT")]
		NbIotOthersat,
		#[serde(rename = "LTE_M_LEO")]
		LteMLeo,
		#[serde(rename = "LTE_M_MEO")]
		LteMMeo,
		#[serde(rename = "LTE_M_GEO")]
		LteMGeo,
		#[serde(rename = "LTE_M_OTHERSAT")]
		LteMOthersat,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&RatType> for RatType {
		fn from(value: &RatType) -> Self {
			value.clone()
		}
	}

	impl ToString for RatType {
		fn to_string(&self) -> String {
			match *self {
				Self::Nr => "NR".to_string(),
				Self::Eutra => "EUTRA".to_string(),
				Self::Wlan => "WLAN".to_string(),
				Self::Virtual => "VIRTUAL".to_string(),
				Self::Nbiot => "NBIOT".to_string(),
				Self::Wireline => "WIRELINE".to_string(),
				Self::WirelineCable => "WIRELINE_CABLE".to_string(),
				Self::WirelineBbf => "WIRELINE_BBF".to_string(),
				Self::LteM => "LTE-M".to_string(),
				Self::NrU => "NR_U".to_string(),
				Self::EutraU => "EUTRA_U".to_string(),
				Self::TrustedN3ga => "TRUSTED_N3GA".to_string(),
				Self::TrustedWlan => "TRUSTED_WLAN".to_string(),
				Self::Utra => "UTRA".to_string(),
				Self::Gera => "GERA".to_string(),
				Self::NrLeo => "NR_LEO".to_string(),
				Self::NrMeo => "NR_MEO".to_string(),
				Self::NrGeo => "NR_GEO".to_string(),
				Self::NrOtherSat => "NR_OTHER_SAT".to_string(),
				Self::NrRedcap => "NR_REDCAP".to_string(),
				Self::WbEUtranLeo => "WB_E_UTRAN_LEO".to_string(),
				Self::WbEUtranMeo => "WB_E_UTRAN_MEO".to_string(),
				Self::WbEUtranGeo => "WB_E_UTRAN_GEO".to_string(),
				Self::WbEUtranOthersat => "WB_E_UTRAN_OTHERSAT".to_string(),
				Self::NbIotLeo => "NB_IOT_LEO".to_string(),
				Self::NbIotMeo => "NB_IOT_MEO".to_string(),
				Self::NbIotGeo => "NB_IOT_GEO".to_string(),
				Self::NbIotOthersat => "NB_IOT_OTHERSAT".to_string(),
				Self::LteMLeo => "LTE_M_LEO".to_string(),
				Self::LteMMeo => "LTE_M_MEO".to_string(),
				Self::LteMGeo => "LTE_M_GEO".to_string(),
				Self::LteMOthersat => "LTE_M_OTHERSAT".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for RatType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"NR" => Ok(Self::Nr),
				"EUTRA" => Ok(Self::Eutra),
				"WLAN" => Ok(Self::Wlan),
				"VIRTUAL" => Ok(Self::Virtual),
				"NBIOT" => Ok(Self::Nbiot),
				"WIRELINE" => Ok(Self::Wireline),
				"WIRELINE_CABLE" => Ok(Self::WirelineCable),
				"WIRELINE_BBF" => Ok(Self::WirelineBbf),
				"LTE-M" => Ok(Self::LteM),
				"NR_U" => Ok(Self::NrU),
				"EUTRA_U" => Ok(Self::EutraU),
				"TRUSTED_N3GA" => Ok(Self::TrustedN3ga),
				"TRUSTED_WLAN" => Ok(Self::TrustedWlan),
				"UTRA" => Ok(Self::Utra),
				"GERA" => Ok(Self::Gera),
				"NR_LEO" => Ok(Self::NrLeo),
				"NR_MEO" => Ok(Self::NrMeo),
				"NR_GEO" => Ok(Self::NrGeo),
				"NR_OTHER_SAT" => Ok(Self::NrOtherSat),
				"NR_REDCAP" => Ok(Self::NrRedcap),
				"WB_E_UTRAN_LEO" => Ok(Self::WbEUtranLeo),
				"WB_E_UTRAN_MEO" => Ok(Self::WbEUtranMeo),
				"WB_E_UTRAN_GEO" => Ok(Self::WbEUtranGeo),
				"WB_E_UTRAN_OTHERSAT" => Ok(Self::WbEUtranOthersat),
				"NB_IOT_LEO" => Ok(Self::NbIotLeo),
				"NB_IOT_MEO" => Ok(Self::NbIotMeo),
				"NB_IOT_GEO" => Ok(Self::NbIotGeo),
				"NB_IOT_OTHERSAT" => Ok(Self::NbIotOthersat),
				"LTE_M_LEO" => Ok(Self::LteMLeo),
				"LTE_M_MEO" => Ok(Self::LteMMeo),
				"LTE_M_GEO" => Ok(Self::LteMGeo),
				"LTE_M_OTHERSAT" => Ok(Self::LteMOthersat),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for RatType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for RatType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for RatType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// ReachabilityForDataConfiguration
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "reportCfg"
	///  ],
	///  "properties": {
	///    "minInterval": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "reportCfg": {
	///      "$ref": "#/components/schemas/ReachabilityForDataReportConfig"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ReachabilityForDataConfiguration {
		#[serde(
			rename = "minInterval",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub min_interval: Option<DurationSec>,
		#[serde(rename = "reportCfg")]
		pub report_cfg: ReachabilityForDataReportConfig,
	}

	impl From<&ReachabilityForDataConfiguration> for ReachabilityForDataConfiguration {
		fn from(value: &ReachabilityForDataConfiguration) -> Self {
			value.clone()
		}
	}

	/// ReachabilityForDataReportConfig
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "DIRECT_REPORT",
	///    "INDIRECT_REPORT"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum ReachabilityForDataReportConfig {
		#[default]
		#[serde(rename = "DIRECT_REPORT")]
		DirectReport,
		#[serde(rename = "INDIRECT_REPORT")]
		IndirectReport,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&ReachabilityForDataReportConfig> for ReachabilityForDataReportConfig {
		fn from(value: &ReachabilityForDataReportConfig) -> Self {
			value.clone()
		}
	}

	impl ToString for ReachabilityForDataReportConfig {
		fn to_string(&self) -> String {
			match *self {
				Self::DirectReport => "DIRECT_REPORT".to_string(),
				Self::IndirectReport => "INDIRECT_REPORT".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for ReachabilityForDataReportConfig {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"DIRECT_REPORT" => Ok(Self::DirectReport),
				"INDIRECT_REPORT" => Ok(Self::IndirectReport),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for ReachabilityForDataReportConfig {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for ReachabilityForDataReportConfig {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for ReachabilityForDataReportConfig {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// ReachabilityForSmsConfiguration
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "REACHABILITY_FOR_SMS_OVER_NAS",
	///    "REACHABILITY_FOR_SMS_OVER_IP"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum ReachabilityForSmsConfiguration {
		#[default]
		#[serde(rename = "REACHABILITY_FOR_SMS_OVER_NAS")]
		ReachabilityForSmsOverNas,
		#[serde(rename = "REACHABILITY_FOR_SMS_OVER_IP")]
		ReachabilityForSmsOverIp,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&ReachabilityForSmsConfiguration> for ReachabilityForSmsConfiguration {
		fn from(value: &ReachabilityForSmsConfiguration) -> Self {
			value.clone()
		}
	}

	impl ToString for ReachabilityForSmsConfiguration {
		fn to_string(&self) -> String {
			match *self {
				Self::ReachabilityForSmsOverNas => "REACHABILITY_FOR_SMS_OVER_NAS".to_string(),
				Self::ReachabilityForSmsOverIp => "REACHABILITY_FOR_SMS_OVER_IP".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for ReachabilityForSmsConfiguration {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"REACHABILITY_FOR_SMS_OVER_NAS" => Ok(Self::ReachabilityForSmsOverNas),
				"REACHABILITY_FOR_SMS_OVER_IP" => Ok(Self::ReachabilityForSmsOverIp),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for ReachabilityForSmsConfiguration {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for ReachabilityForSmsConfiguration {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for ReachabilityForSmsConfiguration {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// ReachabilityForSmsReport
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "smsfAccessType"
	///  ],
	///  "properties": {
	///    "maxAvailabilityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "smsfAccessType": {
	///      "$ref": "#/components/schemas/AccessType"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ReachabilityForSmsReport {
		#[serde(
			rename = "maxAvailabilityTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub max_availability_time: Option<DateTime>,
		#[serde(rename = "smsfAccessType")]
		pub smsf_access_type: AccessType,
	}

	impl From<&ReachabilityForSmsReport> for ReachabilityForSmsReport {
		fn from(value: &ReachabilityForSmsReport) -> Self {
			value.clone()
		}
	}

	/// ReachabilityReport
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "accessTypeList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/AccessType"
	///      },
	///      "minItems": 1
	///    },
	///    "amfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "idleStatusIndication": {
	///      "$ref": "#/components/schemas/IdleStatusIndication"
	///    },
	///    "maxAvailabilityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "reachability": {
	///      "$ref": "#/components/schemas/UeReachability"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ReachabilityReport {
		#[serde(
			rename = "accessTypeList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub access_type_list: Vec<AccessType>,
		#[serde(
			rename = "amfInstanceId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub amf_instance_id: Option<NfInstanceId>,
		#[serde(
			rename = "idleStatusIndication",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub idle_status_indication: Option<IdleStatusIndication>,
		#[serde(
			rename = "maxAvailabilityTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub max_availability_time: Option<DateTime>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub reachability: Option<UeReachability>,
	}

	impl From<&ReachabilityReport> for ReachabilityReport {
		fn from(value: &ReachabilityReport) -> Self {
			value.clone()
		}
	}

	/// The response shall include a Location header field containing a
	/// different URI  (pointing to a different URI of an other service
	/// instance), or the same URI if a request  is redirected to the same
	/// target resource via a different SCP.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The response shall include a Location header field
	/// containing a different URI  (pointing to a different URI of an other
	/// service instance), or the same URI if a request  is redirected to the
	/// same target resource via a different SCP.\n",
	///  "type": "object",
	///  "properties": {
	///    "cause": {
	///      "type": "string"
	///    },
	///    "targetScp": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "targetSepp": {
	///      "$ref": "#/components/schemas/Uri"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct RedirectResponse {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub cause: Option<String>,
		#[serde(rename = "targetScp", default, skip_serializing_if = "Option::is_none")]
		pub target_scp: Option<Uri>,
		#[serde(
			rename = "targetSepp",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub target_sepp: Option<Uri>,
	}

	impl From<&RedirectResponse> for RedirectResponse {
		fn from(value: &RedirectResponse) -> Self {
			value.clone()
		}
	}

	/// ReferenceId
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "integer"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ReferenceId(pub i64);
	impl ::std::ops::Deref for ReferenceId {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<ReferenceId> for i64 {
		fn from(value: ReferenceId) -> Self {
			value.0
		}
	}

	impl From<&ReferenceId> for ReferenceId {
		fn from(value: &ReferenceId) -> Self {
			value.clone()
		}
	}

	impl From<i64> for ReferenceId {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for ReferenceId {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for ReferenceId {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for ReferenceId {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for ReferenceId {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for ReferenceId {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// RegistrationDataSetName
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "AMF_3GPP",
	///    "AMF_NON_3GPP",
	///    "SMF_PDU_SESSIONS",
	///    "SMSF_3GPP",
	///    "SMSF_NON_3GPP",
	///    "IP_SM_GW",
	///    "NWDAF"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum RegistrationDataSetName {
		#[default]
		#[serde(rename = "AMF_3GPP")]
		Amf3gpp,
		#[serde(rename = "AMF_NON_3GPP")]
		AmfNon3gpp,
		#[serde(rename = "SMF_PDU_SESSIONS")]
		SmfPduSessions,
		#[serde(rename = "SMSF_3GPP")]
		Smsf3gpp,
		#[serde(rename = "SMSF_NON_3GPP")]
		SmsfNon3gpp,
		#[serde(rename = "IP_SM_GW")]
		IpSmGw,
		#[serde(rename = "NWDAF")]
		Nwdaf,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&RegistrationDataSetName> for RegistrationDataSetName {
		fn from(value: &RegistrationDataSetName) -> Self {
			value.clone()
		}
	}

	impl ToString for RegistrationDataSetName {
		fn to_string(&self) -> String {
			match *self {
				Self::Amf3gpp => "AMF_3GPP".to_string(),
				Self::AmfNon3gpp => "AMF_NON_3GPP".to_string(),
				Self::SmfPduSessions => "SMF_PDU_SESSIONS".to_string(),
				Self::Smsf3gpp => "SMSF_3GPP".to_string(),
				Self::SmsfNon3gpp => "SMSF_NON_3GPP".to_string(),
				Self::IpSmGw => "IP_SM_GW".to_string(),
				Self::Nwdaf => "NWDAF".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for RegistrationDataSetName {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"AMF_3GPP" => Ok(Self::Amf3gpp),
				"AMF_NON_3GPP" => Ok(Self::AmfNon3gpp),
				"SMF_PDU_SESSIONS" => Ok(Self::SmfPduSessions),
				"SMSF_3GPP" => Ok(Self::Smsf3gpp),
				"SMSF_NON_3GPP" => Ok(Self::SmsfNon3gpp),
				"IP_SM_GW" => Ok(Self::IpSmGw),
				"NWDAF" => Ok(Self::Nwdaf),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for RegistrationDataSetName {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for RegistrationDataSetName {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for RegistrationDataSetName {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// RegistrationDataSets
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "amf3Gpp": {
	///      "$ref": "#/components/schemas/Amf3GppAccessRegistration"
	///    },
	///    "amfNon3Gpp": {
	///      "$ref": "#/components/schemas/AmfNon3GppAccessRegistration"
	///    },
	///    "ipSmGw": {
	///      "$ref": "#/components/schemas/IpSmGwRegistration"
	///    },
	///    "nwdafRegistration": {
	///      "$ref": "#/components/schemas/NwdafRegistrationInfo"
	///    },
	///    "smfRegistration": {
	///      "$ref": "#/components/schemas/SmfRegistrationInfo"
	///    },
	///    "smsf3Gpp": {
	///      "$ref": "#/components/schemas/SmsfRegistration"
	///    },
	///    "smsfNon3Gpp": {
	///      "$ref": "#/components/schemas/SmsfRegistration"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct RegistrationDataSets {
		#[serde(rename = "amf3Gpp", default, skip_serializing_if = "Option::is_none")]
		pub amf3_gpp: Option<Amf3GppAccessRegistration>,
		#[serde(
			rename = "amfNon3Gpp",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub amf_non3_gpp: Option<AmfNon3GppAccessRegistration>,
		#[serde(rename = "ipSmGw", default, skip_serializing_if = "Option::is_none")]
		pub ip_sm_gw: Option<IpSmGwRegistration>,
		#[serde(
			rename = "nwdafRegistration",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub nwdaf_registration: Option<NwdafRegistrationInfo>,
		#[serde(
			rename = "smfRegistration",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub smf_registration: Option<SmfRegistrationInfo>,
		#[serde(rename = "smsf3Gpp", default, skip_serializing_if = "Option::is_none")]
		pub smsf3_gpp: Option<SmsfRegistration>,
		#[serde(
			rename = "smsfNon3Gpp",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub smsf_non3_gpp: Option<SmsfRegistration>,
	}

	impl From<&RegistrationDataSets> for RegistrationDataSets {
		fn from(value: &RegistrationDataSets) -> Self {
			value.clone()
		}
	}

	/// RegistrationDatasetNames
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "array",
	///  "items": {
	///    "$ref": "#/components/schemas/RegistrationDataSetName"
	///  },
	///  "minItems": 2,
	///  "uniqueItems": true
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct RegistrationDatasetNames(pub Vec<RegistrationDataSetName>);
	impl ::std::ops::Deref for RegistrationDatasetNames {
		type Target = Vec<RegistrationDataSetName>;
		fn deref(&self) -> &Vec<RegistrationDataSetName> {
			&self.0
		}
	}

	impl From<RegistrationDatasetNames> for Vec<RegistrationDataSetName> {
		fn from(value: RegistrationDatasetNames) -> Self {
			value.0
		}
	}

	impl From<&RegistrationDatasetNames> for RegistrationDatasetNames {
		fn from(value: &RegistrationDatasetNames) -> Self {
			value.clone()
		}
	}

	impl From<Vec<RegistrationDataSetName>> for RegistrationDatasetNames {
		fn from(value: Vec<RegistrationDataSetName>) -> Self {
			Self(value)
		}
	}

	/// RegistrationLocationInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "accessTypeList",
	///    "amfInstanceId"
	///  ],
	///  "properties": {
	///    "accessTypeList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/AccessType"
	///      },
	///      "maxItems": 2,
	///      "minItems": 1
	///    },
	///    "amfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "guami": {
	///      "$ref": "#/components/schemas/Guami"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "vgmlcAddress": {
	///      "$ref": "#/components/schemas/VgmlcAddress"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct RegistrationLocationInfo {
		#[serde(rename = "accessTypeList")]
		pub access_type_list: Vec<AccessType>,
		#[serde(rename = "amfInstanceId")]
		pub amf_instance_id: NfInstanceId,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub guami: Option<Guami>,
		#[serde(rename = "plmnId", default, skip_serializing_if = "Option::is_none")]
		pub plmn_id: Option<PlmnId>,
		#[serde(
			rename = "vgmlcAddress",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub vgmlc_address: Option<VgmlcAddress>,
	}

	impl From<&RegistrationLocationInfo> for RegistrationLocationInfo {
		fn from(value: &RegistrationLocationInfo) -> Self {
			value.clone()
		}
	}

	/// RegistrationReason
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "SMF_CONTEXT_TRANSFERRED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum RegistrationReason {
		#[default]
		#[serde(rename = "SMF_CONTEXT_TRANSFERRED")]
		SmfContextTransferred,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&RegistrationReason> for RegistrationReason {
		fn from(value: &RegistrationReason) -> Self {
			value.clone()
		}
	}

	impl ToString for RegistrationReason {
		fn to_string(&self) -> String {
			match *self {
				Self::SmfContextTransferred => "SMF_CONTEXT_TRANSFERRED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for RegistrationReason {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"SMF_CONTEXT_TRANSFERRED" => Ok(Self::SmfContextTransferred),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for RegistrationReason {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for RegistrationReason {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for RegistrationReason {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Relative Cartesian Location
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Relative Cartesian Location",
	///  "type": "object",
	///  "required": [
	///    "x",
	///    "y"
	///  ],
	///  "properties": {
	///    "x": {
	///      "$ref": "#/components/schemas/Float"
	///    },
	///    "y": {
	///      "$ref": "#/components/schemas/Float"
	///    },
	///    "z": {
	///      "$ref": "#/components/schemas/Float"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct RelativeCartesianLocation {
		pub x: Float,
		pub y: Float,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub z: Option<Float>,
	}

	impl From<&RelativeCartesianLocation> for RelativeCartesianLocation {
		fn from(value: &RelativeCartesianLocation) -> Self {
			value.clone()
		}
	}

	/// Relay Service Code to identify a connectivity service provided by the
	/// UE-to-Network relay.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Relay Service Code to identify a connectivity service
	/// provided by the UE-to-Network relay.\n",
	///  "type": "integer",
	///  "maximum": 16777215.0,
	///  "minimum": 0.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct RelayServiceCode(pub i64);
	impl ::std::ops::Deref for RelayServiceCode {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<RelayServiceCode> for i64 {
		fn from(value: RelayServiceCode) -> Self {
			value.0
		}
	}

	impl From<&RelayServiceCode> for RelayServiceCode {
		fn from(value: &RelayServiceCode) -> Self {
			value.clone()
		}
	}

	impl From<i64> for RelayServiceCode {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for RelayServiceCode {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for RelayServiceCode {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for RelayServiceCode {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for RelayServiceCode {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for RelayServiceCode {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Report
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "oneOf": [
	///    {
	///      "$ref": "#/components/schemas/ChangeOfSupiPeiAssociationReport"
	///    },
	///    {
	///      "$ref": "#/components/schemas/RoamingStatusReport"
	///    },
	///    {
	///      "$ref": "#/components/schemas/CnTypeChangeReport"
	///    },
	///    {
	///      "$ref": "#/components/schemas/CmInfoReport"
	///    },
	///    {
	///      "$ref": "#/components/schemas/LossConnectivityReport"
	///    },
	///    {
	///      "$ref": "#/components/schemas/LocationReport"
	///    },
	///    {
	///      "$ref": "#/components/schemas/PdnConnectivityStatReport"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum Report {
		#[default]
		ChangeOfSupiPeiAssociationReport(ChangeOfSupiPeiAssociationReport),
		RoamingStatusReport(RoamingStatusReport),
		CnTypeChangeReport(CnTypeChangeReport),
		CmInfoReport(CmInfoReport),
		LossConnectivityReport(LossConnectivityReport),
		LocationReport(LocationReport),
		PdnConnectivityStatReport(PdnConnectivityStatReport),
	}

	impl From<&Report> for Report {
		fn from(value: &Report) -> Self {
			value.clone()
		}
	}

	impl From<ChangeOfSupiPeiAssociationReport> for Report {
		fn from(value: ChangeOfSupiPeiAssociationReport) -> Self {
			Self::ChangeOfSupiPeiAssociationReport(value)
		}
	}

	impl From<RoamingStatusReport> for Report {
		fn from(value: RoamingStatusReport) -> Self {
			Self::RoamingStatusReport(value)
		}
	}

	impl From<CnTypeChangeReport> for Report {
		fn from(value: CnTypeChangeReport) -> Self {
			Self::CnTypeChangeReport(value)
		}
	}

	impl From<CmInfoReport> for Report {
		fn from(value: CmInfoReport) -> Self {
			Self::CmInfoReport(value)
		}
	}

	impl From<LossConnectivityReport> for Report {
		fn from(value: LossConnectivityReport) -> Self {
			Self::LossConnectivityReport(value)
		}
	}

	impl From<LocationReport> for Report {
		fn from(value: LocationReport) -> Self {
			Self::LocationReport(value)
		}
	}

	impl From<PdnConnectivityStatReport> for Report {
		fn from(value: PdnConnectivityStatReport) -> Self {
			Self::PdnConnectivityStatReport(value)
		}
	}

	/// The enumeration ReportAmountMdt defines Report Amount for MDT in the
	/// trace. See 3GPP TS 32.422 for further description of the values. It
	/// shall comply with the provisions defined in table 5.6.3.10-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration ReportAmountMdt defines Report Amount
	/// for MDT in the trace. See 3GPP TS 32.422 for further description of the
	/// values. It shall comply with the provisions defined in table
	/// 5.6.3.10-1.\n",
	///  "type": "string",
	///  "enum": [
	///    1,
	///    2,
	///    4,
	///    8,
	///    16,
	///    32,
	///    64,
	///    "infinity"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum ReportAmountMdt {
		#[default]
		#[serde(rename = "1")]
		NUM1,
		#[serde(rename = "2")]
		NUM2,
		#[serde(rename = "4")]
		NUM4,
		#[serde(rename = "8")]
		NUM8,
		#[serde(rename = "16")]
		NUM16,
		#[serde(rename = "32")]
		NUM32,
		#[serde(rename = "64")]
		NUM64,
		#[serde(rename = "infinity")]
		Infinity,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&ReportAmountMdt> for ReportAmountMdt {
		fn from(value: &ReportAmountMdt) -> Self {
			value.clone()
		}
	}

	impl ToString for ReportAmountMdt {
		fn to_string(&self) -> String {
			match *self {
				Self::NUM1 => "1".to_string(),
				Self::NUM2 => "2".to_string(),
				Self::NUM4 => "4".to_string(),
				Self::NUM8 => "8".to_string(),
				Self::NUM16 => "16".to_string(),
				Self::NUM32 => "32".to_string(),
				Self::NUM64 => "64".to_string(),
				Self::Infinity => "infinity".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for ReportAmountMdt {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"1" => Ok(Self::NUM1),
				"2" => Ok(Self::NUM2),
				"4" => Ok(Self::NUM4),
				"8" => Ok(Self::NUM8),
				"16" => Ok(Self::NUM16),
				"32" => Ok(Self::NUM32),
				"64" => Ok(Self::NUM64),
				"infinity" => Ok(Self::Infinity),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for ReportAmountMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for ReportAmountMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for ReportAmountMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// The enumeration ReportIntervalMdt defines Report Interval for MDT in the
	/// trace. See 3GPP TS 32.422 for further description of the values. It
	/// shall comply with the provisions defined in table 5.6.3.9-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration ReportIntervalMdt defines Report
	/// Interval for MDT in the trace. See 3GPP TS 32.422 for further
	/// description of the values. It shall comply with the provisions defined
	/// in table 5.6.3.9-1.\n",
	///  "type": "string",
	///  "enum": [
	///    120,
	///    240,
	///    480,
	///    640,
	///    1024,
	///    2048,
	///    5120,
	///    10240,
	///    60000,
	///    360000,
	///    720000,
	///    1800000,
	///    3600000
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum ReportIntervalMdt {
		#[default]
		#[serde(rename = "120")]
		NUM120,
		#[serde(rename = "240")]
		NUM240,
		#[serde(rename = "480")]
		NUM480,
		#[serde(rename = "640")]
		NUM640,
		#[serde(rename = "1024")]
		NUM1024,
		#[serde(rename = "2048")]
		NUM2048,
		#[serde(rename = "5120")]
		NUM5120,
		#[serde(rename = "10240")]
		NUM10240,
		#[serde(rename = "60000")]
		NUM60000,
		#[serde(rename = "360000")]
		NUM360000,
		#[serde(rename = "720000")]
		NUM720000,
		#[serde(rename = "1800000")]
		NUM1800000,
		#[serde(rename = "3600000")]
		NUM3600000,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&ReportIntervalMdt> for ReportIntervalMdt {
		fn from(value: &ReportIntervalMdt) -> Self {
			value.clone()
		}
	}

	impl ToString for ReportIntervalMdt {
		fn to_string(&self) -> String {
			match *self {
				Self::NUM120 => "120".to_string(),
				Self::NUM240 => "240".to_string(),
				Self::NUM480 => "480".to_string(),
				Self::NUM640 => "640".to_string(),
				Self::NUM1024 => "1024".to_string(),
				Self::NUM2048 => "2048".to_string(),
				Self::NUM5120 => "5120".to_string(),
				Self::NUM10240 => "10240".to_string(),
				Self::NUM60000 => "60000".to_string(),
				Self::NUM360000 => "360000".to_string(),
				Self::NUM720000 => "720000".to_string(),
				Self::NUM1800000 => "1800000".to_string(),
				Self::NUM3600000 => "3600000".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for ReportIntervalMdt {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"120" => Ok(Self::NUM120),
				"240" => Ok(Self::NUM240),
				"480" => Ok(Self::NUM480),
				"640" => Ok(Self::NUM640),
				"1024" => Ok(Self::NUM1024),
				"2048" => Ok(Self::NUM2048),
				"5120" => Ok(Self::NUM5120),
				"10240" => Ok(Self::NUM10240),
				"60000" => Ok(Self::NUM60000),
				"360000" => Ok(Self::NUM360000),
				"720000" => Ok(Self::NUM720000),
				"1800000" => Ok(Self::NUM1800000),
				"3600000" => Ok(Self::NUM3600000),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for ReportIntervalMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for ReportIntervalMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for ReportIntervalMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// The enumeration ReportIntervalNrMdt defines Report Interval in NR for
	/// MDT in the trace. See 3GPP TS 32.422 for further description of the
	/// values. It shall comply with the provisions defined in table 5.6.3.17-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration ReportIntervalNrMdt defines Report
	/// Interval in NR for MDT in the trace. See 3GPP TS 32.422 for further
	/// description of the values. It shall comply with the provisions defined
	/// in table 5.6.3.17-1.\n",
	///  "type": "string",
	///  "enum": [
	///    120,
	///    240,
	///    480,
	///    640,
	///    1024,
	///    2048,
	///    5120,
	///    10240,
	///    20480,
	///    40960,
	///    60000,
	///    360000,
	///    720000,
	///    1800000,
	///    3600000
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum ReportIntervalNrMdt {
		#[default]
		#[serde(rename = "120")]
		NUM120,
		#[serde(rename = "240")]
		NUM240,
		#[serde(rename = "480")]
		NUM480,
		#[serde(rename = "640")]
		NUM640,
		#[serde(rename = "1024")]
		NUM1024,
		#[serde(rename = "2048")]
		NUM2048,
		#[serde(rename = "5120")]
		NUM5120,
		#[serde(rename = "10240")]
		NUM10240,
		#[serde(rename = "20480")]
		NUM20480,
		#[serde(rename = "40960")]
		NUM40960,
		#[serde(rename = "60000")]
		NUM60000,
		#[serde(rename = "360000")]
		NUM360000,
		#[serde(rename = "720000")]
		NUM720000,
		#[serde(rename = "1800000")]
		NUM1800000,
		#[serde(rename = "3600000")]
		NUM3600000,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&ReportIntervalNrMdt> for ReportIntervalNrMdt {
		fn from(value: &ReportIntervalNrMdt) -> Self {
			value.clone()
		}
	}

	impl ToString for ReportIntervalNrMdt {
		fn to_string(&self) -> String {
			match *self {
				Self::NUM120 => "120".to_string(),
				Self::NUM240 => "240".to_string(),
				Self::NUM480 => "480".to_string(),
				Self::NUM640 => "640".to_string(),
				Self::NUM1024 => "1024".to_string(),
				Self::NUM2048 => "2048".to_string(),
				Self::NUM5120 => "5120".to_string(),
				Self::NUM10240 => "10240".to_string(),
				Self::NUM20480 => "20480".to_string(),
				Self::NUM40960 => "40960".to_string(),
				Self::NUM60000 => "60000".to_string(),
				Self::NUM360000 => "360000".to_string(),
				Self::NUM720000 => "720000".to_string(),
				Self::NUM1800000 => "1800000".to_string(),
				Self::NUM3600000 => "3600000".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for ReportIntervalNrMdt {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"120" => Ok(Self::NUM120),
				"240" => Ok(Self::NUM240),
				"480" => Ok(Self::NUM480),
				"640" => Ok(Self::NUM640),
				"1024" => Ok(Self::NUM1024),
				"2048" => Ok(Self::NUM2048),
				"5120" => Ok(Self::NUM5120),
				"10240" => Ok(Self::NUM10240),
				"20480" => Ok(Self::NUM20480),
				"40960" => Ok(Self::NUM40960),
				"60000" => Ok(Self::NUM60000),
				"360000" => Ok(Self::NUM360000),
				"720000" => Ok(Self::NUM720000),
				"1800000" => Ok(Self::NUM1800000),
				"3600000" => Ok(Self::NUM3600000),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for ReportIntervalNrMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for ReportIntervalNrMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for ReportIntervalNrMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// indicates performed modivications.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "indicates performed modivications.",
	///  "type": "object",
	///  "required": [
	///    "path"
	///  ],
	///  "properties": {
	///    "path": {
	///      "description": "Contains a JSON pointer value (as defined in IETF
	/// RFC 6901) that references a  location of a resource to which the
	/// modification is subject.\n",
	///      "type": "string"
	///    },
	///    "reason": {
	///      "description": "A human-readable reason providing details on the
	/// reported modification failure.  The reason string should identify the
	/// operation that failed using the operation's  array index to assist in
	/// correlation of the invalid parameter with the failed  operation, e.g.
	/// \"Replacement value invalid for attribute (failed operation index=
	/// 4)\".\n",
	///      "type": "string"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ReportItem {
		/// Contains a JSON pointer value (as defined in IETF RFC 6901) that
		/// references a  location of a resource to which the modification is
		/// subject.
		pub path: String,
		/// A human-readable reason providing details on the reported
		/// modification failure.  The reason string should identify the
		/// operation that failed using the operation's  array index to assist
		/// in correlation of the invalid parameter with the failed  operation,
		/// e.g. "Replacement value invalid for attribute (failed operation
		/// index= 4)".
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub reason: Option<String>,
	}

	impl From<&ReportItem> for ReportItem {
		fn from(value: &ReportItem) -> Self {
			value.clone()
		}
	}

	/// The enumeration ReportTypeMdt defines Report Type for logged MDT in the
	/// trace. See 3GPP TS 32.422 for further description of the values. It
	/// shall comply with the provisions defined in table 5.6.3.4-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration ReportTypeMdt defines Report Type for
	/// logged MDT in the trace. See 3GPP TS 32.422 for further description of
	/// the values. It shall comply with the provisions defined in table
	/// 5.6.3.4-1.\n",
	///  "type": "string",
	///  "enum": [
	///    "PERIODICAL",
	///    "EVENT_TRIGGED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum ReportTypeMdt {
		#[default]
		#[serde(rename = "PERIODICAL")]
		Periodical,
		#[serde(rename = "EVENT_TRIGGED")]
		EventTrigged,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&ReportTypeMdt> for ReportTypeMdt {
		fn from(value: &ReportTypeMdt) -> Self {
			value.clone()
		}
	}

	impl ToString for ReportTypeMdt {
		fn to_string(&self) -> String {
			match *self {
				Self::Periodical => "PERIODICAL".to_string(),
				Self::EventTrigged => "EVENT_TRIGGED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for ReportTypeMdt {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"PERIODICAL" => Ok(Self::Periodical),
				"EVENT_TRIGGED" => Ok(Self::EventTrigged),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for ReportTypeMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for ReportTypeMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for ReportTypeMdt {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// ReportingOptions
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "expiry": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "guardTime": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "maxNumOfReports": {
	///      "$ref": "#/components/schemas/MaxNumOfReports"
	///    },
	///    "notifFlag": {
	///      "$ref": "#/components/schemas/NotificationFlag"
	///    },
	///    "reportMode": {
	///      "$ref": "#/components/schemas/EventReportMode"
	///    },
	///    "reportPeriod": {
	///      "$ref": "#/components/schemas/DurationSec"
	///    },
	///    "samplingRatio": {
	///      "$ref": "#/components/schemas/SamplingRatio"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ReportingOptions {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub expiry: Option<DateTime>,
		#[serde(rename = "guardTime", default, skip_serializing_if = "Option::is_none")]
		pub guard_time: Option<DurationSec>,
		#[serde(
			rename = "maxNumOfReports",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub max_num_of_reports: Option<MaxNumOfReports>,
		#[serde(rename = "notifFlag", default, skip_serializing_if = "Option::is_none")]
		pub notif_flag: Option<NotificationFlag>,
		#[serde(
			rename = "reportMode",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub report_mode: Option<EventReportMode>,
		#[serde(
			rename = "reportPeriod",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub report_period: Option<DurationSec>,
		#[serde(
			rename = "samplingRatio",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub sampling_ratio: Option<SamplingRatio>,
	}

	impl From<&ReportingOptions> for ReportingOptions {
		fn from(value: &ReportingOptions) -> Self {
			value.clone()
		}
	}

	/// The enumeration ReportingTrigger defines Reporting Triggers for MDT in
	/// the trace. See 3GPP TS 32.42] for further  description of the values. It
	/// shall comply with the provisions defined in table 5.6.3.8-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration ReportingTrigger defines Reporting
	/// Triggers for MDT in the trace. See 3GPP TS 32.42] for further
	/// description of the values. It shall comply with the provisions defined
	/// in table 5.6.3.8-1.\n",
	///  "type": "string",
	///  "enum": [
	///    "PERIODICAL",
	///    "EVENT_A2",
	///    "EVENT_A2_PERIODIC",
	///    "ALL_RRM_EVENT_TRIGGERS"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum ReportingTrigger {
		#[default]
		#[serde(rename = "PERIODICAL")]
		Periodical,
		#[serde(rename = "EVENT_A2")]
		EventA2,
		#[serde(rename = "EVENT_A2_PERIODIC")]
		EventA2Periodic,
		#[serde(rename = "ALL_RRM_EVENT_TRIGGERS")]
		AllRrmEventTriggers,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&ReportingTrigger> for ReportingTrigger {
		fn from(value: &ReportingTrigger) -> Self {
			value.clone()
		}
	}

	impl ToString for ReportingTrigger {
		fn to_string(&self) -> String {
			match *self {
				Self::Periodical => "PERIODICAL".to_string(),
				Self::EventA2 => "EVENT_A2".to_string(),
				Self::EventA2Periodic => "EVENT_A2_PERIODIC".to_string(),
				Self::AllRrmEventTriggers => "ALL_RRM_EVENT_TRIGGERS".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for ReportingTrigger {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"PERIODICAL" => Ok(Self::Periodical),
				"EVENT_A2" => Ok(Self::EventA2),
				"EVENT_A2_PERIODIC" => Ok(Self::EventA2Periodic),
				"ALL_RRM_EVENT_TRIGGERS" => Ok(Self::AllRrmEventTriggers),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for ReportingTrigger {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for ReportingTrigger {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for ReportingTrigger {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// It contains the restriction type ALLOWED_AREAS or NOT_ALLOWED_AREAS.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "It contains the restriction type ALLOWED_AREAS or
	/// NOT_ALLOWED_AREAS.",
	///  "type": "string",
	///  "enum": [
	///    "ALLOWED_AREAS",
	///    "NOT_ALLOWED_AREAS"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum RestrictionType {
		#[default]
		#[serde(rename = "ALLOWED_AREAS")]
		AllowedAreas,
		#[serde(rename = "NOT_ALLOWED_AREAS")]
		NotAllowedAreas,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&RestrictionType> for RestrictionType {
		fn from(value: &RestrictionType) -> Self {
			value.clone()
		}
	}

	impl ToString for RestrictionType {
		fn to_string(&self) -> String {
			match *self {
				Self::AllowedAreas => "ALLOWED_AREAS".to_string(),
				Self::NotAllowedAreas => "NOT_ALLOWED_AREAS".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for RestrictionType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"ALLOWED_AREAS" => Ok(Self::AllowedAreas),
				"NOT_ALLOWED_AREAS" => Ok(Self::NotAllowedAreas),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for RestrictionType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for RestrictionType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for RestrictionType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// ResynchronizationInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "auts",
	///    "rand"
	///  ],
	///  "properties": {
	///    "auts": {
	///      "$ref": "#/components/schemas/Auts"
	///    },
	///    "rand": {
	///      "$ref": "#/components/schemas/Rand"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ResynchronizationInfo {
		pub auts: Auts,
		pub rand: Rand,
	}

	impl From<&ResynchronizationInfo> for ResynchronizationInfo {
		fn from(value: &ResynchronizationInfo) -> Self {
			value.clone()
		}
	}

	/// RevokedCause
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "NOT_ALLOWED",
	///    "EXCLUDED_FROM_GROUP",
	///    "GPSI_REMOVED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum RevokedCause {
		#[default]
		#[serde(rename = "NOT_ALLOWED")]
		NotAllowed,
		#[serde(rename = "EXCLUDED_FROM_GROUP")]
		ExcludedFromGroup,
		#[serde(rename = "GPSI_REMOVED")]
		GpsiRemoved,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&RevokedCause> for RevokedCause {
		fn from(value: &RevokedCause) -> Self {
			value.clone()
		}
	}

	impl ToString for RevokedCause {
		fn to_string(&self) -> String {
			match *self {
				Self::NotAllowed => "NOT_ALLOWED".to_string(),
				Self::ExcludedFromGroup => "EXCLUDED_FROM_GROUP".to_string(),
				Self::GpsiRemoved => "GPSI_REMOVED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for RevokedCause {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"NOT_ALLOWED" => Ok(Self::NotAllowed),
				"EXCLUDED_FROM_GROUP" => Ok(Self::ExcludedFromGroup),
				"GPSI_REMOVED" => Ok(Self::GpsiRemoved),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for RevokedCause {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for RevokedCause {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for RevokedCause {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Unsigned integer representing the 'Subscriber Profile ID for
	/// RAT/Frequency Priority'  as specified in 3GPP TS 36.413 with the OpenAPI
	/// 'nullable: true' property.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Unsigned integer representing the 'Subscriber Profile
	/// ID for RAT/Frequency Priority'  as specified in 3GPP TS 36.413 with the
	/// OpenAPI 'nullable: true' property. \n",
	///  "type": [
	///    "integer",
	///    "null"
	///  ],
	///  "maximum": 256.0,
	///  "minimum": 1.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct RfspIndexRm(pub Option<i64>);
	impl ::std::ops::Deref for RfspIndexRm {
		type Target = Option<i64>;
		fn deref(&self) -> &Option<i64> {
			&self.0
		}
	}

	impl From<RfspIndexRm> for Option<i64> {
		fn from(value: RfspIndexRm) -> Self {
			value.0
		}
	}

	impl From<&RfspIndexRm> for RfspIndexRm {
		fn from(value: &RfspIndexRm) -> Self {
			value.clone()
		}
	}

	impl From<Option<i64>> for RfspIndexRm {
		fn from(value: Option<i64>) -> Self {
			Self(value)
		}
	}

	/// RgAuthCtx
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "authInd"
	///  ],
	///  "properties": {
	///    "authInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "supi": {
	///      "$ref": "#/components/schemas/Supi"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct RgAuthCtx {
		#[serde(rename = "authInd")]
		pub auth_ind: bool,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub supi: Option<Supi>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&RgAuthCtx> for RgAuthCtx {
		fn from(value: &RgAuthCtx) -> Self {
			value.clone()
		}
	}

	/// Contains the Roaming Information Update
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the Roaming Information Update",
	///  "type": "object",
	///  "required": [
	///    "servingPlmn"
	///  ],
	///  "properties": {
	///    "roaming": {
	///      "type": "boolean"
	///    },
	///    "servingPlmn": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct RoamingInfoUpdate {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub roaming: Option<bool>,
		#[serde(rename = "servingPlmn")]
		pub serving_plmn: PlmnId,
	}

	impl From<&RoamingInfoUpdate> for RoamingInfoUpdate {
		fn from(value: &RoamingInfoUpdate) -> Self {
			value.clone()
		}
	}

	/// Indicates if access is allowed to a given serving network, e.g. a PLMN
	/// (MCC, MNC) or an  SNPN (MCC, MNC, NID).
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates if access is allowed to a given serving
	/// network, e.g. a PLMN (MCC, MNC) or an  SNPN (MCC, MNC, NID).\n",
	///  "type": "object",
	///  "properties": {
	///    "accessAllowed": {
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct RoamingRestrictions {
		#[serde(
			rename = "accessAllowed",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub access_allowed: Option<bool>,
	}

	impl From<&RoamingRestrictions> for RoamingRestrictions {
		fn from(value: &RoamingRestrictions) -> Self {
			value.clone()
		}
	}

	/// RoamingStatusReport
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "newServingPlmn",
	///    "roaming"
	///  ],
	///  "properties": {
	///    "accessType": {
	///      "$ref": "#/components/schemas/AccessType"
	///    },
	///    "newServingPlmn": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "roaming": {
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct RoamingStatusReport {
		#[serde(
			rename = "accessType",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub access_type: Option<AccessType>,
		#[serde(rename = "newServingPlmn")]
		pub new_serving_plmn: PlmnId,
		pub roaming: bool,
	}

	impl From<&RoamingStatusReport> for RoamingStatusReport {
		fn from(value: &RoamingStatusReport) -> Self {
			value.clone()
		}
	}

	/// Contains a Routing Area Identification as defined in 3GPP TS 23.003,
	/// clause 4.2.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains a Routing Area Identification as defined in
	/// 3GPP TS 23.003, clause 4.2.",
	///  "type": "object",
	///  "required": [
	///    "lac",
	///    "plmnId",
	///    "rac"
	///  ],
	///  "properties": {
	///    "lac": {
	///      "description": "Location Area Code",
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]{4}$"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "rac": {
	///      "description": "Routing Area Code",
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]{2}$"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct RoutingAreaId {
		/// Location Area Code
		pub lac: RoutingAreaIdLac,
		#[serde(rename = "plmnId")]
		pub plmn_id: PlmnId,
		/// Routing Area Code
		pub rac: RoutingAreaIdRac,
	}

	impl From<&RoutingAreaId> for RoutingAreaId {
		fn from(value: &RoutingAreaId) -> Self {
			value.clone()
		}
	}

	/// Location Area Code
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Location Area Code",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{4}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct RoutingAreaIdLac(String);
	impl ::std::ops::Deref for RoutingAreaIdLac {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<RoutingAreaIdLac> for String {
		fn from(value: RoutingAreaIdLac) -> Self {
			value.0
		}
	}

	impl From<&RoutingAreaIdLac> for RoutingAreaIdLac {
		fn from(value: &RoutingAreaIdLac) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for RoutingAreaIdLac {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{4}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{4}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for RoutingAreaIdLac {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for RoutingAreaIdLac {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for RoutingAreaIdLac {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for RoutingAreaIdLac {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Routing Area Code
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Routing Area Code",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{2}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct RoutingAreaIdRac(String);
	impl ::std::ops::Deref for RoutingAreaIdRac {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<RoutingAreaIdRac> for String {
		fn from(value: RoutingAreaIdRac) -> Self {
			value.0
		}
	}

	impl From<&RoutingAreaIdRac> for RoutingAreaIdRac {
		fn from(value: &RoutingAreaIdRac) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for RoutingAreaIdRac {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{2}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{2}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for RoutingAreaIdRac {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for RoutingAreaIdRac {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for RoutingAreaIdRac {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for RoutingAreaIdRac {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Represents a routing indicator.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents a routing indicator.",
	///  "type": "string",
	///  "pattern": "^[0-9]{1,4}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct RoutingId(String);
	impl ::std::ops::Deref for RoutingId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<RoutingId> for String {
		fn from(value: RoutingId) -> Self {
			value.0
		}
	}

	impl From<&RoutingId> for RoutingId {
		fn from(value: &RoutingId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for RoutingId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9]{1,4}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9]{1,4}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for RoutingId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for RoutingId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for RoutingId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for RoutingId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Request body of the send-routing-info-sm custom operation
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Request body of the send-routing-info-sm custom
	/// operation",
	///  "type": "object",
	///  "properties": {
	///    "correlationId": {
	///      "type": "string"
	///    },
	///    "ipSmGwInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct RoutingInfoSmRequest {
		#[serde(
			rename = "correlationId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub correlation_id: Option<String>,
		#[serde(rename = "ipSmGwInd", default)]
		pub ip_sm_gw_ind: bool,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&RoutingInfoSmRequest> for RoutingInfoSmRequest {
		fn from(value: &RoutingInfoSmRequest) -> Self {
			value.clone()
		}
	}

	/// Addressing information of available nodes for SMS delivery
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Addressing information of available nodes for SMS
	/// delivery",
	///  "type": "object",
	///  "properties": {
	///    "ipSmGw": {
	///      "$ref": "#/components/schemas/IpSmGwInfo"
	///    },
	///    "smsRouter": {
	///      "$ref": "#/components/schemas/SmsRouterInfo"
	///    },
	///    "smsf3Gpp": {
	///      "$ref": "#/components/schemas/SmsfRegistration"
	///    },
	///    "smsfNon3Gpp": {
	///      "$ref": "#/components/schemas/SmsfRegistration"
	///    },
	///    "supi": {
	///      "$ref": "#/components/schemas/Supi"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct RoutingInfoSmResponse {
		#[serde(rename = "ipSmGw", default, skip_serializing_if = "Option::is_none")]
		pub ip_sm_gw: Option<IpSmGwInfo>,
		#[serde(rename = "smsRouter", default, skip_serializing_if = "Option::is_none")]
		pub sms_router: Option<SmsRouterInfo>,
		#[serde(rename = "smsf3Gpp", default, skip_serializing_if = "Option::is_none")]
		pub smsf3_gpp: Option<SmsfRegistration>,
		#[serde(
			rename = "smsfNon3Gpp",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub smsf_non3_gpp: Option<SmsfRegistration>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub supi: Option<Supi>,
	}

	impl From<&RoutingInfoSmResponse> for RoutingInfoSmResponse {
		fn from(value: &RoutingInfoSmResponse) -> Self {
			value.clone()
		}
	}

	/// Unsigned integer indicating Sampling Ratio (see clauses 4.15.1 of 3GPP
	/// TS 23.502), expressed in percent.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Unsigned integer indicating Sampling Ratio (see clauses
	/// 4.15.1 of 3GPP TS 23.502), expressed in percent. \n",
	///  "type": "integer",
	///  "maximum": 100.0,
	///  "minimum": 1.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SamplingRatio(pub i64);
	impl ::std::ops::Deref for SamplingRatio {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<SamplingRatio> for i64 {
		fn from(value: SamplingRatio) -> Self {
			value.0
		}
	}

	impl From<&SamplingRatio> for SamplingRatio {
		fn from(value: &SamplingRatio) -> Self {
			value.clone()
		}
	}

	impl From<i64> for SamplingRatio {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for SamplingRatio {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for SamplingRatio {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for SamplingRatio {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for SamplingRatio {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for SamplingRatio {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Identifies time and day of the week when the UE is available for
	/// communication.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Identifies time and day of the week when the UE is
	/// available for communication.",
	///  "type": "object",
	///  "properties": {
	///    "daysOfWeek": {
	///      "description": "Identifies the day(s) of the week. If absent, it
	/// indicates every day of the week.\n",
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/DayOfWeek"
	///      },
	///      "maxItems": 6,
	///      "minItems": 1
	///    },
	///    "timeOfDayEnd": {
	///      "$ref": "#/components/schemas/TimeOfDay"
	///    },
	///    "timeOfDayStart": {
	///      "$ref": "#/components/schemas/TimeOfDay"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ScheduledCommunicationTime {
		/// Identifies the day(s) of the week. If absent, it indicates every day
		/// of the week.
		#[serde(rename = "daysOfWeek", default, skip_serializing_if = "Vec::is_empty")]
		pub days_of_week: Vec<DayOfWeek>,
		#[serde(
			rename = "timeOfDayEnd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub time_of_day_end: Option<TimeOfDay>,
		#[serde(
			rename = "timeOfDayStart",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub time_of_day_start: Option<TimeOfDay>,
	}

	impl From<&ScheduledCommunicationTime> for ScheduledCommunicationTime {
		fn from(value: &ScheduledCommunicationTime) -> Self {
			value.clone()
		}
	}

	/// This data type is defined in the same way as the
	/// 'ScheduledCommunicationTime' data type, but with the OpenAPI 'nullable:
	/// true' property.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This data type is defined in the same way as the
	/// 'ScheduledCommunicationTime' data type, but with the OpenAPI 'nullable:
	/// true' property.\n",
	///  "anyOf": [
	///    {
	///      "$ref": "#/components/schemas/ScheduledCommunicationTime"
	///    },
	///    {
	///      "$ref": "#/components/schemas/NullValue"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum ScheduledCommunicationTimeRm {
		#[default]
		ScheduledCommunicationTime(ScheduledCommunicationTime),
		NullValue(NullValue),
	}

	impl From<&ScheduledCommunicationTimeRm> for ScheduledCommunicationTimeRm {
		fn from(value: &ScheduledCommunicationTimeRm) -> Self {
			value.clone()
		}
	}

	impl From<ScheduledCommunicationTime> for ScheduledCommunicationTimeRm {
		fn from(value: ScheduledCommunicationTime) -> Self {
			Self::ScheduledCommunicationTime(value)
		}
	}

	impl From<NullValue> for ScheduledCommunicationTimeRm {
		fn from(value: NullValue) -> Self {
			Self::NullValue(value)
		}
	}

	/// Possible values are:
	/// -DOWNLINK_ONLY: Downlink only
	/// -UPLINK_ONLY: Uplink only
	/// -BIDIRECTIONA: Bi-directional
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Possible values are:\n-DOWNLINK_ONLY: Downlink
	/// only\n-UPLINK_ONLY: Uplink only\n-BIDIRECTIONA: Bi-directional\n",
	///  "type": "string",
	///  "enum": [
	///    "DOWNLINK_ONLY",
	///    "UPLINK_ONLY",
	///    "BIDIRECTIONAL"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum ScheduledCommunicationType {
		#[default]
		#[serde(rename = "DOWNLINK_ONLY")]
		DownlinkOnly,
		#[serde(rename = "UPLINK_ONLY")]
		UplinkOnly,
		#[serde(rename = "BIDIRECTIONAL")]
		Bidirectional,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&ScheduledCommunicationType> for ScheduledCommunicationType {
		fn from(value: &ScheduledCommunicationType) -> Self {
			value.clone()
		}
	}

	impl ToString for ScheduledCommunicationType {
		fn to_string(&self) -> String {
			match *self {
				Self::DownlinkOnly => "DOWNLINK_ONLY".to_string(),
				Self::UplinkOnly => "UPLINK_ONLY".to_string(),
				Self::Bidirectional => "BIDIRECTIONAL".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for ScheduledCommunicationType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"DOWNLINK_ONLY" => Ok(Self::DownlinkOnly),
				"UPLINK_ONLY" => Ok(Self::UplinkOnly),
				"BIDIRECTIONAL" => Ok(Self::Bidirectional),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for ScheduledCommunicationType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for ScheduledCommunicationType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for ScheduledCommunicationType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// This enumeration is defined in the same way as the
	/// 'ScheduledCommunicationTypen' enumeration, but with the OpenAPI
	/// 'nullable: true' property."
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This enumeration is defined in the same way as the
	/// 'ScheduledCommunicationTypen' enumeration, but with the OpenAPI
	/// 'nullable: true' property.\" \n",
	///  "anyOf": [
	///    {
	///      "$ref": "#/components/schemas/ScheduledCommunicationType"
	///    },
	///    {
	///      "$ref": "#/components/schemas/NullValue"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum ScheduledCommunicationTypeRm {
		#[default]
		ScheduledCommunicationType(ScheduledCommunicationType),
		NullValue(NullValue),
	}

	impl From<&ScheduledCommunicationTypeRm> for ScheduledCommunicationTypeRm {
		fn from(value: &ScheduledCommunicationTypeRm) -> Self {
			value.clone()
		}
	}

	impl From<ScheduledCommunicationType> for ScheduledCommunicationTypeRm {
		fn from(value: ScheduledCommunicationType) -> Self {
			Self::ScheduledCommunicationType(value)
		}
	}

	impl From<NullValue> for ScheduledCommunicationTypeRm {
		fn from(value: NullValue) -> Self {
			Self::NullValue(value)
		}
	}

	/// SchemasAppDescriptor
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "appId": {
	///      "type": "string"
	///    },
	///    "osId": {
	///      "$ref": "#/components/schemas/OsId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SchemasAppDescriptor {
		#[serde(rename = "appId", default, skip_serializing_if = "Option::is_none")]
		pub app_id: Option<String>,
		#[serde(rename = "osId", default, skip_serializing_if = "Option::is_none")]
		pub os_id: Option<OsId>,
	}

	impl From<&SchemasAppDescriptor> for SchemasAppDescriptor {
		fn from(value: &SchemasAppDescriptor) -> Self {
			value.clone()
		}
	}

	/// Contains identities representing those UEs potentially affected by a
	/// data-loss event at the UDR
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains identities representing those UEs potentially
	/// affected by a data-loss event at the UDR",
	///  "type": "object",
	///  "properties": {
	///    "dnnList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Dnn"
	///      },
	///      "minItems": 1
	///    },
	///    "gpsiRanges": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/IdentityRange"
	///      },
	///      "minItems": 1
	///    },
	///    "lastReplicationTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "recoveryTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "resetIds": {
	///      "type": "array",
	///      "items": {
	///        "type": "string"
	///      },
	///      "minItems": 1
	///    },
	///    "sNssaiList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Snssai"
	///      },
	///      "minItems": 1
	///    },
	///    "supiRanges": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/SupiRange"
	///      },
	///      "minItems": 1
	///    },
	///    "udmGroupId": {
	///      "$ref": "#/components/schemas/NfGroupId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SchemasDataRestorationNotification {
		#[serde(rename = "dnnList", default, skip_serializing_if = "Vec::is_empty")]
		pub dnn_list: Vec<Dnn>,
		#[serde(rename = "gpsiRanges", default, skip_serializing_if = "Vec::is_empty")]
		pub gpsi_ranges: Vec<IdentityRange>,
		#[serde(
			rename = "lastReplicationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub last_replication_time: Option<DateTime>,
		#[serde(rename = "plmnId", default, skip_serializing_if = "Option::is_none")]
		pub plmn_id: Option<PlmnId>,
		#[serde(
			rename = "recoveryTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub recovery_time: Option<DateTime>,
		#[serde(rename = "resetIds", default, skip_serializing_if = "Vec::is_empty")]
		pub reset_ids: Vec<String>,
		#[serde(rename = "sNssaiList", default, skip_serializing_if = "Vec::is_empty")]
		pub s_nssai_list: Vec<Snssai>,
		#[serde(rename = "supiRanges", default, skip_serializing_if = "Vec::is_empty")]
		pub supi_ranges: Vec<SupiRange>,
		#[serde(
			rename = "udmGroupId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub udm_group_id: Option<NfGroupId>,
	}

	impl From<&SchemasDataRestorationNotification> for SchemasDataRestorationNotification {
		fn from(value: &SchemasDataRestorationNotification) -> Self {
			value.clone()
		}
	}

	/// SchemasEpsInterworkingInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "epsIwkPgws": {
	///      "description": "A map (list of key-value pairs where Dnn serves as
	/// key) of EpsIwkPgws",
	///      "type": "object",
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/schemas-EpsIwkPgw"
	///      }
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SchemasEpsInterworkingInfo {
		/// A map (list of key-value pairs where Dnn serves as key) of
		/// EpsIwkPgws
		#[serde(
			rename = "epsIwkPgws",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub eps_iwk_pgws: ::std::collections::HashMap<String, SchemasEpsIwkPgw>,
	}

	impl From<&SchemasEpsInterworkingInfo> for SchemasEpsInterworkingInfo {
		fn from(value: &SchemasEpsInterworkingInfo) -> Self {
			value.clone()
		}
	}

	/// SchemasEpsIwkPgw
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "pgwFqdn",
	///    "smfInstanceId"
	///  ],
	///  "properties": {
	///    "pgwFqdn": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "smfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SchemasEpsIwkPgw {
		#[serde(rename = "pgwFqdn")]
		pub pgw_fqdn: Fqdn,
		#[serde(rename = "plmnId", default, skip_serializing_if = "Option::is_none")]
		pub plmn_id: Option<PlmnId>,
		#[serde(rename = "smfInstanceId")]
		pub smf_instance_id: NfInstanceId,
	}

	impl From<&SchemasEpsIwkPgw> for SchemasEpsIwkPgw {
		fn from(value: &SchemasEpsIwkPgw) -> Self {
			value.clone()
		}
	}

	/// SchemasIpAddress
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "oneOf": [
	///    {
	///      "required": [
	///        "ipv4Addr"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "ipv6Addr"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "ipv6Prefix"
	///      ]
	///    }
	///  ],
	///  "properties": {
	///    "ipv4Addr": {
	///      "$ref": "#/components/schemas/Ipv4Addr"
	///    },
	///    "ipv6Addr": {
	///      "$ref": "#/components/schemas/Ipv6Addr"
	///    },
	///    "ipv6Prefix": {
	///      "$ref": "#/components/schemas/Ipv6Prefix"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum SchemasIpAddress {
		#[default]
		Variant0 {
			#[serde(rename = "ipv4Addr")]
			ipv4_addr: Ipv4Addr,
		},
		Variant1 {
			#[serde(rename = "ipv6Addr")]
			ipv6_addr: Ipv6Addr,
		},
		Variant2 {
			#[serde(rename = "ipv6Prefix")]
			ipv6_prefix: Ipv6Prefix,
		},
	}

	impl From<&SchemasIpAddress> for SchemasIpAddress {
		fn from(value: &SchemasIpAddress) -> Self {
			value.clone()
		}
	}

	/// SchemasLpi
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "locationPrivacyInd"
	///  ],
	///  "properties": {
	///    "locationPrivacyInd": {
	///      "$ref": "#/components/schemas/LocationPrivacyInd"
	///    },
	///    "validTimePeriod": {
	///      "$ref": "#/components/schemas/schemas-ValidTimePeriod"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SchemasLpi {
		#[serde(rename = "locationPrivacyInd")]
		pub location_privacy_ind: LocationPrivacyInd,
		#[serde(
			rename = "validTimePeriod",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub valid_time_period: Option<SchemasValidTimePeriod>,
	}

	impl From<&SchemasLpi> for SchemasLpi {
		fn from(value: &SchemasLpi) -> Self {
			value.clone()
		}
	}

	/// Contains RAND and AUTS
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains RAND and AUTS",
	///  "type": "object",
	///  "required": [
	///    "auts",
	///    "rand"
	///  ],
	///  "properties": {
	///    "auts": {
	///      "$ref": "#/components/schemas/Auts"
	///    },
	///    "rand": {
	///      "$ref": "#/components/schemas/Rand"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SchemasResynchronizationInfo {
		pub auts: Auts,
		pub rand: Rand,
	}

	impl From<&SchemasResynchronizationInfo> for SchemasResynchronizationInfo {
		fn from(value: &SchemasResynchronizationInfo) -> Self {
			value.clone()
		}
	}

	/// Contains a secure packet.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains a secure packet.",
	///  "type": "string",
	///  "format": "byte"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct SchemasSecuredPacket(pub String);
	impl ::std::ops::Deref for SchemasSecuredPacket {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<SchemasSecuredPacket> for String {
		fn from(value: SchemasSecuredPacket) -> Self {
			value.0
		}
	}

	impl From<&SchemasSecuredPacket> for SchemasSecuredPacket {
		fn from(value: &SchemasSecuredPacket) -> Self {
			value.clone()
		}
	}

	impl From<String> for SchemasSecuredPacket {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for SchemasSecuredPacket {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for SchemasSecuredPacket {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// SchemasSorInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "ackInd",
	///    "provisioningTime"
	///  ],
	///  "properties": {
	///    "ackInd": {
	///      "$ref": "#/components/schemas/AckInd"
	///    },
	///    "countersor": {
	///      "$ref": "#/components/schemas/CounterSor"
	///    },
	///    "provisioningTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "sorCmci": {
	///      "$ref": "#/components/schemas/Bytes"
	///    },
	///    "sorMacIausf": {
	///      "$ref": "#/components/schemas/SorMac"
	///    },
	///    "sorTransparentContainer": {
	///      "$ref": "#/components/schemas/Bytes"
	///    },
	///    "steeringContainer": {
	///      "$ref": "#/components/schemas/schemas-SteeringContainer"
	///    },
	///    "storeSorCmciInMe": {
	///      "type": "boolean"
	///    },
	///    "usimSupportOfSorCmci": {
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SchemasSorInfo {
		#[serde(rename = "ackInd")]
		pub ack_ind: AckInd,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub countersor: Option<CounterSor>,
		#[serde(rename = "provisioningTime")]
		pub provisioning_time: DateTime,
		#[serde(rename = "sorCmci", default, skip_serializing_if = "Option::is_none")]
		pub sor_cmci: Option<Bytes>,
		#[serde(
			rename = "sorMacIausf",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub sor_mac_iausf: Option<SorMac>,
		#[serde(
			rename = "sorTransparentContainer",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub sor_transparent_container: Option<Bytes>,
		#[serde(
			rename = "steeringContainer",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub steering_container: Option<SchemasSteeringContainer>,
		#[serde(
			rename = "storeSorCmciInMe",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub store_sor_cmci_in_me: Option<bool>,
		#[serde(
			rename = "usimSupportOfSorCmci",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub usim_support_of_sor_cmci: Option<bool>,
	}

	impl From<&SchemasSorInfo> for SchemasSorInfo {
		fn from(value: &SchemasSorInfo) -> Self {
			value.clone()
		}
	}

	/// SchemasSteeringContainer
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "oneOf": [
	///    {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/SteeringInfo"
	///      },
	///      "minItems": 1
	///    },
	///    {
	///      "$ref": "#/components/schemas/SecuredPacket"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum SchemasSteeringContainer {
		#[default]
		Variant0(Vec<SteeringInfo>),
		Variant1(SecuredPacket),
	}

	impl From<&SchemasSteeringContainer> for SchemasSteeringContainer {
		fn from(value: &SchemasSteeringContainer) -> Self {
			value.clone()
		}
	}

	impl From<Vec<SteeringInfo>> for SchemasSteeringContainer {
		fn from(value: Vec<SteeringInfo>) -> Self {
			Self::Variant0(value)
		}
	}

	impl From<SecuredPacket> for SchemasSteeringContainer {
		fn from(value: SecuredPacket) -> Self {
			Self::Variant1(value)
		}
	}

	/// SchemasValidTimePeriod
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "endTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "startTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SchemasValidTimePeriod {
		#[serde(rename = "endTime", default, skip_serializing_if = "Option::is_none")]
		pub end_time: Option<DateTime>,
		#[serde(rename = "startTime", default, skip_serializing_if = "Option::is_none")]
		pub start_time: Option<DateTime>,
	}

	impl From<&SchemasValidTimePeriod> for SchemasValidTimePeriod {
		fn from(value: &SchemasValidTimePeriod) -> Self {
			value.clone()
		}
	}

	/// SdmSubsModification
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "expires": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "monitoredResourceUris": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Uri"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SdmSubsModification {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub expires: Option<DateTime>,
		#[serde(
			rename = "monitoredResourceUris",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub monitored_resource_uris: Vec<Uri>,
	}

	impl From<&SdmSubsModification> for SdmSubsModification {
		fn from(value: &SdmSubsModification) -> Self {
			value.clone()
		}
	}

	/// SdmSubscription
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "callbackReference",
	///    "monitoredResourceUris",
	///    "nfInstanceId"
	///  ],
	///  "properties": {
	///    "amfServiceName": {
	///      "$ref": "#/components/schemas/ServiceName"
	///    },
	///    "callbackReference": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "contextInfo": {
	///      "$ref": "#/components/schemas/ContextInfo"
	///    },
	///    "dataRestorationCallbackUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "expires": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "immediateReport": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "implicitUnsubscribe": {
	///      "type": "boolean"
	///    },
	///    "monitoredResourceUris": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Uri"
	///      },
	///      "minItems": 1
	///    },
	///    "nfChangeFilter": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "nfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "report": {
	///      "$ref": "#/components/schemas/ImmediateReport"
	///    },
	///    "resetIds": {
	///      "type": "array",
	///      "items": {
	///        "type": "string"
	///      },
	///      "minItems": 1
	///    },
	///    "singleNssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    },
	///    "subscriptionId": {
	///      "type": "string"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "udrRestartInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "ueConSmfDataSubFilter": {
	///      "$ref": "#/components/schemas/UeContextInSmfDataSubFilter"
	///    },
	///    "uniqueSubscription": {
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SdmSubscription {
		#[serde(
			rename = "amfServiceName",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub amf_service_name: Option<ServiceName>,
		#[serde(rename = "callbackReference")]
		pub callback_reference: Uri,
		#[serde(
			rename = "contextInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub context_info: Option<ContextInfo>,
		#[serde(
			rename = "dataRestorationCallbackUri",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub data_restoration_callback_uri: Option<Uri>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub dnn: Option<Dnn>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub expires: Option<DateTime>,
		#[serde(rename = "immediateReport", default)]
		pub immediate_report: bool,
		#[serde(
			rename = "implicitUnsubscribe",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub implicit_unsubscribe: Option<bool>,
		#[serde(rename = "monitoredResourceUris")]
		pub monitored_resource_uris: Vec<Uri>,
		#[serde(rename = "nfChangeFilter", default)]
		pub nf_change_filter: bool,
		#[serde(rename = "nfInstanceId")]
		pub nf_instance_id: NfInstanceId,
		#[serde(rename = "plmnId", default, skip_serializing_if = "Option::is_none")]
		pub plmn_id: Option<PlmnId>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub report: Option<ImmediateReport>,
		#[serde(rename = "resetIds", default, skip_serializing_if = "Vec::is_empty")]
		pub reset_ids: Vec<String>,
		#[serde(
			rename = "singleNssai",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub single_nssai: Option<Snssai>,
		#[serde(
			rename = "subscriptionId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub subscription_id: Option<String>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
		#[serde(rename = "udrRestartInd", default)]
		pub udr_restart_ind: bool,
		#[serde(
			rename = "ueConSmfDataSubFilter",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ue_con_smf_data_sub_filter: Option<UeContextInSmfDataSubFilter>,
		#[serde(
			rename = "uniqueSubscription",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub unique_subscription: Option<bool>,
	}

	impl From<&SdmSubscription> for SdmSubscription {
		fn from(value: &SdmSubscription) -> Self {
			value.clone()
		}
	}

	/// SecuredPacket
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "format": "byte"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct SecuredPacket(pub String);
	impl ::std::ops::Deref for SecuredPacket {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<SecuredPacket> for String {
		fn from(value: SecuredPacket) -> Self {
			value.0
		}
	}

	impl From<&SecuredPacket> for SecuredPacket {
		fn from(value: &SecuredPacket) -> Self {
			value.clone()
		}
	}

	impl From<String> for SecuredPacket {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for SecuredPacket {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for SecuredPacket {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// The enumeration SensorMeasurement defines sensor measurement type for
	/// MDT in the trace. See 3GPP TS 32.422 for further description of the
	/// values. It shall comply with the provisions defined in table 5.6.3.7-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration SensorMeasurement defines sensor
	/// measurement type for MDT in the trace. See 3GPP TS 32.422 for further
	/// description of the values. It shall comply with the provisions defined
	/// in table 5.6.3.7-1.\n",
	///  "type": "string",
	///  "enum": [
	///    "BAROMETRIC_PRESSURE",
	///    "UE_SPEED",
	///    "UE_ORIENTATION"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum SensorMeasurement {
		#[default]
		#[serde(rename = "BAROMETRIC_PRESSURE")]
		BarometricPressure,
		#[serde(rename = "UE_SPEED")]
		UeSpeed,
		#[serde(rename = "UE_ORIENTATION")]
		UeOrientation,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&SensorMeasurement> for SensorMeasurement {
		fn from(value: &SensorMeasurement) -> Self {
			value.clone()
		}
	}

	impl ToString for SensorMeasurement {
		fn to_string(&self) -> String {
			match *self {
				Self::BarometricPressure => "BAROMETRIC_PRESSURE".to_string(),
				Self::UeSpeed => "UE_SPEED".to_string(),
				Self::UeOrientation => "UE_ORIENTATION".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for SensorMeasurement {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"BAROMETRIC_PRESSURE" => Ok(Self::BarometricPressure),
				"UE_SPEED" => Ok(Self::UeSpeed),
				"UE_ORIENTATION" => Ok(Self::UeOrientation),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for SensorMeasurement {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for SensorMeasurement {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for SensorMeasurement {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Contains addressing information (IP addresses and/or FQDNs) of a server.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains addressing information (IP addresses and/or
	/// FQDNs) of a server.",
	///  "type": "object",
	///  "anyOf": [
	///    {
	///      "required": [
	///        "ipv4Addresses"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "ipv6Addresses"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "fqdnList"
	///      ]
	///    }
	///  ],
	///  "properties": {
	///    "fqdnList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Fqdn"
	///      },
	///      "minItems": 1
	///    },
	///    "ipv4Addresses": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Ipv4Addr"
	///      },
	///      "minItems": 1
	///    },
	///    "ipv6Addresses": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Ipv6Addr"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum ServerAddressingInfo {
		#[default]
		Variant0 {
			#[serde(rename = "ipv4Addresses")]
			ipv4_addresses: Vec<Ipv4Addr>,
		},
		Variant1 {
			#[serde(rename = "ipv6Addresses")]
			ipv6_addresses: Vec<Ipv6Addr>,
		},
		Variant2 {
			#[serde(rename = "fqdnList")]
			fqdn_list: Vec<Fqdn>,
		},
	}

	impl From<&ServerAddressingInfo> for ServerAddressingInfo {
		fn from(value: &ServerAddressingInfo) -> Self {
			value.clone()
		}
	}

	/// Contains a Service Area Identifier as defined in 3GPP TS 23.003, clause
	/// 12.5.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains a Service Area Identifier as defined in 3GPP
	/// TS 23.003, clause 12.5.",
	///  "type": "object",
	///  "required": [
	///    "lac",
	///    "plmnId",
	///    "sac"
	///  ],
	///  "properties": {
	///    "lac": {
	///      "description": "Location Area Code.",
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]{4}$"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "sac": {
	///      "description": "Service Area Code.",
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]{4}$"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ServiceAreaId {
		/// Location Area Code.
		pub lac: ServiceAreaIdLac,
		#[serde(rename = "plmnId")]
		pub plmn_id: PlmnId,
		/// Service Area Code.
		pub sac: ServiceAreaIdSac,
	}

	impl From<&ServiceAreaId> for ServiceAreaId {
		fn from(value: &ServiceAreaId) -> Self {
			value.clone()
		}
	}

	/// Location Area Code.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Location Area Code.",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{4}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct ServiceAreaIdLac(String);
	impl ::std::ops::Deref for ServiceAreaIdLac {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<ServiceAreaIdLac> for String {
		fn from(value: ServiceAreaIdLac) -> Self {
			value.0
		}
	}

	impl From<&ServiceAreaIdLac> for ServiceAreaIdLac {
		fn from(value: &ServiceAreaIdLac) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for ServiceAreaIdLac {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{4}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{4}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for ServiceAreaIdLac {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for ServiceAreaIdLac {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for ServiceAreaIdLac {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for ServiceAreaIdLac {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Service Area Code.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Service Area Code.",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{4}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct ServiceAreaIdSac(String);
	impl ::std::ops::Deref for ServiceAreaIdSac {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<ServiceAreaIdSac> for String {
		fn from(value: ServiceAreaIdSac) -> Self {
			value.0
		}
	}

	impl From<&ServiceAreaIdSac> for ServiceAreaIdSac {
		fn from(value: &ServiceAreaIdSac) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for ServiceAreaIdSac {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{4}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{4}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for ServiceAreaIdSac {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for ServiceAreaIdSac {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for ServiceAreaIdSac {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for ServiceAreaIdSac {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Provides information about allowed or not allowed areas.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Provides information about allowed or not allowed
	/// areas.",
	///  "type": "object",
	///  "allOf": [
	///    {
	///      "oneOf": [
	///        {
	///          "not": {
	///            "required": [
	///              "restrictionType"
	///            ]
	///          }
	///        },
	///        {
	///          "required": [
	///            "areas"
	///          ]
	///        }
	///      ]
	///    },
	///    {
	///      "anyOf": [
	///        {
	///          "not": {
	///            "required": [
	///              "restrictionType"
	///            ],
	///            "properties": {
	///              "restrictionType": {
	///                "type": "string",
	///                "enum": [
	///                  "NOT_ALLOWED_AREAS"
	///                ]
	///              }
	///            }
	///          }
	///        },
	///        {
	///          "not": {
	///            "required": [
	///              "maxNumOfTAs"
	///            ]
	///          }
	///        }
	///      ]
	///    },
	///    {
	///      "anyOf": [
	///        {
	///          "not": {
	///            "required": [
	///              "restrictionType"
	///            ],
	///            "properties": {
	///              "restrictionType": {
	///                "type": "string",
	///                "enum": [
	///                  "ALLOWED_AREAS"
	///                ]
	///              }
	///            }
	///          }
	///        },
	///        {
	///          "not": {
	///            "required": [
	///              "maxNumOfTAsForNotAllowedAreas"
	///            ]
	///          }
	///        }
	///      ]
	///    }
	///  ],
	///  "properties": {
	///    "areas": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Area"
	///      }
	///    },
	///    "maxNumOfTAs": {
	///      "$ref": "#/components/schemas/Uinteger"
	///    },
	///    "maxNumOfTAsForNotAllowedAreas": {
	///      "$ref": "#/components/schemas/Uinteger"
	///    },
	///    "restrictionType": {
	///      "$ref": "#/components/schemas/RestrictionType"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum ServiceAreaRestriction {
		#[default]
		Variant0(ServiceAreaRestrictionVariant0),
		Variant1(ServiceAreaRestrictionVariant1),
	}

	impl From<&ServiceAreaRestriction> for ServiceAreaRestriction {
		fn from(value: &ServiceAreaRestriction) -> Self {
			value.clone()
		}
	}

	impl From<ServiceAreaRestrictionVariant0> for ServiceAreaRestriction {
		fn from(value: ServiceAreaRestrictionVariant0) -> Self {
			Self::Variant0(value)
		}
	}

	impl From<ServiceAreaRestrictionVariant1> for ServiceAreaRestriction {
		fn from(value: ServiceAreaRestrictionVariant1) -> Self {
			Self::Variant1(value)
		}
	}

	/// ServiceAreaRestrictionVariant0
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "allOf": [
	///    {
	///      "anyOf": [
	///        {
	///          "allOf": [
	///            {},
	///            {
	///              "allOf": [
	///                {
	///                  "oneOf": [
	///                    {
	///                      "allOf": [
	///                        {},
	///                        {
	///                          "allOf": [
	///                            {
	///                              "type": "object",
	///                              "properties": {
	///                                "areas": {
	///                                  "type": "array",
	///                                  "items": {
	///                                    "$ref": "#/components/schemas/Area"
	///                                  }
	///                                },
	///                                "maxNumOfTAs": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "maxNumOfTAsForNotAllowedAreas": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "restrictionType": {
	///                                  "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                }
	///                              }
	///                            },
	///                            {
	///                              "not": {
	///                                "required": [
	///                                  "restrictionType"
	///                                ]
	///                              }
	///                            },
	///                            {
	///                              "not": {
	///                                "required": [
	///                                  "areas"
	///                                ]
	///                              }
	///                            }
	///                          ]
	///                        },
	///                        {
	///                          "not": {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "required": [
	///                                  "areas"
	///                                ]
	///                              },
	///                              {
	///                                "not": {
	///                                  "not": {
	///                                    "required": [
	///                                      "restrictionType"
	///                                    ]
	///                                  }
	///                                }
	///                              }
	///                            ]
	///                          }
	///                        }
	///                      ]
	///                    },
	///                    {
	///                      "allOf": [
	///                        {},
	///                        {
	///                          "allOf": [
	///                            {
	///                              "type": "object",
	///                              "properties": {
	///                                "areas": {
	///                                  "type": "array",
	///                                  "items": {
	///                                    "$ref": "#/components/schemas/Area"
	///                                  }
	///                                },
	///                                "maxNumOfTAs": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "maxNumOfTAsForNotAllowedAreas": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "restrictionType": {
	///                                  "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                }
	///                              }
	///                            },
	///                            {
	///                              "required": [
	///                                "areas"
	///                              ]
	///                            },
	///                            {
	///                              "not": {
	///                                "not": {
	///                                  "required": [
	///                                    "restrictionType"
	///                                  ]
	///                                }
	///                              }
	///                            }
	///                          ]
	///                        },
	///                        {
	///                          "not": {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "restrictionType"
	///                                  ]
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "areas"
	///                                  ]
	///                                }
	///                              }
	///                            ]
	///                          }
	///                        }
	///                      ]
	///                    }
	///                  ]
	///                },
	///                {
	///                  "not": {
	///                    "required": [
	///                      "restrictionType"
	///                    ],
	///                    "properties": {
	///                      "restrictionType": {
	///                        "type": "string",
	///                        "enum": [
	///                          "NOT_ALLOWED_AREAS"
	///                        ]
	///                      }
	///                    }
	///                  }
	///                },
	///                {
	///                  "not": {
	///                    "not": {
	///                      "required": [
	///                        "maxNumOfTAs"
	///                      ]
	///                    }
	///                  }
	///                }
	///              ]
	///            },
	///            {
	///              "not": {
	///                "allOf": [
	///                  {
	///                    "oneOf": [
	///                      {
	///                        "allOf": [
	///                          {},
	///                          {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "restrictionType"
	///                                  ]
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "areas"
	///                                  ]
	///                                }
	///                              }
	///                            ]
	///                          },
	///                          {
	///                            "not": {
	///                              "allOf": [
	///                                {
	///                                  "type": "object",
	///                                  "properties": {
	///                                    "areas": {
	///                                      "type": "array",
	///                                      "items": {
	///                                        "$ref":
	/// "#/components/schemas/Area"
	///                                      }
	///                                    },
	///                                    "maxNumOfTAs": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "maxNumOfTAsForNotAllowedAreas": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "restrictionType": {
	///                                      "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                    }
	///                                  }
	///                                },
	///                                {
	///                                  "required": [
	///                                    "areas"
	///                                  ]
	///                                },
	///                                {
	///                                  "not": {
	///                                    "not": {
	///                                      "required": [
	///                                        "restrictionType"
	///                                      ]
	///                                    }
	///                                  }
	///                                }
	///                              ]
	///                            }
	///                          }
	///                        ]
	///                      },
	///                      {
	///                        "allOf": [
	///                          {},
	///                          {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "required": [
	///                                  "areas"
	///                                ]
	///                              },
	///                              {
	///                                "not": {
	///                                  "not": {
	///                                    "required": [
	///                                      "restrictionType"
	///                                    ]
	///                                  }
	///                                }
	///                              }
	///                            ]
	///                          },
	///                          {
	///                            "not": {
	///                              "allOf": [
	///                                {
	///                                  "type": "object",
	///                                  "properties": {
	///                                    "areas": {
	///                                      "type": "array",
	///                                      "items": {
	///                                        "$ref":
	/// "#/components/schemas/Area"
	///                                      }
	///                                    },
	///                                    "maxNumOfTAs": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "maxNumOfTAsForNotAllowedAreas": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "restrictionType": {
	///                                      "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                    }
	///                                  }
	///                                },
	///                                {
	///                                  "not": {
	///                                    "required": [
	///                                      "restrictionType"
	///                                    ]
	///                                  }
	///                                },
	///                                {
	///                                  "not": {
	///                                    "required": [
	///                                      "areas"
	///                                    ]
	///                                  }
	///                                }
	///                              ]
	///                            }
	///                          }
	///                        ]
	///                      }
	///                    ]
	///                  },
	///                  {
	///                    "not": {
	///                      "required": [
	///                        "maxNumOfTAs"
	///                      ]
	///                    }
	///                  },
	///                  {
	///                    "not": {
	///                      "not": {
	///                        "required": [
	///                          "restrictionType"
	///                        ],
	///                        "properties": {
	///                          "restrictionType": {
	///                            "type": "string",
	///                            "enum": [
	///                              "NOT_ALLOWED_AREAS"
	///                            ]
	///                          }
	///                        }
	///                      }
	///                    }
	///                  }
	///                ]
	///              }
	///            }
	///          ]
	///        },
	///        {
	///          "allOf": [
	///            {},
	///            {
	///              "allOf": [
	///                {
	///                  "oneOf": [
	///                    {
	///                      "allOf": [
	///                        {},
	///                        {
	///                          "allOf": [
	///                            {
	///                              "type": "object",
	///                              "properties": {
	///                                "areas": {
	///                                  "type": "array",
	///                                  "items": {
	///                                    "$ref": "#/components/schemas/Area"
	///                                  }
	///                                },
	///                                "maxNumOfTAs": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "maxNumOfTAsForNotAllowedAreas": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "restrictionType": {
	///                                  "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                }
	///                              }
	///                            },
	///                            {
	///                              "not": {
	///                                "required": [
	///                                  "restrictionType"
	///                                ]
	///                              }
	///                            },
	///                            {
	///                              "not": {
	///                                "required": [
	///                                  "areas"
	///                                ]
	///                              }
	///                            }
	///                          ]
	///                        },
	///                        {
	///                          "not": {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "required": [
	///                                  "areas"
	///                                ]
	///                              },
	///                              {
	///                                "not": {
	///                                  "not": {
	///                                    "required": [
	///                                      "restrictionType"
	///                                    ]
	///                                  }
	///                                }
	///                              }
	///                            ]
	///                          }
	///                        }
	///                      ]
	///                    },
	///                    {
	///                      "allOf": [
	///                        {},
	///                        {
	///                          "allOf": [
	///                            {
	///                              "type": "object",
	///                              "properties": {
	///                                "areas": {
	///                                  "type": "array",
	///                                  "items": {
	///                                    "$ref": "#/components/schemas/Area"
	///                                  }
	///                                },
	///                                "maxNumOfTAs": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "maxNumOfTAsForNotAllowedAreas": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "restrictionType": {
	///                                  "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                }
	///                              }
	///                            },
	///                            {
	///                              "required": [
	///                                "areas"
	///                              ]
	///                            },
	///                            {
	///                              "not": {
	///                                "not": {
	///                                  "required": [
	///                                    "restrictionType"
	///                                  ]
	///                                }
	///                              }
	///                            }
	///                          ]
	///                        },
	///                        {
	///                          "not": {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "restrictionType"
	///                                  ]
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "areas"
	///                                  ]
	///                                }
	///                              }
	///                            ]
	///                          }
	///                        }
	///                      ]
	///                    }
	///                  ]
	///                },
	///                {
	///                  "not": {
	///                    "required": [
	///                      "maxNumOfTAs"
	///                    ]
	///                  }
	///                },
	///                {
	///                  "not": {
	///                    "not": {
	///                      "required": [
	///                        "restrictionType"
	///                      ],
	///                      "properties": {
	///                        "restrictionType": {
	///                          "type": "string",
	///                          "enum": [
	///                            "NOT_ALLOWED_AREAS"
	///                          ]
	///                        }
	///                      }
	///                    }
	///                  }
	///                }
	///              ]
	///            },
	///            {
	///              "not": {
	///                "allOf": [
	///                  {
	///                    "oneOf": [
	///                      {
	///                        "allOf": [
	///                          {},
	///                          {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "restrictionType"
	///                                  ]
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "areas"
	///                                  ]
	///                                }
	///                              }
	///                            ]
	///                          },
	///                          {
	///                            "not": {
	///                              "allOf": [
	///                                {
	///                                  "type": "object",
	///                                  "properties": {
	///                                    "areas": {
	///                                      "type": "array",
	///                                      "items": {
	///                                        "$ref":
	/// "#/components/schemas/Area"
	///                                      }
	///                                    },
	///                                    "maxNumOfTAs": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "maxNumOfTAsForNotAllowedAreas": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "restrictionType": {
	///                                      "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                    }
	///                                  }
	///                                },
	///                                {
	///                                  "required": [
	///                                    "areas"
	///                                  ]
	///                                },
	///                                {
	///                                  "not": {
	///                                    "not": {
	///                                      "required": [
	///                                        "restrictionType"
	///                                      ]
	///                                    }
	///                                  }
	///                                }
	///                              ]
	///                            }
	///                          }
	///                        ]
	///                      },
	///                      {
	///                        "allOf": [
	///                          {},
	///                          {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "required": [
	///                                  "areas"
	///                                ]
	///                              },
	///                              {
	///                                "not": {
	///                                  "not": {
	///                                    "required": [
	///                                      "restrictionType"
	///                                    ]
	///                                  }
	///                                }
	///                              }
	///                            ]
	///                          },
	///                          {
	///                            "not": {
	///                              "allOf": [
	///                                {
	///                                  "type": "object",
	///                                  "properties": {
	///                                    "areas": {
	///                                      "type": "array",
	///                                      "items": {
	///                                        "$ref":
	/// "#/components/schemas/Area"
	///                                      }
	///                                    },
	///                                    "maxNumOfTAs": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "maxNumOfTAsForNotAllowedAreas": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "restrictionType": {
	///                                      "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                    }
	///                                  }
	///                                },
	///                                {
	///                                  "not": {
	///                                    "required": [
	///                                      "restrictionType"
	///                                    ]
	///                                  }
	///                                },
	///                                {
	///                                  "not": {
	///                                    "required": [
	///                                      "areas"
	///                                    ]
	///                                  }
	///                                }
	///                              ]
	///                            }
	///                          }
	///                        ]
	///                      }
	///                    ]
	///                  },
	///                  {
	///                    "not": {
	///                      "required": [
	///                        "restrictionType"
	///                      ],
	///                      "properties": {
	///                        "restrictionType": {
	///                          "type": "string",
	///                          "enum": [
	///                            "NOT_ALLOWED_AREAS"
	///                          ]
	///                        }
	///                      }
	///                    }
	///                  },
	///                  {
	///                    "not": {
	///                      "not": {
	///                        "required": [
	///                          "maxNumOfTAs"
	///                        ]
	///                      }
	///                    }
	///                  }
	///                ]
	///              }
	///            }
	///          ]
	///        }
	///      ]
	///    },
	///    {
	///      "not": {
	///        "required": [
	///          "restrictionType"
	///        ],
	///        "properties": {
	///          "restrictionType": {
	///            "type": "string",
	///            "enum": [
	///              "ALLOWED_AREAS"
	///            ]
	///          }
	///        }
	///      }
	///    },
	///    {
	///      "not": {
	///        "not": {
	///          "required": [
	///            "maxNumOfTAsForNotAllowedAreas"
	///          ]
	///        }
	///      }
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Copy,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
        smart_default::SmartDefault
	)]
	#[serde(deny_unknown_fields)]
	pub enum ServiceAreaRestrictionVariant0 {
        #[default]
        None
    }


	impl From<&ServiceAreaRestrictionVariant0> for ServiceAreaRestrictionVariant0 {
		fn from(value: &ServiceAreaRestrictionVariant0) -> Self {
			value.clone()
		}
	}

	/// ServiceAreaRestrictionVariant1
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "allOf": [
	///    {
	///      "anyOf": [
	///        {
	///          "allOf": [
	///            {},
	///            {
	///              "allOf": [
	///                {
	///                  "oneOf": [
	///                    {
	///                      "allOf": [
	///                        {},
	///                        {
	///                          "allOf": [
	///                            {
	///                              "type": "object",
	///                              "properties": {
	///                                "areas": {
	///                                  "type": "array",
	///                                  "items": {
	///                                    "$ref": "#/components/schemas/Area"
	///                                  }
	///                                },
	///                                "maxNumOfTAs": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "maxNumOfTAsForNotAllowedAreas": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "restrictionType": {
	///                                  "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                }
	///                              }
	///                            },
	///                            {
	///                              "not": {
	///                                "required": [
	///                                  "restrictionType"
	///                                ]
	///                              }
	///                            },
	///                            {
	///                              "not": {
	///                                "required": [
	///                                  "areas"
	///                                ]
	///                              }
	///                            }
	///                          ]
	///                        },
	///                        {
	///                          "not": {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "required": [
	///                                  "areas"
	///                                ]
	///                              },
	///                              {
	///                                "not": {
	///                                  "not": {
	///                                    "required": [
	///                                      "restrictionType"
	///                                    ]
	///                                  }
	///                                }
	///                              }
	///                            ]
	///                          }
	///                        }
	///                      ]
	///                    },
	///                    {
	///                      "allOf": [
	///                        {},
	///                        {
	///                          "allOf": [
	///                            {
	///                              "type": "object",
	///                              "properties": {
	///                                "areas": {
	///                                  "type": "array",
	///                                  "items": {
	///                                    "$ref": "#/components/schemas/Area"
	///                                  }
	///                                },
	///                                "maxNumOfTAs": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "maxNumOfTAsForNotAllowedAreas": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "restrictionType": {
	///                                  "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                }
	///                              }
	///                            },
	///                            {
	///                              "required": [
	///                                "areas"
	///                              ]
	///                            },
	///                            {
	///                              "not": {
	///                                "not": {
	///                                  "required": [
	///                                    "restrictionType"
	///                                  ]
	///                                }
	///                              }
	///                            }
	///                          ]
	///                        },
	///                        {
	///                          "not": {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "restrictionType"
	///                                  ]
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "areas"
	///                                  ]
	///                                }
	///                              }
	///                            ]
	///                          }
	///                        }
	///                      ]
	///                    }
	///                  ]
	///                },
	///                {
	///                  "not": {
	///                    "required": [
	///                      "restrictionType"
	///                    ],
	///                    "properties": {
	///                      "restrictionType": {
	///                        "type": "string",
	///                        "enum": [
	///                          "NOT_ALLOWED_AREAS"
	///                        ]
	///                      }
	///                    }
	///                  }
	///                },
	///                {
	///                  "not": {
	///                    "not": {
	///                      "required": [
	///                        "maxNumOfTAs"
	///                      ]
	///                    }
	///                  }
	///                }
	///              ]
	///            },
	///            {
	///              "not": {
	///                "allOf": [
	///                  {
	///                    "oneOf": [
	///                      {
	///                        "allOf": [
	///                          {},
	///                          {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "restrictionType"
	///                                  ]
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "areas"
	///                                  ]
	///                                }
	///                              }
	///                            ]
	///                          },
	///                          {
	///                            "not": {
	///                              "allOf": [
	///                                {
	///                                  "type": "object",
	///                                  "properties": {
	///                                    "areas": {
	///                                      "type": "array",
	///                                      "items": {
	///                                        "$ref":
	/// "#/components/schemas/Area"
	///                                      }
	///                                    },
	///                                    "maxNumOfTAs": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "maxNumOfTAsForNotAllowedAreas": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "restrictionType": {
	///                                      "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                    }
	///                                  }
	///                                },
	///                                {
	///                                  "required": [
	///                                    "areas"
	///                                  ]
	///                                },
	///                                {
	///                                  "not": {
	///                                    "not": {
	///                                      "required": [
	///                                        "restrictionType"
	///                                      ]
	///                                    }
	///                                  }
	///                                }
	///                              ]
	///                            }
	///                          }
	///                        ]
	///                      },
	///                      {
	///                        "allOf": [
	///                          {},
	///                          {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "required": [
	///                                  "areas"
	///                                ]
	///                              },
	///                              {
	///                                "not": {
	///                                  "not": {
	///                                    "required": [
	///                                      "restrictionType"
	///                                    ]
	///                                  }
	///                                }
	///                              }
	///                            ]
	///                          },
	///                          {
	///                            "not": {
	///                              "allOf": [
	///                                {
	///                                  "type": "object",
	///                                  "properties": {
	///                                    "areas": {
	///                                      "type": "array",
	///                                      "items": {
	///                                        "$ref":
	/// "#/components/schemas/Area"
	///                                      }
	///                                    },
	///                                    "maxNumOfTAs": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "maxNumOfTAsForNotAllowedAreas": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "restrictionType": {
	///                                      "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                    }
	///                                  }
	///                                },
	///                                {
	///                                  "not": {
	///                                    "required": [
	///                                      "restrictionType"
	///                                    ]
	///                                  }
	///                                },
	///                                {
	///                                  "not": {
	///                                    "required": [
	///                                      "areas"
	///                                    ]
	///                                  }
	///                                }
	///                              ]
	///                            }
	///                          }
	///                        ]
	///                      }
	///                    ]
	///                  },
	///                  {
	///                    "not": {
	///                      "required": [
	///                        "maxNumOfTAs"
	///                      ]
	///                    }
	///                  },
	///                  {
	///                    "not": {
	///                      "not": {
	///                        "required": [
	///                          "restrictionType"
	///                        ],
	///                        "properties": {
	///                          "restrictionType": {
	///                            "type": "string",
	///                            "enum": [
	///                              "NOT_ALLOWED_AREAS"
	///                            ]
	///                          }
	///                        }
	///                      }
	///                    }
	///                  }
	///                ]
	///              }
	///            }
	///          ]
	///        },
	///        {
	///          "allOf": [
	///            {},
	///            {
	///              "allOf": [
	///                {
	///                  "oneOf": [
	///                    {
	///                      "allOf": [
	///                        {},
	///                        {
	///                          "allOf": [
	///                            {
	///                              "type": "object",
	///                              "properties": {
	///                                "areas": {
	///                                  "type": "array",
	///                                  "items": {
	///                                    "$ref": "#/components/schemas/Area"
	///                                  }
	///                                },
	///                                "maxNumOfTAs": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "maxNumOfTAsForNotAllowedAreas": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "restrictionType": {
	///                                  "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                }
	///                              }
	///                            },
	///                            {
	///                              "not": {
	///                                "required": [
	///                                  "restrictionType"
	///                                ]
	///                              }
	///                            },
	///                            {
	///                              "not": {
	///                                "required": [
	///                                  "areas"
	///                                ]
	///                              }
	///                            }
	///                          ]
	///                        },
	///                        {
	///                          "not": {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "required": [
	///                                  "areas"
	///                                ]
	///                              },
	///                              {
	///                                "not": {
	///                                  "not": {
	///                                    "required": [
	///                                      "restrictionType"
	///                                    ]
	///                                  }
	///                                }
	///                              }
	///                            ]
	///                          }
	///                        }
	///                      ]
	///                    },
	///                    {
	///                      "allOf": [
	///                        {},
	///                        {
	///                          "allOf": [
	///                            {
	///                              "type": "object",
	///                              "properties": {
	///                                "areas": {
	///                                  "type": "array",
	///                                  "items": {
	///                                    "$ref": "#/components/schemas/Area"
	///                                  }
	///                                },
	///                                "maxNumOfTAs": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "maxNumOfTAsForNotAllowedAreas": {
	///                                  "$ref": "#/components/schemas/Uinteger"
	///                                },
	///                                "restrictionType": {
	///                                  "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                }
	///                              }
	///                            },
	///                            {
	///                              "required": [
	///                                "areas"
	///                              ]
	///                            },
	///                            {
	///                              "not": {
	///                                "not": {
	///                                  "required": [
	///                                    "restrictionType"
	///                                  ]
	///                                }
	///                              }
	///                            }
	///                          ]
	///                        },
	///                        {
	///                          "not": {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "restrictionType"
	///                                  ]
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "areas"
	///                                  ]
	///                                }
	///                              }
	///                            ]
	///                          }
	///                        }
	///                      ]
	///                    }
	///                  ]
	///                },
	///                {
	///                  "not": {
	///                    "required": [
	///                      "maxNumOfTAs"
	///                    ]
	///                  }
	///                },
	///                {
	///                  "not": {
	///                    "not": {
	///                      "required": [
	///                        "restrictionType"
	///                      ],
	///                      "properties": {
	///                        "restrictionType": {
	///                          "type": "string",
	///                          "enum": [
	///                            "NOT_ALLOWED_AREAS"
	///                          ]
	///                        }
	///                      }
	///                    }
	///                  }
	///                }
	///              ]
	///            },
	///            {
	///              "not": {
	///                "allOf": [
	///                  {
	///                    "oneOf": [
	///                      {
	///                        "allOf": [
	///                          {},
	///                          {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "restrictionType"
	///                                  ]
	///                                }
	///                              },
	///                              {
	///                                "not": {
	///                                  "required": [
	///                                    "areas"
	///                                  ]
	///                                }
	///                              }
	///                            ]
	///                          },
	///                          {
	///                            "not": {
	///                              "allOf": [
	///                                {
	///                                  "type": "object",
	///                                  "properties": {
	///                                    "areas": {
	///                                      "type": "array",
	///                                      "items": {
	///                                        "$ref":
	/// "#/components/schemas/Area"
	///                                      }
	///                                    },
	///                                    "maxNumOfTAs": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "maxNumOfTAsForNotAllowedAreas": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "restrictionType": {
	///                                      "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                    }
	///                                  }
	///                                },
	///                                {
	///                                  "required": [
	///                                    "areas"
	///                                  ]
	///                                },
	///                                {
	///                                  "not": {
	///                                    "not": {
	///                                      "required": [
	///                                        "restrictionType"
	///                                      ]
	///                                    }
	///                                  }
	///                                }
	///                              ]
	///                            }
	///                          }
	///                        ]
	///                      },
	///                      {
	///                        "allOf": [
	///                          {},
	///                          {
	///                            "allOf": [
	///                              {
	///                                "type": "object",
	///                                "properties": {
	///                                  "areas": {
	///                                    "type": "array",
	///                                    "items": {
	///                                      "$ref": "#/components/schemas/Area"
	///                                    }
	///                                  },
	///                                  "maxNumOfTAs": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "maxNumOfTAsForNotAllowedAreas": {
	///                                    "$ref":
	/// "#/components/schemas/Uinteger"
	///                                  },
	///                                  "restrictionType": {
	///                                    "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                  }
	///                                }
	///                              },
	///                              {
	///                                "required": [
	///                                  "areas"
	///                                ]
	///                              },
	///                              {
	///                                "not": {
	///                                  "not": {
	///                                    "required": [
	///                                      "restrictionType"
	///                                    ]
	///                                  }
	///                                }
	///                              }
	///                            ]
	///                          },
	///                          {
	///                            "not": {
	///                              "allOf": [
	///                                {
	///                                  "type": "object",
	///                                  "properties": {
	///                                    "areas": {
	///                                      "type": "array",
	///                                      "items": {
	///                                        "$ref":
	/// "#/components/schemas/Area"
	///                                      }
	///                                    },
	///                                    "maxNumOfTAs": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "maxNumOfTAsForNotAllowedAreas": {
	///                                      "$ref":
	/// "#/components/schemas/Uinteger"
	///                                    },
	///                                    "restrictionType": {
	///                                      "$ref":
	/// "#/components/schemas/RestrictionType"
	///                                    }
	///                                  }
	///                                },
	///                                {
	///                                  "not": {
	///                                    "required": [
	///                                      "restrictionType"
	///                                    ]
	///                                  }
	///                                },
	///                                {
	///                                  "not": {
	///                                    "required": [
	///                                      "areas"
	///                                    ]
	///                                  }
	///                                }
	///                              ]
	///                            }
	///                          }
	///                        ]
	///                      }
	///                    ]
	///                  },
	///                  {
	///                    "not": {
	///                      "required": [
	///                        "restrictionType"
	///                      ],
	///                      "properties": {
	///                        "restrictionType": {
	///                          "type": "string",
	///                          "enum": [
	///                            "NOT_ALLOWED_AREAS"
	///                          ]
	///                        }
	///                      }
	///                    }
	///                  },
	///                  {
	///                    "not": {
	///                      "not": {
	///                        "required": [
	///                          "maxNumOfTAs"
	///                        ]
	///                      }
	///                    }
	///                  }
	///                ]
	///              }
	///            }
	///          ]
	///        }
	///      ]
	///    },
	///    {
	///      "not": {
	///        "required": [
	///          "maxNumOfTAsForNotAllowedAreas"
	///        ]
	///      }
	///    },
	///    {
	///      "not": {
	///        "not": {
	///          "required": [
	///            "restrictionType"
	///          ],
	///          "properties": {
	///            "restrictionType": {
	///              "type": "string",
	///              "enum": [
	///                "ALLOWED_AREAS"
	///              ]
	///            }
	///          }
	///        }
	///      }
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Copy,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
	    smart_default::SmartDefault
	)]
	#[serde(deny_unknown_fields)]
	pub enum ServiceAreaRestrictionVariant1 {
        #[default]
        None,
    }

	impl From<&ServiceAreaRestrictionVariant1> for ServiceAreaRestrictionVariant1 {
		fn from(value: &ServiceAreaRestrictionVariant1) -> Self {
			value.clone()
		}
	}

	/// Service names known to NRF
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Service names known to NRF",
	///  "type": "string",
	///  "enum": [
	///    "nnrf-nfm",
	///    "nnrf-disc",
	///    "nnrf-oauth2",
	///    "nudm-sdm",
	///    "nudm-uecm",
	///    "nudm-ueau",
	///    "nudm-ee",
	///    "nudm-pp",
	///    "nudm-niddau",
	///    "nudm-mt",
	///    "nudm-ssau",
	///    "nudm-rsds",
	///    "nudm-ueid",
	///    "namf-comm",
	///    "namf-evts",
	///    "namf-mt",
	///    "namf-loc",
	///    "namf-mbs-comm",
	///    "namf-mbs-bc",
	///    "nsmf-pdusession",
	///    "nsmf-event-exposure",
	///    "nsmf-nidd",
	///    "nausf-auth",
	///    "nausf-sorprotection",
	///    "nausf-upuprotection",
	///    "nnef-pfdmanagement",
	///    "nnef-smcontext",
	///    "nnef-eventexposure",
	///    "nnef-eas-deployment",
	///    "3gpp-cp-parameter-provisioning",
	///    "3gpp-device-triggering",
	///    "3gpp-bdt",
	///    "3gpp-traffic-influence",
	///    "3gpp-chargeable-party",
	///    "3gpp-as-session-with-qos",
	///    "3gpp-msisdn-less-mo-sms",
	///    "3gpp-service-parameter",
	///    "3gpp-monitoring-event",
	///    "3gpp-nidd-configuration-trigger",
	///    "3gpp-nidd",
	///    "3gpp-analyticsexposure",
	///    "3gpp-racs-parameter-provisioning",
	///    "3gpp-ecr-control",
	///    "3gpp-applying-bdt-policy",
	///    "3gpp-mo-lcs-notify",
	///    "3gpp-time-sync",
	///    "3gpp-am-influence",
	///    "3gpp-am-policyauthorization",
	///    "3gpp-akma",
	///    "3gpp-eas-deployment",
	///    "3gpp-iptvconfiguration",
	///    "3gpp-mbs-tmgi",
	///    "3gpp-mbs-session",
	///    "3gpp-authentication",
	///    "3gpp-asti",
	///    "npcf-am-policy-control",
	///    "npcf-smpolicycontrol",
	///    "npcf-policyauthorization",
	///    "npcf-bdtpolicycontrol",
	///    "npcf-eventexposure",
	///    "npcf-ue-policy-control",
	///    "npcf-am-policyauthorization",
	///    "npcf-mbspolicycontrol",
	///    "npcf-mbspolicyauth",
	///    "nsmsf-sms",
	///    "nnssf-nsselection",
	///    "nnssf-nssaiavailability",
	///    "nudr-dr",
	///    "nudr-group-id-map",
	///    "nlmf-loc",
	///    "n5g-eir-eic",
	///    "nbsf-management",
	///    "nchf-spendinglimitcontrol",
	///    "nchf-convergedcharging",
	///    "nchf-offlineonlycharging",
	///    "nnwdaf-eventssubscription",
	///    "nnwdaf-analyticsinfo",
	///    "nnwdaf-datamanagement",
	///    "nnwdaf-mlmodelprovision",
	///    "ngmlc-loc",
	///    "nucmf-provisioning",
	///    "nucmf-uecapabilitymanagement",
	///    "nhss-sdm",
	///    "nhss-uecm",
	///    "nhss-ueau",
	///    "nhss-ee",
	///    "nhss-ims-sdm",
	///    "nhss-ims-uecm",
	///    "nhss-ims-ueau",
	///    "nhss-gba-sdm",
	///    "nhss-gba-ueau",
	///    "nsepp-telescopic",
	///    "nsoraf-sor",
	///    "nspaf-secured-packet",
	///    "nudsf-dr",
	///    "nudsf-timer",
	///    "nnssaaf-nssaa",
	///    "nnssaaf-aiw",
	///    "naanf-akma",
	///    "n5gddnmf-discovery",
	///    "nmfaf-3dadatamanagement",
	///    "nmfaf-3cadatamanagement",
	///    "neasdf-dnscontext",
	///    "neasdf-baselinednspattern",
	///    "ndccf-datamanagement",
	///    "ndccf-contextmanagement",
	///    "nnsacf-nsac",
	///    "nnsacf-slice-ee",
	///    "nmbsmf-tmgi",
	///    "nmbsmf-mbssession",
	///    "nadrf-datamanagement",
	///    "nbsp-gba",
	///    "ntsctsf-time-sync",
	///    "ntsctsf-qos-tscai",
	///    "ntsctsf-asti",
	///    "npkmf-keyreq",
	///    "npkmf-userid",
	///    "npkmf-discovery",
	///    "nmnpf-npstatus",
	///    "niwmsc-smservice",
	///    "nmbsf-mbs-us",
	///    "nmbsf-mbs-ud-ingest",
	///    "nmbstf-distsession",
	///    "npanf-prosekey",
	///    "npanf-userid"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum ServiceName {
		#[default]
		#[serde(rename = "nnrf-nfm")]
		NnrfNfm,
		#[serde(rename = "nnrf-disc")]
		NnrfDisc,
		#[serde(rename = "nnrf-oauth2")]
		NnrfOauth2,
		#[serde(rename = "nudm-sdm")]
		NudmSdm,
		#[serde(rename = "nudm-uecm")]
		NudmUecm,
		#[serde(rename = "nudm-ueau")]
		NudmUeau,
		#[serde(rename = "nudm-ee")]
		NudmEe,
		#[serde(rename = "nudm-pp")]
		NudmPp,
		#[serde(rename = "nudm-niddau")]
		NudmNiddau,
		#[serde(rename = "nudm-mt")]
		NudmMt,
		#[serde(rename = "nudm-ssau")]
		NudmSsau,
		#[serde(rename = "nudm-rsds")]
		NudmRsds,
		#[serde(rename = "nudm-ueid")]
		NudmUeid,
		#[serde(rename = "namf-comm")]
		NamfComm,
		#[serde(rename = "namf-evts")]
		NamfEvts,
		#[serde(rename = "namf-mt")]
		NamfMt,
		#[serde(rename = "namf-loc")]
		NamfLoc,
		#[serde(rename = "namf-mbs-comm")]
		NamfMbsComm,
		#[serde(rename = "namf-mbs-bc")]
		NamfMbsBc,
		#[serde(rename = "nsmf-pdusession")]
		NsmfPdusession,
		#[serde(rename = "nsmf-event-exposure")]
		NsmfEventExposure,
		#[serde(rename = "nsmf-nidd")]
		NsmfNidd,
		#[serde(rename = "nausf-auth")]
		NausfAuth,
		#[serde(rename = "nausf-sorprotection")]
		NausfSorprotection,
		#[serde(rename = "nausf-upuprotection")]
		NausfUpuprotection,
		#[serde(rename = "nnef-pfdmanagement")]
		NnefPfdmanagement,
		#[serde(rename = "nnef-smcontext")]
		NnefSmcontext,
		#[serde(rename = "nnef-eventexposure")]
		NnefEventexposure,
		#[serde(rename = "nnef-eas-deployment")]
		NnefEasDeployment,
		#[serde(rename = "3gpp-cp-parameter-provisioning")]
		ThreeGppCpParameterProvisioning,
		#[serde(rename = "3gpp-device-triggering")]
		ThreeGppDeviceTriggering,
		#[serde(rename = "3gpp-bdt")]
		ThreeGppBdt,
		#[serde(rename = "3gpp-traffic-influence")]
		ThreeGppTrafficInfluence,
		#[serde(rename = "3gpp-chargeable-party")]
		ThreeGppChargeableParty,
		#[serde(rename = "3gpp-as-session-with-qos")]
		ThreeGppAsSessionWithQos,
		#[serde(rename = "3gpp-msisdn-less-mo-sms")]
		ThreeGppMsisdnLessMoSms,
		#[serde(rename = "3gpp-service-parameter")]
		ThreeGppServiceParameter,
		#[serde(rename = "3gpp-monitoring-event")]
		ThreeGppMonitoringEvent,
		#[serde(rename = "3gpp-nidd-configuration-trigger")]
		ThreeGppNiddConfigurationTrigger,
		#[serde(rename = "3gpp-nidd")]
		ThreeGppNidd,
		#[serde(rename = "3gpp-analyticsexposure")]
		ThreeGppAnalyticsexposure,
		#[serde(rename = "3gpp-racs-parameter-provisioning")]
		ThreeGppRacsParameterProvisioning,
		#[serde(rename = "3gpp-ecr-control")]
		ThreeGppEcrControl,
		#[serde(rename = "3gpp-applying-bdt-policy")]
		ThreeGppApplyingBdtPolicy,
		#[serde(rename = "3gpp-mo-lcs-notify")]
		ThreeGppMoLcsNotify,
		#[serde(rename = "3gpp-time-sync")]
		ThreeGppTimeSync,
		#[serde(rename = "3gpp-am-influence")]
		ThreeGppAmInfluence,
		#[serde(rename = "3gpp-am-policyauthorization")]
		ThreeGppAmPolicyauthorization,
		#[serde(rename = "3gpp-akma")]
		ThreeGppAkma,
		#[serde(rename = "3gpp-eas-deployment")]
		ThreeGppEasDeployment,
		#[serde(rename = "3gpp-iptvconfiguration")]
		ThreeGppIptvconfiguration,
		#[serde(rename = "3gpp-mbs-tmgi")]
		ThreeGppMbsTmgi,
		#[serde(rename = "3gpp-mbs-session")]
		ThreeGppMbsSession,
		#[serde(rename = "3gpp-authentication")]
		ThreeGppAuthentication,
		#[serde(rename = "3gpp-asti")]
		ThreeGppAsti,
		#[serde(rename = "npcf-am-policy-control")]
		NpcfAmPolicyControl,
		#[serde(rename = "npcf-smpolicycontrol")]
		NpcfSmpolicycontrol,
		#[serde(rename = "npcf-policyauthorization")]
		NpcfPolicyauthorization,
		#[serde(rename = "npcf-bdtpolicycontrol")]
		NpcfBdtpolicycontrol,
		#[serde(rename = "npcf-eventexposure")]
		NpcfEventexposure,
		#[serde(rename = "npcf-ue-policy-control")]
		NpcfUePolicyControl,
		#[serde(rename = "npcf-am-policyauthorization")]
		NpcfAmPolicyauthorization,
		#[serde(rename = "npcf-mbspolicycontrol")]
		NpcfMbspolicycontrol,
		#[serde(rename = "npcf-mbspolicyauth")]
		NpcfMbspolicyauth,
		#[serde(rename = "nsmsf-sms")]
		NsmsfSms,
		#[serde(rename = "nnssf-nsselection")]
		NnssfNsselection,
		#[serde(rename = "nnssf-nssaiavailability")]
		NnssfNssaiavailability,
		#[serde(rename = "nudr-dr")]
		NudrDr,
		#[serde(rename = "nudr-group-id-map")]
		NudrGroupIdMap,
		#[serde(rename = "nlmf-loc")]
		NlmfLoc,
		#[serde(rename = "n5g-eir-eic")]
		N5gEirEic,
		#[serde(rename = "nbsf-management")]
		NbsfManagement,
		#[serde(rename = "nchf-spendinglimitcontrol")]
		NchfSpendinglimitcontrol,
		#[serde(rename = "nchf-convergedcharging")]
		NchfConvergedcharging,
		#[serde(rename = "nchf-offlineonlycharging")]
		NchfOfflineonlycharging,
		#[serde(rename = "nnwdaf-eventssubscription")]
		NnwdafEventssubscription,
		#[serde(rename = "nnwdaf-analyticsinfo")]
		NnwdafAnalyticsinfo,
		#[serde(rename = "nnwdaf-datamanagement")]
		NnwdafDatamanagement,
		#[serde(rename = "nnwdaf-mlmodelprovision")]
		NnwdafMlmodelprovision,
		#[serde(rename = "ngmlc-loc")]
		NgmlcLoc,
		#[serde(rename = "nucmf-provisioning")]
		NucmfProvisioning,
		#[serde(rename = "nucmf-uecapabilitymanagement")]
		NucmfUecapabilitymanagement,
		#[serde(rename = "nhss-sdm")]
		NhssSdm,
		#[serde(rename = "nhss-uecm")]
		NhssUecm,
		#[serde(rename = "nhss-ueau")]
		NhssUeau,
		#[serde(rename = "nhss-ee")]
		NhssEe,
		#[serde(rename = "nhss-ims-sdm")]
		NhssImsSdm,
		#[serde(rename = "nhss-ims-uecm")]
		NhssImsUecm,
		#[serde(rename = "nhss-ims-ueau")]
		NhssImsUeau,
		#[serde(rename = "nhss-gba-sdm")]
		NhssGbaSdm,
		#[serde(rename = "nhss-gba-ueau")]
		NhssGbaUeau,
		#[serde(rename = "nsepp-telescopic")]
		NseppTelescopic,
		#[serde(rename = "nsoraf-sor")]
		NsorafSor,
		#[serde(rename = "nspaf-secured-packet")]
		NspafSecuredPacket,
		#[serde(rename = "nudsf-dr")]
		NudsfDr,
		#[serde(rename = "nudsf-timer")]
		NudsfTimer,
		#[serde(rename = "nnssaaf-nssaa")]
		NnssaafNssaa,
		#[serde(rename = "nnssaaf-aiw")]
		NnssaafAiw,
		#[serde(rename = "naanf-akma")]
		NaanfAkma,
		#[serde(rename = "n5gddnmf-discovery")]
		N5gddnmfDiscovery,
		#[serde(rename = "nmfaf-3dadatamanagement")]
		Nmfaf3dadatamanagement,
		#[serde(rename = "nmfaf-3cadatamanagement")]
		Nmfaf3cadatamanagement,
		#[serde(rename = "neasdf-dnscontext")]
		NeasdfDnscontext,
		#[serde(rename = "neasdf-baselinednspattern")]
		NeasdfBaselinednspattern,
		#[serde(rename = "ndccf-datamanagement")]
		NdccfDatamanagement,
		#[serde(rename = "ndccf-contextmanagement")]
		NdccfContextmanagement,
		#[serde(rename = "nnsacf-nsac")]
		NnsacfNsac,
		#[serde(rename = "nnsacf-slice-ee")]
		NnsacfSliceEe,
		#[serde(rename = "nmbsmf-tmgi")]
		NmbsmfTmgi,
		#[serde(rename = "nmbsmf-mbssession")]
		NmbsmfMbssession,
		#[serde(rename = "nadrf-datamanagement")]
		NadrfDatamanagement,
		#[serde(rename = "nbsp-gba")]
		NbspGba,
		#[serde(rename = "ntsctsf-time-sync")]
		NtsctsfTimeSync,
		#[serde(rename = "ntsctsf-qos-tscai")]
		NtsctsfQosTscai,
		#[serde(rename = "ntsctsf-asti")]
		NtsctsfAsti,
		#[serde(rename = "npkmf-keyreq")]
		NpkmfKeyreq,
		#[serde(rename = "npkmf-userid")]
		NpkmfUserid,
		#[serde(rename = "npkmf-discovery")]
		NpkmfDiscovery,
		#[serde(rename = "nmnpf-npstatus")]
		NmnpfNpstatus,
		#[serde(rename = "niwmsc-smservice")]
		NiwmscSmservice,
		#[serde(rename = "nmbsf-mbs-us")]
		NmbsfMbsUs,
		#[serde(rename = "nmbsf-mbs-ud-ingest")]
		NmbsfMbsUdIngest,
		#[serde(rename = "nmbstf-distsession")]
		NmbstfDistsession,
		#[serde(rename = "npanf-prosekey")]
		NpanfProsekey,
		#[serde(rename = "npanf-userid")]
		NpanfUserid,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&ServiceName> for ServiceName {
		fn from(value: &ServiceName) -> Self {
			value.clone()
		}
	}

	impl ToString for ServiceName {
		fn to_string(&self) -> String {
			match *self {
				Self::NnrfNfm => "nnrf-nfm".to_string(),
				Self::NnrfDisc => "nnrf-disc".to_string(),
				Self::NnrfOauth2 => "nnrf-oauth2".to_string(),
				Self::NudmSdm => "nudm-sdm".to_string(),
				Self::NudmUecm => "nudm-uecm".to_string(),
				Self::NudmUeau => "nudm-ueau".to_string(),
				Self::NudmEe => "nudm-ee".to_string(),
				Self::NudmPp => "nudm-pp".to_string(),
				Self::NudmNiddau => "nudm-niddau".to_string(),
				Self::NudmMt => "nudm-mt".to_string(),
				Self::NudmSsau => "nudm-ssau".to_string(),
				Self::NudmRsds => "nudm-rsds".to_string(),
				Self::NudmUeid => "nudm-ueid".to_string(),
				Self::NamfComm => "namf-comm".to_string(),
				Self::NamfEvts => "namf-evts".to_string(),
				Self::NamfMt => "namf-mt".to_string(),
				Self::NamfLoc => "namf-loc".to_string(),
				Self::NamfMbsComm => "namf-mbs-comm".to_string(),
				Self::NamfMbsBc => "namf-mbs-bc".to_string(),
				Self::NsmfPdusession => "nsmf-pdusession".to_string(),
				Self::NsmfEventExposure => "nsmf-event-exposure".to_string(),
				Self::NsmfNidd => "nsmf-nidd".to_string(),
				Self::NausfAuth => "nausf-auth".to_string(),
				Self::NausfSorprotection => "nausf-sorprotection".to_string(),
				Self::NausfUpuprotection => "nausf-upuprotection".to_string(),
				Self::NnefPfdmanagement => "nnef-pfdmanagement".to_string(),
				Self::NnefSmcontext => "nnef-smcontext".to_string(),
				Self::NnefEventexposure => "nnef-eventexposure".to_string(),
				Self::NnefEasDeployment => "nnef-eas-deployment".to_string(),
				Self::ThreeGppCpParameterProvisioning => {
					"3gpp-cp-parameter-provisioning".to_string()
				}
				Self::ThreeGppDeviceTriggering => "3gpp-device-triggering".to_string(),
				Self::ThreeGppBdt => "3gpp-bdt".to_string(),
				Self::ThreeGppTrafficInfluence => "3gpp-traffic-influence".to_string(),
				Self::ThreeGppChargeableParty => "3gpp-chargeable-party".to_string(),
				Self::ThreeGppAsSessionWithQos => "3gpp-as-session-with-qos".to_string(),
				Self::ThreeGppMsisdnLessMoSms => "3gpp-msisdn-less-mo-sms".to_string(),
				Self::ThreeGppServiceParameter => "3gpp-service-parameter".to_string(),
				Self::ThreeGppMonitoringEvent => "3gpp-monitoring-event".to_string(),
				Self::ThreeGppNiddConfigurationTrigger => {
					"3gpp-nidd-configuration-trigger".to_string()
				}
				Self::ThreeGppNidd => "3gpp-nidd".to_string(),
				Self::ThreeGppAnalyticsexposure => "3gpp-analyticsexposure".to_string(),
				Self::ThreeGppRacsParameterProvisioning => {
					"3gpp-racs-parameter-provisioning".to_string()
				}
				Self::ThreeGppEcrControl => "3gpp-ecr-control".to_string(),
				Self::ThreeGppApplyingBdtPolicy => "3gpp-applying-bdt-policy".to_string(),
				Self::ThreeGppMoLcsNotify => "3gpp-mo-lcs-notify".to_string(),
				Self::ThreeGppTimeSync => "3gpp-time-sync".to_string(),
				Self::ThreeGppAmInfluence => "3gpp-am-influence".to_string(),
				Self::ThreeGppAmPolicyauthorization => "3gpp-am-policyauthorization".to_string(),
				Self::ThreeGppAkma => "3gpp-akma".to_string(),
				Self::ThreeGppEasDeployment => "3gpp-eas-deployment".to_string(),
				Self::ThreeGppIptvconfiguration => "3gpp-iptvconfiguration".to_string(),
				Self::ThreeGppMbsTmgi => "3gpp-mbs-tmgi".to_string(),
				Self::ThreeGppMbsSession => "3gpp-mbs-session".to_string(),
				Self::ThreeGppAuthentication => "3gpp-authentication".to_string(),
				Self::ThreeGppAsti => "3gpp-asti".to_string(),
				Self::NpcfAmPolicyControl => "npcf-am-policy-control".to_string(),
				Self::NpcfSmpolicycontrol => "npcf-smpolicycontrol".to_string(),
				Self::NpcfPolicyauthorization => "npcf-policyauthorization".to_string(),
				Self::NpcfBdtpolicycontrol => "npcf-bdtpolicycontrol".to_string(),
				Self::NpcfEventexposure => "npcf-eventexposure".to_string(),
				Self::NpcfUePolicyControl => "npcf-ue-policy-control".to_string(),
				Self::NpcfAmPolicyauthorization => "npcf-am-policyauthorization".to_string(),
				Self::NpcfMbspolicycontrol => "npcf-mbspolicycontrol".to_string(),
				Self::NpcfMbspolicyauth => "npcf-mbspolicyauth".to_string(),
				Self::NsmsfSms => "nsmsf-sms".to_string(),
				Self::NnssfNsselection => "nnssf-nsselection".to_string(),
				Self::NnssfNssaiavailability => "nnssf-nssaiavailability".to_string(),
				Self::NudrDr => "nudr-dr".to_string(),
				Self::NudrGroupIdMap => "nudr-group-id-map".to_string(),
				Self::NlmfLoc => "nlmf-loc".to_string(),
				Self::N5gEirEic => "n5g-eir-eic".to_string(),
				Self::NbsfManagement => "nbsf-management".to_string(),
				Self::NchfSpendinglimitcontrol => "nchf-spendinglimitcontrol".to_string(),
				Self::NchfConvergedcharging => "nchf-convergedcharging".to_string(),
				Self::NchfOfflineonlycharging => "nchf-offlineonlycharging".to_string(),
				Self::NnwdafEventssubscription => "nnwdaf-eventssubscription".to_string(),
				Self::NnwdafAnalyticsinfo => "nnwdaf-analyticsinfo".to_string(),
				Self::NnwdafDatamanagement => "nnwdaf-datamanagement".to_string(),
				Self::NnwdafMlmodelprovision => "nnwdaf-mlmodelprovision".to_string(),
				Self::NgmlcLoc => "ngmlc-loc".to_string(),
				Self::NucmfProvisioning => "nucmf-provisioning".to_string(),
				Self::NucmfUecapabilitymanagement => "nucmf-uecapabilitymanagement".to_string(),
				Self::NhssSdm => "nhss-sdm".to_string(),
				Self::NhssUecm => "nhss-uecm".to_string(),
				Self::NhssUeau => "nhss-ueau".to_string(),
				Self::NhssEe => "nhss-ee".to_string(),
				Self::NhssImsSdm => "nhss-ims-sdm".to_string(),
				Self::NhssImsUecm => "nhss-ims-uecm".to_string(),
				Self::NhssImsUeau => "nhss-ims-ueau".to_string(),
				Self::NhssGbaSdm => "nhss-gba-sdm".to_string(),
				Self::NhssGbaUeau => "nhss-gba-ueau".to_string(),
				Self::NseppTelescopic => "nsepp-telescopic".to_string(),
				Self::NsorafSor => "nsoraf-sor".to_string(),
				Self::NspafSecuredPacket => "nspaf-secured-packet".to_string(),
				Self::NudsfDr => "nudsf-dr".to_string(),
				Self::NudsfTimer => "nudsf-timer".to_string(),
				Self::NnssaafNssaa => "nnssaaf-nssaa".to_string(),
				Self::NnssaafAiw => "nnssaaf-aiw".to_string(),
				Self::NaanfAkma => "naanf-akma".to_string(),
				Self::N5gddnmfDiscovery => "n5gddnmf-discovery".to_string(),
				Self::Nmfaf3dadatamanagement => "nmfaf-3dadatamanagement".to_string(),
				Self::Nmfaf3cadatamanagement => "nmfaf-3cadatamanagement".to_string(),
				Self::NeasdfDnscontext => "neasdf-dnscontext".to_string(),
				Self::NeasdfBaselinednspattern => "neasdf-baselinednspattern".to_string(),
				Self::NdccfDatamanagement => "ndccf-datamanagement".to_string(),
				Self::NdccfContextmanagement => "ndccf-contextmanagement".to_string(),
				Self::NnsacfNsac => "nnsacf-nsac".to_string(),
				Self::NnsacfSliceEe => "nnsacf-slice-ee".to_string(),
				Self::NmbsmfTmgi => "nmbsmf-tmgi".to_string(),
				Self::NmbsmfMbssession => "nmbsmf-mbssession".to_string(),
				Self::NadrfDatamanagement => "nadrf-datamanagement".to_string(),
				Self::NbspGba => "nbsp-gba".to_string(),
				Self::NtsctsfTimeSync => "ntsctsf-time-sync".to_string(),
				Self::NtsctsfQosTscai => "ntsctsf-qos-tscai".to_string(),
				Self::NtsctsfAsti => "ntsctsf-asti".to_string(),
				Self::NpkmfKeyreq => "npkmf-keyreq".to_string(),
				Self::NpkmfUserid => "npkmf-userid".to_string(),
				Self::NpkmfDiscovery => "npkmf-discovery".to_string(),
				Self::NmnpfNpstatus => "nmnpf-npstatus".to_string(),
				Self::NiwmscSmservice => "niwmsc-smservice".to_string(),
				Self::NmbsfMbsUs => "nmbsf-mbs-us".to_string(),
				Self::NmbsfMbsUdIngest => "nmbsf-mbs-ud-ingest".to_string(),
				Self::NmbstfDistsession => "nmbstf-distsession".to_string(),
				Self::NpanfProsekey => "npanf-prosekey".to_string(),
				Self::NpanfUserid => "npanf-userid".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for ServiceName {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"nnrf-nfm" => Ok(Self::NnrfNfm),
				"nnrf-disc" => Ok(Self::NnrfDisc),
				"nnrf-oauth2" => Ok(Self::NnrfOauth2),
				"nudm-sdm" => Ok(Self::NudmSdm),
				"nudm-uecm" => Ok(Self::NudmUecm),
				"nudm-ueau" => Ok(Self::NudmUeau),
				"nudm-ee" => Ok(Self::NudmEe),
				"nudm-pp" => Ok(Self::NudmPp),
				"nudm-niddau" => Ok(Self::NudmNiddau),
				"nudm-mt" => Ok(Self::NudmMt),
				"nudm-ssau" => Ok(Self::NudmSsau),
				"nudm-rsds" => Ok(Self::NudmRsds),
				"nudm-ueid" => Ok(Self::NudmUeid),
				"namf-comm" => Ok(Self::NamfComm),
				"namf-evts" => Ok(Self::NamfEvts),
				"namf-mt" => Ok(Self::NamfMt),
				"namf-loc" => Ok(Self::NamfLoc),
				"namf-mbs-comm" => Ok(Self::NamfMbsComm),
				"namf-mbs-bc" => Ok(Self::NamfMbsBc),
				"nsmf-pdusession" => Ok(Self::NsmfPdusession),
				"nsmf-event-exposure" => Ok(Self::NsmfEventExposure),
				"nsmf-nidd" => Ok(Self::NsmfNidd),
				"nausf-auth" => Ok(Self::NausfAuth),
				"nausf-sorprotection" => Ok(Self::NausfSorprotection),
				"nausf-upuprotection" => Ok(Self::NausfUpuprotection),
				"nnef-pfdmanagement" => Ok(Self::NnefPfdmanagement),
				"nnef-smcontext" => Ok(Self::NnefSmcontext),
				"nnef-eventexposure" => Ok(Self::NnefEventexposure),
				"nnef-eas-deployment" => Ok(Self::NnefEasDeployment),
				"3gpp-cp-parameter-provisioning" => Ok(Self::ThreeGppCpParameterProvisioning),
				"3gpp-device-triggering" => Ok(Self::ThreeGppDeviceTriggering),
				"3gpp-bdt" => Ok(Self::ThreeGppBdt),
				"3gpp-traffic-influence" => Ok(Self::ThreeGppTrafficInfluence),
				"3gpp-chargeable-party" => Ok(Self::ThreeGppChargeableParty),
				"3gpp-as-session-with-qos" => Ok(Self::ThreeGppAsSessionWithQos),
				"3gpp-msisdn-less-mo-sms" => Ok(Self::ThreeGppMsisdnLessMoSms),
				"3gpp-service-parameter" => Ok(Self::ThreeGppServiceParameter),
				"3gpp-monitoring-event" => Ok(Self::ThreeGppMonitoringEvent),
				"3gpp-nidd-configuration-trigger" => Ok(Self::ThreeGppNiddConfigurationTrigger),
				"3gpp-nidd" => Ok(Self::ThreeGppNidd),
				"3gpp-analyticsexposure" => Ok(Self::ThreeGppAnalyticsexposure),
				"3gpp-racs-parameter-provisioning" => Ok(Self::ThreeGppRacsParameterProvisioning),
				"3gpp-ecr-control" => Ok(Self::ThreeGppEcrControl),
				"3gpp-applying-bdt-policy" => Ok(Self::ThreeGppApplyingBdtPolicy),
				"3gpp-mo-lcs-notify" => Ok(Self::ThreeGppMoLcsNotify),
				"3gpp-time-sync" => Ok(Self::ThreeGppTimeSync),
				"3gpp-am-influence" => Ok(Self::ThreeGppAmInfluence),
				"3gpp-am-policyauthorization" => Ok(Self::ThreeGppAmPolicyauthorization),
				"3gpp-akma" => Ok(Self::ThreeGppAkma),
				"3gpp-eas-deployment" => Ok(Self::ThreeGppEasDeployment),
				"3gpp-iptvconfiguration" => Ok(Self::ThreeGppIptvconfiguration),
				"3gpp-mbs-tmgi" => Ok(Self::ThreeGppMbsTmgi),
				"3gpp-mbs-session" => Ok(Self::ThreeGppMbsSession),
				"3gpp-authentication" => Ok(Self::ThreeGppAuthentication),
				"3gpp-asti" => Ok(Self::ThreeGppAsti),
				"npcf-am-policy-control" => Ok(Self::NpcfAmPolicyControl),
				"npcf-smpolicycontrol" => Ok(Self::NpcfSmpolicycontrol),
				"npcf-policyauthorization" => Ok(Self::NpcfPolicyauthorization),
				"npcf-bdtpolicycontrol" => Ok(Self::NpcfBdtpolicycontrol),
				"npcf-eventexposure" => Ok(Self::NpcfEventexposure),
				"npcf-ue-policy-control" => Ok(Self::NpcfUePolicyControl),
				"npcf-am-policyauthorization" => Ok(Self::NpcfAmPolicyauthorization),
				"npcf-mbspolicycontrol" => Ok(Self::NpcfMbspolicycontrol),
				"npcf-mbspolicyauth" => Ok(Self::NpcfMbspolicyauth),
				"nsmsf-sms" => Ok(Self::NsmsfSms),
				"nnssf-nsselection" => Ok(Self::NnssfNsselection),
				"nnssf-nssaiavailability" => Ok(Self::NnssfNssaiavailability),
				"nudr-dr" => Ok(Self::NudrDr),
				"nudr-group-id-map" => Ok(Self::NudrGroupIdMap),
				"nlmf-loc" => Ok(Self::NlmfLoc),
				"n5g-eir-eic" => Ok(Self::N5gEirEic),
				"nbsf-management" => Ok(Self::NbsfManagement),
				"nchf-spendinglimitcontrol" => Ok(Self::NchfSpendinglimitcontrol),
				"nchf-convergedcharging" => Ok(Self::NchfConvergedcharging),
				"nchf-offlineonlycharging" => Ok(Self::NchfOfflineonlycharging),
				"nnwdaf-eventssubscription" => Ok(Self::NnwdafEventssubscription),
				"nnwdaf-analyticsinfo" => Ok(Self::NnwdafAnalyticsinfo),
				"nnwdaf-datamanagement" => Ok(Self::NnwdafDatamanagement),
				"nnwdaf-mlmodelprovision" => Ok(Self::NnwdafMlmodelprovision),
				"ngmlc-loc" => Ok(Self::NgmlcLoc),
				"nucmf-provisioning" => Ok(Self::NucmfProvisioning),
				"nucmf-uecapabilitymanagement" => Ok(Self::NucmfUecapabilitymanagement),
				"nhss-sdm" => Ok(Self::NhssSdm),
				"nhss-uecm" => Ok(Self::NhssUecm),
				"nhss-ueau" => Ok(Self::NhssUeau),
				"nhss-ee" => Ok(Self::NhssEe),
				"nhss-ims-sdm" => Ok(Self::NhssImsSdm),
				"nhss-ims-uecm" => Ok(Self::NhssImsUecm),
				"nhss-ims-ueau" => Ok(Self::NhssImsUeau),
				"nhss-gba-sdm" => Ok(Self::NhssGbaSdm),
				"nhss-gba-ueau" => Ok(Self::NhssGbaUeau),
				"nsepp-telescopic" => Ok(Self::NseppTelescopic),
				"nsoraf-sor" => Ok(Self::NsorafSor),
				"nspaf-secured-packet" => Ok(Self::NspafSecuredPacket),
				"nudsf-dr" => Ok(Self::NudsfDr),
				"nudsf-timer" => Ok(Self::NudsfTimer),
				"nnssaaf-nssaa" => Ok(Self::NnssaafNssaa),
				"nnssaaf-aiw" => Ok(Self::NnssaafAiw),
				"naanf-akma" => Ok(Self::NaanfAkma),
				"n5gddnmf-discovery" => Ok(Self::N5gddnmfDiscovery),
				"nmfaf-3dadatamanagement" => Ok(Self::Nmfaf3dadatamanagement),
				"nmfaf-3cadatamanagement" => Ok(Self::Nmfaf3cadatamanagement),
				"neasdf-dnscontext" => Ok(Self::NeasdfDnscontext),
				"neasdf-baselinednspattern" => Ok(Self::NeasdfBaselinednspattern),
				"ndccf-datamanagement" => Ok(Self::NdccfDatamanagement),
				"ndccf-contextmanagement" => Ok(Self::NdccfContextmanagement),
				"nnsacf-nsac" => Ok(Self::NnsacfNsac),
				"nnsacf-slice-ee" => Ok(Self::NnsacfSliceEe),
				"nmbsmf-tmgi" => Ok(Self::NmbsmfTmgi),
				"nmbsmf-mbssession" => Ok(Self::NmbsmfMbssession),
				"nadrf-datamanagement" => Ok(Self::NadrfDatamanagement),
				"nbsp-gba" => Ok(Self::NbspGba),
				"ntsctsf-time-sync" => Ok(Self::NtsctsfTimeSync),
				"ntsctsf-qos-tscai" => Ok(Self::NtsctsfQosTscai),
				"ntsctsf-asti" => Ok(Self::NtsctsfAsti),
				"npkmf-keyreq" => Ok(Self::NpkmfKeyreq),
				"npkmf-userid" => Ok(Self::NpkmfUserid),
				"npkmf-discovery" => Ok(Self::NpkmfDiscovery),
				"nmnpf-npstatus" => Ok(Self::NmnpfNpstatus),
				"niwmsc-smservice" => Ok(Self::NiwmscSmservice),
				"nmbsf-mbs-us" => Ok(Self::NmbsfMbsUs),
				"nmbsf-mbs-ud-ingest" => Ok(Self::NmbsfMbsUdIngest),
				"nmbstf-distsession" => Ok(Self::NmbstfDistsession),
				"npanf-prosekey" => Ok(Self::NpanfProsekey),
				"npanf-userid" => Ok(Self::NpanfUserid),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for ServiceName {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for ServiceName {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for ServiceName {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Authorization Response for a specific service.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Authorization Response for a specific service.",
	///  "type": "object",
	///  "properties": {
	///    "authId": {
	///      "type": "string"
	///    },
	///    "authorizationUeId": {
	///      "$ref": "#/components/schemas/AuthorizationUeId"
	///    },
	///    "extGroupId": {
	///      "$ref": "#/components/schemas/ExternalGroupId"
	///    },
	///    "intGroupId": {
	///      "$ref": "#/components/schemas/GroupId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ServiceSpecificAuthorizationData {
		#[serde(rename = "authId", default, skip_serializing_if = "Option::is_none")]
		pub auth_id: Option<String>,
		#[serde(
			rename = "authorizationUeId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub authorization_ue_id: Option<AuthorizationUeId>,
		#[serde(
			rename = "extGroupId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ext_group_id: Option<ExternalGroupId>,
		#[serde(
			rename = "intGroupId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub int_group_id: Option<GroupId>,
	}

	impl From<&ServiceSpecificAuthorizationData> for ServiceSpecificAuthorizationData {
		fn from(value: &ServiceSpecificAuthorizationData) -> Self {
			value.clone()
		}
	}

	/// Authorization information for a specific service
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Authorization information for a specific service",
	///  "type": "object",
	///  "properties": {
	///    "afId": {
	///      "type": "string"
	///    },
	///    "authUpdateCallbackUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "nefId": {
	///      "$ref": "#/components/schemas/NefId"
	///    },
	///    "snssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ServiceSpecificAuthorizationInfo {
		#[serde(rename = "afId", default, skip_serializing_if = "Option::is_none")]
		pub af_id: Option<String>,
		#[serde(
			rename = "authUpdateCallbackUri",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub auth_update_callback_uri: Option<Uri>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub dnn: Option<Dnn>,
		#[serde(
			rename = "mtcProviderInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mtc_provider_information: Option<MtcProviderInformation>,
		#[serde(rename = "nefId", default, skip_serializing_if = "Option::is_none")]
		pub nef_id: Option<NefId>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub snssai: Option<Snssai>,
	}

	impl From<&ServiceSpecificAuthorizationInfo> for ServiceSpecificAuthorizationInfo {
		fn from(value: &ServiceSpecificAuthorizationInfo) -> Self {
			value.clone()
		}
	}

	/// Information for Authorization removal of a specific service.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Information for Authorization removal of a specific
	/// service.",
	///  "type": "object",
	///  "required": [
	///    "authId"
	///  ],
	///  "properties": {
	///    "authId": {
	///      "type": "string"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ServiceSpecificAuthorizationRemoveData {
		#[serde(rename = "authId")]
		pub auth_id: String,
	}

	impl From<&ServiceSpecificAuthorizationRemoveData> for ServiceSpecificAuthorizationRemoveData {
		fn from(value: &ServiceSpecificAuthorizationRemoveData) -> Self {
			value.clone()
		}
	}

	/// Possible values are - AF_GUIDANCE_FOR_URSP
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Possible values are - AF_GUIDANCE_FOR_URSP\n",
	///  "type": "string",
	///  "enum": [
	///    "AF_GUIDANCE_FOR_URSP"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum ServiceType {
		#[default]
		#[serde(rename = "AF_GUIDANCE_FOR_URSP")]
		AfGuidanceForUrsp,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&ServiceType> for ServiceType {
		fn from(value: &ServiceType) -> Self {
			value.clone()
		}
	}

	impl ToString for ServiceType {
		fn to_string(&self) -> String {
			match *self {
				Self::AfGuidanceForUrsp => "AF_GUIDANCE_FOR_URSP".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for ServiceType {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"AF_GUIDANCE_FOR_URSP" => Ok(Self::AfGuidanceForUrsp),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for ServiceType {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for ServiceType {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for ServiceType {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// ServiceTypeUnrelatedClass
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "serviceType"
	///  ],
	///  "properties": {
	///    "allowedGeographicArea": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/GeographicArea"
	///      },
	///      "minItems": 1
	///    },
	///    "codeWordInd": {
	///      "$ref": "#/components/schemas/CodeWordInd"
	///    },
	///    "codeWordList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/CodeWord"
	///      },
	///      "minItems": 1
	///    },
	///    "privacyCheckRelatedAction": {
	///      "$ref": "#/components/schemas/PrivacyCheckRelatedAction"
	///    },
	///    "serviceType": {
	///      "$ref": "#/components/schemas/LcsServiceType"
	///    },
	///    "validTimePeriod": {
	///      "$ref": "#/components/schemas/ValidTimePeriod"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ServiceTypeUnrelatedClass {
		#[serde(
			rename = "allowedGeographicArea",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub allowed_geographic_area: Vec<GeographicArea>,
		#[serde(
			rename = "codeWordInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub code_word_ind: Option<CodeWordInd>,
		#[serde(
			rename = "codeWordList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub code_word_list: Vec<CodeWord>,
		#[serde(
			rename = "privacyCheckRelatedAction",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub privacy_check_related_action: Option<PrivacyCheckRelatedAction>,
		#[serde(rename = "serviceType")]
		pub service_type: LcsServiceType,
		#[serde(
			rename = "validTimePeriod",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub valid_time_period: Option<ValidTimePeriod>,
	}

	impl From<&ServiceTypeUnrelatedClass> for ServiceTypeUnrelatedClass {
		fn from(value: &ServiceTypeUnrelatedClass) -> Self {
			value.clone()
		}
	}

	/// ServingNetworkName
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern":
	/// "^(5G:mnc[0-9]{3}[.]mcc[0-9]{3}[.]3gppnetwork[.]org(:[A-F0-9]{11})?)|5G:
	/// NSWO$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct ServingNetworkName(String);
	impl ::std::ops::Deref for ServingNetworkName {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<ServingNetworkName> for String {
		fn from(value: ServingNetworkName) -> Self {
			value.0
		}
	}

	impl From<&ServingNetworkName> for ServingNetworkName {
		fn from(value: &ServingNetworkName) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for ServingNetworkName {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new(
				"^(5G:mnc[0-9]{3}[.]mcc[0-9]{3}[.]3gppnetwork[.]org(:[A-F0-9]{11})?)|5G:NSWO$",
			)
			.unwrap()
			.find(value)
			.is_none()
			{
				return Err("doesn't match pattern \
				            \"^(5G:mnc[0-9]{3}[.]mcc[0-9]{3}[.]3gppnetwork[.]org(:[A-F0-9]{11})?\
				            )|5G:NSWO$\""
					.into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for ServingNetworkName {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for ServingNetworkName {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for ServingNetworkName {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for ServingNetworkName {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// SessionManagementSubscriptionData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "singleNssai"
	///  ],
	///  "properties": {
	///    "3gppChargingCharacteristics": {
	///      "$ref": "#/components/schemas/3GppChargingCharacteristics"
	///    },
	///    "dnnConfigurations": {
	///      "description": "A map (list of key-value pairs where Dnn, or
	/// optionally the Wildcard DNN, serves as key) of DnnConfigurations",
	///      "type": "object",
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/DnnConfiguration"
	///      }
	///    },
	///    "expectedUeBehavioursList": {
	///      "description": "A map(list of key-value pairs) where Dnn serves as
	/// key of ExpectedUeBehaviourData",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/ExpectedUeBehaviourData"
	///      }
	///    },
	///    "internalGroupIds": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/GroupId"
	///      },
	///      "minItems": 1
	///    },
	///    "odbPacketServices": {
	///      "$ref": "#/components/schemas/OdbPacketServices"
	///    },
	///    "sharedDnnConfigurationsId": {
	///      "$ref": "#/components/schemas/SharedDataId"
	///    },
	///    "sharedTraceDataId": {
	///      "$ref": "#/components/schemas/SharedDataId"
	///    },
	///    "sharedVnGroupDataIds": {
	///      "description": "A map(list of key-value pairs) where GroupId serves
	/// as key of SharedDataId",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/SharedDataId"
	///      }
	///    },
	///    "singleNssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    },
	///    "suggestedPacketNumDlList": {
	///      "description": "A map(list of key-value pairs) where Dnn serves as
	/// key of SuggestedPacketNumDl",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/SuggestedPacketNumDl"
	///      }
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "traceData": {
	///      "$ref": "#/components/schemas/TraceData"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SessionManagementSubscriptionData {
		/// A map (list of key-value pairs where Dnn, or optionally the Wildcard
		/// DNN, serves as key) of DnnConfigurations
		#[serde(
			rename = "dnnConfigurations",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub dnn_configurations: ::std::collections::HashMap<String, DnnConfiguration>,
		/// A map(list of key-value pairs) where Dnn serves as key of
		/// ExpectedUeBehaviourData
		#[serde(
			rename = "expectedUeBehavioursList",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub expected_ue_behaviours_list:
			::std::collections::HashMap<String, ExpectedUeBehaviourData>,
		#[serde(
			rename = "internalGroupIds",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub internal_group_ids: Vec<GroupId>,
		#[serde(
			rename = "odbPacketServices",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub odb_packet_services: Option<OdbPacketServices>,
		#[serde(
			rename = "sharedDnnConfigurationsId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub shared_dnn_configurations_id: Option<SharedDataId>,
		#[serde(
			rename = "sharedTraceDataId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub shared_trace_data_id: Option<SharedDataId>,
		/// A map(list of key-value pairs) where GroupId serves as key of
		/// SharedDataId
		#[serde(
			rename = "sharedVnGroupDataIds",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub shared_vn_group_data_ids: ::std::collections::HashMap<String, SharedDataId>,
		#[serde(rename = "singleNssai")]
		pub single_nssai: Snssai,
		/// A map(list of key-value pairs) where Dnn serves as key of
		/// SuggestedPacketNumDl
		#[serde(
			rename = "suggestedPacketNumDlList",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub suggested_packet_num_dl_list: ::std::collections::HashMap<String, SuggestedPacketNumDl>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
		#[serde(
			rename = "3gppChargingCharacteristics",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub three_gpp_charging_characteristics: Option<_3gppChargingCharacteristics>,
		#[serde(rename = "traceData", default, skip_serializing_if = "Option::is_none")]
		pub trace_data: Option<TraceData>,
	}

	impl From<&SessionManagementSubscriptionData> for SessionManagementSubscriptionData {
		fn from(value: &SessionManagementSubscriptionData) -> Self {
			value.clone()
		}
	}

	/// SharedData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "sharedDataId"
	///  ],
	///  "properties": {
	///    "sharedAmData": {
	///      "$ref": "#/components/schemas/AccessAndMobilitySubscriptionData"
	///    },
	///    "sharedDataId": {
	///      "$ref": "#/components/schemas/SharedDataId"
	///    },
	///    "sharedDnnConfigurations": {
	///      "description": "A map(list of key-value pairs) where Dnn, or
	/// optionally the Wildcard DNN, serves as key of DnnConfiguration",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/DnnConfiguration"
	///      }
	///    },
	///    "sharedEcsAddrConfigInfo": {
	///      "$ref": "#/components/schemas/EcsAddrConfigInfo"
	///    },
	///    "sharedSmSubsData": {
	///      "$ref": "#/components/schemas/SessionManagementSubscriptionData"
	///    },
	///    "sharedSmsMngSubsData": {
	///      "$ref": "#/components/schemas/SmsManagementSubscriptionData"
	///    },
	///    "sharedSmsSubsData": {
	///      "$ref": "#/components/schemas/SmsSubscriptionData"
	///    },
	///    "sharedSnssaiInfos": {
	///      "description": "A map(list of key-value pairs) where singleNssai
	/// serves as key of SnssaiInfo",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/SnssaiInfo"
	///      }
	///    },
	///    "sharedTraceData": {
	///      "$ref": "#/components/schemas/TraceData"
	///    },
	///    "sharedVnGroupDatas": {
	///      "description": "A map(list of key-value pairs) where GroupId serves
	/// as key of VnGroupData",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/VnGroupData"
	///      }
	///    },
	///    "treatmentInstructions": {
	///      "description": "A map(list of key-value pairs) where JSON pointer
	/// pointing to an attribute within the SharedData serves as key of
	/// SharedDataTreatmentInstruction",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/SharedDataTreatmentInstruction"
	///      }
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SharedData {
		#[serde(
			rename = "sharedAmData",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub shared_am_data: Option<AccessAndMobilitySubscriptionData>,
		#[serde(rename = "sharedDataId")]
		pub shared_data_id: SharedDataId,
		/// A map(list of key-value pairs) where Dnn, or optionally the Wildcard
		/// DNN, serves as key of DnnConfiguration
		#[serde(
			rename = "sharedDnnConfigurations",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub shared_dnn_configurations: ::std::collections::HashMap<String, DnnConfiguration>,
		#[serde(
			rename = "sharedEcsAddrConfigInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub shared_ecs_addr_config_info: Option<EcsAddrConfigInfo>,
		#[serde(
			rename = "sharedSmSubsData",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub shared_sm_subs_data: Option<SessionManagementSubscriptionData>,
		#[serde(
			rename = "sharedSmsMngSubsData",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub shared_sms_mng_subs_data: Option<SmsManagementSubscriptionData>,
		#[serde(
			rename = "sharedSmsSubsData",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub shared_sms_subs_data: Option<SmsSubscriptionData>,
		/// A map(list of key-value pairs) where singleNssai serves as key of
		/// SnssaiInfo
		#[serde(
			rename = "sharedSnssaiInfos",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub shared_snssai_infos: ::std::collections::HashMap<String, SnssaiInfo>,
		#[serde(
			rename = "sharedTraceData",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub shared_trace_data: Option<TraceData>,
		/// A map(list of key-value pairs) where GroupId serves as key of
		/// VnGroupData
		#[serde(
			rename = "sharedVnGroupDatas",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub shared_vn_group_datas: ::std::collections::HashMap<String, VnGroupData>,
		/// A map(list of key-value pairs) where JSON pointer pointing to an
		/// attribute within the SharedData serves as key of
		/// SharedDataTreatmentInstruction
		#[serde(
			rename = "treatmentInstructions",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub treatment_instructions:
			::std::collections::HashMap<String, SharedDataTreatmentInstruction>,
	}

	impl From<&SharedData> for SharedData {
		fn from(value: &SharedData) -> Self {
			value.clone()
		}
	}

	/// SharedDataId
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[0-9]{5,6}-.+$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct SharedDataId(String);
	impl ::std::ops::Deref for SharedDataId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<SharedDataId> for String {
		fn from(value: SharedDataId) -> Self {
			value.0
		}
	}

	impl From<&SharedDataId> for SharedDataId {
		fn from(value: &SharedDataId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for SharedDataId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9]{5,6}-.+$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9]{5,6}-.+$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for SharedDataId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for SharedDataId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for SharedDataId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for SharedDataId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// SharedDataIds
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "array",
	///  "items": {
	///    "$ref": "#/components/schemas/SharedDataId"
	///  },
	///  "minItems": 1,
	///  "uniqueItems": true
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SharedDataIds(pub Vec<SharedDataId>);
	impl ::std::ops::Deref for SharedDataIds {
		type Target = Vec<SharedDataId>;
		fn deref(&self) -> &Vec<SharedDataId> {
			&self.0
		}
	}

	impl From<SharedDataIds> for Vec<SharedDataId> {
		fn from(value: SharedDataIds) -> Self {
			value.0
		}
	}

	impl From<&SharedDataIds> for SharedDataIds {
		fn from(value: &SharedDataIds) -> Self {
			value.clone()
		}
	}

	impl From<Vec<SharedDataId>> for SharedDataIds {
		fn from(value: Vec<SharedDataId>) -> Self {
			Self(value)
		}
	}

	/// SharedDataTreatmentInstruction
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "USE_IF_NO_CLASH",
	///    "OVERWRITE",
	///    "MAX",
	///    "MIN"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum SharedDataTreatmentInstruction {
		#[default]
		#[serde(rename = "USE_IF_NO_CLASH")]
		UseIfNoClash,
		#[serde(rename = "OVERWRITE")]
		Overwrite,
		#[serde(rename = "MAX")]
		Max,
		#[serde(rename = "MIN")]
		Min,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&SharedDataTreatmentInstruction> for SharedDataTreatmentInstruction {
		fn from(value: &SharedDataTreatmentInstruction) -> Self {
			value.clone()
		}
	}

	impl ToString for SharedDataTreatmentInstruction {
		fn to_string(&self) -> String {
			match *self {
				Self::UseIfNoClash => "USE_IF_NO_CLASH".to_string(),
				Self::Overwrite => "OVERWRITE".to_string(),
				Self::Max => "MAX".to_string(),
				Self::Min => "MIN".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for SharedDataTreatmentInstruction {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"USE_IF_NO_CLASH" => Ok(Self::UseIfNoClash),
				"OVERWRITE" => Ok(Self::Overwrite),
				"MAX" => Ok(Self::Max),
				"MIN" => Ok(Self::Min),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for SharedDataTreatmentInstruction {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for SharedDataTreatmentInstruction {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for SharedDataTreatmentInstruction {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// MBR related to slice
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "MBR related to slice",
	///  "type": "object",
	///  "required": [
	///    "downlink",
	///    "uplink"
	///  ],
	///  "properties": {
	///    "downlink": {
	///      "$ref": "#/components/schemas/BitRate"
	///    },
	///    "uplink": {
	///      "$ref": "#/components/schemas/BitRate"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SliceMbr {
		pub downlink: BitRate,
		pub uplink: BitRate,
	}

	impl From<&SliceMbr> for SliceMbr {
		fn from(value: &SliceMbr) -> Self {
			value.clone()
		}
	}

	/// SliceMbr with nullable: true
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "SliceMbr with nullable: true",
	///  "anyOf": [
	///    {
	///      "$ref": "#/components/schemas/SliceMbr"
	///    },
	///    {
	///      "$ref": "#/components/schemas/NullValue"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum SliceMbrRm {
		#[default]
		SliceMbr(SliceMbr),
		NullValue(NullValue),
	}

	impl From<&SliceMbrRm> for SliceMbrRm {
		fn from(value: &SliceMbrRm) -> Self {
			value.clone()
		}
	}

	impl From<SliceMbr> for SliceMbrRm {
		fn from(value: SliceMbr) -> Self {
			Self::SliceMbr(value)
		}
	}

	impl From<NullValue> for SliceMbrRm {
		fn from(value: NullValue) -> Self {
			Self::NullValue(value)
		}
	}

	/// Represents SM Delivery Status.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents SM Delivery Status.",
	///  "type": "object",
	///  "required": [
	///    "gpsi",
	///    "smStatusReport"
	///  ],
	///  "properties": {
	///    "gpsi": {
	///      "$ref": "#/components/schemas/Gpsi"
	///    },
	///    "smStatusReport": {
	///      "type": "string"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SmDeliveryStatus {
		pub gpsi: Gpsi,
		#[serde(rename = "smStatusReport")]
		pub sm_status_report: String,
	}

	impl From<&SmDeliveryStatus> for SmDeliveryStatus {
		fn from(value: &SmDeliveryStatus) -> Self {
			value.clone()
		}
	}

	/// SmSubsData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "oneOf": [
	///    {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/SessionManagementSubscriptionData"
	///      },
	///      "minItems": 1
	///    },
	///    {
	///      "$ref": "#/components/schemas/ExtendedSmSubsData"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum SmSubsData {
		#[default]
		Variant0(Vec<SessionManagementSubscriptionData>),
		Variant1(ExtendedSmSubsData),
	}

	impl From<&SmSubsData> for SmSubsData {
		fn from(value: &SmSubsData) -> Self {
			value.clone()
		}
	}

	impl From<Vec<SessionManagementSubscriptionData>> for SmSubsData {
		fn from(value: Vec<SessionManagementSubscriptionData>) -> Self {
			Self::Variant0(value)
		}
	}

	impl From<ExtendedSmSubsData> for SmSubsData {
		fn from(value: ExtendedSmSubsData) -> Self {
			Self::Variant1(value)
		}
	}

	/// SmfRegistration
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "pduSessionId",
	///    "plmnId",
	///    "singleNssai",
	///    "smfInstanceId"
	///  ],
	///  "properties": {
	///    "contextInfo": {
	///      "$ref": "#/components/schemas/ContextInfo"
	///    },
	///    "dataRestorationCallbackUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "deregCallbackUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "emergencyServices": {
	///      "type": "boolean"
	///    },
	///    "epdgInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "lastSynchronizationTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "pcfId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "pcscfRestorationCallbackUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "pduSessionId": {
	///      "$ref": "#/components/schemas/PduSessionId"
	///    },
	///    "pgwFqdn": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "pgwIpAddr": {
	///      "$ref": "#/components/schemas/IpAddress"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "registrationReason": {
	///      "$ref": "#/components/schemas/RegistrationReason"
	///    },
	///    "registrationTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "resetIds": {
	///      "type": "array",
	///      "items": {
	///        "type": "string"
	///      },
	///      "minItems": 1
	///    },
	///    "singleNssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    },
	///    "smfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "smfSetId": {
	///      "$ref": "#/components/schemas/NfSetId"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "udrRestartInd": {
	///      "default": false,
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SmfRegistration {
		#[serde(
			rename = "contextInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub context_info: Option<ContextInfo>,
		#[serde(
			rename = "dataRestorationCallbackUri",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub data_restoration_callback_uri: Option<Uri>,
		#[serde(
			rename = "deregCallbackUri",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub dereg_callback_uri: Option<Uri>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub dnn: Option<Dnn>,
		#[serde(
			rename = "emergencyServices",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub emergency_services: Option<bool>,
		#[serde(rename = "epdgInd", default)]
		pub epdg_ind: bool,
		#[serde(
			rename = "lastSynchronizationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub last_synchronization_time: Option<DateTime>,
		#[serde(rename = "pcfId", default, skip_serializing_if = "Option::is_none")]
		pub pcf_id: Option<NfInstanceId>,
		#[serde(
			rename = "pcscfRestorationCallbackUri",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pcscf_restoration_callback_uri: Option<Uri>,
		#[serde(rename = "pduSessionId")]
		pub pdu_session_id: PduSessionId,
		#[serde(rename = "pgwFqdn", default, skip_serializing_if = "Option::is_none")]
		pub pgw_fqdn: Option<Fqdn>,
		#[serde(rename = "pgwIpAddr", default, skip_serializing_if = "Option::is_none")]
		pub pgw_ip_addr: Option<IpAddress>,
		#[serde(rename = "plmnId")]
		pub plmn_id: PlmnId,
		#[serde(
			rename = "registrationReason",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub registration_reason: Option<RegistrationReason>,
		#[serde(
			rename = "registrationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub registration_time: Option<DateTime>,
		#[serde(rename = "resetIds", default, skip_serializing_if = "Vec::is_empty")]
		pub reset_ids: Vec<String>,
		#[serde(rename = "singleNssai")]
		pub single_nssai: Snssai,
		#[serde(rename = "smfInstanceId")]
		pub smf_instance_id: NfInstanceId,
		#[serde(rename = "smfSetId", default, skip_serializing_if = "Option::is_none")]
		pub smf_set_id: Option<NfSetId>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
		#[serde(rename = "udrRestartInd", default)]
		pub udr_restart_ind: bool,
	}

	impl From<&SmfRegistration> for SmfRegistration {
		fn from(value: &SmfRegistration) -> Self {
			value.clone()
		}
	}

	/// SmfRegistrationInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "smfRegistrationList"
	///  ],
	///  "properties": {
	///    "smfRegistrationList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/SmfRegistration"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SmfRegistrationInfo {
		#[serde(rename = "smfRegistrationList")]
		pub smf_registration_list: Vec<SmfRegistration>,
	}

	impl From<&SmfRegistrationInfo> for SmfRegistrationInfo {
		fn from(value: &SmfRegistrationInfo) -> Self {
			value.clone()
		}
	}

	/// Contains attributes of SmfRegistration that can be modified using PATCH
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains attributes of SmfRegistration that can be
	/// modified using PATCH",
	///  "type": "object",
	///  "required": [
	///    "smfInstanceId"
	///  ],
	///  "properties": {
	///    "pgwFqdn": {
	///      "$ref": "#/components/schemas/FqdnRm"
	///    },
	///    "smfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "smfSetId": {
	///      "$ref": "#/components/schemas/NfSetId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SmfRegistrationModification {
		#[serde(rename = "pgwFqdn", default, skip_serializing_if = "Option::is_none")]
		pub pgw_fqdn: Option<FqdnRm>,
		#[serde(rename = "smfInstanceId")]
		pub smf_instance_id: NfInstanceId,
		#[serde(rename = "smfSetId", default, skip_serializing_if = "Option::is_none")]
		pub smf_set_id: Option<NfSetId>,
	}

	impl From<&SmfRegistrationModification> for SmfRegistrationModification {
		fn from(value: &SmfRegistrationModification) -> Self {
			value.clone()
		}
	}

	/// SmfSelectionSubscriptionData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "hssGroupId": {
	///      "$ref": "#/components/schemas/NfGroupId"
	///    },
	///    "sharedSnssaiInfosId": {
	///      "$ref": "#/components/schemas/SharedDataId"
	///    },
	///    "subscribedSnssaiInfos": {
	///      "description": "A map(list of key-value pairs) where singleNssai
	/// serves as key of SnssaiInfo",
	///      "type": "object",
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/SnssaiInfo"
	///      }
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SmfSelectionSubscriptionData {
		#[serde(
			rename = "hssGroupId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub hss_group_id: Option<NfGroupId>,
		#[serde(
			rename = "sharedSnssaiInfosId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub shared_snssai_infos_id: Option<SharedDataId>,
		/// A map(list of key-value pairs) where singleNssai serves as key of
		/// SnssaiInfo
		#[serde(
			rename = "subscribedSnssaiInfos",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub subscribed_snssai_infos: ::std::collections::HashMap<String, SnssaiInfo>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&SmfSelectionSubscriptionData> for SmfSelectionSubscriptionData {
		fn from(value: &SmfSelectionSubscriptionData) -> Self {
			value.clone()
		}
	}

	/// SmsManagementSubscriptionData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "moSmsBarringAll": {
	///      "type": "boolean"
	///    },
	///    "moSmsBarringRoaming": {
	///      "type": "boolean"
	///    },
	///    "moSmsSubscribed": {
	///      "type": "boolean"
	///    },
	///    "mtSmsBarringAll": {
	///      "type": "boolean"
	///    },
	///    "mtSmsBarringRoaming": {
	///      "type": "boolean"
	///    },
	///    "mtSmsSubscribed": {
	///      "type": "boolean"
	///    },
	///    "sharedSmsMngDataIds": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/SharedDataId"
	///      },
	///      "minItems": 1
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "traceData": {
	///      "$ref": "#/components/schemas/TraceData"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SmsManagementSubscriptionData {
		#[serde(
			rename = "moSmsBarringAll",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mo_sms_barring_all: Option<bool>,
		#[serde(
			rename = "moSmsBarringRoaming",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mo_sms_barring_roaming: Option<bool>,
		#[serde(
			rename = "moSmsSubscribed",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mo_sms_subscribed: Option<bool>,
		#[serde(
			rename = "mtSmsBarringAll",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mt_sms_barring_all: Option<bool>,
		#[serde(
			rename = "mtSmsBarringRoaming",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mt_sms_barring_roaming: Option<bool>,
		#[serde(
			rename = "mtSmsSubscribed",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mt_sms_subscribed: Option<bool>,
		#[serde(
			rename = "sharedSmsMngDataIds",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub shared_sms_mng_data_ids: Vec<SharedDataId>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
		#[serde(rename = "traceData", default, skip_serializing_if = "Option::is_none")]
		pub trace_data: Option<TraceData>,
	}

	impl From<&SmsManagementSubscriptionData> for SmsManagementSubscriptionData {
		fn from(value: &SmsManagementSubscriptionData) -> Self {
			value.clone()
		}
	}

	/// Addressing information of the SMS Router configured at the UDM
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Addressing information of the SMS Router configured at
	/// the UDM",
	///  "type": "object",
	///  "properties": {
	///    "diameterAddress": {
	///      "$ref": "#/components/schemas/NetworkNodeDiameterAddress"
	///    },
	///    "mapAddress": {
	///      "$ref": "#/components/schemas/E164Number"
	///    },
	///    "nfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "routerFqdn": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "routerIpv4": {
	///      "$ref": "#/components/schemas/Ipv4Addr"
	///    },
	///    "routerIpv6": {
	///      "$ref": "#/components/schemas/Ipv6Addr"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SmsRouterInfo {
		#[serde(
			rename = "diameterAddress",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub diameter_address: Option<NetworkNodeDiameterAddress>,
		#[serde(
			rename = "mapAddress",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub map_address: Option<E164Number>,
		#[serde(
			rename = "nfInstanceId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub nf_instance_id: Option<NfInstanceId>,
		#[serde(
			rename = "routerFqdn",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub router_fqdn: Option<Fqdn>,
		#[serde(
			rename = "routerIpv4",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub router_ipv4: Option<Ipv4Addr>,
		#[serde(
			rename = "routerIpv6",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub router_ipv6: Option<Ipv6Addr>,
	}

	impl From<&SmsRouterInfo> for SmsRouterInfo {
		fn from(value: &SmsRouterInfo) -> Self {
			value.clone()
		}
	}

	/// SmsSubscribed
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "boolean"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SmsSubscribed(pub bool);
	impl ::std::ops::Deref for SmsSubscribed {
		type Target = bool;
		fn deref(&self) -> &bool {
			&self.0
		}
	}

	impl From<SmsSubscribed> for bool {
		fn from(value: SmsSubscribed) -> Self {
			value.0
		}
	}

	impl From<&SmsSubscribed> for SmsSubscribed {
		fn from(value: &SmsSubscribed) -> Self {
			value.clone()
		}
	}

	impl From<bool> for SmsSubscribed {
		fn from(value: bool) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for SmsSubscribed {
		type Err = <bool as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for SmsSubscribed {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for SmsSubscribed {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for SmsSubscribed {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for SmsSubscribed {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// SmsSubscriptionData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "sharedSmsSubsDataId": {
	///      "$ref": "#/components/schemas/SharedDataId"
	///    },
	///    "smsSubscribed": {
	///      "$ref": "#/components/schemas/SmsSubscribed"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SmsSubscriptionData {
		#[serde(
			rename = "sharedSmsSubsDataId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub shared_sms_subs_data_id: Option<SharedDataId>,
		#[serde(
			rename = "smsSubscribed",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub sms_subscribed: Option<SmsSubscribed>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&SmsSubscriptionData> for SmsSubscriptionData {
		fn from(value: &SmsSubscriptionData) -> Self {
			value.clone()
		}
	}

	/// SmsfInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "plmnId",
	///    "smsfInstanceId"
	///  ],
	///  "properties": {
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "smsfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "smsfSetId": {
	///      "$ref": "#/components/schemas/NfSetId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SmsfInfo {
		#[serde(rename = "plmnId")]
		pub plmn_id: PlmnId,
		#[serde(rename = "smsfInstanceId")]
		pub smsf_instance_id: NfInstanceId,
		#[serde(rename = "smsfSetId", default, skip_serializing_if = "Option::is_none")]
		pub smsf_set_id: Option<NfSetId>,
	}

	impl From<&SmsfInfo> for SmsfInfo {
		fn from(value: &SmsfInfo) -> Self {
			value.clone()
		}
	}

	/// SmsfRegistration
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "plmnId",
	///    "smsfInstanceId"
	///  ],
	///  "properties": {
	///    "contextInfo": {
	///      "$ref": "#/components/schemas/ContextInfo"
	///    },
	///    "dataRestorationCallbackUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    },
	///    "lastSynchronizationTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "registrationTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "resetIds": {
	///      "type": "array",
	///      "items": {
	///        "type": "string"
	///      },
	///      "minItems": 1
	///    },
	///    "smsfDiameterAddress": {
	///      "$ref": "#/components/schemas/NetworkNodeDiameterAddress"
	///    },
	///    "smsfInstanceId": {
	///      "$ref": "#/components/schemas/NfInstanceId"
	///    },
	///    "smsfMAPAddress": {
	///      "$ref": "#/components/schemas/E164Number"
	///    },
	///    "smsfSbiSupInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "smsfSetId": {
	///      "$ref": "#/components/schemas/NfSetId"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "udrRestartInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "ueMemoryAvailableInd": {
	///      "type": "boolean",
	///      "enum": [
	///        true
	///      ]
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SmsfRegistration {
		#[serde(
			rename = "contextInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub context_info: Option<ContextInfo>,
		#[serde(
			rename = "dataRestorationCallbackUri",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub data_restoration_callback_uri: Option<Uri>,
		#[serde(
			rename = "lastSynchronizationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub last_synchronization_time: Option<DateTime>,
		#[serde(rename = "plmnId")]
		pub plmn_id: PlmnId,
		#[serde(
			rename = "registrationTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub registration_time: Option<DateTime>,
		#[serde(rename = "resetIds", default, skip_serializing_if = "Vec::is_empty")]
		pub reset_ids: Vec<String>,
		#[serde(
			rename = "smsfDiameterAddress",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub smsf_diameter_address: Option<NetworkNodeDiameterAddress>,
		#[serde(rename = "smsfInstanceId")]
		pub smsf_instance_id: NfInstanceId,
		#[serde(
			rename = "smsfMAPAddress",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub smsf_map_address: Option<E164Number>,
		#[serde(rename = "smsfSbiSupInd", default)]
		pub smsf_sbi_sup_ind: bool,
		#[serde(rename = "smsfSetId", default, skip_serializing_if = "Option::is_none")]
		pub smsf_set_id: Option<NfSetId>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
		#[serde(rename = "udrRestartInd", default)]
		pub udr_restart_ind: bool,
		#[serde(
			rename = "ueMemoryAvailableInd",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub ue_memory_available_ind: Option<bool>,
	}

	impl From<&SmsfRegistration> for SmsfRegistration {
		fn from(value: &SmsfRegistration) -> Self {
			value.clone()
		}
	}

	/// When Snssai needs to be converted to string (e.g. when used in maps as
	/// key), the string shall be composed of one to three digits "sst"
	/// optionally followed by "-" and 6 hexadecimal digits "sd".
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "When Snssai needs to be converted to string (e.g. when
	/// used in maps as key), the string shall be composed of one to three
	/// digits \"sst\" optionally followed by \"-\" and 6 hexadecimal digits
	/// \"sd\".\n",
	///  "type": "object",
	///  "required": [
	///    "sst"
	///  ],
	///  "properties": {
	///    "sd": {
	///      "description": "3-octet string, representing the Slice
	/// Differentiator, in hexadecimal representation. Each character in the
	/// string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to
	/// \"F\" and shall represent 4 bits. The most significant character
	/// representing the 4 most significant bits of the SD shall appear first in
	/// the string, and the character representing the 4 least significant bit
	/// of the SD shall appear last in the string. This is an optional parameter
	/// that complements the Slice/Service type(s) to allow to  differentiate
	/// amongst multiple Network Slices of the same Slice/Service type. This IE
	/// shall be absent if no SD value is associated with the SST.\n",
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]{6}$"
	///    },
	///    "sst": {
	///      "description": "Unsigned integer, within the range 0 to 255,
	/// representing the Slice/Service Type.  It indicates the expected Network
	/// Slice behaviour in terms of features and services. Values 0 to 127
	/// correspond to the standardized SST range. Values 128 to 255 correspond
	/// to the Operator-specific range. See clause 28.4.2 of 3GPP TS 23.003.
	/// Standardized values are defined in clause 5.15.2.2 of 3GPP TS 23.501.
	/// \n",
	///      "type": "integer",
	///      "maximum": 255.0,
	///      "minimum": 0.0
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Snssai {
		/// 3-octet string, representing the Slice Differentiator, in
		/// hexadecimal representation. Each character in the string shall take
		/// a value of "0" to "9", "a" to "f" or "A" to "F" and shall represent
		/// 4 bits. The most significant character representing the 4 most
		/// significant bits of the SD shall appear first in the string, and the
		/// character representing the 4 least significant bit of the SD shall
		/// appear last in the string. This is an optional parameter that
		/// complements the Slice/Service type(s) to allow to  differentiate
		/// amongst multiple Network Slices of the same Slice/Service type. This
		/// IE shall be absent if no SD value is associated with the SST.
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub sd: Option<SnssaiSd>,
		/// Unsigned integer, within the range 0 to 255, representing the
		/// Slice/Service Type.  It indicates the expected Network Slice
		/// behaviour in terms of features and services. Values 0 to 127
		/// correspond to the standardized SST range. Values 128 to 255
		/// correspond  to the Operator-specific range. See clause 28.4.2 of
		/// 3GPP TS 23.003. Standardized values are defined in clause 5.15.2.2
		/// of 3GPP TS 23.501.
		pub sst: u8,
	}

	impl From<&Snssai> for Snssai {
		fn from(value: &Snssai) -> Self {
			value.clone()
		}
	}

	/// SnssaiInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "dnnInfos"
	///  ],
	///  "properties": {
	///    "dnnInfos": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/DnnInfo"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SnssaiInfo {
		#[serde(rename = "dnnInfos")]
		pub dnn_infos: Vec<DnnInfo>,
	}

	impl From<&SnssaiInfo> for SnssaiInfo {
		fn from(value: &SnssaiInfo) -> Self {
			value.clone()
		}
	}

	/// 3-octet string, representing the Slice Differentiator, in hexadecimal
	/// representation. Each character in the string shall take a value of "0"
	/// to "9", "a" to "f" or "A" to "F" and shall represent 4 bits. The most
	/// significant character representing the 4 most significant bits of the SD
	/// shall appear first in the string, and the character representing the 4
	/// least significant bit of the SD shall appear last in the string. This is
	/// an optional parameter that complements the Slice/Service type(s) to
	/// allow to  differentiate amongst multiple Network Slices of the same
	/// Slice/Service type. This IE shall be absent if no SD value is associated
	/// with the SST.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "3-octet string, representing the Slice Differentiator,
	/// in hexadecimal representation. Each character in the string shall take a
	/// value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall
	/// represent 4 bits. The most significant character representing the 4 most
	/// significant bits of the SD shall appear first in the string, and the
	/// character representing the 4 least significant bit of the SD shall
	/// appear last in the string. This is an optional parameter that
	/// complements the Slice/Service type(s) to allow to  differentiate amongst
	/// multiple Network Slices of the same Slice/Service type. This IE shall be
	/// absent if no SD value is associated with the SST.\n",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{6}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct SnssaiSd(String);
	impl ::std::ops::Deref for SnssaiSd {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<SnssaiSd> for String {
		fn from(value: SnssaiSd) -> Self {
			value.0
		}
	}

	impl From<&SnssaiSd> for SnssaiSd {
		fn from(value: &SnssaiSd) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for SnssaiSd {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{6}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{6}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for SnssaiSd {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for SnssaiSd {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for SnssaiSd {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for SnssaiSd {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// SorCmci
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "$ref": "#/components/schemas/Bytes"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SorCmci(pub Bytes);
	impl ::std::ops::Deref for SorCmci {
		type Target = Bytes;
		fn deref(&self) -> &Bytes {
			&self.0
		}
	}

	impl From<SorCmci> for Bytes {
		fn from(value: SorCmci) -> Self {
			value.0
		}
	}

	impl From<&SorCmci> for SorCmci {
		fn from(value: &SorCmci) -> Self {
			value.clone()
		}
	}

	impl From<Bytes> for SorCmci {
		fn from(value: Bytes) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for SorCmci {
		type Err = <Bytes as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for SorCmci {
		type Error = <Bytes as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for SorCmci {
		type Error = <Bytes as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for SorCmci {
		type Error = <Bytes as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for SorCmci {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// SorInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "ackInd",
	///    "provisioningTime"
	///  ],
	///  "properties": {
	///    "ackInd": {
	///      "$ref": "#/components/schemas/AckInd"
	///    },
	///    "countersor": {
	///      "$ref": "#/components/schemas/CounterSor"
	///    },
	///    "provisioningTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "sorCmci": {
	///      "$ref": "#/components/schemas/Bytes"
	///    },
	///    "sorMacIausf": {
	///      "$ref": "#/components/schemas/SorMac"
	///    },
	///    "sorTransparentContainer": {
	///      "$ref": "#/components/schemas/Bytes"
	///    },
	///    "steeringContainer": {
	///      "$ref": "#/components/schemas/SteeringContainer"
	///    },
	///    "storeSorCmciInMe": {
	///      "type": "boolean"
	///    },
	///    "usimSupportOfSorCmci": {
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SorInfo {
		#[serde(rename = "ackInd")]
		pub ack_ind: AckInd,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub countersor: Option<CounterSor>,
		#[serde(rename = "provisioningTime")]
		pub provisioning_time: DateTime,
		#[serde(rename = "sorCmci", default, skip_serializing_if = "Option::is_none")]
		pub sor_cmci: Option<Bytes>,
		#[serde(
			rename = "sorMacIausf",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub sor_mac_iausf: Option<SorMac>,
		#[serde(
			rename = "sorTransparentContainer",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub sor_transparent_container: Option<Bytes>,
		#[serde(
			rename = "steeringContainer",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub steering_container: Option<SteeringContainer>,
		#[serde(
			rename = "storeSorCmciInMe",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub store_sor_cmci_in_me: Option<bool>,
		#[serde(
			rename = "usimSupportOfSorCmci",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub usim_support_of_sor_cmci: Option<bool>,
	}

	impl From<&SorInfo> for SorInfo {
		fn from(value: &SorInfo) -> Self {
			value.clone()
		}
	}

	/// MAC value for protecting SOR procedure (SoR-MAC-IAUSF and SoR-XMAC-IUE).
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "MAC value for protecting SOR procedure (SoR-MAC-IAUSF
	/// and SoR-XMAC-IUE).",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{32}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct SorMac(String);
	impl ::std::ops::Deref for SorMac {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<SorMac> for String {
		fn from(value: SorMac) -> Self {
			value.0
		}
	}

	impl From<&SorMac> for SorMac {
		fn from(value: &SorMac) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for SorMac {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{32}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{32}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for SorMac {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for SorMac {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for SorMac {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for SorMac {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// SorTransparentContainer
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "$ref": "#/components/schemas/Bytes"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SorTransparentContainer(pub Bytes);
	impl ::std::ops::Deref for SorTransparentContainer {
		type Target = Bytes;
		fn deref(&self) -> &Bytes {
			&self.0
		}
	}

	impl From<SorTransparentContainer> for Bytes {
		fn from(value: SorTransparentContainer) -> Self {
			value.0
		}
	}

	impl From<&SorTransparentContainer> for SorTransparentContainer {
		fn from(value: &SorTransparentContainer) -> Self {
			value.clone()
		}
	}

	impl From<Bytes> for SorTransparentContainer {
		fn from(value: Bytes) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for SorTransparentContainer {
		type Err = <Bytes as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for SorTransparentContainer {
		type Error = <Bytes as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for SorTransparentContainer {
		type Error = <Bytes as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for SorTransparentContainer {
		type Error = <Bytes as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for SorTransparentContainer {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// SorUpdateIndicator
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "INITIAL_REGISTRATION",
	///    "EMERGENCY_REGISTRATION"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum SorUpdateIndicator {
		#[default]
		#[serde(rename = "INITIAL_REGISTRATION")]
		InitialRegistration,
		#[serde(rename = "EMERGENCY_REGISTRATION")]
		EmergencyRegistration,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&SorUpdateIndicator> for SorUpdateIndicator {
		fn from(value: &SorUpdateIndicator) -> Self {
			value.clone()
		}
	}

	impl ToString for SorUpdateIndicator {
		fn to_string(&self) -> String {
			match *self {
				Self::InitialRegistration => "INITIAL_REGISTRATION".to_string(),
				Self::EmergencyRegistration => "EMERGENCY_REGISTRATION".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for SorUpdateIndicator {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"INITIAL_REGISTRATION" => Ok(Self::InitialRegistration),
				"EMERGENCY_REGISTRATION" => Ok(Self::EmergencyRegistration),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for SorUpdateIndicator {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for SorUpdateIndicator {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for SorUpdateIndicator {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// SorUpdateInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "vplmnId"
	///  ],
	///  "properties": {
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    },
	///    "vplmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SorUpdateInfo {
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
		#[serde(rename = "vplmnId")]
		pub vplmn_id: PlmnId,
	}

	impl From<&SorUpdateInfo> for SorUpdateInfo {
		fn from(value: &SorUpdateInfo) -> Self {
			value.clone()
		}
	}

	/// Contains the Spatial Validity Condition.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the Spatial Validity Condition.",
	///  "type": "object",
	///  "properties": {
	///    "countries": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Mcc"
	///      },
	///      "minItems": 1
	///    },
	///    "geographicalServiceArea": {
	///      "$ref": "#/components/schemas/GeoServiceArea"
	///    },
	///    "trackingAreaList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Tai"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SpatialValidityCond {
		#[serde(default, skip_serializing_if = "Vec::is_empty")]
		pub countries: Vec<Mcc>,
		#[serde(
			rename = "geographicalServiceArea",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub geographical_service_area: Option<GeoServiceArea>,
		#[serde(
			rename = "trackingAreaList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub tracking_area_list: Vec<Tai>,
	}

	impl From<&SpatialValidityCond> for SpatialValidityCond {
		fn from(value: &SpatialValidityCond) -> Self {
			value.clone()
		}
	}

	/// represents the service and session continuity mode It shall comply with
	/// the provisions defined in table 5.4.3.6-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "represents the service and session continuity mode It
	/// shall comply with the provisions defined in table 5.4.3.6-1. \n",
	///  "type": "string",
	///  "enum": [
	///    "SSC_MODE_1",
	///    "SSC_MODE_2",
	///    "SSC_MODE_3"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum SscMode {
		#[default]
		#[serde(rename = "SSC_MODE_1")]
		SscMode1,
		#[serde(rename = "SSC_MODE_2")]
		SscMode2,
		#[serde(rename = "SSC_MODE_3")]
		SscMode3,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&SscMode> for SscMode {
		fn from(value: &SscMode) -> Self {
			value.clone()
		}
	}

	impl ToString for SscMode {
		fn to_string(&self) -> String {
			match *self {
				Self::SscMode1 => "SSC_MODE_1".to_string(),
				Self::SscMode2 => "SSC_MODE_2".to_string(),
				Self::SscMode3 => "SSC_MODE_3".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for SscMode {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"SSC_MODE_1" => Ok(Self::SscMode1),
				"SSC_MODE_2" => Ok(Self::SscMode2),
				"SSC_MODE_3" => Ok(Self::SscMode3),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for SscMode {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for SscMode {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for SscMode {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// SscModes
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "defaultSscMode"
	///  ],
	///  "properties": {
	///    "allowedSscModes": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/SscMode"
	///      },
	///      "maxItems": 2,
	///      "minItems": 1
	///    },
	///    "defaultSscMode": {
	///      "$ref": "#/components/schemas/SscMode"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SscModes {
		#[serde(
			rename = "allowedSscModes",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub allowed_ssc_modes: Vec<SscMode>,
		#[serde(rename = "defaultSscMode")]
		pub default_ssc_mode: SscMode,
	}

	impl From<&SscModes> for SscModes {
		fn from(value: &SscModes) -> Self {
			value.clone()
		}
	}

	/// Source specific IP multicast address
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Source specific IP multicast address",
	///  "type": "object",
	///  "required": [
	///    "destIpAddr",
	///    "sourceIpAddr"
	///  ],
	///  "properties": {
	///    "destIpAddr": {
	///      "$ref": "#/components/schemas/IpAddr"
	///    },
	///    "sourceIpAddr": {
	///      "$ref": "#/components/schemas/IpAddr"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Ssm {
		#[serde(rename = "destIpAddr")]
		pub dest_ip_addr: IpAddr,
		#[serde(rename = "sourceIpAddr")]
		pub source_ip_addr: IpAddr,
	}

	impl From<&Ssm> for Ssm {
		fn from(value: &Ssm) -> Self {
			value.clone()
		}
	}

	/// Possible values are:
	/// - STATIONARY: Identifies the UE is stationary
	/// - MOBILE: Identifies the UE is mobile
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Possible values are:\n- STATIONARY: Identifies the UE
	/// is stationary\n- MOBILE: Identifies the UE is mobile\n",
	///  "type": "string",
	///  "enum": [
	///    "STATIONARY",
	///    "MOBILE"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum StationaryIndication {
		#[default]
		#[serde(rename = "STATIONARY")]
		Stationary,
		#[serde(rename = "MOBILE")]
		Mobile,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&StationaryIndication> for StationaryIndication {
		fn from(value: &StationaryIndication) -> Self {
			value.clone()
		}
	}

	impl ToString for StationaryIndication {
		fn to_string(&self) -> String {
			match *self {
				Self::Stationary => "STATIONARY".to_string(),
				Self::Mobile => "MOBILE".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for StationaryIndication {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"STATIONARY" => Ok(Self::Stationary),
				"MOBILE" => Ok(Self::Mobile),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for StationaryIndication {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for StationaryIndication {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for StationaryIndication {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// This enumeration is defined in the same way as the
	/// 'StationaryIndication' enumeration, but with the OpenAPI 'nullable:
	/// true' property."
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This enumeration is defined in the same way as the
	/// 'StationaryIndication' enumeration, but with the OpenAPI 'nullable:
	/// true' property.\"\n",
	///  "anyOf": [
	///    {
	///      "$ref": "#/components/schemas/StationaryIndication"
	///    },
	///    {
	///      "$ref": "#/components/schemas/NullValue"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum StationaryIndicationRm {
		#[default]
		StationaryIndication(StationaryIndication),
		NullValue(NullValue),
	}

	impl From<&StationaryIndicationRm> for StationaryIndicationRm {
		fn from(value: &StationaryIndicationRm) -> Self {
			value.clone()
		}
	}

	impl From<StationaryIndication> for StationaryIndicationRm {
		fn from(value: StationaryIndication) -> Self {
			Self::StationaryIndication(value)
		}
	}

	impl From<NullValue> for StationaryIndicationRm {
		fn from(value: NullValue) -> Self {
			Self::NullValue(value)
		}
	}

	/// SteeringContainer
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "oneOf": [
	///    {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/SteeringInfo"
	///      },
	///      "minItems": 1
	///    },
	///    {
	///      "$ref": "#/components/schemas/SecuredPacket"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum SteeringContainer {
		#[default]
		Variant0(Vec<SteeringInfo>),
		Variant1(SecuredPacket),
	}

	impl From<&SteeringContainer> for SteeringContainer {
		fn from(value: &SteeringContainer) -> Self {
			value.clone()
		}
	}

	impl From<Vec<SteeringInfo>> for SteeringContainer {
		fn from(value: Vec<SteeringInfo>) -> Self {
			Self::Variant0(value)
		}
	}

	impl From<SecuredPacket> for SteeringContainer {
		fn from(value: SecuredPacket) -> Self {
			Self::Variant1(value)
		}
	}

	/// Contains a combination of one PLMN identity and zero or more access
	/// technologies.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains a combination of one PLMN identity and zero or
	/// more access technologies.",
	///  "type": "object",
	///  "required": [
	///    "plmnId"
	///  ],
	///  "properties": {
	///    "accessTechList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/AccessTech"
	///      },
	///      "minItems": 1
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SteeringInfo {
		#[serde(
			rename = "accessTechList",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub access_tech_list: Vec<AccessTech>,
		#[serde(rename = "plmnId")]
		pub plmn_id: PlmnId,
	}

	impl From<&SteeringInfo> for SteeringInfo {
		fn from(value: &SteeringInfo) -> Self {
			value.clone()
		}
	}

	/// String representing the STN-SR as defined in clause 18.6 of 3GPP TS
	/// 23.003.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String representing the STN-SR as defined in clause
	/// 18.6 of 3GPP TS 23.003.",
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct StnSr(pub String);
	impl ::std::ops::Deref for StnSr {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<StnSr> for String {
		fn from(value: StnSr) -> Self {
			value.0
		}
	}

	impl From<&StnSr> for StnSr {
		fn from(value: &StnSr) -> Self {
			value.clone()
		}
	}

	impl From<String> for StnSr {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for StnSr {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for StnSr {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// String representing the STN-SR as defined in clause 18.6 of 3GPP TS
	/// 23.003 with the OpenAPI 'nullable: true' property.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String representing the STN-SR as defined in clause 18.6 of 3GPP TS 23.003 with the OpenAPI 'nullable: true' property. \n",
	///  "type": [
	///    "string",
	///    "null"
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct StnSrRm(pub Option<String>);
	impl ::std::ops::Deref for StnSrRm {
		type Target = Option<String>;
		fn deref(&self) -> &Option<String> {
			&self.0
		}
	}

	impl From<StnSrRm> for Option<String> {
		fn from(value: StnSrRm) -> Self {
			value.0
		}
	}

	impl From<&StnSrRm> for StnSrRm {
		fn from(value: &StnSrRm) -> Self {
			value.clone()
		}
	}

	impl From<Option<String>> for StnSrRm {
		fn from(value: Option<String>) -> Self {
			Self(value)
		}
	}

	/// Provides the subsribed 5QI and the ARP, it may contain the priority
	/// level.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Provides the subsribed 5QI and the ARP, it may contain
	/// the priority level.",
	///  "type": "object",
	///  "required": [
	///    "5qi",
	///    "arp"
	///  ],
	///  "properties": {
	///    "5qi": {
	///      "$ref": "#/components/schemas/5Qi"
	///    },
	///    "arp": {
	///      "$ref": "#/components/schemas/Arp"
	///    },
	///    "priorityLevel": {
	///      "$ref": "#/components/schemas/5QiPriorityLevel"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SubscribedDefaultQos {
		pub arp: Arp,
		#[serde(rename = "5qi")]
		pub five_qi: _5qi,
		#[serde(
			rename = "priorityLevel",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub priority_level: Option<_5qiPriorityLevel>,
	}

	impl From<&SubscribedDefaultQos> for SubscribedDefaultQos {
		fn from(value: &SubscribedDefaultQos) -> Self {
			value.clone()
		}
	}

	/// SubscriptionDataSets
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "amData": {
	///      "$ref": "#/components/schemas/AccessAndMobilitySubscriptionData"
	///    },
	///    "lcsBroadcastAssistanceTypesData": {
	///      "$ref": "#/components/schemas/LcsBroadcastAssistanceTypesData"
	///    },
	///    "lcsMoData": {
	///      "$ref": "#/components/schemas/LcsMoData"
	///    },
	///    "lcsPrivacyData": {
	///      "$ref": "#/components/schemas/LcsPrivacyData"
	///    },
	///    "mbsData": {
	///      "$ref": "#/components/schemas/MbsSubscriptionData"
	///    },
	///    "proseData": {
	///      "$ref": "#/components/schemas/ProseSubscriptionData"
	///    },
	///    "smData": {
	///      "$ref": "#/components/schemas/SmSubsData"
	///    },
	///    "smfSelData": {
	///      "$ref": "#/components/schemas/SmfSelectionSubscriptionData"
	///    },
	///    "smsMngData": {
	///      "$ref": "#/components/schemas/SmsManagementSubscriptionData"
	///    },
	///    "smsSubsData": {
	///      "$ref": "#/components/schemas/SmsSubscriptionData"
	///    },
	///    "traceData": {
	///      "$ref": "#/components/schemas/TraceData"
	///    },
	///    "ucData": {
	///      "$ref": "#/components/schemas/UcSubscriptionData"
	///    },
	///    "uecAmfData": {
	///      "$ref": "#/components/schemas/UeContextInAmfData"
	///    },
	///    "uecSmfData": {
	///      "$ref": "#/components/schemas/UeContextInSmfData"
	///    },
	///    "uecSmsfData": {
	///      "$ref": "#/components/schemas/UeContextInSmsfData"
	///    },
	///    "v2xData": {
	///      "$ref": "#/components/schemas/V2xSubscriptionData"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SubscriptionDataSets {
		#[serde(rename = "amData", default, skip_serializing_if = "Option::is_none")]
		pub am_data: Option<AccessAndMobilitySubscriptionData>,
		#[serde(
			rename = "lcsBroadcastAssistanceTypesData",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub lcs_broadcast_assistance_types_data: Option<LcsBroadcastAssistanceTypesData>,
		#[serde(rename = "lcsMoData", default, skip_serializing_if = "Option::is_none")]
		pub lcs_mo_data: Option<LcsMoData>,
		#[serde(
			rename = "lcsPrivacyData",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub lcs_privacy_data: Option<LcsPrivacyData>,
		#[serde(rename = "mbsData", default, skip_serializing_if = "Option::is_none")]
		pub mbs_data: Option<MbsSubscriptionData>,
		#[serde(rename = "proseData", default, skip_serializing_if = "Option::is_none")]
		pub prose_data: Option<ProseSubscriptionData>,
		#[serde(rename = "smData", default, skip_serializing_if = "Option::is_none")]
		pub sm_data: Option<SmSubsData>,
		#[serde(
			rename = "smfSelData",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub smf_sel_data: Option<SmfSelectionSubscriptionData>,
		#[serde(
			rename = "smsMngData",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub sms_mng_data: Option<SmsManagementSubscriptionData>,
		#[serde(
			rename = "smsSubsData",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub sms_subs_data: Option<SmsSubscriptionData>,
		#[serde(rename = "traceData", default, skip_serializing_if = "Option::is_none")]
		pub trace_data: Option<TraceData>,
		#[serde(rename = "ucData", default, skip_serializing_if = "Option::is_none")]
		pub uc_data: Option<UcSubscriptionData>,
		#[serde(
			rename = "uecAmfData",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub uec_amf_data: Option<UeContextInAmfData>,
		#[serde(
			rename = "uecSmfData",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub uec_smf_data: Option<UeContextInSmfData>,
		#[serde(
			rename = "uecSmsfData",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub uec_smsf_data: Option<UeContextInSmsfData>,
		#[serde(rename = "v2xData", default, skip_serializing_if = "Option::is_none")]
		pub v2x_data: Option<V2xSubscriptionData>,
	}

	impl From<&SubscriptionDataSets> for SubscriptionDataSets {
		fn from(value: &SubscriptionDataSets) -> Self {
			value.clone()
		}
	}

	/// Success
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "boolean"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Success(pub bool);
	impl ::std::ops::Deref for Success {
		type Target = bool;
		fn deref(&self) -> &bool {
			&self.0
		}
	}

	impl From<Success> for bool {
		fn from(value: Success) -> Self {
			value.0
		}
	}

	impl From<&Success> for Success {
		fn from(value: &Success) -> Self {
			value.clone()
		}
	}

	impl From<bool> for Success {
		fn from(value: bool) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for Success {
		type Err = <bool as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for Success {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for Success {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for Success {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for Success {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Contains the SUCI.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the SUCI.",
	///  "type": "string",
	///  "pattern":
	/// "^(suci-(0-[0-9]{3}-[0-9]{2,3}|[1-7]-.+)-[0-9]{1,4}-(0-0-.
	/// +|[a-fA-F1-9]-([1-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])-[a-fA-F0-9]+)|.
	/// +)$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Suci(String);
	impl ::std::ops::Deref for Suci {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Suci> for String {
		fn from(value: Suci) -> Self {
			value.0
		}
	}

	impl From<&Suci> for Suci {
		fn from(value: &Suci) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Suci {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new(
				"^(suci-(0-[0-9]{3}-[0-9]{2,3}|[1-7]-.+)-[0-9]{1,4}-(0-0-.\
				 +|[a-fA-F1-9]-([1-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])-[a-fA-F0-9]+)|.+)$",
			)
			.unwrap()
			.find(value)
			.is_none()
			{
				return Err("doesn't match pattern \
				            \"^(suci-(0-[0-9]{3}-[0-9]{2,3}|[1-7]-.+)-[0-9]{1,4}-(0-0-.\
				            +|[a-fA-F1-9]-([1-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])-[a-fA-F0-9]+)|.\
				            +)$\""
					.into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Suci {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Suci {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Suci {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Suci {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// SuggestedPacketNumDl
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "suggestedPacketNumDl"
	///  ],
	///  "properties": {
	///    "suggestedPacketNumDl": {
	///      "type": "integer",
	///      "minimum": 1.0
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SuggestedPacketNumDl {
		#[serde(rename = "suggestedPacketNumDl")]
		#[default(_code = "unsafe {std::num::NonZeroU64::new_unchecked(1)}")]
		pub suggested_packet_num_dl: std::num::NonZeroU64,
		#[serde(
			rename = "validityTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub validity_time: Option<DateTime>,
	}

	impl From<&SuggestedPacketNumDl> for SuggestedPacketNumDl {
		fn from(value: &SuggestedPacketNumDl) -> Self {
			value.clone()
		}
	}

	/// String identifying a Supi that shall contain either an IMSI, a network
	/// specific identifier, a Global Cable Identifier (GCI) or a Global
	/// Line Identifier (GLI) as specified in clause 2.2A of 3GPP TS 23.003.
	/// It shall be formatted as follows
	/// - for an IMSI "imsi-<imsi>", where <imsi> shall be formatted according
	///   to clause 2.2 of 3GPP TS 23.003 that describes an IMSI.
	/// - for a network specific identifier "nai-<nai>, where <nai> shall be
	///   formatted according to clause 28.7.2 of 3GPP TS 23.003 that describes
	///   an NAI.
	/// - for a GCI "gci-<gci>", where <gci> shall be formatted according to
	///   clause 28.15.2 of 3GPP TS 23.003.
	/// - for a GLI "gli-<gli>", where <gli> shall be formatted according to
	///   clause 28.16.2 of 3GPP TS 23.003.To enable that the value is used as
	///   part of an URI, the string shall only contain characters allowed
	///   according to the "lower-with-hyphen" naming convention defined in 3GPP
	///   TS 29.501.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String identifying a Supi that shall contain either an
	/// IMSI, a network specific identifier,\na Global Cable Identifier (GCI) or
	/// a Global Line Identifier (GLI) as specified in clause \n2.2A of 3GPP TS
	/// 23.003. It shall be formatted as follows\n - for an IMSI
	/// \"imsi-<imsi>\", where <imsi> shall be formatted according to clause
	/// 2.2\n   of 3GPP TS 23.003 that describes an IMSI.\n - for a network
	/// specific identifier \"nai-<nai>, where <nai> shall be formatted\n
	/// according to clause 28.7.2 of 3GPP TS 23.003 that describes an NAI.\n -
	/// for a GCI \"gci-<gci>\", where <gci> shall be formatted according to
	/// clause 28.15.2\n   of 3GPP TS 23.003.\n - for a GLI \"gli-<gli>\", where
	/// <gli> shall be formatted according to clause 28.16.2 of\n   3GPP TS
	/// 23.003.To enable that the value is used as part of an URI, the string
	/// shall\n   only contain characters allowed according to the
	/// \"lower-with-hyphen\" naming convention\n   defined in 3GPP TS
	/// 29.501.\n",
	///  "type": "string",
	///  "pattern": "^(imsi-[0-9]{5,15}|nai-.+|gci-.+|gli-.+|.+)$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Supi(String);
	impl ::std::ops::Deref for Supi {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Supi> for String {
		fn from(value: Supi) -> Self {
			value.0
		}
	}

	impl From<&Supi> for Supi {
		fn from(value: &Supi) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Supi {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^(imsi-[0-9]{5,15}|nai-.+|gci-.+|gli-.+|.+)$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \
				            \"^(imsi-[0-9]{5,15}|nai-.+|gci-.+|gli-.+|.+)$\""
					.into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Supi {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Supi {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Supi {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Supi {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// List of Supis.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "List of Supis.",
	///  "type": "object",
	///  "required": [
	///    "supiList"
	///  ],
	///  "properties": {
	///    "supiList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Supi"
	///      }
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SupiInfo {
		#[serde(rename = "supiList")]
		pub supi_list: Vec<Supi>,
	}

	impl From<&SupiInfo> for SupiInfo {
		fn from(value: &SupiInfo) -> Self {
			value.clone()
		}
	}

	/// String identifying a SUPI or a SUCI.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String identifying a SUPI or a SUCI.",
	///  "type": "string",
	///  "pattern":
	/// "^(imsi-[0-9]{5,15}|nai-.+|gli-.+|gci-.+|suci-(0-[0-9]{3}-[0-9]{2,
	/// 3}|[1-7]-.+)-[0-9]{1,4}-(0-0-.*
	/// |[a-fA-F1-9]-([1-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])-[a-fA-F0-9]+)|.
	/// +)$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct SupiOrSuci(String);
	impl ::std::ops::Deref for SupiOrSuci {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<SupiOrSuci> for String {
		fn from(value: SupiOrSuci) -> Self {
			value.0
		}
	}

	impl From<&SupiOrSuci> for SupiOrSuci {
		fn from(value: &SupiOrSuci) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for SupiOrSuci {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new(
				"^(imsi-[0-9]{5,15}|nai-.+|gli-.+|gci-.+|suci-(0-[0-9]{3}-[0-9]{2,3}|[1-7]-.\
				 +)-[0-9]{1,4}-(0-0-.*\
				 |[a-fA-F1-9]-([1-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])-[a-fA-F0-9]+)|.+)$",
			)
			.unwrap()
			.find(value)
			.is_none()
			{
				return Err("doesn't match pattern \
				            \"^(imsi-[0-9]{5,15}|nai-.+|gli-.+|gci-.+|suci-(0-[0-9]{3}-[0-9]{2,\
				            3}|[1-7]-.+)-[0-9]{1,4}-(0-0-.*\
				            |[a-fA-F1-9]-([1-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])-[a-fA-F0-9]+)|.\
				            +)$\""
					.into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for SupiOrSuci {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for SupiOrSuci {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for SupiOrSuci {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for SupiOrSuci {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// A range of SUPIs (subscriber identities), either based on a numeric
	/// range, or based on regular-expression matching
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "A range of SUPIs (subscriber identities), either based
	/// on a numeric range, or based on regular-expression matching\n",
	///  "type": "object",
	///  "properties": {
	///    "end": {
	///      "type": "string",
	///      "pattern": "^[0-9]+$"
	///    },
	///    "pattern": {
	///      "type": "string"
	///    },
	///    "start": {
	///      "type": "string",
	///      "pattern": "^[0-9]+$"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct SupiRange {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub end: Option<SupiRangeEnd>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub pattern: Option<String>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub start: Option<SupiRangeStart>,
	}

	impl From<&SupiRange> for SupiRange {
		fn from(value: &SupiRange) -> Self {
			value.clone()
		}
	}

	/// SupiRangeEnd
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[0-9]+$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct SupiRangeEnd(String);
	impl ::std::ops::Deref for SupiRangeEnd {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<SupiRangeEnd> for String {
		fn from(value: SupiRangeEnd) -> Self {
			value.0
		}
	}

	impl From<&SupiRangeEnd> for SupiRangeEnd {
		fn from(value: &SupiRangeEnd) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for SupiRangeEnd {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9]+$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9]+$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for SupiRangeEnd {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for SupiRangeEnd {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for SupiRangeEnd {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for SupiRangeEnd {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// SupiRangeStart
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[0-9]+$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct SupiRangeStart(String);
	impl ::std::ops::Deref for SupiRangeStart {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<SupiRangeStart> for String {
		fn from(value: SupiRangeStart) -> Self {
			value.0
		}
	}

	impl From<&SupiRangeStart> for SupiRangeStart {
		fn from(value: &SupiRangeStart) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for SupiRangeStart {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9]+$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9]+$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for SupiRangeStart {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for SupiRangeStart {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for SupiRangeStart {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for SupiRangeStart {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// A string used to indicate the features supported by an API that is used
	/// as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a
	/// bitmask indicating supported features in  hexadecimal representation
	/// Each character in the string shall take a value of "0" to "9",  "a" to
	/// "f" or "A" to "F" and shall represent the support of 4 features as
	/// described in  table 5.2.2-3. The most significant character representing
	/// the highest-numbered features shall  appear first in the string, and the
	/// character representing features 1 to 4 shall appear last  in the string.
	/// The list of features and their numbering (starting with 1) are defined
	/// separately for each API. If the string contains a lower number of
	/// characters than there are  defined features for an API, all features
	/// that would be represented by characters that are not  present in the
	/// string are not supported.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  table 5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.\n",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]*$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct SupportedFeatures(String);
	impl ::std::ops::Deref for SupportedFeatures {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<SupportedFeatures> for String {
		fn from(value: SupportedFeatures) -> Self {
			value.0
		}
	}

	impl From<&SupportedFeatures> for SupportedFeatures {
		fn from(value: &SupportedFeatures) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for SupportedFeatures {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]*$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]*$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for SupportedFeatures {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for SupportedFeatures {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for SupportedFeatures {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for SupportedFeatures {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Indicates supported GAD shapes.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates supported GAD shapes.",
	///  "type": "string",
	///  "enum": [
	///    "POINT",
	///    "POINT_UNCERTAINTY_CIRCLE",
	///    "POINT_UNCERTAINTY_ELLIPSE",
	///    "POLYGON",
	///    "POINT_ALTITUDE",
	///    "POINT_ALTITUDE_UNCERTAINTY",
	///    "ELLIPSOID_ARC",
	///    "LOCAL_2D_POINT_UNCERTAINTY_ELLIPSE",
	///    "LOCAL_3D_POINT_UNCERTAINTY_ELLIPSOID"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum SupportedGadShapes {
		#[default]
		#[serde(rename = "POINT")]
		Point,
		#[serde(rename = "POINT_UNCERTAINTY_CIRCLE")]
		PointUncertaintyCircle,
		#[serde(rename = "POINT_UNCERTAINTY_ELLIPSE")]
		PointUncertaintyEllipse,
		#[serde(rename = "POLYGON")]
		Polygon,
		#[serde(rename = "POINT_ALTITUDE")]
		PointAltitude,
		#[serde(rename = "POINT_ALTITUDE_UNCERTAINTY")]
		PointAltitudeUncertainty,
		#[serde(rename = "ELLIPSOID_ARC")]
		EllipsoidArc,
		#[serde(rename = "LOCAL_2D_POINT_UNCERTAINTY_ELLIPSE")]
		Local2dPointUncertaintyEllipse,
		#[serde(rename = "LOCAL_3D_POINT_UNCERTAINTY_ELLIPSOID")]
		Local3dPointUncertaintyEllipsoid,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&SupportedGadShapes> for SupportedGadShapes {
		fn from(value: &SupportedGadShapes) -> Self {
			value.clone()
		}
	}

	impl ToString for SupportedGadShapes {
		fn to_string(&self) -> String {
			match *self {
				Self::Point => "POINT".to_string(),
				Self::PointUncertaintyCircle => "POINT_UNCERTAINTY_CIRCLE".to_string(),
				Self::PointUncertaintyEllipse => "POINT_UNCERTAINTY_ELLIPSE".to_string(),
				Self::Polygon => "POLYGON".to_string(),
				Self::PointAltitude => "POINT_ALTITUDE".to_string(),
				Self::PointAltitudeUncertainty => "POINT_ALTITUDE_UNCERTAINTY".to_string(),
				Self::EllipsoidArc => "ELLIPSOID_ARC".to_string(),
				Self::Local2dPointUncertaintyEllipse => {
					"LOCAL_2D_POINT_UNCERTAINTY_ELLIPSE".to_string()
				}
				Self::Local3dPointUncertaintyEllipsoid => {
					"LOCAL_3D_POINT_UNCERTAINTY_ELLIPSOID".to_string()
				}
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for SupportedGadShapes {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"POINT" => Ok(Self::Point),
				"POINT_UNCERTAINTY_CIRCLE" => Ok(Self::PointUncertaintyCircle),
				"POINT_UNCERTAINTY_ELLIPSE" => Ok(Self::PointUncertaintyEllipse),
				"POLYGON" => Ok(Self::Polygon),
				"POINT_ALTITUDE" => Ok(Self::PointAltitude),
				"POINT_ALTITUDE_UNCERTAINTY" => Ok(Self::PointAltitudeUncertainty),
				"ELLIPSOID_ARC" => Ok(Self::EllipsoidArc),
				"LOCAL_2D_POINT_UNCERTAINTY_ELLIPSE" => Ok(Self::Local2dPointUncertaintyEllipse),
				"LOCAL_3D_POINT_UNCERTAINTY_ELLIPSOID" => {
					Ok(Self::Local3dPointUncertaintyEllipsoid)
				}
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for SupportedGadShapes {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for SupportedGadShapes {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for SupportedGadShapes {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// 2 or 3-octet string identifying a tracking area code as specified in
	/// clause 9.3.3.10  of 3GPP TS 38.413, in hexadecimal representation. Each
	/// character in the string shall  take a value of "0" to "9", "a" to "f" or
	/// "A" to "F" and shall represent 4 bits. The most significant character
	/// representing the 4 most significant bits of the TAC shall  appear first
	/// in the string, and the character representing the 4 least significant
	/// bit  of the TAC shall appear last in the string.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "2 or 3-octet string identifying a tracking area code as
	/// specified in clause 9.3.3.10  of 3GPP TS 38.413, in hexadecimal
	/// representation. Each character in the string shall  take a value of
	/// \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4
	/// bits. The most significant character representing the 4 most significant
	/// bits of the TAC shall  appear first in the string, and the character
	/// representing the 4 least significant bit  of the TAC shall appear last
	/// in the string. \n",
	///  "type": "string",
	///  "pattern": "(^[A-Fa-f0-9]{4}$)|(^[A-Fa-f0-9]{6}$)"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Tac(String);
	impl ::std::ops::Deref for Tac {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Tac> for String {
		fn from(value: Tac) -> Self {
			value.0
		}
	}

	impl From<&Tac> for Tac {
		fn from(value: &Tac) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Tac {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("(^[A-Fa-f0-9]{4}$)|(^[A-Fa-f0-9]{6}$)")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err(
					"doesn't match pattern \"(^[A-Fa-f0-9]{4}$)|(^[A-Fa-f0-9]{6}$)\"".into(),
				);
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Tac {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Tac {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Tac {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Tac {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// contains tracking area information (tracking area codes).
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "contains tracking area information (tracking area
	/// codes).",
	///  "type": "object",
	///  "required": [
	///    "tacList"
	///  ],
	///  "properties": {
	///    "tacList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Tac"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct TacInfo {
		#[serde(rename = "tacList")]
		pub tac_list: Vec<Tac>,
	}

	impl From<&TacInfo> for TacInfo {
		fn from(value: &TacInfo) -> Self {
			value.clone()
		}
	}

	/// Contains the tracking area identity as described in 3GPP 23.003
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the tracking area identity as described in
	/// 3GPP 23.003",
	///  "type": "object",
	///  "required": [
	///    "plmnId",
	///    "tac"
	///  ],
	///  "properties": {
	///    "nid": {
	///      "$ref": "#/components/schemas/Nid"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    },
	///    "tac": {
	///      "$ref": "#/components/schemas/Tac"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Tai {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub nid: Option<Nid>,
		#[serde(rename = "plmnId")]
		pub plmn_id: PlmnId,
		pub tac: Tac,
	}

	impl From<&Tai> for Tai {
		fn from(value: &Tai) -> Self {
			value.clone()
		}
	}

	/// String with format partial-time or full-time as defined in clause 5.6 of
	/// IETF RFC 3339. Examples, 20:15:00, 20:15:00-08:00 (for 8 hours behind
	/// UTC).
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String with format partial-time or full-time as defined
	/// in clause 5.6 of IETF RFC 3339. Examples, 20:15:00, 20:15:00-08:00 (for
	/// 8 hours behind UTC). \n",
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct TimeOfDay(pub String);
	impl ::std::ops::Deref for TimeOfDay {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<TimeOfDay> for String {
		fn from(value: TimeOfDay) -> Self {
			value.0
		}
	}

	impl From<&TimeOfDay> for TimeOfDay {
		fn from(value: &TimeOfDay) -> Self {
			value.clone()
		}
	}

	impl From<String> for TimeOfDay {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for TimeOfDay {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for TimeOfDay {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// String with format "time-numoffset" optionally appended by
	/// "daylightSavingTime", where
	/// - "time-numoffset" shall represent the time zone adjusted for daylight
	///   saving time and be encoded as time-numoffset as defined in clause 5.6
	///   of IETF RFC 3339;
	/// - "daylightSavingTime" shall represent the adjustment that has been made
	///   and shall be encoded as "+1" or "+2" for a +1 or +2 hours adjustment.
	///
	/// The example is for 8 hours behind UTC, +1 hour adjustment for Daylight
	/// Saving Time.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String with format \"time-numoffset\" optionally
	/// appended by \"daylightSavingTime\", where \n- \"time-numoffset\" shall
	/// represent the time zone adjusted for daylight saving time and be\n
	/// encoded as time-numoffset as defined in clause 5.6 of IETF RFC 3339; \n-
	/// \"daylightSavingTime\" shall represent the adjustment that has been made
	/// and shall be\n   encoded as \"+1\" or \"+2\" for a +1 or +2 hours
	/// adjustment. \n\nThe example is for 8 hours behind UTC, +1 hour
	/// adjustment for Daylight Saving Time.\n",
	///  "examples": [
	///    "-08:00+1"
	///  ],
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct TimeZone(pub String);
	impl ::std::ops::Deref for TimeZone {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<TimeZone> for String {
		fn from(value: TimeZone) -> Self {
			value.0
		}
	}

	impl From<&TimeZone> for TimeZone {
		fn from(value: &TimeZone) -> Self {
			value.clone()
		}
	}

	impl From<String> for TimeZone {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for TimeZone {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for TimeZone {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Temporary Mobile Group Identity
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Temporary Mobile Group Identity",
	///  "type": "object",
	///  "required": [
	///    "mbsServiceId",
	///    "plmnId"
	///  ],
	///  "properties": {
	///    "mbsServiceId": {
	///      "description": "MBS Service ID",
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]{6}$"
	///    },
	///    "plmnId": {
	///      "$ref": "#/components/schemas/PlmnId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Tmgi {
		/// MBS Service ID
		#[serde(rename = "mbsServiceId")]
		pub mbs_service_id: TmgiMbsServiceId,
		#[serde(rename = "plmnId")]
		pub plmn_id: PlmnId,
	}

	impl From<&Tmgi> for Tmgi {
		fn from(value: &Tmgi) -> Self {
			value.clone()
		}
	}

	/// MBS Service ID
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "MBS Service ID",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{6}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct TmgiMbsServiceId(String);
	impl ::std::ops::Deref for TmgiMbsServiceId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<TmgiMbsServiceId> for String {
		fn from(value: TmgiMbsServiceId) -> Self {
			value.0
		}
	}

	impl From<&TmgiMbsServiceId> for TmgiMbsServiceId {
		fn from(value: &TmgiMbsServiceId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for TmgiMbsServiceId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{6}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{6}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for TmgiMbsServiceId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for TmgiMbsServiceId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for TmgiMbsServiceId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for TmgiMbsServiceId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Contain the TNAP Identifier see clause5.6.2 of 3GPP TS 23.501.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contain the TNAP Identifier see clause5.6.2 of 3GPP TS
	/// 23.501.",
	///  "type": "object",
	///  "properties": {
	///    "bssId": {
	///      "description": "When present, it shall contain the BSSID of the
	/// access point to which the UE is attached, that is received over NGAP,
	/// see IEEE Std 802.11-2012. \n",
	///      "type": "string"
	///    },
	///    "civicAddress": {
	///      "$ref": "#/components/schemas/Bytes"
	///    },
	///    "ssId": {
	///      "description": "This IE shall be present if the UE is accessing the
	/// 5GC via a trusted WLAN access network.When present, it shall contain the
	/// SSID of the access point to which the UE is attached, that is received
	/// over NGAP,  see IEEE Std 802.11-2012. \n",
	///      "type": "string"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct TnapId {
		/// When present, it shall contain the BSSID of the access point to
		/// which the UE is attached, that is received over NGAP, see IEEE Std
		/// 802.11-2012.
		#[serde(rename = "bssId", default, skip_serializing_if = "Option::is_none")]
		pub bss_id: Option<String>,
		#[serde(
			rename = "civicAddress",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub civic_address: Option<Bytes>,
		/// This IE shall be present if the UE is accessing the 5GC via a
		/// trusted WLAN access network.When present, it shall contain the SSID
		/// of the access point to which the UE is attached, that is received
		/// over NGAP,  see IEEE Std 802.11-2012.
		#[serde(rename = "ssId", default, skip_serializing_if = "Option::is_none")]
		pub ss_id: Option<String>,
	}

	impl From<&TnapId> for TnapId {
		fn from(value: &TnapId) -> Self {
			value.clone()
		}
	}

	/// This represents the identifier of the TNGF ID as specified in clause
	/// 9.3.1.161 of  3GPP TS 38.413  in hexadecimal representation. Each
	/// character in the string shall take a value of "0" to "9", "a"  to "f" or
	/// "A" to "F" and shall represent 4 bits. The most significant character
	/// representing the  4 most significant bits of the TNGF ID shall appear
	/// first in the string, and the character  representing the 4 least
	/// significant bit of the TNGF ID shall appear last in the string.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This represents the identifier of the TNGF ID as
	/// specified in clause 9.3.1.161 of  3GPP TS 38.413  in hexadecimal
	/// representation. Each character in the string shall take a value of \"0\"
	/// to \"9\", \"a\"  to \"f\" or \"A\" to \"F\" and shall represent 4 bits.
	/// The most significant character representing the  4 most significant bits
	/// of the TNGF ID shall appear first in the string, and the character
	/// representing the 4 least significant bit of the TNGF ID shall appear
	/// last in the string. \n",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]+$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct TngfId(String);
	impl ::std::ops::Deref for TngfId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<TngfId> for String {
		fn from(value: TngfId) -> Self {
			value.0
		}
	}

	impl From<&TngfId> for TngfId {
		fn from(value: &TngfId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for TngfId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]+$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]+$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for TngfId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for TngfId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for TngfId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for TngfId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// contains Trace control and configuration parameters.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "contains Trace control and configuration parameters.",
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "required": [
	///    "eventList",
	///    "neTypeList",
	///    "traceDepth",
	///    "traceRef"
	///  ],
	///  "properties": {
	///    "collectionEntityIpv4Addr": {
	///      "$ref": "#/components/schemas/Ipv4Addr"
	///    },
	///    "collectionEntityIpv6Addr": {
	///      "$ref": "#/components/schemas/Ipv6Addr"
	///    },
	///    "eventList": {
	///      "description": "Triggering events (see 3GPP TS 32.422).It shall be
	/// encoded as an octet string in hexadecimal representation. Each character
	/// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
	/// \"A\" to \"F\" and shall represent 4 bits. The most significant
	/// character representing the 4 most significant bits shall appear first in
	/// the string, and the character representing the 4 least significant bit
	/// shall appear last in the string. Octets shall be coded according to 3GPP
	/// TS 32.422.\n",
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]+$"
	///    },
	///    "interfaceList": {
	///      "description": "List of Interfaces (see 3GPP TS 32.422).It shall be
	/// encoded as an octet string in hexadecimal representation. Each character
	/// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
	/// \"A\" to \"F\" and shall represent 4 bits. The most significant
	/// character representing the 4 most significant bits shall appear first in
	/// the string, and the character representing the  4 least significant bit
	/// shall appear last in the string. Octets shall be coded according to 3GPP
	/// TS 32.422. If this attribute is not present, all the interfaces
	/// applicable to the list of NE types indicated in the neTypeList attribute
	/// should be traced.\n",
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]+$"
	///    },
	///    "neTypeList": {
	///      "description": "List of NE Types (see 3GPP TS 32.422).It shall be
	/// encoded as an octet string in hexadecimal representation. Each character
	/// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
	/// \"A\" to \"F\" and shall represent 4 bits. The most significant
	/// character representing the 4 most significant bits shall Appear first in
	/// the string, and the character representing the 4 least significant bit
	/// shall appear last in the string.Octets shall be coded according to 3GPP
	/// TS 32.422.\n",
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]+$"
	///    },
	///    "traceDepth": {
	///      "$ref": "#/components/schemas/TraceDepth"
	///    },
	///    "traceRef": {
	///      "description": "Trace Reference (see 3GPP TS 32.422).It shall be
	/// encoded as the concatenation of MCC, MNC and Trace ID as follows:
	/// <MCC><MNC>-<Trace ID> The Trace ID shall be encoded as a 3 octet string
	/// in hexadecimal representation. Each character in the Trace ID string
	/// shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\"
	/// and shall represent 4 bits. The most significant character representing
	/// the 4 most significant bits of the Trace ID shall appear first  in the
	/// string, and the character representing the 4 least significant bit of
	/// the Trace ID shall appear last in the string.\n",
	///      "type": "string",
	///      "pattern": "^[0-9]{3}[0-9]{2,3}-[A-Fa-f0-9]{6}$"
	///    },
	///    "traceReportingConsumerUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct TraceData(pub Option<TraceDataInner>);
	impl ::std::ops::Deref for TraceData {
		type Target = Option<TraceDataInner>;
		fn deref(&self) -> &Option<TraceDataInner> {
			&self.0
		}
	}

	impl From<TraceData> for Option<TraceDataInner> {
		fn from(value: TraceData) -> Self {
			value.0
		}
	}

	impl From<&TraceData> for TraceData {
		fn from(value: &TraceData) -> Self {
			value.clone()
		}
	}

	impl From<Option<TraceDataInner>> for TraceData {
		fn from(value: Option<TraceDataInner>) -> Self {
			Self(value)
		}
	}

	/// contains Trace control and configuration parameters.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "contains Trace control and configuration parameters.",
	///  "type": "object",
	///  "required": [
	///    "eventList",
	///    "neTypeList",
	///    "traceDepth",
	///    "traceRef"
	///  ],
	///  "properties": {
	///    "collectionEntityIpv4Addr": {
	///      "$ref": "#/components/schemas/Ipv4Addr"
	///    },
	///    "collectionEntityIpv6Addr": {
	///      "$ref": "#/components/schemas/Ipv6Addr"
	///    },
	///    "eventList": {
	///      "description": "Triggering events (see 3GPP TS 32.422).It shall be
	/// encoded as an octet string in hexadecimal representation. Each character
	/// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
	/// \"A\" to \"F\" and shall represent 4 bits. The most significant
	/// character representing the 4 most significant bits shall appear first in
	/// the string, and the character representing the 4 least significant bit
	/// shall appear last in the string. Octets shall be coded according to 3GPP
	/// TS 32.422.\n",
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]+$"
	///    },
	///    "interfaceList": {
	///      "description": "List of Interfaces (see 3GPP TS 32.422).It shall be
	/// encoded as an octet string in hexadecimal representation. Each character
	/// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
	/// \"A\" to \"F\" and shall represent 4 bits. The most significant
	/// character representing the 4 most significant bits shall appear first in
	/// the string, and the character representing the  4 least significant bit
	/// shall appear last in the string. Octets shall be coded according to 3GPP
	/// TS 32.422. If this attribute is not present, all the interfaces
	/// applicable to the list of NE types indicated in the neTypeList attribute
	/// should be traced.\n",
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]+$"
	///    },
	///    "neTypeList": {
	///      "description": "List of NE Types (see 3GPP TS 32.422).It shall be
	/// encoded as an octet string in hexadecimal representation. Each character
	/// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
	/// \"A\" to \"F\" and shall represent 4 bits. The most significant
	/// character representing the 4 most significant bits shall Appear first in
	/// the string, and the character representing the 4 least significant bit
	/// shall appear last in the string.Octets shall be coded according to 3GPP
	/// TS 32.422.\n",
	///      "type": "string",
	///      "pattern": "^[A-Fa-f0-9]+$"
	///    },
	///    "traceDepth": {
	///      "$ref": "#/components/schemas/TraceDepth"
	///    },
	///    "traceRef": {
	///      "description": "Trace Reference (see 3GPP TS 32.422).It shall be
	/// encoded as the concatenation of MCC, MNC and Trace ID as follows:
	/// <MCC><MNC>-<Trace ID> The Trace ID shall be encoded as a 3 octet string
	/// in hexadecimal representation. Each character in the Trace ID string
	/// shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\"
	/// and shall represent 4 bits. The most significant character representing
	/// the 4 most significant bits of the Trace ID shall appear first  in the
	/// string, and the character representing the 4 least significant bit of
	/// the Trace ID shall appear last in the string.\n",
	///      "type": "string",
	///      "pattern": "^[0-9]{3}[0-9]{2,3}-[A-Fa-f0-9]{6}$"
	///    },
	///    "traceReportingConsumerUri": {
	///      "$ref": "#/components/schemas/Uri"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct TraceDataInner {
		#[serde(
			rename = "collectionEntityIpv4Addr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub collection_entity_ipv4_addr: Option<Ipv4Addr>,
		#[serde(
			rename = "collectionEntityIpv6Addr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub collection_entity_ipv6_addr: Option<Ipv6Addr>,
		/// Triggering events (see 3GPP TS 32.422).It shall be encoded as an
		/// octet string in hexadecimal representation. Each character in the
		/// string shall take a value of "0" to "9", "a" to "f" or "A" to "F"
		/// and shall represent 4 bits. The most significant character
		/// representing the 4 most significant bits shall appear first in the
		/// string, and the character representing the 4 least significant bit
		/// shall appear last in the string. Octets shall be coded according to
		/// 3GPP TS 32.422.
		#[serde(rename = "eventList")]
		pub event_list: TraceDataInnerEventList,
		/// List of Interfaces (see 3GPP TS 32.422).It shall be encoded as an
		/// octet string in hexadecimal representation. Each character in the
		/// string shall take a value of "0" to "9", "a" to "f" or "A" to "F"
		/// and shall represent 4 bits. The most significant character
		/// representing the 4 most significant bits shall appear first in the
		/// string, and the character representing the  4 least significant bit
		/// shall appear last in the string. Octets shall be coded according to
		/// 3GPP TS 32.422. If this attribute is not present, all the interfaces
		/// applicable to the list of NE types indicated in the neTypeList
		/// attribute should be traced.
		#[serde(
			rename = "interfaceList",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub interface_list: Option<TraceDataInnerInterfaceList>,
		/// List of NE Types (see 3GPP TS 32.422).It shall be encoded as an
		/// octet string in hexadecimal representation. Each character in the
		/// string shall take a value of "0" to "9", "a" to "f" or "A" to "F"
		/// and shall represent 4 bits. The most significant character
		/// representing the 4 most significant bits shall Appear first in the
		/// string, and the character representing the 4 least significant bit
		/// shall appear last in the string.Octets shall be coded according to
		/// 3GPP TS 32.422.
		#[serde(rename = "neTypeList")]
		pub ne_type_list: TraceDataInnerNeTypeList,
		#[serde(rename = "traceDepth")]
		pub trace_depth: TraceDepth,
		/// Trace Reference (see 3GPP TS 32.422).It shall be encoded as the
		/// concatenation of MCC, MNC and Trace ID as follows: <MCC><MNC>-<Trace
		/// ID> The Trace ID shall be encoded as a 3 octet string in hexadecimal
		/// representation. Each character in the Trace ID string shall take a
		/// value of "0" to "9", "a" to "f" or "A" to "F" and shall represent 4
		/// bits. The most significant character representing the 4 most
		/// significant bits of the Trace ID shall appear first  in the string,
		/// and the character representing the 4 least significant bit of the
		/// Trace ID shall appear last in the string.
		#[serde(rename = "traceRef")]
		pub trace_ref: TraceDataInnerTraceRef,
		#[serde(
			rename = "traceReportingConsumerUri",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub trace_reporting_consumer_uri: Option<Uri>,
	}

	impl From<&TraceDataInner> for TraceDataInner {
		fn from(value: &TraceDataInner) -> Self {
			value.clone()
		}
	}

	/// Triggering events (see 3GPP TS 32.422).It shall be encoded as an octet
	/// string in hexadecimal representation. Each character in the string shall
	/// take a value of "0" to "9", "a" to "f" or "A" to "F" and shall represent
	/// 4 bits. The most significant character representing the 4 most
	/// significant bits shall appear first in the string, and the character
	/// representing the 4 least significant bit shall appear last in the
	/// string. Octets shall be coded according to 3GPP TS 32.422.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Triggering events (see 3GPP TS 32.422).It shall be
	/// encoded as an octet string in hexadecimal representation. Each character
	/// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
	/// \"A\" to \"F\" and shall represent 4 bits. The most significant
	/// character representing the 4 most significant bits shall appear first in
	/// the string, and the character representing the 4 least significant bit
	/// shall appear last in the string. Octets shall be coded according to 3GPP
	/// TS 32.422.\n",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]+$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct TraceDataInnerEventList(String);
	impl ::std::ops::Deref for TraceDataInnerEventList {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<TraceDataInnerEventList> for String {
		fn from(value: TraceDataInnerEventList) -> Self {
			value.0
		}
	}

	impl From<&TraceDataInnerEventList> for TraceDataInnerEventList {
		fn from(value: &TraceDataInnerEventList) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for TraceDataInnerEventList {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]+$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]+$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for TraceDataInnerEventList {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for TraceDataInnerEventList {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for TraceDataInnerEventList {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for TraceDataInnerEventList {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// List of Interfaces (see 3GPP TS 32.422).It shall be encoded as an octet
	/// string in hexadecimal representation. Each character in the string shall
	/// take a value of "0" to "9", "a" to "f" or "A" to "F" and shall represent
	/// 4 bits. The most significant character representing the 4 most
	/// significant bits shall appear first in the string, and the character
	/// representing the  4 least significant bit shall appear last in the
	/// string. Octets shall be coded according to 3GPP TS 32.422. If this
	/// attribute is not present, all the interfaces applicable to the list of
	/// NE types indicated in the neTypeList attribute should be traced.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "List of Interfaces (see 3GPP TS 32.422).It shall be
	/// encoded as an octet string in hexadecimal representation. Each character
	/// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
	/// \"A\" to \"F\" and shall represent 4 bits. The most significant
	/// character representing the 4 most significant bits shall appear first in
	/// the string, and the character representing the  4 least significant bit
	/// shall appear last in the string. Octets shall be coded according to 3GPP
	/// TS 32.422. If this attribute is not present, all the interfaces
	/// applicable to the list of NE types indicated in the neTypeList attribute
	/// should be traced.\n",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]+$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct TraceDataInnerInterfaceList(String);
	impl ::std::ops::Deref for TraceDataInnerInterfaceList {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<TraceDataInnerInterfaceList> for String {
		fn from(value: TraceDataInnerInterfaceList) -> Self {
			value.0
		}
	}

	impl From<&TraceDataInnerInterfaceList> for TraceDataInnerInterfaceList {
		fn from(value: &TraceDataInnerInterfaceList) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for TraceDataInnerInterfaceList {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]+$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]+$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for TraceDataInnerInterfaceList {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for TraceDataInnerInterfaceList {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for TraceDataInnerInterfaceList {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for TraceDataInnerInterfaceList {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// List of NE Types (see 3GPP TS 32.422).It shall be encoded as an octet
	/// string in hexadecimal representation. Each character in the string shall
	/// take a value of "0" to "9", "a" to "f" or "A" to "F" and shall represent
	/// 4 bits. The most significant character representing the 4 most
	/// significant bits shall Appear first in the string, and the character
	/// representing the 4 least significant bit shall appear last in the
	/// string.Octets shall be coded according to 3GPP TS 32.422.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "List of NE Types (see 3GPP TS 32.422).It shall be
	/// encoded as an octet string in hexadecimal representation. Each character
	/// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
	/// \"A\" to \"F\" and shall represent 4 bits. The most significant
	/// character representing the 4 most significant bits shall Appear first in
	/// the string, and the character representing the 4 least significant bit
	/// shall appear last in the string.Octets shall be coded according to 3GPP
	/// TS 32.422.\n",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]+$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct TraceDataInnerNeTypeList(String);
	impl ::std::ops::Deref for TraceDataInnerNeTypeList {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<TraceDataInnerNeTypeList> for String {
		fn from(value: TraceDataInnerNeTypeList) -> Self {
			value.0
		}
	}

	impl From<&TraceDataInnerNeTypeList> for TraceDataInnerNeTypeList {
		fn from(value: &TraceDataInnerNeTypeList) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for TraceDataInnerNeTypeList {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]+$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]+$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for TraceDataInnerNeTypeList {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for TraceDataInnerNeTypeList {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for TraceDataInnerNeTypeList {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for TraceDataInnerNeTypeList {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Trace Reference (see 3GPP TS 32.422).It shall be encoded as the
	/// concatenation of MCC, MNC and Trace ID as follows: <MCC><MNC>-<Trace ID>
	/// The Trace ID shall be encoded as a 3 octet string in hexadecimal
	/// representation. Each character in the Trace ID string shall take a value
	/// of "0" to "9", "a" to "f" or "A" to "F" and shall represent 4 bits. The
	/// most significant character representing the 4 most significant bits of
	/// the Trace ID shall appear first  in the string, and the character
	/// representing the 4 least significant bit of the Trace ID shall appear
	/// last in the string.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Trace Reference (see 3GPP TS 32.422).It shall be
	/// encoded as the concatenation of MCC, MNC and Trace ID as follows:
	/// <MCC><MNC>-<Trace ID> The Trace ID shall be encoded as a 3 octet string
	/// in hexadecimal representation. Each character in the Trace ID string
	/// shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\"
	/// and shall represent 4 bits. The most significant character representing
	/// the 4 most significant bits of the Trace ID shall appear first  in the
	/// string, and the character representing the 4 least significant bit of
	/// the Trace ID shall appear last in the string.\n",
	///  "type": "string",
	///  "pattern": "^[0-9]{3}[0-9]{2,3}-[A-Fa-f0-9]{6}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct TraceDataInnerTraceRef(String);
	impl ::std::ops::Deref for TraceDataInnerTraceRef {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<TraceDataInnerTraceRef> for String {
		fn from(value: TraceDataInnerTraceRef) -> Self {
			value.0
		}
	}

	impl From<&TraceDataInnerTraceRef> for TraceDataInnerTraceRef {
		fn from(value: &TraceDataInnerTraceRef) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for TraceDataInnerTraceRef {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9]{3}[0-9]{2,3}-[A-Fa-f0-9]{6}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9]{3}[0-9]{2,3}-[A-Fa-f0-9]{6}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for TraceDataInnerTraceRef {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for TraceDataInnerTraceRef {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for TraceDataInnerTraceRef {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for TraceDataInnerTraceRef {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// TraceDataResponse
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "sharedTraceDataId": {
	///      "$ref": "#/components/schemas/SharedDataId"
	///    },
	///    "traceData": {
	///      "$ref": "#/components/schemas/TraceData"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct TraceDataResponse {
		#[serde(
			rename = "sharedTraceDataId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub shared_trace_data_id: Option<SharedDataId>,
		#[serde(rename = "traceData", default, skip_serializing_if = "Option::is_none")]
		pub trace_data: Option<TraceData>,
	}

	impl From<&TraceDataResponse> for TraceDataResponse {
		fn from(value: &TraceDataResponse) -> Self {
			value.clone()
		}
	}

	/// The enumeration TraceDepth defines how detailed information should be
	/// recorded in the trace. See 3GPP TS 32.422 for further description of the
	/// values. It shall comply with the provisions defined in table 5.6.3.1-1
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The enumeration TraceDepth defines how detailed
	/// information should be recorded in the trace. See 3GPP TS 32.422 for
	/// further description of the values. It shall comply with the provisions
	/// defined in table 5.6.3.1-1\n",
	///  "type": "string",
	///  "enum": [
	///    "MINIMUM",
	///    "MEDIUM",
	///    "MAXIMUM",
	///    "MINIMUM_WO_VENDOR_EXTENSION",
	///    "MEDIUM_WO_VENDOR_EXTENSION",
	///    "MAXIMUM_WO_VENDOR_EXTENSION"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum TraceDepth {
		#[default]
		#[serde(rename = "MINIMUM")]
		Minimum,
		#[serde(rename = "MEDIUM")]
		Medium,
		#[serde(rename = "MAXIMUM")]
		Maximum,
		#[serde(rename = "MINIMUM_WO_VENDOR_EXTENSION")]
		MinimumWoVendorExtension,
		#[serde(rename = "MEDIUM_WO_VENDOR_EXTENSION")]
		MediumWoVendorExtension,
		#[serde(rename = "MAXIMUM_WO_VENDOR_EXTENSION")]
		MaximumWoVendorExtension,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&TraceDepth> for TraceDepth {
		fn from(value: &TraceDepth) -> Self {
			value.clone()
		}
	}

	impl ToString for TraceDepth {
		fn to_string(&self) -> String {
			match *self {
				Self::Minimum => "MINIMUM".to_string(),
				Self::Medium => "MEDIUM".to_string(),
				Self::Maximum => "MAXIMUM".to_string(),
				Self::MinimumWoVendorExtension => "MINIMUM_WO_VENDOR_EXTENSION".to_string(),
				Self::MediumWoVendorExtension => "MEDIUM_WO_VENDOR_EXTENSION".to_string(),
				Self::MaximumWoVendorExtension => "MAXIMUM_WO_VENDOR_EXTENSION".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for TraceDepth {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"MINIMUM" => Ok(Self::Minimum),
				"MEDIUM" => Ok(Self::Medium),
				"MAXIMUM" => Ok(Self::Maximum),
				"MINIMUM_WO_VENDOR_EXTENSION" => Ok(Self::MinimumWoVendorExtension),
				"MEDIUM_WO_VENDOR_EXTENSION" => Ok(Self::MediumWoVendorExtension),
				"MAXIMUM_WO_VENDOR_EXTENSION" => Ok(Self::MaximumWoVendorExtension),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for TraceDepth {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for TraceDepth {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for TraceDepth {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Possible values are:
	/// - SINGLE_TRANS_UL: Uplink single packet transmission.
	/// - SINGLE_TRANS_DL: Downlink single packet transmission.
	/// - DUAL_TRANS_UL_FIRST: Dual packet transmission, firstly uplink packet
	///   transmission
	///  with subsequent downlink packet transmission.
	/// - DUAL_TRANS_DL_FIRST: Dual packet transmission, firstly downlink packet
	///   transmission
	///  with subsequent uplink packet transmission.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Possible values are:\n- SINGLE_TRANS_UL: Uplink single
	/// packet transmission.\n- SINGLE_TRANS_DL: Downlink single packet
	/// transmission.\n- DUAL_TRANS_UL_FIRST: Dual packet transmission, firstly
	/// uplink packet transmission\n  with subsequent downlink packet
	/// transmission.\n- DUAL_TRANS_DL_FIRST: Dual packet transmission, firstly
	/// downlink packet transmission\n  with subsequent uplink packet
	/// transmission. \n",
	///  "type": "string",
	///  "enum": [
	///    "SINGLE_TRANS_UL",
	///    "SINGLE_TRANS_DL",
	///    "DUAL_TRANS_UL_FIRST",
	///    "DUAL_TRANS_DL_FIRST",
	///    "MULTI_TRANS"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum TrafficProfile {
		#[default]
		#[serde(rename = "SINGLE_TRANS_UL")]
		SingleTransUl,
		#[serde(rename = "SINGLE_TRANS_DL")]
		SingleTransDl,
		#[serde(rename = "DUAL_TRANS_UL_FIRST")]
		DualTransUlFirst,
		#[serde(rename = "DUAL_TRANS_DL_FIRST")]
		DualTransDlFirst,
		#[serde(rename = "MULTI_TRANS")]
		MultiTrans,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&TrafficProfile> for TrafficProfile {
		fn from(value: &TrafficProfile) -> Self {
			value.clone()
		}
	}

	impl ToString for TrafficProfile {
		fn to_string(&self) -> String {
			match *self {
				Self::SingleTransUl => "SINGLE_TRANS_UL".to_string(),
				Self::SingleTransDl => "SINGLE_TRANS_DL".to_string(),
				Self::DualTransUlFirst => "DUAL_TRANS_UL_FIRST".to_string(),
				Self::DualTransDlFirst => "DUAL_TRANS_DL_FIRST".to_string(),
				Self::MultiTrans => "MULTI_TRANS".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for TrafficProfile {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"SINGLE_TRANS_UL" => Ok(Self::SingleTransUl),
				"SINGLE_TRANS_DL" => Ok(Self::SingleTransDl),
				"DUAL_TRANS_UL_FIRST" => Ok(Self::DualTransUlFirst),
				"DUAL_TRANS_DL_FIRST" => Ok(Self::DualTransDlFirst),
				"MULTI_TRANS" => Ok(Self::MultiTrans),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for TrafficProfile {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for TrafficProfile {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for TrafficProfile {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// This enumeration is defined in the same way as the 'TrafficProfile'
	/// enumeration, but with the OpenAPI 'nullable: true' property.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This enumeration is defined in the same way as the
	/// 'TrafficProfile' enumeration, but with the OpenAPI 'nullable: true'
	/// property. \n",
	///  "anyOf": [
	///    {
	///      "$ref": "#/components/schemas/TrafficProfile"
	///    },
	///    {
	///      "$ref": "#/components/schemas/NullValue"
	///    }
	///  ]
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum TrafficProfileRm {
		#[default]
		TrafficProfile(TrafficProfile),
		NullValue(NullValue),
	}

	impl From<&TrafficProfileRm> for TrafficProfileRm {
		fn from(value: &TrafficProfileRm) -> Self {
			value.clone()
		}
	}

	impl From<TrafficProfile> for TrafficProfileRm {
		fn from(value: TrafficProfile) -> Self {
			Self::TrafficProfile(value)
		}
	}

	impl From<NullValue> for TrafficProfileRm {
		fn from(value: NullValue) -> Self {
			Self::NullValue(value)
		}
	}

	/// Possible values are:
	/// - UDP: User Datagram Protocol.
	/// - TCP: Transmission Control Protocol.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Possible values are:\n- UDP: User Datagram Protocol.\n-
	/// TCP: Transmission Control Protocol. \n",
	///  "type": "string",
	///  "enum": [
	///    "UDP",
	///    "TCP"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum TransportProtocol {
		#[default]
		#[serde(rename = "UDP")]
		Udp,
		#[serde(rename = "TCP")]
		Tcp,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&TransportProtocol> for TransportProtocol {
		fn from(value: &TransportProtocol) -> Self {
			value.clone()
		}
	}

	impl ToString for TransportProtocol {
		fn to_string(&self) -> String {
			match *self {
				Self::Udp => "UDP".to_string(),
				Self::Tcp => "TCP".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for TransportProtocol {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"UDP" => Ok(Self::Udp),
				"TCP" => Ok(Self::Tcp),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for TransportProtocol {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for TransportProtocol {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for TransportProtocol {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// TriggerRequest
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "supi"
	///  ],
	///  "properties": {
	///    "failedPcscf": {
	///      "$ref": "#/components/schemas/PcscfAddress"
	///    },
	///    "supi": {
	///      "$ref": "#/components/schemas/Supi"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct TriggerRequest {
		#[serde(
			rename = "failedPcscf",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub failed_pcscf: Option<PcscfAddress>,
		pub supi: Supi,
	}

	impl From<&TriggerRequest> for TriggerRequest {
		fn from(value: &TriggerRequest) -> Self {
			value.clone()
		}
	}

	/// Contain the TWAP Identifier as defined in clause 4.2.8.5.3 of 3GPP TS
	/// 23.501 or the WLAN location information as defined in clause 4.5.7.2.8
	/// of 3GPP TS 23.402.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contain the TWAP Identifier as defined in clause
	/// 4.2.8.5.3 of 3GPP TS 23.501 or the WLAN location information as defined
	/// in clause 4.5.7.2.8 of 3GPP TS 23.402.\n",
	///  "type": "object",
	///  "required": [
	///    "ssId"
	///  ],
	///  "properties": {
	///    "bssId": {
	///      "description": "When present, it shall contain the BSSID of the
	/// access point to which the UE is attached, for trusted WLAN access, see
	/// IEEE Std 802.11-2012. \n",
	///      "type": "string"
	///    },
	///    "civicAddress": {
	///      "$ref": "#/components/schemas/Bytes"
	///    },
	///    "ssId": {
	///      "description": "This IE shall contain the SSID of the access point
	/// to which the UE is attached, that is received over NGAP, see IEEE Std
	/// 802.11-2012. \n",
	///      "type": "string"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct TwapId {
		/// When present, it shall contain the BSSID of the access point to
		/// which the UE is attached, for trusted WLAN access, see IEEE Std
		/// 802.11-2012.
		#[serde(rename = "bssId", default, skip_serializing_if = "Option::is_none")]
		pub bss_id: Option<String>,
		#[serde(
			rename = "civicAddress",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub civic_address: Option<Bytes>,
		/// This IE shall contain the SSID of the access point to which the UE
		/// is attached, that is received over NGAP, see IEEE Std 802.11-2012.
		#[serde(rename = "ssId")]
		pub ss_id: String,
	}

	impl From<&TwapId> for TwapId {
		fn from(value: &TwapId) -> Self {
			value.clone()
		}
	}

	/// Indicates the purpose of the user consent.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates the purpose of the user consent.",
	///  "type": "string",
	///  "enum": [
	///    "ANALYTICS",
	///    "MODEL_TRAINING",
	///    "NW_CAP_EXPOSURE",
	///    "EDGEAPP_UE_LOCATION"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum UcPurpose {
		#[default]
		#[serde(rename = "ANALYTICS")]
		Analytics,
		#[serde(rename = "MODEL_TRAINING")]
		ModelTraining,
		#[serde(rename = "NW_CAP_EXPOSURE")]
		NwCapExposure,
		#[serde(rename = "EDGEAPP_UE_LOCATION")]
		EdgeappUeLocation,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&UcPurpose> for UcPurpose {
		fn from(value: &UcPurpose) -> Self {
			value.clone()
		}
	}

	impl ToString for UcPurpose {
		fn to_string(&self) -> String {
			match *self {
				Self::Analytics => "ANALYTICS".to_string(),
				Self::ModelTraining => "MODEL_TRAINING".to_string(),
				Self::NwCapExposure => "NW_CAP_EXPOSURE".to_string(),
				Self::EdgeappUeLocation => "EDGEAPP_UE_LOCATION".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for UcPurpose {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"ANALYTICS" => Ok(Self::Analytics),
				"MODEL_TRAINING" => Ok(Self::ModelTraining),
				"NW_CAP_EXPOSURE" => Ok(Self::NwCapExposure),
				"EDGEAPP_UE_LOCATION" => Ok(Self::EdgeappUeLocation),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for UcPurpose {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for UcPurpose {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for UcPurpose {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Contains the User Consent Subscription Data.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the User Consent Subscription Data.",
	///  "type": "object",
	///  "properties": {
	///    "userConsentPerPurposeList": {
	///      "description": "A map(list of key-value pairs) where user consent
	/// purpose serves as key of user consent",
	///      "type": "object",
	///      "minProperties": 1,
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/UserConsent"
	///      }
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UcSubscriptionData {
		/// A map(list of key-value pairs) where user consent purpose serves as
		/// key of user consent
		#[serde(
			rename = "userConsentPerPurposeList",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub user_consent_per_purpose_list: ::std::collections::HashMap<String, UserConsent>,
	}

	impl From<&UcSubscriptionData> for UcSubscriptionData {
		fn from(value: &UcSubscriptionData) -> Self {
			value.clone()
		}
	}

	/// Possible values are:
	/// - AUTHORIZED: Indicates that the UE is authorized.
	/// - NOT_AUTHORIZED: Indicates that the UE is not authorized.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Possible values are:\n- AUTHORIZED: Indicates that the
	/// UE is authorized.\n- NOT_AUTHORIZED: Indicates that the UE is not
	/// authorized.\n",
	///  "type": "string",
	///  "enum": [
	///    "AUTHORIZED",
	///    "NOT_AUTHORIZED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum UeAuth {
		#[default]
		#[serde(rename = "AUTHORIZED")]
		Authorized,
		#[serde(rename = "NOT_AUTHORIZED")]
		NotAuthorized,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&UeAuth> for UeAuth {
		fn from(value: &UeAuth) -> Self {
			value.clone()
		}
	}

	impl ToString for UeAuth {
		fn to_string(&self) -> String {
			match *self {
				Self::Authorized => "AUTHORIZED".to_string(),
				Self::NotAuthorized => "NOT_AUTHORIZED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for UeAuth {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"AUTHORIZED" => Ok(Self::Authorized),
				"NOT_AUTHORIZED" => Ok(Self::NotAuthorized),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for UeAuth {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for UeAuth {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for UeAuth {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// UeContextInAmfData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "amfInfo": {
	///      "description": "AMF information",
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/AmfInfo"
	///      },
	///      "maxItems": 2,
	///      "minItems": 1
	///    },
	///    "epsInterworkingInfo": {
	///      "$ref": "#/components/schemas/schemas-EpsInterworkingInfo"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UeContextInAmfData {
		/// AMF information
		#[serde(rename = "amfInfo", default, skip_serializing_if = "Vec::is_empty")]
		pub amf_info: Vec<AmfInfo>,
		#[serde(
			rename = "epsInterworkingInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub eps_interworking_info: Option<SchemasEpsInterworkingInfo>,
	}

	impl From<&UeContextInAmfData> for UeContextInAmfData {
		fn from(value: &UeContextInAmfData) -> Self {
			value.clone()
		}
	}

	/// UeContextInSmfData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "emergencyInfo": {
	///      "$ref": "#/components/schemas/EmergencyInfo"
	///    },
	///    "pduSessions": {
	///      "description": "A map (list of key-value pairs where PduSessionId
	/// serves as key) of PduSessions",
	///      "type": "object",
	///      "additionalProperties": {
	///        "$ref": "#/components/schemas/PduSession"
	///      }
	///    },
	///    "pgwInfo": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/PgwInfo"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UeContextInSmfData {
		#[serde(
			rename = "emergencyInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub emergency_info: Option<EmergencyInfo>,
		/// A map (list of key-value pairs where PduSessionId serves as key) of
		/// PduSessions
		#[serde(
			rename = "pduSessions",
			default,
			skip_serializing_if = "::std::collections::HashMap::is_empty"
		)]
		pub pdu_sessions: ::std::collections::HashMap<String, PduSession>,
		#[serde(rename = "pgwInfo", default, skip_serializing_if = "Vec::is_empty")]
		pub pgw_info: Vec<PgwInfo>,
	}

	impl From<&UeContextInSmfData> for UeContextInSmfData {
		fn from(value: &UeContextInSmfData) -> Self {
			value.clone()
		}
	}

	/// UE Context In Smf Data Subscription Filter.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "UE Context In Smf Data Subscription Filter.",
	///  "type": "object",
	///  "properties": {
	///    "dnnList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Dnn"
	///      },
	///      "minItems": 1
	///    },
	///    "emergencyInd": {
	///      "default": false,
	///      "type": "boolean"
	///    },
	///    "snssaiList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Snssai"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UeContextInSmfDataSubFilter {
		#[serde(rename = "dnnList", default, skip_serializing_if = "Vec::is_empty")]
		pub dnn_list: Vec<Dnn>,
		#[serde(rename = "emergencyInd", default)]
		pub emergency_ind: bool,
		#[serde(rename = "snssaiList", default, skip_serializing_if = "Vec::is_empty")]
		pub snssai_list: Vec<Snssai>,
	}

	impl From<&UeContextInSmfDataSubFilter> for UeContextInSmfDataSubFilter {
		fn from(value: &UeContextInSmfDataSubFilter) -> Self {
			value.clone()
		}
	}

	/// UeContextInSmsfData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "smsfInfo3GppAccess": {
	///      "$ref": "#/components/schemas/SmsfInfo"
	///    },
	///    "smsfInfoNon3GppAccess": {
	///      "$ref": "#/components/schemas/SmsfInfo"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UeContextInSmsfData {
		#[serde(
			rename = "smsfInfo3GppAccess",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub smsf_info3_gpp_access: Option<SmsfInfo>,
		#[serde(
			rename = "smsfInfoNon3GppAccess",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub smsf_info_non3_gpp_access: Option<SmsfInfo>,
	}

	impl From<&UeContextInSmsfData> for UeContextInSmsfData {
		fn from(value: &UeContextInSmsfData) -> Self {
			value.clone()
		}
	}

	/// UE Context Information
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "UE Context Information",
	///  "type": "object",
	///  "properties": {
	///    "accessType": {
	///      "$ref": "#/components/schemas/AccessType"
	///    },
	///    "lastActTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "ratType": {
	///      "$ref": "#/components/schemas/RatType"
	///    },
	///    "supportVoPS": {
	///      "type": "boolean"
	///    },
	///    "supportVoPSn3gpp": {
	///      "type": "boolean"
	///    },
	///    "supportedFeatures": {
	///      "$ref": "#/components/schemas/SupportedFeatures"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UeContextInfo {
		#[serde(
			rename = "accessType",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub access_type: Option<AccessType>,
		#[serde(
			rename = "lastActTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub last_act_time: Option<DateTime>,
		#[serde(rename = "ratType", default, skip_serializing_if = "Option::is_none")]
		pub rat_type: Option<RatType>,
		#[serde(
			rename = "supportVoPSn3gpp",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub support_vo_p_sn3gpp: Option<bool>,
		#[serde(
			rename = "supportVoPS",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub support_vo_ps: Option<bool>,
		#[serde(
			rename = "supportedFeatures",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub supported_features: Option<SupportedFeatures>,
	}

	impl From<&UeContextInfo> for UeContextInfo {
		fn from(value: &UeContextInfo) -> Self {
			value.clone()
		}
	}

	/// UeId
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "supi"
	///  ],
	///  "properties": {
	///    "gpsiList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Gpsi"
	///      },
	///      "minItems": 1
	///    },
	///    "supi": {
	///      "$ref": "#/components/schemas/Supi"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UeId {
		#[serde(rename = "gpsiList", default, skip_serializing_if = "Vec::is_empty")]
		pub gpsi_list: Vec<Gpsi>,
		pub supi: Supi,
	}

	impl From<&UeId> for UeId {
		fn from(value: &UeId) -> Self {
			value.clone()
		}
	}

	/// A map(list of key-value pairs) where Gpsi serves as key of arrays of
	/// Supi
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "A map(list of key-value pairs) where Gpsi serves as key
	/// of arrays of Supi",
	///  "type": "object",
	///  "minProperties": 1,
	///  "additionalProperties": {
	///    "$ref": "#/components/schemas/SupiInfo"
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UeIdentifiers(pub ::std::collections::HashMap<String, SupiInfo>);
	impl ::std::ops::Deref for UeIdentifiers {
		type Target = ::std::collections::HashMap<String, SupiInfo>;
		fn deref(&self) -> &::std::collections::HashMap<String, SupiInfo> {
			&self.0
		}
	}

	impl From<UeIdentifiers> for ::std::collections::HashMap<String, SupiInfo> {
		fn from(value: UeIdentifiers) -> Self {
			value.0
		}
	}

	impl From<&UeIdentifiers> for UeIdentifiers {
		fn from(value: &UeIdentifiers) -> Self {
			value.clone()
		}
	}

	impl From<::std::collections::HashMap<String, SupiInfo>> for UeIdentifiers {
		fn from(value: ::std::collections::HashMap<String, SupiInfo>) -> Self {
			Self(value)
		}
	}

	/// Represents UE information.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents UE information.",
	///  "type": "object",
	///  "properties": {
	///    "5gSrvccInfo": {
	///      "$ref": "#/components/schemas/5GSrvccInfo"
	///    },
	///    "tadsInfo": {
	///      "$ref": "#/components/schemas/UeContextInfo"
	///    },
	///    "userState": {
	///      "$ref": "#/components/schemas/5GsUserState"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UeInfo {
		#[serde(
			rename = "5gSrvccInfo",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub five_g_srvcc_info: Option<_5gSrvccInfo>,
		#[serde(rename = "tadsInfo", default, skip_serializing_if = "Option::is_none")]
		pub tads_info: Option<UeContextInfo>,
		#[serde(rename = "userState", default, skip_serializing_if = "Option::is_none")]
		pub user_state: Option<_5gsUserState>,
	}

	impl From<&UeInfo> for UeInfo {
		fn from(value: &UeInfo) -> Self {
			value.clone()
		}
	}

	/// Describes the reachability of the UE
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Describes the reachability of the UE",
	///  "type": "string",
	///  "enum": [
	///    "UNREACHABLE",
	///    "REACHABLE",
	///    "REGULATORY_ONLY"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum UeReachability {
		#[default]
		#[serde(rename = "UNREACHABLE")]
		Unreachable,
		#[serde(rename = "REACHABLE")]
		Reachable,
		#[serde(rename = "REGULATORY_ONLY")]
		RegulatoryOnly,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&UeReachability> for UeReachability {
		fn from(value: &UeReachability) -> Self {
			value.clone()
		}
	}

	impl ToString for UeReachability {
		fn to_string(&self) -> String {
			match *self {
				Self::Unreachable => "UNREACHABLE".to_string(),
				Self::Reachable => "REACHABLE".to_string(),
				Self::RegulatoryOnly => "REGULATORY_ONLY".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for UeReachability {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"UNREACHABLE" => Ok(Self::Unreachable),
				"REACHABLE" => Ok(Self::Reachable),
				"REGULATORY_ONLY" => Ok(Self::RegulatoryOnly),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for UeReachability {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for UeReachability {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for UeReachability {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// UE Reachable Indication
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "UE Reachable Indication",
	///  "type": "string",
	///  "enum": [
	///    "REACHABLE",
	///    "NOT_REACHABLE",
	///    "UNKNOWN"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum UeReachableInd {
		#[default]
		#[serde(rename = "REACHABLE")]
		Reachable,
		#[serde(rename = "NOT_REACHABLE")]
		NotReachable,
		#[serde(rename = "UNKNOWN")]
		Unknown,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&UeReachableInd> for UeReachableInd {
		fn from(value: &UeReachableInd) -> Self {
			value.clone()
		}
	}

	impl ToString for UeReachableInd {
		fn to_string(&self) -> String {
			match *self {
				Self::Reachable => "REACHABLE".to_string(),
				Self::NotReachable => "NOT_REACHABLE".to_string(),
				Self::Unknown => "UNKNOWN".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for UeReachableInd {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"REACHABLE" => Ok(Self::Reachable),
				"NOT_REACHABLE" => Ok(Self::NotReachable),
				"UNKNOWN" => Ok(Self::Unknown),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for UeReachableInd {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for UeReachableInd {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for UeReachableInd {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// UeUsageType
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "integer"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UeUsageType(pub i64);
	impl ::std::ops::Deref for UeUsageType {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<UeUsageType> for i64 {
		fn from(value: UeUsageType) -> Self {
			value.0
		}
	}

	impl From<&UeUsageType> for UeUsageType {
		fn from(value: &UeUsageType) -> Self {
			value.clone()
		}
	}

	impl From<i64> for UeUsageType {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for UeUsageType {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for UeUsageType {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for UeUsageType {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for UeUsageType {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for UeUsageType {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Integer where the allowed values correspond to the value range of an
	/// unsigned 16-bit integer.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Integer where the allowed values correspond to the
	/// value range of an unsigned 16-bit integer.",
	///  "type": "integer",
	///  "maximum": 65535.0,
	///  "minimum": 0.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Uint16(pub u16);
	impl ::std::ops::Deref for Uint16 {
		type Target = u16;
		fn deref(&self) -> &u16 {
			&self.0
		}
	}

	impl From<Uint16> for u16 {
		fn from(value: Uint16) -> Self {
			value.0
		}
	}

	impl From<&Uint16> for Uint16 {
		fn from(value: &Uint16) -> Self {
			value.clone()
		}
	}

	impl From<u16> for Uint16 {
		fn from(value: u16) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for Uint16 {
		type Err = <u16 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for Uint16 {
		type Error = <u16 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for Uint16 {
		type Error = <u16 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for Uint16 {
		type Error = <u16 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for Uint16 {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Unsigned Integer, i.e. only value 0 and integers above 0 are
	/// permissible.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Unsigned Integer, i.e. only value 0 and integers above
	/// 0 are permissible.",
	///  "type": "integer",
	///  "minimum": 0.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Uinteger(pub u64);
	impl ::std::ops::Deref for Uinteger {
		type Target = u64;
		fn deref(&self) -> &u64 {
			&self.0
		}
	}

	impl From<Uinteger> for u64 {
		fn from(value: Uinteger) -> Self {
			value.0
		}
	}

	impl From<&Uinteger> for Uinteger {
		fn from(value: &Uinteger) -> Self {
			value.clone()
		}
	}

	impl From<u64> for Uinteger {
		fn from(value: u64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for Uinteger {
		type Err = <u64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for Uinteger {
		type Error = <u64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for Uinteger {
		type Error = <u64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for Uinteger {
		type Error = <u64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for Uinteger {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// UmtTime
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "dayOfWeek",
	///    "timeOfDay"
	///  ],
	///  "properties": {
	///    "dayOfWeek": {
	///      "$ref": "#/components/schemas/DayOfWeek"
	///    },
	///    "timeOfDay": {
	///      "$ref": "#/components/schemas/TimeOfDay"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UmtTime {
		#[serde(rename = "dayOfWeek")]
		pub day_of_week: DayOfWeek,
		#[serde(rename = "timeOfDay")]
		pub time_of_day: TimeOfDay,
	}

	impl From<&UmtTime> for UmtTime {
		fn from(value: &UmtTime) -> Self {
			value.clone()
		}
	}

	/// Uncertainty
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Indicates value of uncertainty.",
	///  "type": "number",
	///  "format": "float",
	///  "minimum": 0.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Uncertainty(pub f32);
	impl ::std::ops::Deref for Uncertainty {
		type Target = f32;
		fn deref(&self) -> &f32 {
			&self.0
		}
	}

	impl From<Uncertainty> for f32 {
		fn from(value: Uncertainty) -> Self {
			value.0
		}
	}

	impl From<&Uncertainty> for Uncertainty {
		fn from(value: &Uncertainty) -> Self {
			value.clone()
		}
	}

	impl From<f32> for Uncertainty {
		fn from(value: f32) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for Uncertainty {
		type Err = <f32 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for Uncertainty {
		type Error = <f32 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for Uncertainty {
		type Error = <f32 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for Uncertainty {
		type Error = <f32 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for Uncertainty {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Ellipse with uncertainty.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Ellipse with uncertainty.",
	///  "type": "object",
	///  "required": [
	///    "orientationMajor",
	///    "semiMajor",
	///    "semiMinor"
	///  ],
	///  "properties": {
	///    "orientationMajor": {
	///      "$ref": "#/components/schemas/Orientation"
	///    },
	///    "semiMajor": {
	///      "$ref": "#/components/schemas/Uncertainty"
	///    },
	///    "semiMinor": {
	///      "$ref": "#/components/schemas/Uncertainty"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UncertaintyEllipse {
		#[serde(rename = "orientationMajor")]
		pub orientation_major: Orientation,
		#[serde(rename = "semiMajor")]
		pub semi_major: Uncertainty,
		#[serde(rename = "semiMinor")]
		pub semi_minor: Uncertainty,
	}

	impl From<&UncertaintyEllipse> for UncertaintyEllipse {
		fn from(value: &UncertaintyEllipse) -> Self {
			value.clone()
		}
	}

	/// Ellipsoid with uncertainty
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Ellipsoid with uncertainty",
	///  "type": "object",
	///  "required": [
	///    "orientationMajor",
	///    "semiMajor",
	///    "semiMinor",
	///    "vertical"
	///  ],
	///  "properties": {
	///    "orientationMajor": {
	///      "$ref": "#/components/schemas/Orientation"
	///    },
	///    "semiMajor": {
	///      "$ref": "#/components/schemas/Uncertainty"
	///    },
	///    "semiMinor": {
	///      "$ref": "#/components/schemas/Uncertainty"
	///    },
	///    "vertical": {
	///      "$ref": "#/components/schemas/Uncertainty"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UncertaintyEllipsoid {
		#[serde(rename = "orientationMajor")]
		pub orientation_major: Orientation,
		#[serde(rename = "semiMajor")]
		pub semi_major: Uncertainty,
		#[serde(rename = "semiMinor")]
		pub semi_minor: Uncertainty,
		pub vertical: Uncertainty,
	}

	impl From<&UncertaintyEllipsoid> for UncertaintyEllipsoid {
		fn from(value: &UncertaintyEllipsoid) -> Self {
			value.clone()
		}
	}

	/// UnrelatedClass
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "defaultUnrelatedClass"
	///  ],
	///  "properties": {
	///    "defaultUnrelatedClass": {
	///      "$ref": "#/components/schemas/DefaultUnrelatedClass"
	///    },
	///    "externalUnrelatedClass": {
	///      "$ref": "#/components/schemas/ExternalUnrelatedClass"
	///    },
	///    "serviceTypeUnrelatedClasses": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/ServiceTypeUnrelatedClass"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UnrelatedClass {
		#[serde(rename = "defaultUnrelatedClass")]
		pub default_unrelated_class: DefaultUnrelatedClass,
		#[serde(
			rename = "externalUnrelatedClass",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub external_unrelated_class: Option<ExternalUnrelatedClass>,
		#[serde(
			rename = "serviceTypeUnrelatedClasses",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub service_type_unrelated_classes: Vec<ServiceTypeUnrelatedClass>,
	}

	impl From<&UnrelatedClass> for UnrelatedClass {
		fn from(value: &UnrelatedClass) -> Self {
			value.clone()
		}
	}

	/// indicates whether UP confidentiality protection is required, preferred
	/// or not needed for all the traffic on the PDU Session. It shall comply
	/// with the provisions defined in table 5.4.3.5-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "indicates whether UP confidentiality protection is
	/// required, preferred or not needed for all the traffic on the PDU
	/// Session. It shall comply with the provisions defined in table
	/// 5.4.3.5-1.\n",
	///  "type": "string",
	///  "enum": [
	///    "REQUIRED",
	///    "PREFERRED",
	///    "NOT_NEEDED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum UpConfidentiality {
		#[default]
		#[serde(rename = "REQUIRED")]
		Required,
		#[serde(rename = "PREFERRED")]
		Preferred,
		#[serde(rename = "NOT_NEEDED")]
		NotNeeded,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&UpConfidentiality> for UpConfidentiality {
		fn from(value: &UpConfidentiality) -> Self {
			value.clone()
		}
	}

	impl ToString for UpConfidentiality {
		fn to_string(&self) -> String {
			match *self {
				Self::Required => "REQUIRED".to_string(),
				Self::Preferred => "PREFERRED".to_string(),
				Self::NotNeeded => "NOT_NEEDED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for UpConfidentiality {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"REQUIRED" => Ok(Self::Required),
				"PREFERRED" => Ok(Self::Preferred),
				"NOT_NEEDED" => Ok(Self::NotNeeded),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for UpConfidentiality {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for UpConfidentiality {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for UpConfidentiality {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// indicates whether UP integrity protection is required, preferred or not
	/// needed for all the traffic on the PDU Session. It shall comply with the
	/// provisions defined in  table 5.4.3.4-1.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "indicates whether UP integrity protection is required,
	/// preferred or not needed for all the traffic on the PDU Session. It shall
	/// comply with the provisions defined in  table 5.4.3.4-1. \n",
	///  "type": "string",
	///  "enum": [
	///    "REQUIRED",
	///    "PREFERRED",
	///    "NOT_NEEDED"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum UpIntegrity {
		#[default]
		#[serde(rename = "REQUIRED")]
		Required,
		#[serde(rename = "PREFERRED")]
		Preferred,
		#[serde(rename = "NOT_NEEDED")]
		NotNeeded,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&UpIntegrity> for UpIntegrity {
		fn from(value: &UpIntegrity) -> Self {
			value.clone()
		}
	}

	impl ToString for UpIntegrity {
		fn to_string(&self) -> String {
			match *self {
				Self::Required => "REQUIRED".to_string(),
				Self::Preferred => "PREFERRED".to_string(),
				Self::NotNeeded => "NOT_NEEDED".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for UpIntegrity {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"REQUIRED" => Ok(Self::Required),
				"PREFERRED" => Ok(Self::Preferred),
				"NOT_NEEDED" => Ok(Self::NotNeeded),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for UpIntegrity {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for UpIntegrity {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for UpIntegrity {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Contains Userplain security information.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains Userplain security information.",
	///  "type": "object",
	///  "required": [
	///    "upConfid",
	///    "upIntegr"
	///  ],
	///  "properties": {
	///    "upConfid": {
	///      "$ref": "#/components/schemas/UpConfidentiality"
	///    },
	///    "upIntegr": {
	///      "$ref": "#/components/schemas/UpIntegrity"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UpSecurity {
		#[serde(rename = "upConfid")]
		pub up_confid: UpConfidentiality,
		#[serde(rename = "upIntegr")]
		pub up_integr: UpIntegrity,
	}

	impl From<&UpSecurity> for UpSecurity {
		fn from(value: &UpSecurity) -> Self {
			value.clone()
		}
	}

	/// Contains the indication of whether the acknowledgement from UE is
	/// needed.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains the indication of whether the acknowledgement
	/// from UE is needed.",
	///  "type": "boolean"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UpuAckInd(pub bool);
	impl ::std::ops::Deref for UpuAckInd {
		type Target = bool;
		fn deref(&self) -> &bool {
			&self.0
		}
	}

	impl From<UpuAckInd> for bool {
		fn from(value: UpuAckInd) -> Self {
			value.0
		}
	}

	impl From<&UpuAckInd> for UpuAckInd {
		fn from(value: &UpuAckInd) -> Self {
			value.clone()
		}
	}

	impl From<bool> for UpuAckInd {
		fn from(value: bool) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for UpuAckInd {
		type Err = <bool as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for UpuAckInd {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for UpuAckInd {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for UpuAckInd {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for UpuAckInd {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Contains UE parameters update data set (e.g., the updated Routing ID
	/// Data or the smart_default::SmartDefault configured NSSAI or the disaster roaming
	/// parameters).
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains UE parameters update data set (e.g., the
	/// updated Routing ID Data or the smart_default::SmartDefault configured NSSAI or the disaster
	/// roaming parameters).",
	///  "type": "object",
	///  "properties": {
	///    "aol": {
	///      "type": "boolean"
	///    },
	///    "defaultConfNssai": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Snssai"
	///      },
	///      "minItems": 1
	///    },
	///    "drei": {
	///      "type": "boolean"
	///    },
	///    "routingId": {
	///      "$ref": "#/components/schemas/RoutingId"
	///    },
	///    "secPacket": {
	///      "$ref": "#/components/schemas/schemas-SecuredPacket"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UpuData {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub aol: Option<bool>,
		#[serde(
			rename = "defaultConfNssai",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub default_conf_nssai: Vec<Snssai>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub drei: Option<bool>,
		#[serde(rename = "routingId", default, skip_serializing_if = "Option::is_none")]
		pub routing_id: Option<RoutingId>,
		#[serde(rename = "secPacket", default, skip_serializing_if = "Option::is_none")]
		pub sec_packet: Option<SchemasSecuredPacket>,
	}

	impl From<&UpuData> for UpuData {
		fn from(value: &UpuData) -> Self {
			value.clone()
		}
	}

	/// UpuInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "provisioningTime"
	///  ],
	///  "properties": {
	///    "counterUpu": {
	///      "$ref": "#/components/schemas/CounterUpu"
	///    },
	///    "provisioningTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "upuAckInd": {
	///      "$ref": "#/components/schemas/UpuAckInd"
	///    },
	///    "upuDataList": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/UpuData"
	///      },
	///      "minItems": 1
	///    },
	///    "upuMacIausf": {
	///      "$ref": "#/components/schemas/UpuMac"
	///    },
	///    "upuRegInd": {
	///      "$ref": "#/components/schemas/UpuRegInd"
	///    },
	///    "upuTransparentContainer": {
	///      "$ref": "#/components/schemas/Bytes"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UpuInfo {
		#[serde(
			rename = "counterUpu",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub counter_upu: Option<CounterUpu>,
		#[serde(rename = "provisioningTime")]
		pub provisioning_time: DateTime,
		#[serde(rename = "upuAckInd", default, skip_serializing_if = "Option::is_none")]
		pub upu_ack_ind: Option<UpuAckInd>,
		#[serde(rename = "upuDataList", default, skip_serializing_if = "Vec::is_empty")]
		pub upu_data_list: Vec<UpuData>,
		#[serde(
			rename = "upuMacIausf",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub upu_mac_iausf: Option<UpuMac>,
		#[serde(rename = "upuRegInd", default, skip_serializing_if = "Option::is_none")]
		pub upu_reg_ind: Option<UpuRegInd>,
		#[serde(
			rename = "upuTransparentContainer",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub upu_transparent_container: Option<Bytes>,
	}

	impl From<&UpuInfo> for UpuInfo {
		fn from(value: &UpuInfo) -> Self {
			value.clone()
		}
	}

	/// MAC value for protecting UPU procedure (UPU-MAC-IAUSF and UPU-MAC-IUE).
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "MAC value for protecting UPU procedure (UPU-MAC-IAUSF
	/// and UPU-MAC-IUE).",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{32}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct UpuMac(String);
	impl ::std::ops::Deref for UpuMac {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<UpuMac> for String {
		fn from(value: UpuMac) -> Self {
			value.0
		}
	}

	impl From<&UpuMac> for UpuMac {
		fn from(value: &UpuMac) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for UpuMac {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{32}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{32}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for UpuMac {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for UpuMac {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for UpuMac {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for UpuMac {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// UpuRegInd
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "boolean"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UpuRegInd(pub bool);
	impl ::std::ops::Deref for UpuRegInd {
		type Target = bool;
		fn deref(&self) -> &bool {
			&self.0
		}
	}

	impl From<UpuRegInd> for bool {
		fn from(value: UpuRegInd) -> Self {
			value.0
		}
	}

	impl From<&UpuRegInd> for UpuRegInd {
		fn from(value: &UpuRegInd) -> Self {
			value.clone()
		}
	}

	impl From<bool> for UpuRegInd {
		fn from(value: bool) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for UpuRegInd {
		type Err = <bool as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for UpuRegInd {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for UpuRegInd {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for UpuRegInd {
		type Error = <bool as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for UpuRegInd {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// UpuTransparentContainer
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "$ref": "#/components/schemas/Bytes"
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UpuTransparentContainer(pub Bytes);
	impl ::std::ops::Deref for UpuTransparentContainer {
		type Target = Bytes;
		fn deref(&self) -> &Bytes {
			&self.0
		}
	}

	impl From<UpuTransparentContainer> for Bytes {
		fn from(value: UpuTransparentContainer) -> Self {
			value.0
		}
	}

	impl From<&UpuTransparentContainer> for UpuTransparentContainer {
		fn from(value: &UpuTransparentContainer) -> Self {
			value.clone()
		}
	}

	impl From<Bytes> for UpuTransparentContainer {
		fn from(value: Bytes) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for UpuTransparentContainer {
		type Err = <Bytes as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for UpuTransparentContainer {
		type Error = <Bytes as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for UpuTransparentContainer {
		type Error = <Bytes as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for UpuTransparentContainer {
		type Error = <Bytes as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for UpuTransparentContainer {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// String providing an URI formatted according to RFC 3986.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String providing an URI formatted according to RFC
	/// 3986.",
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct Uri(pub String);
	impl ::std::ops::Deref for Uri {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Uri> for String {
		fn from(value: Uri) -> Self {
			value.0
		}
	}

	impl From<&Uri> for Uri {
		fn from(value: &Uri) -> Self {
			value.clone()
		}
	}

	impl From<String> for Uri {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for Uri {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for Uri {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// UserConsent
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "enum": [
	///    "CONSENT_NOT_GIVEN",
	///    "CONSENT_GIVEN"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub enum UserConsent {
		#[default]
		#[serde(rename = "CONSENT_NOT_GIVEN")]
		ConsentNotGiven,
		#[serde(rename = "CONSENT_GIVEN")]
		ConsentGiven,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&UserConsent> for UserConsent {
		fn from(value: &UserConsent) -> Self {
			value.clone()
		}
	}

	impl ToString for UserConsent {
		fn to_string(&self) -> String {
			match *self {
				Self::ConsentNotGiven => "CONSENT_NOT_GIVEN".to_string(),
				Self::ConsentGiven => "CONSENT_GIVEN".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for UserConsent {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"CONSENT_NOT_GIVEN" => Ok(Self::ConsentNotGiven),
				"CONSENT_GIVEN" => Ok(Self::ConsentGiven),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for UserConsent {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for UserConsent {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for UserConsent {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// Represents the user identifier.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents the user identifier.",
	///  "type": "object",
	///  "required": [
	///    "supi"
	///  ],
	///  "properties": {
	///    "gpsi": {
	///      "$ref": "#/components/schemas/Gpsi"
	///    },
	///    "supi": {
	///      "$ref": "#/components/schemas/Supi"
	///    },
	///    "validityTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UserIdentifier {
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub gpsi: Option<Gpsi>,
		pub supi: Supi,
		#[serde(
			rename = "validityTime",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub validity_time: Option<DateTime>,
	}

	impl From<&UserIdentifier> for UserIdentifier {
		fn from(value: &UserIdentifier) -> Self {
			value.clone()
		}
	}

	/// At least one of eutraLocation, nrLocation and n3gaLocation shall be
	/// present. Several of them may be present.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "At least one of eutraLocation, nrLocation and
	/// n3gaLocation shall be present. Several of them may be present.\n",
	///  "type": "object",
	///  "properties": {
	///    "eutraLocation": {
	///      "$ref": "#/components/schemas/EutraLocation"
	///    },
	///    "geraLocation": {
	///      "$ref": "#/components/schemas/GeraLocation"
	///    },
	///    "n3gaLocation": {
	///      "$ref": "#/components/schemas/N3gaLocation"
	///    },
	///    "nrLocation": {
	///      "$ref": "#/components/schemas/NrLocation"
	///    },
	///    "utraLocation": {
	///      "$ref": "#/components/schemas/UtraLocation"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct UserLocation {
		#[serde(
			rename = "eutraLocation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub eutra_location: Option<EutraLocation>,
		#[serde(
			rename = "geraLocation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub gera_location: Option<GeraLocation>,
		#[serde(
			rename = "n3gaLocation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub n3ga_location: Option<N3gaLocation>,
		#[serde(
			rename = "nrLocation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub nr_location: Option<NrLocation>,
		#[serde(
			rename = "utraLocation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub utra_location: Option<UtraLocation>,
	}

	impl From<&UserLocation> for UserLocation {
		fn from(value: &UserLocation) -> Self {
			value.clone()
		}
	}

	/// Exactly one of cgi, sai or lai shall be present.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Exactly one of cgi, sai or lai shall be present.",
	///  "type": "object",
	///  "oneOf": [
	///    {
	///      "required": [
	///        "cgi"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "sai"
	///      ]
	///    },
	///    {
	///      "required": [
	///        "lai"
	///      ]
	///    }
	///  ],
	///  "properties": {
	///    "ageOfLocationInformation": {
	///      "description": "The value represents the elapsed time in minutes
	/// since the last network contact of the mobile station.  Value \"0\"
	/// indicates that the location information was obtained after a successful
	/// paging procedure for  Active Location Retrieval when the UE is in idle
	/// mode\n or after a successful location reporting procedure  the UE is in
	/// connected mode. Any\nother value than \"0\" indicates that the location
	/// information is the last known one.  See 3GPP TS 29.002 clause
	/// 17.7.8.\n",
	///      "type": "integer",
	///      "maximum": 32767.0,
	///      "minimum": 0.0
	///    },
	///    "cgi": {
	///      "$ref": "#/components/schemas/CellGlobalId"
	///    },
	///    "geodeticInformation": {
	///      "description": "Refers to Calling Geodetic Location. See ITU-T
	/// Recommendation Q.763 (1999) clause 3.88.2. Only the description of an
	/// ellipsoid point with uncertainty circle is allowed to be used.\n",
	///      "type": "string",
	///      "pattern": "^[0-9A-F]{20}$"
	///    },
	///    "geographicalInformation": {
	///      "description": "Refer to geographical Information.See 3GPP TS
	/// 23.032 clause 7.3.2. Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.\n",
	///      "type": "string",
	///      "pattern": "^[0-9A-F]{16}$"
	///    },
	///    "lai": {
	///      "$ref": "#/components/schemas/LocationAreaId"
	///    },
	///    "rai": {
	///      "$ref": "#/components/schemas/RoutingAreaId"
	///    },
	///    "sai": {
	///      "$ref": "#/components/schemas/ServiceAreaId"
	///    },
	///    "ueLocationTimestamp": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	#[serde(untagged)]
	pub enum UtraLocation {
		#[default]
		Variant0 {
			/// The value represents the elapsed time in minutes since the last
			/// network contact of the mobile station.  Value "0" indicates that
			/// the location information was obtained after a successful paging
			/// procedure for  Active Location Retrieval when the UE is in idle
			/// mode or after a successful location reporting
			/// procedure  the UE is in connected mode. Any
			/// other value than "0" indicates that the location information is
			/// the last known one.  See 3GPP TS 29.002 clause 17.7.8.
			#[serde(
				rename = "ageOfLocationInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			age_of_location_information: Option<i64>,
			cgi: CellGlobalId,
			/// Refers to Calling Geodetic Location. See ITU-T Recommendation
			/// Q.763 (1999) clause 3.88.2. Only the description of an ellipsoid
			/// point with uncertainty circle is allowed to be used.
			#[serde(
				rename = "geodeticInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			geodetic_information: Option<UtraLocationVariant0GeodeticInformation>,
			/// Refer to geographical Information.See 3GPP TS 23.032 clause
			/// 7.3.2. Only the description of an ellipsoid point with
			/// uncertainty circle is allowed to be used.
			#[serde(
				rename = "geographicalInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			geographical_information: Option<UtraLocationVariant0GeographicalInformation>,
			#[serde(default, skip_serializing_if = "Option::is_none")]
			rai: Option<RoutingAreaId>,
			#[serde(
				rename = "ueLocationTimestamp",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			ue_location_timestamp: Option<DateTime>,
		},
		Variant1 {
			/// The value represents the elapsed time in minutes since the last
			/// network contact of the mobile station.  Value "0" indicates that
			/// the location information was obtained after a successful paging
			/// procedure for  Active Location Retrieval when the UE is in idle
			/// mode or after a successful location reporting
			/// procedure  the UE is in connected mode. Any
			/// other value than "0" indicates that the location information is
			/// the last known one.  See 3GPP TS 29.002 clause 17.7.8.
			#[serde(
				rename = "ageOfLocationInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			age_of_location_information: Option<i64>,
			/// Refers to Calling Geodetic Location. See ITU-T Recommendation
			/// Q.763 (1999) clause 3.88.2. Only the description of an ellipsoid
			/// point with uncertainty circle is allowed to be used.
			#[serde(
				rename = "geodeticInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			geodetic_information: Option<UtraLocationVariant1GeodeticInformation>,
			/// Refer to geographical Information.See 3GPP TS 23.032 clause
			/// 7.3.2. Only the description of an ellipsoid point with
			/// uncertainty circle is allowed to be used.
			#[serde(
				rename = "geographicalInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			geographical_information: Option<UtraLocationVariant1GeographicalInformation>,
			#[serde(default, skip_serializing_if = "Option::is_none")]
			rai: Option<RoutingAreaId>,
			sai: ServiceAreaId,
			#[serde(
				rename = "ueLocationTimestamp",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			ue_location_timestamp: Option<DateTime>,
		},
		Variant2 {
			/// The value represents the elapsed time in minutes since the last
			/// network contact of the mobile station.  Value "0" indicates that
			/// the location information was obtained after a successful paging
			/// procedure for  Active Location Retrieval when the UE is in idle
			/// mode or after a successful location reporting
			/// procedure  the UE is in connected mode. Any
			/// other value than "0" indicates that the location information is
			/// the last known one.  See 3GPP TS 29.002 clause 17.7.8.
			#[serde(
				rename = "ageOfLocationInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			age_of_location_information: Option<i64>,
			/// Refers to Calling Geodetic Location. See ITU-T Recommendation
			/// Q.763 (1999) clause 3.88.2. Only the description of an ellipsoid
			/// point with uncertainty circle is allowed to be used.
			#[serde(
				rename = "geodeticInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			geodetic_information: Option<UtraLocationVariant2GeodeticInformation>,
			/// Refer to geographical Information.See 3GPP TS 23.032 clause
			/// 7.3.2. Only the description of an ellipsoid point with
			/// uncertainty circle is allowed to be used.
			#[serde(
				rename = "geographicalInformation",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			geographical_information: Option<UtraLocationVariant2GeographicalInformation>,
			lai: LocationAreaId,
			#[serde(default, skip_serializing_if = "Option::is_none")]
			rai: Option<RoutingAreaId>,
			#[serde(
				rename = "ueLocationTimestamp",
				default,
				skip_serializing_if = "Option::is_none"
			)]
			ue_location_timestamp: Option<DateTime>,
		},
	}

	impl From<&UtraLocation> for UtraLocation {
		fn from(value: &UtraLocation) -> Self {
			value.clone()
		}
	}

	/// Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763
	/// (1999) clause 3.88.2. Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refers to Calling Geodetic Location. See ITU-T
	/// Recommendation Q.763 (1999) clause 3.88.2. Only the description of an
	/// ellipsoid point with uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{20}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct UtraLocationVariant0GeodeticInformation(String);
	impl ::std::ops::Deref for UtraLocationVariant0GeodeticInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<UtraLocationVariant0GeodeticInformation> for String {
		fn from(value: UtraLocationVariant0GeodeticInformation) -> Self {
			value.0
		}
	}

	impl From<&UtraLocationVariant0GeodeticInformation> for UtraLocationVariant0GeodeticInformation {
		fn from(value: &UtraLocationVariant0GeodeticInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for UtraLocationVariant0GeodeticInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{20}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for UtraLocationVariant0GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for UtraLocationVariant0GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for UtraLocationVariant0GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for UtraLocationVariant0GeodeticInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Refer to geographical Information.See 3GPP TS 23.032 clause 7.3.2. Only
	/// the description of an ellipsoid point with uncertainty circle is allowed
	/// to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refer to geographical Information.See 3GPP TS 23.032
	/// clause 7.3.2. Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{16}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct UtraLocationVariant0GeographicalInformation(String);
	impl ::std::ops::Deref for UtraLocationVariant0GeographicalInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<UtraLocationVariant0GeographicalInformation> for String {
		fn from(value: UtraLocationVariant0GeographicalInformation) -> Self {
			value.0
		}
	}

	impl From<&UtraLocationVariant0GeographicalInformation>
		for UtraLocationVariant0GeographicalInformation
	{
		fn from(value: &UtraLocationVariant0GeographicalInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for UtraLocationVariant0GeographicalInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{16}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for UtraLocationVariant0GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for UtraLocationVariant0GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for UtraLocationVariant0GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for UtraLocationVariant0GeographicalInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763
	/// (1999) clause 3.88.2. Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refers to Calling Geodetic Location. See ITU-T
	/// Recommendation Q.763 (1999) clause 3.88.2. Only the description of an
	/// ellipsoid point with uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{20}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct UtraLocationVariant1GeodeticInformation(String);
	impl ::std::ops::Deref for UtraLocationVariant1GeodeticInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<UtraLocationVariant1GeodeticInformation> for String {
		fn from(value: UtraLocationVariant1GeodeticInformation) -> Self {
			value.0
		}
	}

	impl From<&UtraLocationVariant1GeodeticInformation> for UtraLocationVariant1GeodeticInformation {
		fn from(value: &UtraLocationVariant1GeodeticInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for UtraLocationVariant1GeodeticInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{20}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for UtraLocationVariant1GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for UtraLocationVariant1GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for UtraLocationVariant1GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for UtraLocationVariant1GeodeticInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Refer to geographical Information.See 3GPP TS 23.032 clause 7.3.2. Only
	/// the description of an ellipsoid point with uncertainty circle is allowed
	/// to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refer to geographical Information.See 3GPP TS 23.032
	/// clause 7.3.2. Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{16}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct UtraLocationVariant1GeographicalInformation(String);
	impl ::std::ops::Deref for UtraLocationVariant1GeographicalInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<UtraLocationVariant1GeographicalInformation> for String {
		fn from(value: UtraLocationVariant1GeographicalInformation) -> Self {
			value.0
		}
	}

	impl From<&UtraLocationVariant1GeographicalInformation>
		for UtraLocationVariant1GeographicalInformation
	{
		fn from(value: &UtraLocationVariant1GeographicalInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for UtraLocationVariant1GeographicalInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{16}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for UtraLocationVariant1GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for UtraLocationVariant1GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for UtraLocationVariant1GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for UtraLocationVariant1GeographicalInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763
	/// (1999) clause 3.88.2. Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refers to Calling Geodetic Location. See ITU-T
	/// Recommendation Q.763 (1999) clause 3.88.2. Only the description of an
	/// ellipsoid point with uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{20}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct UtraLocationVariant2GeodeticInformation(String);
	impl ::std::ops::Deref for UtraLocationVariant2GeodeticInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<UtraLocationVariant2GeodeticInformation> for String {
		fn from(value: UtraLocationVariant2GeodeticInformation) -> Self {
			value.0
		}
	}

	impl From<&UtraLocationVariant2GeodeticInformation> for UtraLocationVariant2GeodeticInformation {
		fn from(value: &UtraLocationVariant2GeodeticInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for UtraLocationVariant2GeodeticInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{20}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for UtraLocationVariant2GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for UtraLocationVariant2GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for UtraLocationVariant2GeodeticInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for UtraLocationVariant2GeodeticInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Refer to geographical Information.See 3GPP TS 23.032 clause 7.3.2. Only
	/// the description of an ellipsoid point with uncertainty circle is allowed
	/// to be used.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Refer to geographical Information.See 3GPP TS 23.032
	/// clause 7.3.2. Only the description of an ellipsoid point with
	/// uncertainty circle is allowed to be used.\n",
	///  "type": "string",
	///  "pattern": "^[0-9A-F]{16}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct UtraLocationVariant2GeographicalInformation(String);
	impl ::std::ops::Deref for UtraLocationVariant2GeographicalInformation {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<UtraLocationVariant2GeographicalInformation> for String {
		fn from(value: UtraLocationVariant2GeographicalInformation) -> Self {
			value.0
		}
	}

	impl From<&UtraLocationVariant2GeographicalInformation>
		for UtraLocationVariant2GeographicalInformation
	{
		fn from(value: &UtraLocationVariant2GeographicalInformation) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for UtraLocationVariant2GeographicalInformation {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[0-9A-F]{16}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for UtraLocationVariant2GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for UtraLocationVariant2GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for UtraLocationVariant2GeographicalInformation {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for UtraLocationVariant2GeographicalInformation {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// V2xSubscriptionData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "ltePc5Ambr": {
	///      "$ref": "#/components/schemas/BitRate"
	///    },
	///    "lteV2xServicesAuth": {
	///      "$ref": "#/components/schemas/LteV2xAuth"
	///    },
	///    "nrUePc5Ambr": {
	///      "$ref": "#/components/schemas/BitRate"
	///    },
	///    "nrV2xServicesAuth": {
	///      "$ref": "#/components/schemas/NrV2xAuth"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct V2xSubscriptionData {
		#[serde(
			rename = "ltePc5Ambr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub lte_pc5_ambr: Option<BitRate>,
		#[serde(
			rename = "lteV2xServicesAuth",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub lte_v2x_services_auth: Option<LteV2xAuth>,
		#[serde(
			rename = "nrUePc5Ambr",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub nr_ue_pc5_ambr: Option<BitRate>,
		#[serde(
			rename = "nrV2xServicesAuth",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub nr_v2x_services_auth: Option<NrV2xAuth>,
	}

	impl From<&V2xSubscriptionData> for V2xSubscriptionData {
		fn from(value: &V2xSubscriptionData) -> Self {
			value.clone()
		}
	}

	/// ValidTimePeriod
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "endTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    },
	///    "startTime": {
	///      "$ref": "#/components/schemas/DateTime"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct ValidTimePeriod {
		#[serde(rename = "endTime", default, skip_serializing_if = "Option::is_none")]
		pub end_time: Option<DateTime>,
		#[serde(rename = "startTime", default, skip_serializing_if = "Option::is_none")]
		pub start_time: Option<DateTime>,
	}

	impl From<&ValidTimePeriod> for ValidTimePeriod {
		fn from(value: &ValidTimePeriod) -> Self {
			value.clone()
		}
	}

	/// String represents the SUPI or GPSI
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String represents the SUPI or GPSI",
	///  "type": "string",
	///  "pattern":
	/// "^(imsi-[0-9]{5,15}|nai-.+|msisdn-[0-9]{5,15}|extid-[^@]+@[^@]+|gci-.
	/// +|gli-.+|.+)$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct VarUeId(String);
	impl ::std::ops::Deref for VarUeId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<VarUeId> for String {
		fn from(value: VarUeId) -> Self {
			value.0
		}
	}

	impl From<&VarUeId> for VarUeId {
		fn from(value: &VarUeId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for VarUeId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new(
				"^(imsi-[0-9]{5,15}|nai-.+|msisdn-[0-9]{5,15}|extid-[^@]+@[^@]+|gci-.+|gli-.+|.+)$",
			)
			.unwrap()
			.find(value)
			.is_none()
			{
				return Err("doesn't match pattern \
				            \"^(imsi-[0-9]{5,15}|nai-.+|msisdn-[0-9]{5,15}|extid-[^@]+@[^@\
				            ]+|gci-.+|gli-.+|.+)$\""
					.into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for VarUeId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for VarUeId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for VarUeId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for VarUeId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// VgmlcAddress
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "vgmlcAddressIpv4": {
	///      "$ref": "#/components/schemas/Ipv4Addr"
	///    },
	///    "vgmlcAddressIpv6": {
	///      "$ref": "#/components/schemas/Ipv6Addr"
	///    },
	///    "vgmlcFqdn": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct VgmlcAddress {
		#[serde(
			rename = "vgmlcAddressIpv4",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub vgmlc_address_ipv4: Option<Ipv4Addr>,
		#[serde(
			rename = "vgmlcAddressIpv6",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub vgmlc_address_ipv6: Option<Ipv6Addr>,
		#[serde(rename = "vgmlcFqdn", default, skip_serializing_if = "Option::is_none")]
		pub vgmlc_fqdn: Option<Fqdn>,
	}

	impl From<&VgmlcAddress> for VgmlcAddress {
		fn from(value: &VgmlcAddress) -> Self {
			value.clone()
		}
	}

	/// VnGroupData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "appDescriptors": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/AppDescriptor"
	///      },
	///      "minItems": 1
	///    },
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "pduSessionTypes": {
	///      "$ref": "#/components/schemas/PduSessionTypes"
	///    },
	///    "singleNssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct VnGroupData {
		#[serde(
			rename = "appDescriptors",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub app_descriptors: Vec<AppDescriptor>,
		#[serde(default, skip_serializing_if = "Option::is_none")]
		pub dnn: Option<Dnn>,
		#[serde(
			rename = "pduSessionTypes",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub pdu_session_types: Option<PduSessionTypes>,
		#[serde(
			rename = "singleNssai",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub single_nssai: Option<Snssai>,
	}

	impl From<&VnGroupData> for VnGroupData {
		fn from(value: &VnGroupData) -> Self {
			value.clone()
		}
	}

	/// This represents the identifier of the W-AGF ID as specified in clause
	/// 9.3.1.162 of  3GPP TS 38.413 in hexadecimal representation. Each
	/// character in the string shall take a value  of "0" to "9", "a" to "f" or
	/// "A" to "F" and shall represent 4 bits. The most significant  character
	/// representing the 4 most significant bits of the W-AGF ID shall appear
	/// first in the  string, and the character representing the 4 least
	/// significant bit of the W-AGF ID shall  appear last in the string.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "This represents the identifier of the W-AGF ID as
	/// specified in clause 9.3.1.162 of  3GPP TS 38.413 in hexadecimal
	/// representation. Each character in the string shall take a value  of
	/// \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4
	/// bits. The most significant  character representing the 4 most
	/// significant bits of the W-AGF ID shall appear first in the  string, and
	/// the character representing the 4 least significant bit of the W-AGF ID
	/// shall  appear last in the string. \n",
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]+$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct WAgfId(String);
	impl ::std::ops::Deref for WAgfId {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<WAgfId> for String {
		fn from(value: WAgfId) -> Self {
			value.0
		}
	}

	impl From<&WAgfId> for WAgfId {
		fn from(value: &WAgfId) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for WAgfId {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]+$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]+$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for WAgfId {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for WAgfId {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for WAgfId {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for WAgfId {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// String representing the Wildcard DNN. It shall contain the string "*".
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "String representing the Wildcard DNN. It shall contain
	/// the string \"*\".",
	///  "type": "string",
	///  "pattern": "^[*]$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct WildcardDnn(String);
	impl ::std::ops::Deref for WildcardDnn {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<WildcardDnn> for String {
		fn from(value: WildcardDnn) -> Self {
			value.0
		}
	}

	impl From<&WildcardDnn> for WildcardDnn {
		fn from(value: &WildcardDnn) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for WildcardDnn {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[*]$").unwrap().find(value).is_none() {
				return Err("doesn't match pattern \"^[*]$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for WildcardDnn {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for WildcardDnn {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for WildcardDnn {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for WildcardDnn {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// One and only one of the "globLineIds", "hfcNIds", "areaCodeB" and
	/// "areaCodeC" attributes shall be included in a WirelineArea data
	/// structure
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "One and only one of the \"globLineIds\", \"hfcNIds\",
	/// \"areaCodeB\" and \"areaCodeC\" attributes shall be included in a
	/// WirelineArea data structure\n",
	///  "type": "object",
	///  "properties": {
	///    "areaCodeB": {
	///      "$ref": "#/components/schemas/AreaCode"
	///    },
	///    "areaCodeC": {
	///      "$ref": "#/components/schemas/AreaCode"
	///    },
	///    "globalLineIds": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Bytes"
	///      },
	///      "minItems": 1
	///    },
	///    "hfcNIds": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/HfcNId"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct WirelineArea {
		#[serde(rename = "areaCodeB", default, skip_serializing_if = "Option::is_none")]
		pub area_code_b: Option<AreaCode>,
		#[serde(rename = "areaCodeC", default, skip_serializing_if = "Option::is_none")]
		pub area_code_c: Option<AreaCode>,
		#[serde(
			rename = "globalLineIds",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub global_line_ids: Vec<Bytes>,
		#[serde(rename = "hfcNIds", default, skip_serializing_if = "Vec::is_empty")]
		pub hfc_n_ids: Vec<HfcNId>,
	}

	impl From<&WirelineArea> for WirelineArea {
		fn from(value: &WirelineArea) -> Self {
			value.clone()
		}
	}

	/// The "restrictionType" attribute and the "areas" attribute shall be
	/// either both present or absent.  The empty array of areas is used when
	/// service is allowed/restricted nowhere.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "The \"restrictionType\" attribute and the \"areas\"
	/// attribute shall be either both present or absent.  The empty array of
	/// areas is used when service is allowed/restricted nowhere.\n",
	///  "type": "object",
	///  "properties": {
	///    "areas": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/WirelineArea"
	///      }
	///    },
	///    "restrictionType": {
	///      "$ref": "#/components/schemas/RestrictionType"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct WirelineServiceAreaRestriction {
		#[serde(default, skip_serializing_if = "Vec::is_empty")]
		pub areas: Vec<WirelineArea>,
		#[serde(
			rename = "restrictionType",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub restriction_type: Option<RestrictionType>,
	}

	impl From<&WirelineServiceAreaRestriction> for WirelineServiceAreaRestriction {
		fn from(value: &WirelineServiceAreaRestriction) -> Self {
			value.clone()
		}
	}

	/// Xres
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{8,32}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct Xres(String);
	impl ::std::ops::Deref for Xres {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<Xres> for String {
		fn from(value: Xres) -> Self {
			value.0
		}
	}

	impl From<&Xres> for Xres {
		fn from(value: &Xres) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for Xres {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{8,32}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{8,32}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for Xres {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for Xres {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for Xres {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for Xres {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// XresStar
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string",
	///  "pattern": "^[A-Fa-f0-9]{32}$"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, smart_default::SmartDefault,
	)]
	pub struct XresStar(String);
	impl ::std::ops::Deref for XresStar {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<XresStar> for String {
		fn from(value: XresStar) -> Self {
			value.0
		}
	}

	impl From<&XresStar> for XresStar {
		fn from(value: &XresStar) -> Self {
			value.clone()
		}
	}

	impl ::std::str::FromStr for XresStar {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			if regress::Regex::new("^[A-Fa-f0-9]{32}$")
				.unwrap()
				.find(value)
				.is_none()
			{
				return Err("doesn't match pattern \"^[A-Fa-f0-9]{32}$\"".into());
			}
			Ok(Self(value.to_string()))
		}
	}

	impl ::std::convert::TryFrom<&str> for XresStar {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<&String> for XresStar {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl ::std::convert::TryFrom<String> for XresStar {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl<'de> ::serde::Deserialize<'de> for XresStar {
		fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
		where
			D: ::serde::Deserializer<'de>,
		{
			String::deserialize(deserializer)?
				.parse()
				.map_err(|e: self::error::ConversionError| {
					<D::Error as ::serde::de::Error>::custom(e.to_string())
				})
		}
	}

	/// Contains RAND, XRES, AUTN, CK, and IK
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Contains RAND, XRES, AUTN, CK, and IK",
	///  "type": "object",
	///  "required": [
	///    "autn",
	///    "ck",
	///    "ik",
	///    "rand",
	///    "xres"
	///  ],
	///  "properties": {
	///    "autn": {
	///      "$ref": "#/components/schemas/Autn"
	///    },
	///    "ck": {
	///      "$ref": "#/components/schemas/ConfidentialityKey"
	///    },
	///    "ik": {
	///      "$ref": "#/components/schemas/IntegrityKey"
	///    },
	///    "rand": {
	///      "$ref": "#/components/schemas/Rand"
	///    },
	///    "xres": {
	///      "$ref": "#/components/schemas/Xres"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct _3gAkaAv {
		pub autn: Autn,
		pub ck: ConfidentialityKey,
		pub ik: IntegrityKey,
		pub rand: Rand,
		pub xres: Xres,
	}

	impl From<&_3gAkaAv> for _3gAkaAv {
		fn from(value: &_3gAkaAv) -> Self {
			value.clone()
		}
	}

	/// _3gppChargingCharacteristics
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "string"
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
		smart_default::SmartDefault,
	)]
	pub struct _3gppChargingCharacteristics(pub String);
	impl ::std::ops::Deref for _3gppChargingCharacteristics {
		type Target = String;
		fn deref(&self) -> &String {
			&self.0
		}
	}

	impl From<_3gppChargingCharacteristics> for String {
		fn from(value: _3gppChargingCharacteristics) -> Self {
			value.0
		}
	}

	impl From<&_3gppChargingCharacteristics> for _3gppChargingCharacteristics {
		fn from(value: &_3gppChargingCharacteristics) -> Self {
			value.clone()
		}
	}

	impl From<String> for _3gppChargingCharacteristics {
		fn from(value: String) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for _3gppChargingCharacteristics {
		type Err = std::convert::Infallible;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.to_string()))
		}
	}

	impl ToString for _3gppChargingCharacteristics {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Represents 5G SRVCC information for a UE.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Represents 5G SRVCC information for a UE.",
	///  "type": "object",
	///  "required": [
	///    "ue5GSrvccCapability"
	///  ],
	///  "properties": {
	///    "cMsisdn": {
	///      "$ref": "#/components/schemas/CMsisdn"
	///    },
	///    "stnSr": {
	///      "$ref": "#/components/schemas/StnSr"
	///    },
	///    "ue5GSrvccCapability": {
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct _5gSrvccInfo {
		#[serde(rename = "cMsisdn", default, skip_serializing_if = "Option::is_none")]
		pub c_msisdn: Option<CMsisdn>,
		#[serde(rename = "stnSr", default, skip_serializing_if = "Option::is_none")]
		pub stn_sr: Option<StnSr>,
		#[serde(rename = "ue5GSrvccCapability")]
		pub ue5_g_srvcc_capability: bool,
	}

	impl From<&_5gSrvccInfo> for _5gSrvccInfo {
		fn from(value: &_5gSrvccInfo) -> Self {
			value.clone()
		}
	}

	/// _5gVnGroupConfiguration
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "5gVnGroupData": {
	///      "$ref": "#/components/schemas/5GVnGroupData"
	///    },
	///    "afInstanceId": {
	///      "type": "string"
	///    },
	///    "internalGroupIdentifier": {
	///      "$ref": "#/components/schemas/GroupId"
	///    },
	///    "members": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/Gpsi"
	///      },
	///      "minItems": 1
	///    },
	///    "mtcProviderInformation": {
	///      "$ref": "#/components/schemas/MtcProviderInformation"
	///    },
	///    "referenceId": {
	///      "$ref": "#/components/schemas/ReferenceId"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct Model5GvnGroupConfiguration {
		#[serde(
			rename = "afInstanceId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub af_instance_id: Option<String>,
		#[serde(
			rename = "5gVnGroupData",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub five_g_vn_group_data: Option<_5gVnGroupData>,
		#[serde(
			rename = "internalGroupIdentifier",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub internal_group_identifier: Option<GroupId>,
		#[serde(default, skip_serializing_if = "Vec::is_empty")]
		pub members: Vec<Gpsi>,
		#[serde(
			rename = "mtcProviderInformation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub mtc_provider_information: Option<MtcProviderInformation>,
		#[serde(
			rename = "referenceId",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub reference_id: Option<ReferenceId>,
	}

	impl From<&Model5GvnGroupConfiguration> for Model5GvnGroupConfiguration {
		fn from(value: &Model5GvnGroupConfiguration) -> Self {
			value.clone()
		}
	}

	/// _5gVnGroupData
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "required": [
	///    "dnn",
	///    "sNssai"
	///  ],
	///  "properties": {
	///    "additionalDnAaaAddresses": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/schemas-IpAddress"
	///      },
	///      "minItems": 1
	///    },
	///    "appDescriptors": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/schemas-AppDescriptor"
	///      },
	///      "minItems": 1
	///    },
	///    "dnAaaAddress": {
	///      "$ref": "#/components/schemas/schemas-IpAddress"
	///    },
	///    "dnAaaFqdn": {
	///      "$ref": "#/components/schemas/Fqdn"
	///    },
	///    "dnAaaIpAddressAllocation": {
	///      "type": "boolean"
	///    },
	///    "dnn": {
	///      "$ref": "#/components/schemas/Dnn"
	///    },
	///    "pduSessionTypes": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/PduSessionType"
	///      },
	///      "minItems": 1
	///    },
	///    "sNssai": {
	///      "$ref": "#/components/schemas/Snssai"
	///    },
	///    "secondaryAuth": {
	///      "type": "boolean"
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct _5gVnGroupData {
		#[serde(
			rename = "additionalDnAaaAddresses",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub additional_dn_aaa_addresses: Vec<SchemasIpAddress>,
		#[serde(
			rename = "appDescriptors",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub app_descriptors: Vec<SchemasAppDescriptor>,
		#[serde(
			rename = "dnAaaAddress",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub dn_aaa_address: Option<SchemasIpAddress>,
		#[serde(rename = "dnAaaFqdn", default, skip_serializing_if = "Option::is_none")]
		pub dn_aaa_fqdn: Option<Fqdn>,
		#[serde(
			rename = "dnAaaIpAddressAllocation",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub dn_aaa_ip_address_allocation: Option<bool>,
		pub dnn: Dnn,
		#[serde(
			rename = "pduSessionTypes",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub pdu_session_types: Vec<PduSessionType>,
		#[serde(rename = "sNssai")]
		pub s_nssai: Snssai,
		#[serde(
			rename = "secondaryAuth",
			default,
			skip_serializing_if = "Option::is_none"
		)]
		pub secondary_auth: Option<bool>,
	}

	impl From<&_5gVnGroupData> for _5gVnGroupData {
		fn from(value: &_5gVnGroupData) -> Self {
			value.clone()
		}
	}

	/// Describes the 5GS User State of a UE
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Describes the 5GS User State of a UE",
	///  "type": "string",
	///  "enum": [
	///    "DEREGISTERED",
	///    "CONNECTED_NOT_REACHABLE_FOR_PAGING",
	///    "CONNECTED_REACHABLE_FOR_PAGING",
	///    "NOT_PROVIDED_FROM_AMF"
	///  ],
	///  "x-allow-unknown": true
	/// }
	/// ```
	/// </details>
	#[derive(
		:: serde :: Deserialize,
		:: serde :: Serialize,
		Clone,
		Debug,
		Eq,
		Hash,
		Ord,
		PartialEq,
		PartialOrd,
	    smart_default::SmartDefault
	)]
	pub enum _5gsUserState {
		#[default]
		#[serde(rename = "DEREGISTERED")]
		Deregistered,
		#[serde(rename = "CONNECTED_NOT_REACHABLE_FOR_PAGING")]
		ConnectedNotReachableForPaging,
		#[serde(rename = "CONNECTED_REACHABLE_FOR_PAGING")]
		ConnectedReachableForPaging,
		#[serde(rename = "NOT_PROVIDED_FROM_AMF")]
		NotProvidedFromAmf,
		#[serde(untagged)]
		UnknownOther(String),
	}

	impl From<&_5gsUserState> for _5gsUserState {
		fn from(value: &_5gsUserState) -> Self {
			value.clone()
		}
	}

	impl ToString for _5gsUserState {
		fn to_string(&self) -> String {
			match *self {
				Self::Deregistered => "DEREGISTERED".to_string(),
				Self::ConnectedNotReachableForPaging => {
					"CONNECTED_NOT_REACHABLE_FOR_PAGING".to_string()
				}
				Self::ConnectedReachableForPaging => "CONNECTED_REACHABLE_FOR_PAGING".to_string(),
				Self::NotProvidedFromAmf => "NOT_PROVIDED_FROM_AMF".to_string(),
				Self::UnknownOther(ref value) => value.clone(),
			}
		}
	}

	impl std::str::FromStr for _5gsUserState {
		type Err = self::error::ConversionError;
		fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
			match value {
				"DEREGISTERED" => Ok(Self::Deregistered),
				"CONNECTED_NOT_REACHABLE_FOR_PAGING" => Ok(Self::ConnectedNotReachableForPaging),
				"CONNECTED_REACHABLE_FOR_PAGING" => Ok(Self::ConnectedReachableForPaging),
				"NOT_PROVIDED_FROM_AMF" => Ok(Self::NotProvidedFromAmf),
				_ => Ok(Self::UnknownOther(value.to_string())),
			}
		}
	}

	impl std::convert::TryFrom<&str> for _5gsUserState {
		type Error = self::error::ConversionError;
		fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for _5gsUserState {
		type Error = self::error::ConversionError;
		fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for _5gsUserState {
		type Error = self::error::ConversionError;
		fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
			value.parse()
		}
	}

	/// _5mbsAuthorizationInfo
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": [
	///    "object",
	///    "null"
	///  ],
	///  "properties": {
	///    "5mbsSessionIds": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/MbsSessionId"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct _5mbsAuthorizationInfo(pub Option<_5mbsAuthorizationInfoInner>);
	impl ::std::ops::Deref for _5mbsAuthorizationInfo {
		type Target = Option<_5mbsAuthorizationInfoInner>;
		fn deref(&self) -> &Option<_5mbsAuthorizationInfoInner> {
			&self.0
		}
	}

	impl From<_5mbsAuthorizationInfo> for Option<_5mbsAuthorizationInfoInner> {
		fn from(value: _5mbsAuthorizationInfo) -> Self {
			value.0
		}
	}

	impl From<&_5mbsAuthorizationInfo> for _5mbsAuthorizationInfo {
		fn from(value: &_5mbsAuthorizationInfo) -> Self {
			value.clone()
		}
	}

	impl From<Option<_5mbsAuthorizationInfoInner>> for _5mbsAuthorizationInfo {
		fn from(value: Option<_5mbsAuthorizationInfoInner>) -> Self {
			Self(value)
		}
	}

	/// _5mbsAuthorizationInfoInner
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "type": "object",
	///  "properties": {
	///    "5mbsSessionIds": {
	///      "type": "array",
	///      "items": {
	///        "$ref": "#/components/schemas/MbsSessionId"
	///      },
	///      "minItems": 1
	///    }
	///  }
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct _5mbsAuthorizationInfoInner {
		#[serde(
			rename = "5mbsSessionIds",
			default,
			skip_serializing_if = "Vec::is_empty"
		)]
		pub five_mbs_session_ids: Vec<MbsSessionId>,
	}

	impl From<&_5mbsAuthorizationInfoInner> for _5mbsAuthorizationInfoInner {
		fn from(value: &_5mbsAuthorizationInfoInner) -> Self {
			value.clone()
		}
	}

	/// Unsigned integer representing a 5G QoS Identifier (see clause 5.7.2.1 of
	/// 3GPP TS 23.501, within the range 0 to 255.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Unsigned integer representing a 5G QoS Identifier (see
	/// clause 5.7.2.1 of 3GPP TS 23.501, within the range 0 to 255.\n",
	///  "type": "integer",
	///  "maximum": 255.0,
	///  "minimum": 0.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct _5qi(pub u8);
	impl ::std::ops::Deref for _5qi {
		type Target = u8;
		fn deref(&self) -> &u8 {
			&self.0
		}
	}

	impl From<_5qi> for u8 {
		fn from(value: _5qi) -> Self {
			value.0
		}
	}

	impl From<&_5qi> for _5qi {
		fn from(value: &_5qi) -> Self {
			value.clone()
		}
	}

	impl From<u8> for _5qi {
		fn from(value: u8) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for _5qi {
		type Err = <u8 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for _5qi {
		type Error = <u8 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for _5qi {
		type Error = <u8 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for _5qi {
		type Error = <u8 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for _5qi {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}

	/// Unsigned integer indicating the 5QI Priority Level (see clauses 5.7.3.3
	/// and 5.7.4 of 3GPP TS 23.501, within the range 1 to 127.Values are
	/// ordered in decreasing order of priority,  i.e. with 1 as the highest
	/// priority and 127 as the lowest priority.
	///
	/// <details><summary>JSON schema</summary>
	///
	/// ```json
	/// {
	///  "description": "Unsigned integer indicating the 5QI Priority Level (see
	/// clauses 5.7.3.3 and 5.7.4 of 3GPP TS 23.501, within the range 1 to
	/// 127.Values are ordered in decreasing order of priority,  i.e. with 1 as
	/// the highest priority and 127 as the lowest priority. \n",
	///  "type": "integer",
	///  "maximum": 127.0,
	///  "minimum": 1.0
	/// }
	/// ```
	/// </details>
	#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, smart_default::SmartDefault)]
	pub struct _5qiPriorityLevel(pub i64);
	impl ::std::ops::Deref for _5qiPriorityLevel {
		type Target = i64;
		fn deref(&self) -> &i64 {
			&self.0
		}
	}

	impl From<_5qiPriorityLevel> for i64 {
		fn from(value: _5qiPriorityLevel) -> Self {
			value.0
		}
	}

	impl From<&_5qiPriorityLevel> for _5qiPriorityLevel {
		fn from(value: &_5qiPriorityLevel) -> Self {
			value.clone()
		}
	}

	impl From<i64> for _5qiPriorityLevel {
		fn from(value: i64) -> Self {
			Self(value)
		}
	}

	impl std::str::FromStr for _5qiPriorityLevel {
		type Err = <i64 as std::str::FromStr>::Err;
		fn from_str(value: &str) -> Result<Self, Self::Err> {
			Ok(Self(value.parse()?))
		}
	}

	impl std::convert::TryFrom<&str> for _5qiPriorityLevel {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &str) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<&String> for _5qiPriorityLevel {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: &String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl std::convert::TryFrom<String> for _5qiPriorityLevel {
		type Error = <i64 as std::str::FromStr>::Err;
		fn try_from(value: String) -> Result<Self, Self::Error> {
			value.parse()
		}
	}

	impl ToString for _5qiPriorityLevel {
		fn to_string(&self) -> String {
			self.0.to_string()
		}
	}
}

#[derive(Clone, Debug)]
/// Client for Openapi-5GC
///
/// Merged Apis. © 2024, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI,
/// TSDSI, TTA, TTC). All rights reserved.
///
/// Version: 1.2.6
pub struct Client {
	pub(crate) baseurl: String,
	pub(crate) client: reqwest::Client,
}

impl Client {
	/// Create a new client.
	///
	/// `baseurl` is the base URL provided to the internal
	/// `reqwest::Client`, and should include a scheme and hostname,
	/// as well as port and a path stem if applicable.
	pub fn new(baseurl: &str) -> Self {
		#[cfg(not(target_arch = "wasm32"))]
		let client = {
			let dur = std::time::Duration::from_secs(15);
			reqwest::ClientBuilder::new()
				.connect_timeout(dur)
				.timeout(dur)
		};
		#[cfg(target_arch = "wasm32")]
		let client = reqwest::ClientBuilder::new();
		Self::new_with_client(baseurl, client.build().unwrap())
	}

	/// Construct a new client with an existing `reqwest::Client`,
	/// allowing more control over its configuration.
	///
	/// `baseurl` is the base URL provided to the internal
	/// `reqwest::Client`, and should include a scheme and hostname,
	/// as well as port and a path stem if applicable.
	pub fn new_with_client(
		baseurl: &str,
		client: reqwest::Client,
	) -> Self {
		Self {
			baseurl: baseurl.to_string(),
			client,
		}
	}

	/// Get the base URL to which requests are made.
	pub fn baseurl(&self) -> &String {
		&self.baseurl
	}

	/// Get the internal `reqwest::Client` used to make requests.
	pub fn client(&self) -> &reqwest::Client {
		&self.client
	}

	/// Get the version of this API.
	///
	/// This string is pulled directly from the source OpenAPI
	/// document and may be in any format the API selects.
	pub fn api_version(&self) -> &'static str {
		"1.2.6"
	}
}

#[allow(clippy::all)]
impl Client {}
/// Items consumers will typically use such as the Client.
pub mod prelude {
	#[allow(unused_imports)]
	pub use super::Client;
}
