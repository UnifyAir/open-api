#[allow(unused_imports)]
use crate::progenitor_client::{encode_path, RequestBuilderExt};
#[allow(unused_imports)]
pub use crate::progenitor_client::{ByteStream, Error, ResponseValue};
#[allow(unused_imports)]
use reqwest::header::{HeaderMap, HeaderValue};
/// Types used as operation parameters and responses.
#[allow(clippy::all)]
pub mod types {
    /// Error types.
    pub mod error {
        /// Error from a TryFrom or FromStr implementation.
        pub struct ConversionError(::std::borrow::Cow<'static, str>);
        impl ::std::error::Error for ConversionError {}
        impl ::std::fmt::Display for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Display::fmt(&self.0, f)
            }
        }

        impl ::std::fmt::Debug for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Debug::fmt(&self.0, f)
            }
        }

        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }

        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }

    ///Represents the abnormal behaviour information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the abnormal behaviour information.",
    ///  "type": "object",
    ///  "required": [
    ///    "excep"
    ///  ],
    ///  "properties": {
    ///    "addtMeasInfo": {
    ///      "$ref": "#/components/schemas/AdditionalMeasurement"
    ///    },
    ///    "confidence": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "dnn": {
    ///      "$ref": "#/components/schemas/Dnn"
    ///    },
    ///    "excep": {
    ///      "$ref": "#/components/schemas/Exception"
    ///    },
    ///    "ratio": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "supis": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AbnormalBehaviour {
        #[serde(
            rename = "addtMeasInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub addt_meas_info: Option<AdditionalMeasurement>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub confidence: Option<Uinteger>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dnn: Option<Dnn>,
        pub excep: Exception,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ratio: Option<SamplingRatio>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub snssai: Option<Snssai>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub supis: Vec<Supi>,
    }

    impl From<&AbnormalBehaviour> for AbnormalBehaviour {
        fn from(value: &AbnormalBehaviour) -> Self {
            value.clone()
        }
    }

    ///Access State Transition Type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Access State Transition Type.",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACCESS_TYPE_CHANGE_3GPP",
    ///    "ACCESS_TYPE_CHANGE_N3GPP",
    ///    "RM_STATE_CHANGE_DEREGISTERED",
    ///    "RM_STATE_CHANGE_REGISTERED",
    ///    "CM_STATE_CHANGE_IDLE",
    ///    "CM_STATE_CHANGE_CONNECTED",
    ///    "HANDOVER",
    ///    "MOBILITY_REGISTRATION_UPDATE"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AccessStateTransitionType {
        #[serde(rename = "ACCESS_TYPE_CHANGE_3GPP")]
        AccessTypeChange3gpp,
        #[serde(rename = "ACCESS_TYPE_CHANGE_N3GPP")]
        AccessTypeChangeN3gpp,
        #[serde(rename = "RM_STATE_CHANGE_DEREGISTERED")]
        RmStateChangeDeregistered,
        #[serde(rename = "RM_STATE_CHANGE_REGISTERED")]
        RmStateChangeRegistered,
        #[serde(rename = "CM_STATE_CHANGE_IDLE")]
        CmStateChangeIdle,
        #[serde(rename = "CM_STATE_CHANGE_CONNECTED")]
        CmStateChangeConnected,
        #[serde(rename = "HANDOVER")]
        Handover,
        #[serde(rename = "MOBILITY_REGISTRATION_UPDATE")]
        MobilityRegistrationUpdate,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&AccessStateTransitionType> for AccessStateTransitionType {
        fn from(value: &AccessStateTransitionType) -> Self {
            value.clone()
        }
    }

    impl ToString for AccessStateTransitionType {
        fn to_string(&self) -> String {
            match *self {
                Self::AccessTypeChange3gpp => "ACCESS_TYPE_CHANGE_3GPP".to_string(),
                Self::AccessTypeChangeN3gpp => "ACCESS_TYPE_CHANGE_N3GPP".to_string(),
                Self::RmStateChangeDeregistered => "RM_STATE_CHANGE_DEREGISTERED".to_string(),
                Self::RmStateChangeRegistered => "RM_STATE_CHANGE_REGISTERED".to_string(),
                Self::CmStateChangeIdle => "CM_STATE_CHANGE_IDLE".to_string(),
                Self::CmStateChangeConnected => "CM_STATE_CHANGE_CONNECTED".to_string(),
                Self::Handover => "HANDOVER".to_string(),
                Self::MobilityRegistrationUpdate => "MOBILITY_REGISTRATION_UPDATE".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for AccessStateTransitionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACCESS_TYPE_CHANGE_3GPP" => Ok(Self::AccessTypeChange3gpp),
                "ACCESS_TYPE_CHANGE_N3GPP" => Ok(Self::AccessTypeChangeN3gpp),
                "RM_STATE_CHANGE_DEREGISTERED" => Ok(Self::RmStateChangeDeregistered),
                "RM_STATE_CHANGE_REGISTERED" => Ok(Self::RmStateChangeRegistered),
                "CM_STATE_CHANGE_IDLE" => Ok(Self::CmStateChangeIdle),
                "CM_STATE_CHANGE_CONNECTED" => Ok(Self::CmStateChangeConnected),
                "HANDOVER" => Ok(Self::Handover),
                "MOBILITY_REGISTRATION_UPDATE" => Ok(Self::MobilityRegistrationUpdate),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AccessStateTransitionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AccessStateTransitionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AccessStateTransitionType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Error returned in the access token response message
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Error returned in the access token response message",
    ///  "type": "object",
    ///  "required": [
    ///    "error"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "type": "string",
    ///      "enum": [
    ///        "invalid_request",
    ///        "invalid_client",
    ///        "invalid_grant",
    ///        "unauthorized_client",
    ///        "unsupported_grant_type",
    ///        "invalid_scope"
    ///      ]
    ///    },
    ///    "error_description": {
    ///      "type": "string"
    ///    },
    ///    "error_uri": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AccessTokenErr {
        pub error: AccessTokenErrError,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error_description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error_uri: Option<String>,
    }

    impl From<&AccessTokenErr> for AccessTokenErr {
        fn from(value: &AccessTokenErr) -> Self {
            value.clone()
        }
    }

    ///AccessTokenErrError
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "invalid_request",
    ///    "invalid_client",
    ///    "invalid_grant",
    ///    "unauthorized_client",
    ///    "unsupported_grant_type",
    ///    "invalid_scope"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AccessTokenErrError {
        #[serde(rename = "invalid_request")]
        InvalidRequest,
        #[serde(rename = "invalid_client")]
        InvalidClient,
        #[serde(rename = "invalid_grant")]
        InvalidGrant,
        #[serde(rename = "unauthorized_client")]
        UnauthorizedClient,
        #[serde(rename = "unsupported_grant_type")]
        UnsupportedGrantType,
        #[serde(rename = "invalid_scope")]
        InvalidScope,
    }

    impl From<&AccessTokenErrError> for AccessTokenErrError {
        fn from(value: &AccessTokenErrError) -> Self {
            value.clone()
        }
    }

    impl ToString for AccessTokenErrError {
        fn to_string(&self) -> String {
            match *self {
                Self::InvalidRequest => "invalid_request".to_string(),
                Self::InvalidClient => "invalid_client".to_string(),
                Self::InvalidGrant => "invalid_grant".to_string(),
                Self::UnauthorizedClient => "unauthorized_client".to_string(),
                Self::UnsupportedGrantType => "unsupported_grant_type".to_string(),
                Self::InvalidScope => "invalid_scope".to_string(),
            }
        }
    }

    impl std::str::FromStr for AccessTokenErrError {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "invalid_request" => Ok(Self::InvalidRequest),
                "invalid_client" => Ok(Self::InvalidClient),
                "invalid_grant" => Ok(Self::InvalidGrant),
                "unauthorized_client" => Ok(Self::UnauthorizedClient),
                "unsupported_grant_type" => Ok(Self::UnsupportedGrantType),
                "invalid_scope" => Ok(Self::InvalidScope),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AccessTokenErrError {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AccessTokenErrError {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AccessTokenErrError {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Contains information related to the access token request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains information related to the access token
    /// request",
    ///  "type": "object",
    ///  "required": [
    ///    "grant_type",
    ///    "nfInstanceId",
    ///    "scope"
    ///  ],
    ///  "properties": {
    ///    "grant_type": {
    ///      "type": "string",
    ///      "enum": [
    ///        "client_credentials"
    ///      ]
    ///    },
    ///    "hnrfAccessTokenUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "nfInstanceId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "nfType": {
    ///      "$ref": "#/components/schemas/NFType"
    ///    },
    ///    "requesterFqdn": {
    ///      "$ref": "#/components/schemas/Fqdn"
    ///    },
    ///    "requesterPlmn": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    },
    ///    "requesterPlmnList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PlmnId"
    ///      },
    ///      "minItems": 2
    ///    },
    ///    "requesterSnpnList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PlmnIdNid"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "requesterSnssaiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Snssai"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "scope": {
    ///      "type": "string",
    ///      "pattern": "^([a-zA-Z0-9_:-]+)( [a-zA-Z0-9_:-]+)*$"
    ///    },
    ///    "sourceNfInstanceId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "targetNfInstanceId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "targetNfServiceSetId": {
    ///      "$ref": "#/components/schemas/NfServiceSetId"
    ///    },
    ///    "targetNfSetId": {
    ///      "$ref": "#/components/schemas/NfSetId"
    ///    },
    ///    "targetNfType": {
    ///      "$ref": "#/components/schemas/NFType"
    ///    },
    ///    "targetNsiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "targetPlmn": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    },
    ///    "targetSnpn": {
    ///      "$ref": "#/components/schemas/PlmnIdNid"
    ///    },
    ///    "targetSnssaiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Snssai"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AccessTokenReq {
        pub grant_type: AccessTokenReqGrantType,
        #[serde(
            rename = "hnrfAccessTokenUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub hnrf_access_token_uri: Option<Uri>,
        #[serde(rename = "nfInstanceId")]
        pub nf_instance_id: NfInstanceId,
        #[serde(rename = "nfType", default, skip_serializing_if = "Option::is_none")]
        pub nf_type: Option<NfType>,
        #[serde(
            rename = "requesterFqdn",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub requester_fqdn: Option<Fqdn>,
        #[serde(
            rename = "requesterPlmn",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub requester_plmn: Option<PlmnId>,
        #[serde(
            rename = "requesterPlmnList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub requester_plmn_list: Vec<PlmnId>,
        #[serde(
            rename = "requesterSnpnList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub requester_snpn_list: Vec<PlmnIdNid>,
        #[serde(
            rename = "requesterSnssaiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub requester_snssai_list: Vec<Snssai>,
        pub scope: AccessTokenReqScope,
        #[serde(
            rename = "sourceNfInstanceId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub source_nf_instance_id: Option<NfInstanceId>,
        #[serde(
            rename = "targetNfInstanceId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_nf_instance_id: Option<NfInstanceId>,
        #[serde(
            rename = "targetNfServiceSetId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_nf_service_set_id: Option<NfServiceSetId>,
        #[serde(
            rename = "targetNfSetId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_nf_set_id: Option<NfSetId>,
        #[serde(
            rename = "targetNfType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_nf_type: Option<NfType>,
        #[serde(
            rename = "targetNsiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub target_nsi_list: Vec<String>,
        #[serde(
            rename = "targetPlmn",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_plmn: Option<PlmnId>,
        #[serde(
            rename = "targetSnpn",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_snpn: Option<PlmnIdNid>,
        #[serde(
            rename = "targetSnssaiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub target_snssai_list: Vec<Snssai>,
    }

    impl From<&AccessTokenReq> for AccessTokenReq {
        fn from(value: &AccessTokenReq) -> Self {
            value.clone()
        }
    }

    ///AccessTokenReqGrantType
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "client_credentials"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AccessTokenReqGrantType {
        #[serde(rename = "client_credentials")]
        ClientCredentials,
    }

    impl From<&AccessTokenReqGrantType> for AccessTokenReqGrantType {
        fn from(value: &AccessTokenReqGrantType) -> Self {
            value.clone()
        }
    }

    impl ToString for AccessTokenReqGrantType {
        fn to_string(&self) -> String {
            match *self {
                Self::ClientCredentials => "client_credentials".to_string(),
            }
        }
    }

    impl std::str::FromStr for AccessTokenReqGrantType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "client_credentials" => Ok(Self::ClientCredentials),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AccessTokenReqGrantType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AccessTokenReqGrantType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AccessTokenReqGrantType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///AccessTokenReqScope
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^([a-zA-Z0-9_:-]+)( [a-zA-Z0-9_:-]+)*$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AccessTokenReqScope(String);
    impl ::std::ops::Deref for AccessTokenReqScope {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AccessTokenReqScope> for String {
        fn from(value: AccessTokenReqScope) -> Self {
            value.0
        }
    }

    impl From<&AccessTokenReqScope> for AccessTokenReqScope {
        fn from(value: &AccessTokenReqScope) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AccessTokenReqScope {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^([a-zA-Z0-9_:-]+)( [a-zA-Z0-9_:-]+)*$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err(
                    "doesn't match pattern \"^([a-zA-Z0-9_:-]+)( [a-zA-Z0-9_:-]+)*$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AccessTokenReqScope {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AccessTokenReqScope {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AccessTokenReqScope {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AccessTokenReqScope {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Indicates whether the access is  via 3GPP or via non-3GPP.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates whether the access is  via 3GPP or via
    /// non-3GPP.",
    ///  "type": "string",
    ///  "enum": [
    ///    "3GPP_ACCESS",
    ///    "NON_3GPP_ACCESS"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AccessType {
        #[serde(rename = "3GPP_ACCESS")]
        ThreeGppAccess,
        #[serde(rename = "NON_3GPP_ACCESS")]
        Non3gppAccess,
    }

    impl From<&AccessType> for AccessType {
        fn from(value: &AccessType) -> Self {
            value.clone()
        }
    }

    impl ToString for AccessType {
        fn to_string(&self) -> String {
            match *self {
                Self::ThreeGppAccess => "3GPP_ACCESS".to_string(),
                Self::Non3gppAccess => "NON_3GPP_ACCESS".to_string(),
            }
        }
    }

    impl std::str::FromStr for AccessType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "3GPP_ACCESS" => Ok(Self::ThreeGppAccess),
                "NON_3GPP_ACCESS" => Ok(Self::Non3gppAccess),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AccessType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AccessType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AccessType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Possible values are:
    /// - LOW: Low accuracy.
    /// - HIGH: High accuracy.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- LOW: Low accuracy.\n- HIGH:
    /// High accuracy.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "LOW",
    ///    "HIGH"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum Accuracy {
        #[serde(rename = "LOW")]
        Low,
        #[serde(rename = "HIGH")]
        High,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&Accuracy> for Accuracy {
        fn from(value: &Accuracy) -> Self {
            value.clone()
        }
    }

    impl ToString for Accuracy {
        fn to_string(&self) -> String {
            match *self {
                Self::Low => "LOW".to_string(),
                Self::High => "HIGH".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for Accuracy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "LOW" => Ok(Self::Low),
                "HIGH" => Ok(Self::High),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for Accuracy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Accuracy {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Accuracy {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates fulfilment of requested accuracy.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates fulfilment of requested accuracy.",
    ///  "type": "string",
    ///  "enum": [
    ///    "REQUESTED_ACCURACY_FULFILLED",
    ///    "REQUESTED_ACCURACY_NOT_FULFILLED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AccuracyFulfilmentIndicator {
        #[serde(rename = "REQUESTED_ACCURACY_FULFILLED")]
        RequestedAccuracyFulfilled,
        #[serde(rename = "REQUESTED_ACCURACY_NOT_FULFILLED")]
        RequestedAccuracyNotFulfilled,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&AccuracyFulfilmentIndicator> for AccuracyFulfilmentIndicator {
        fn from(value: &AccuracyFulfilmentIndicator) -> Self {
            value.clone()
        }
    }

    impl ToString for AccuracyFulfilmentIndicator {
        fn to_string(&self) -> String {
            match *self {
                Self::RequestedAccuracyFulfilled => "REQUESTED_ACCURACY_FULFILLED".to_string(),
                Self::RequestedAccuracyNotFulfilled => {
                    "REQUESTED_ACCURACY_NOT_FULFILLED".to_string()
                }
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for AccuracyFulfilmentIndicator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "REQUESTED_ACCURACY_FULFILLED" => Ok(Self::RequestedAccuracyFulfilled),
                "REQUESTED_ACCURACY_NOT_FULFILLED" => Ok(Self::RequestedAccuracyNotFulfilled),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AccuracyFulfilmentIndicator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AccuracyFulfilmentIndicator {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AccuracyFulfilmentIndicator {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Additional information to be returned in EnableUeReachability error
    /// response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Additional information to be returned in
    /// EnableUeReachability error response",
    ///  "type": "object",
    ///  "properties": {
    ///    "maxWaitingTime": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AdditionInfoEnableUeReachability {
        #[serde(
            rename = "maxWaitingTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_waiting_time: Option<DurationSec>,
    }

    impl From<&AdditionInfoEnableUeReachability> for AdditionInfoEnableUeReachability {
        fn from(value: &AdditionInfoEnableUeReachability) -> Self {
            value.clone()
        }
    }

    ///Represents additional measurement information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents additional measurement information.",
    ///  "type": "object",
    ///  "properties": {
    ///    "circums": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CircumstanceDescription"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "ddosAttack": {
    ///      "$ref": "#/components/schemas/AddressList"
    ///    },
    ///    "unexpFlowTeps": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IpEthFlowDescription"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "unexpLoc": {
    ///      "$ref": "#/components/schemas/NetworkAreaInfo"
    ///    },
    ///    "unexpWakes": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DateTime"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "wrgDest": {
    ///      "$ref": "#/components/schemas/AddressList"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AdditionalMeasurement {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub circums: Vec<CircumstanceDescription>,
        #[serde(
            rename = "ddosAttack",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ddos_attack: Option<AddressList>,
        #[serde(
            rename = "unexpFlowTeps",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub unexp_flow_teps: Vec<IpEthFlowDescription>,
        #[serde(rename = "unexpLoc", default, skip_serializing_if = "Option::is_none")]
        pub unexp_loc: Option<NetworkAreaInfo>,
        #[serde(rename = "unexpWakes", default, skip_serializing_if = "Vec::is_empty")]
        pub unexp_wakes: Vec<DateTime>,
        #[serde(rename = "wrgDest", default, skip_serializing_if = "Option::is_none")]
        pub wrg_dest: Option<AddressList>,
    }

    impl From<&AdditionalMeasurement> for AdditionalMeasurement {
        fn from(value: &AdditionalMeasurement) -> Self {
            value.clone()
        }
    }

    ///IP address and/or FQDN.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "IP address and/or FQDN.",
    ///  "type": "object",
    ///  "properties": {
    ///    "fqdn": {
    ///      "description": "Indicates an FQDN.",
    ///      "type": "string"
    ///    },
    ///    "ipAddr": {
    ///      "$ref": "#/components/schemas/IpAddr"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AddrFqdn {
        ///Indicates an FQDN.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fqdn: Option<String>,
        #[serde(rename = "ipAddr", default, skip_serializing_if = "Option::is_none")]
        pub ip_addr: Option<IpAddr>,
    }

    impl From<&AddrFqdn> for AddrFqdn {
        fn from(value: &AddrFqdn) -> Self {
            value.clone()
        }
    }

    ///Represents a list of IPv4 and/or IPv6 addresses.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a list of IPv4 and/or IPv6 addresses.",
    ///  "type": "object",
    ///  "properties": {
    ///    "ipv4Addrs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Ipv4Addr"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "ipv6Addrs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Ipv6Addr"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AddressList {
        #[serde(rename = "ipv4Addrs", default, skip_serializing_if = "Vec::is_empty")]
        pub ipv4_addrs: Vec<Ipv4Addr>,
        #[serde(rename = "ipv6Addrs", default, skip_serializing_if = "Vec::is_empty")]
        pub ipv6_addrs: Vec<Ipv6Addr>,
    }

    impl From<&AddressList> for AddressList {
        fn from(value: &AddressList) -> Self {
            value.clone()
        }
    }

    ///Indicates value of the age of the location estimate.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates value of the age of the location estimate.",
    ///  "type": "integer",
    ///  "maximum": 32767.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AgeOfLocationEstimate(pub i64);
    impl ::std::ops::Deref for AgeOfLocationEstimate {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<AgeOfLocationEstimate> for i64 {
        fn from(value: AgeOfLocationEstimate) -> Self {
            value.0
        }
    }

    impl From<&AgeOfLocationEstimate> for AgeOfLocationEstimate {
        fn from(value: &AgeOfLocationEstimate) -> Self {
            value.clone()
        }
    }

    impl From<i64> for AgeOfLocationEstimate {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for AgeOfLocationEstimate {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for AgeOfLocationEstimate {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AgeOfLocationEstimate {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AgeOfLocationEstimate {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for AgeOfLocationEstimate {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Alert Limit.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Alert Limit.",
    ///  "type": "object",
    ///  "required": [
    ///    "horizontalProtectionLevel"
    ///  ],
    ///  "properties": {
    ///    "horizontalProtectionLevel": {
    ///      "$ref": "#/components/schemas/HorizontalProtectionLevel"
    ///    },
    ///    "verticalProtectionLevel": {
    ///      "$ref": "#/components/schemas/VerticalProtectionLevel"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AlertLimit {
        #[serde(rename = "horizontalProtectionLevel")]
        pub horizontal_protection_level: HorizontalProtectionLevel,
        #[serde(
            rename = "verticalProtectionLevel",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub vertical_protection_level: Option<VerticalProtectionLevel>,
    }

    impl From<&AlertLimit> for AlertLimit {
        fn from(value: &AlertLimit) -> Self {
            value.clone()
        }
    }

    ///Contains an array of allowed S-NSSAI that constitute the allowed NSSAI
    /// information for the authorized network slice information
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains an array of allowed S-NSSAI that constitute
    /// the allowed NSSAI information for the authorized network slice
    /// information\n",
    ///  "type": "object",
    ///  "required": [
    ///    "accessType",
    ///    "allowedSnssaiList"
    ///  ],
    ///  "properties": {
    ///    "accessType": {
    ///      "$ref": "#/components/schemas/AccessType"
    ///    },
    ///    "allowedSnssaiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AllowedSnssai"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AllowedNssai {
        #[serde(rename = "accessType")]
        pub access_type: AccessType,
        #[serde(rename = "allowedSnssaiList")]
        pub allowed_snssai_list: Vec<AllowedSnssai>,
    }

    impl From<&AllowedNssai> for AllowedNssai {
        fn from(value: &AllowedNssai) -> Self {
            value.clone()
        }
    }

    ///Contains the authorized S-NSSAI and optional mapped home S-NSSAI and
    /// network slice instance information
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the authorized S-NSSAI and optional mapped
    /// home S-NSSAI and network slice instance information\n",
    ///  "type": "object",
    ///  "required": [
    ///    "allowedSnssai"
    ///  ],
    ///  "properties": {
    ///    "allowedSnssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "mappedHomeSnssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "nsiInformationList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NsiInformation"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AllowedSnssai {
        #[serde(rename = "allowedSnssai")]
        pub allowed_snssai: Snssai,
        #[serde(
            rename = "mappedHomeSnssai",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub mapped_home_snssai: Option<Snssai>,
        #[serde(
            rename = "nsiInformationList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub nsi_information_list: Vec<NsiInformation>,
    }

    impl From<&AllowedSnssai> for AllowedSnssai {
        fn from(value: &AllowedSnssai) -> Self {
            value.clone()
        }
    }

    ///Altitude
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates value of altitude.",
    ///  "type": "number",
    ///  "format": "double",
    ///  "maximum": 32767.0,
    ///  "minimum": -32767.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Altitude(pub f64);
    impl ::std::ops::Deref for Altitude {
        type Target = f64;
        fn deref(&self) -> &f64 {
            &self.0
        }
    }

    impl From<Altitude> for f64 {
        fn from(value: Altitude) -> Self {
            value.0
        }
    }

    impl From<&Altitude> for Altitude {
        fn from(value: &Altitude) -> Self {
            value.clone()
        }
    }

    impl From<f64> for Altitude {
        fn from(value: f64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for Altitude {
        type Err = <f64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for Altitude {
        type Error = <f64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Altitude {
        type Error = <f64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Altitude {
        type Error = <f64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for Altitude {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Contains the maximum aggregated uplink and downlink bit rates.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the maximum aggregated uplink and downlink bit
    /// rates.",
    ///  "type": "object",
    ///  "required": [
    ///    "downlink",
    ///    "uplink"
    ///  ],
    ///  "properties": {
    ///    "downlink": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "uplink": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Ambr {
        pub downlink: BitRate,
        pub uplink: BitRate,
    }

    impl From<&Ambr> for Ambr {
        fn from(value: &Ambr) -> Self {
            value.clone()
        }
    }

    ///Data within a create AMF event subscription request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a create AMF event subscription request",
    ///  "type": "object",
    ///  "required": [
    ///    "subscription"
    ///  ],
    ///  "properties": {
    ///    "oldGuami": {
    ///      "$ref": "#/components/schemas/Guami"
    ///    },
    ///    "subscription": {
    ///      "$ref": "#/components/schemas/AmfEventSubscription"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfCreateEventSubscription {
        #[serde(rename = "oldGuami", default, skip_serializing_if = "Option::is_none")]
        pub old_guami: Option<Guami>,
        pub subscription: AmfEventSubscription,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
    }

    impl From<&AmfCreateEventSubscription> for AmfCreateEventSubscription {
        fn from(value: &AmfCreateEventSubscription) -> Self {
            value.clone()
        }
    }

    ///Data within a create AMF event subscription response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a create AMF event subscription response",
    ///  "type": "object",
    ///  "required": [
    ///    "subscription",
    ///    "subscriptionId"
    ///  ],
    ///  "properties": {
    ///    "reportList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AmfEventReport"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "subscription": {
    ///      "$ref": "#/components/schemas/AmfEventSubscription"
    ///    },
    ///    "subscriptionId": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfCreatedEventSubscription {
        #[serde(rename = "reportList", default, skip_serializing_if = "Vec::is_empty")]
        pub report_list: Vec<AmfEventReport>,
        pub subscription: AmfEventSubscription,
        #[serde(rename = "subscriptionId")]
        pub subscription_id: Uri,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
    }

    impl From<&AmfCreatedEventSubscription> for AmfCreatedEventSubscription {
        fn from(value: &AmfCreatedEventSubscription) -> Self {
            value.clone()
        }
    }

    ///Describes an event to be subscribed
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes an event to be subscribed",
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "areaList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AmfEventArea"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "dispersionArea": {
    ///      "$ref": "#/components/schemas/DispersionArea"
    ///    },
    ///    "idleStatusInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "immediateFlag": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "locationFilterList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LocationFilter"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "maxReports": {
    ///      "type": "integer"
    ///    },
    ///    "maxResponseTime": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "minInterval": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "nextPeriodicReportTime": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "nextReport": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "presenceInfoList": {
    ///      "description": "A map(list of key-value pairs) where praId serves
    /// as key.",
    ///      "type": "object",
    ///      "minProperties": 1,
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/PresenceInfo"
    ///      }
    ///    },
    ///    "reachabilityFilter": {
    ///      "$ref": "#/components/schemas/ReachabilityFilter"
    ///    },
    ///    "refId": {
    ///      "$ref": "#/components/schemas/ReferenceId"
    ///    },
    ///    "reportUeReachable": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "snssaiFilter": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ExtSnssai"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "targetArea": {
    ///      "$ref": "#/components/schemas/TargetArea"
    ///    },
    ///    "trafficDescriptorList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TrafficDescriptor"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/AmfEventType"
    ///    },
    ///    "udmDetectInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "ueInAreaFilter": {
    ///      "$ref": "#/components/schemas/UeInAreaFilter"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfEvent {
        #[serde(rename = "areaList", default, skip_serializing_if = "Vec::is_empty")]
        pub area_list: Vec<AmfEventArea>,
        #[serde(
            rename = "dispersionArea",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub dispersion_area: Option<DispersionArea>,
        #[serde(rename = "idleStatusInd", default)]
        pub idle_status_ind: bool,
        #[serde(rename = "immediateFlag", default)]
        pub immediate_flag: bool,
        #[serde(
            rename = "locationFilterList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub location_filter_list: Vec<LocationFilter>,
        #[serde(
            rename = "maxReports",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_reports: Option<i64>,
        #[serde(
            rename = "maxResponseTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_response_time: Option<DurationSec>,
        #[serde(
            rename = "minInterval",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub min_interval: Option<DurationSec>,
        #[serde(
            rename = "nextPeriodicReportTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub next_periodic_report_time: Option<DateTime>,
        #[serde(
            rename = "nextReport",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub next_report: Option<DateTime>,
        ///A map(list of key-value pairs) where praId serves as key.
        #[serde(
            rename = "presenceInfoList",
            default,
            skip_serializing_if = "::std::collections::HashMap::is_empty"
        )]
        pub presence_info_list: ::std::collections::HashMap<String, PresenceInfo>,
        #[serde(
            rename = "reachabilityFilter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub reachability_filter: Option<ReachabilityFilter>,
        #[serde(rename = "refId", default, skip_serializing_if = "Option::is_none")]
        pub ref_id: Option<ReferenceId>,
        #[serde(rename = "reportUeReachable", default)]
        pub report_ue_reachable: bool,
        #[serde(
            rename = "snssaiFilter",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub snssai_filter: Vec<ExtSnssai>,
        #[serde(
            rename = "targetArea",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_area: Option<TargetArea>,
        #[serde(
            rename = "trafficDescriptorList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub traffic_descriptor_list: Vec<TrafficDescriptor>,
        #[serde(rename = "type")]
        pub type_: AmfEventType,
        #[serde(rename = "udmDetectInd", default)]
        pub udm_detect_ind: bool,
        #[serde(
            rename = "ueInAreaFilter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_in_area_filter: Option<UeInAreaFilter>,
    }

    impl From<&AmfEvent> for AmfEvent {
        fn from(value: &AmfEvent) -> Self {
            value.clone()
        }
    }

    ///Represents an area to be monitored by an AMF event
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents an area to be monitored by an AMF event",
    ///  "type": "object",
    ///  "properties": {
    ///    "ladnInfo": {
    ///      "$ref": "#/components/schemas/LadnInfo"
    ///    },
    ///    "nsiId": {
    ///      "$ref": "#/components/schemas/NsiId"
    ///    },
    ///    "presenceInfo": {
    ///      "$ref": "#/components/schemas/PresenceInfo"
    ///    },
    ///    "sNssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfEventArea {
        #[serde(rename = "ladnInfo", default, skip_serializing_if = "Option::is_none")]
        pub ladn_info: Option<LadnInfo>,
        #[serde(rename = "nsiId", default, skip_serializing_if = "Option::is_none")]
        pub nsi_id: Option<NsiId>,
        #[serde(
            rename = "presenceInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub presence_info: Option<PresenceInfo>,
        #[serde(rename = "sNssai", default, skip_serializing_if = "Option::is_none")]
        pub s_nssai: Option<Snssai>,
    }

    impl From<&AmfEventArea> for AmfEventArea {
        fn from(value: &AmfEventArea) -> Self {
            value.clone()
        }
    }

    ///Describes how the reports shall be generated by a subscribed event
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes how the reports shall be generated by a
    /// subscribed event",
    ///  "type": "object",
    ///  "required": [
    ///    "trigger"
    ///  ],
    ///  "properties": {
    ///    "expiry": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "maxReports": {
    ///      "type": "integer"
    ///    },
    ///    "notifFlag": {
    ///      "$ref": "#/components/schemas/NotificationFlag"
    ///    },
    ///    "partitioningCriteria": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PartitioningCriteria"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "repPeriod": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "sampRatio": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    },
    ///    "trigger": {
    ///      "$ref": "#/components/schemas/AmfEventTrigger"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfEventMode {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub expiry: Option<DateTime>,
        #[serde(
            rename = "maxReports",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_reports: Option<i64>,
        #[serde(rename = "notifFlag", default, skip_serializing_if = "Option::is_none")]
        pub notif_flag: Option<NotificationFlag>,
        #[serde(
            rename = "partitioningCriteria",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub partitioning_criteria: Vec<PartitioningCriteria>,
        #[serde(rename = "repPeriod", default, skip_serializing_if = "Option::is_none")]
        pub rep_period: Option<DurationSec>,
        #[serde(rename = "sampRatio", default, skip_serializing_if = "Option::is_none")]
        pub samp_ratio: Option<SamplingRatio>,
        pub trigger: AmfEventTrigger,
    }

    impl From<&AmfEventMode> for AmfEventMode {
        fn from(value: &AmfEventMode) -> Self {
            value.clone()
        }
    }

    ///Data within a AMF Event Notification request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a AMF Event Notification request",
    ///  "type": "object",
    ///  "properties": {
    ///    "eventSubsSyncInfo": {
    ///      "$ref": "#/components/schemas/AmfEventSubsSyncInfo"
    ///    },
    ///    "notifyCorrelationId": {
    ///      "type": "string"
    ///    },
    ///    "reportList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AmfEventReport"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "subsChangeNotifyCorrelationId": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfEventNotification {
        #[serde(
            rename = "eventSubsSyncInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub event_subs_sync_info: Option<AmfEventSubsSyncInfo>,
        #[serde(
            rename = "notifyCorrelationId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub notify_correlation_id: Option<String>,
        #[serde(rename = "reportList", default, skip_serializing_if = "Vec::is_empty")]
        pub report_list: Vec<AmfEventReport>,
        #[serde(
            rename = "subsChangeNotifyCorrelationId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub subs_change_notify_correlation_id: Option<String>,
    }

    impl From<&AmfEventNotification> for AmfEventNotification {
        fn from(value: &AmfEventNotification) -> Self {
            value.clone()
        }
    }

    ///Represents a report triggered by a subscribed event type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a report triggered by a subscribed event
    /// type",
    ///  "type": "object",
    ///  "required": [
    ///    "state",
    ///    "timeStamp",
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "5gsUserStateList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/5GsUserStateInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "accessTypeList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AccessType"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "additionalLocation": {
    ///      "$ref": "#/components/schemas/UserLocation"
    ///    },
    ///    "anyUe": {
    ///      "type": "boolean"
    ///    },
    ///    "areaList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AmfEventArea"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "cmInfoList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CmInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "commFailure": {
    ///      "$ref": "#/components/schemas/CommunicationFailure"
    ///    },
    ///    "gpsi": {
    ///      "$ref": "#/components/schemas/Gpsi"
    ///    },
    ///    "idleStatusIndication": {
    ///      "$ref": "#/components/schemas/IdleStatusIndication"
    ///    },
    ///    "location": {
    ///      "$ref": "#/components/schemas/UserLocation"
    ///    },
    ///    "lossOfConnectReason": {
    ///      "$ref": "#/components/schemas/LossOfConnectivityReason"
    ///    },
    ///    "maxAvailabilityTime": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "mmTransLocationReportList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/MmTransactionLocationReportItem"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "mmTransSliceReportList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/MmTransactionSliceReportItem"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "numberOfUes": {
    ///      "type": "integer"
    ///    },
    ///    "pei": {
    ///      "$ref": "#/components/schemas/Pei"
    ///    },
    ///    "reachability": {
    ///      "$ref": "#/components/schemas/UeReachability"
    ///    },
    ///    "refId": {
    ///      "$ref": "#/components/schemas/ReferenceId"
    ///    },
    ///    "registrationNumber": {
    ///      "type": "integer"
    ///    },
    ///    "rmInfoList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RmInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "snssaiTaiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SnssaiTaiMapping"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "state": {
    ///      "$ref": "#/components/schemas/AmfEventState"
    ///    },
    ///    "subscriptionId": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "supi": {
    ///      "$ref": "#/components/schemas/Supi"
    ///    },
    ///    "timeStamp": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "timezone": {
    ///      "$ref": "#/components/schemas/TimeZone"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/AmfEventType"
    ///    },
    ///    "typeCode": {
    ///      "type": "string",
    ///      "pattern": "^imeitac-[0-9]{8}$"
    ///    },
    ///    "ueAccessBehaviorTrends": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UeAccessBehaviorReportItem"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "ueIdExt": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UEIdExt"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "ueLocationTrends": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UeLocationTrendsReportItem"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfEventReport {
        #[serde(
            rename = "accessTypeList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub access_type_list: Vec<AccessType>,
        #[serde(
            rename = "additionalLocation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub additional_location: Option<UserLocation>,
        #[serde(rename = "anyUe", default, skip_serializing_if = "Option::is_none")]
        pub any_ue: Option<bool>,
        #[serde(rename = "areaList", default, skip_serializing_if = "Vec::is_empty")]
        pub area_list: Vec<AmfEventArea>,
        #[serde(rename = "cmInfoList", default, skip_serializing_if = "Vec::is_empty")]
        pub cm_info_list: Vec<CmInfo>,
        #[serde(
            rename = "commFailure",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub comm_failure: Option<CommunicationFailure>,
        #[serde(
            rename = "5gsUserStateList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub five_gs_user_state_list: Vec<_5gsUserStateInfo>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub gpsi: Option<Gpsi>,
        #[serde(
            rename = "idleStatusIndication",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub idle_status_indication: Option<IdleStatusIndication>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub location: Option<UserLocation>,
        #[serde(
            rename = "lossOfConnectReason",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub loss_of_connect_reason: Option<LossOfConnectivityReason>,
        #[serde(
            rename = "maxAvailabilityTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_availability_time: Option<DateTime>,
        #[serde(
            rename = "mmTransLocationReportList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub mm_trans_location_report_list: Vec<MmTransactionLocationReportItem>,
        #[serde(
            rename = "mmTransSliceReportList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub mm_trans_slice_report_list: Vec<MmTransactionSliceReportItem>,
        #[serde(
            rename = "numberOfUes",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub number_of_ues: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pei: Option<Pei>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reachability: Option<UeReachability>,
        #[serde(rename = "refId", default, skip_serializing_if = "Option::is_none")]
        pub ref_id: Option<ReferenceId>,
        #[serde(
            rename = "registrationNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub registration_number: Option<i64>,
        #[serde(rename = "rmInfoList", default, skip_serializing_if = "Vec::is_empty")]
        pub rm_info_list: Vec<RmInfo>,
        #[serde(
            rename = "snssaiTaiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub snssai_tai_list: Vec<SnssaiTaiMapping>,
        pub state: AmfEventState,
        #[serde(
            rename = "subscriptionId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub subscription_id: Option<Uri>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub supi: Option<Supi>,
        #[serde(rename = "timeStamp")]
        pub time_stamp: DateTime,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub timezone: Option<TimeZone>,
        #[serde(rename = "type")]
        pub type_: AmfEventType,
        #[serde(rename = "typeCode", default, skip_serializing_if = "Option::is_none")]
        pub type_code: Option<AmfEventReportTypeCode>,
        #[serde(
            rename = "ueAccessBehaviorTrends",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub ue_access_behavior_trends: Vec<UeAccessBehaviorReportItem>,
        #[serde(rename = "ueIdExt", default, skip_serializing_if = "Vec::is_empty")]
        pub ue_id_ext: Vec<UeIdExt>,
        #[serde(
            rename = "ueLocationTrends",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub ue_location_trends: Vec<UeLocationTrendsReportItem>,
    }

    impl From<&AmfEventReport> for AmfEventReport {
        fn from(value: &AmfEventReport) -> Self {
            value.clone()
        }
    }

    ///AmfEventReportTypeCode
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^imeitac-[0-9]{8}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AmfEventReportTypeCode(String);
    impl ::std::ops::Deref for AmfEventReportTypeCode {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AmfEventReportTypeCode> for String {
        fn from(value: AmfEventReportTypeCode) -> Self {
            value.0
        }
    }

    impl From<&AmfEventReportTypeCode> for AmfEventReportTypeCode {
        fn from(value: &AmfEventReportTypeCode) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AmfEventReportTypeCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^imeitac-[0-9]{8}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^imeitac-[0-9]{8}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AmfEventReportTypeCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AmfEventReportTypeCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AmfEventReportTypeCode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AmfEventReportTypeCode {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Represents the state of a subscribed event
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the state of a subscribed event",
    ///  "type": "object",
    ///  "required": [
    ///    "active"
    ///  ],
    ///  "properties": {
    ///    "active": {
    ///      "type": "boolean"
    ///    },
    ///    "remainDuration": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "remainReports": {
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfEventState {
        pub active: bool,
        #[serde(
            rename = "remainDuration",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub remain_duration: Option<DurationSec>,
        #[serde(
            rename = "remainReports",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub remain_reports: Option<i64>,
    }

    impl From<&AmfEventState> for AmfEventState {
        fn from(value: &AmfEventState) -> Self {
            value.clone()
        }
    }

    ///AMF Event Subscriptions Information for synchronization
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "AMF Event Subscriptions Information for
    /// synchronization",
    ///  "type": "object",
    ///  "required": [
    ///    "subscriptionList"
    ///  ],
    ///  "properties": {
    ///    "subscriptionList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AmfEventSubscriptionInfo"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfEventSubsSyncInfo {
        #[serde(rename = "subscriptionList")]
        pub subscription_list: Vec<AmfEventSubscriptionInfo>,
    }

    impl From<&AmfEventSubsSyncInfo> for AmfEventSubsSyncInfo {
        fn from(value: &AmfEventSubsSyncInfo) -> Self {
            value.clone()
        }
    }

    ///Represents an individual event subscription resource on AMF
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents an individual event subscription resource on
    /// AMF",
    ///  "type": "object",
    ///  "required": [
    ///    "eventList",
    ///    "eventNotifyUri",
    ///    "nfId",
    ///    "notifyCorrelationId"
    ///  ],
    ///  "properties": {
    ///    "anyUE": {
    ///      "type": "boolean"
    ///    },
    ///    "eventList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AmfEvent"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "eventNotifyUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "excludeGpsiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Gpsi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "excludeSupiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "gpsi": {
    ///      "$ref": "#/components/schemas/Gpsi"
    ///    },
    ///    "groupId": {
    ///      "$ref": "#/components/schemas/GroupId"
    ///    },
    ///    "includeGpsiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Gpsi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "includeSupiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "nfId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "notifyCorrelationId": {
    ///      "type": "string"
    ///    },
    ///    "options": {
    ///      "$ref": "#/components/schemas/AmfEventMode"
    ///    },
    ///    "pei": {
    ///      "$ref": "#/components/schemas/Pei"
    ///    },
    ///    "sourceNfType": {
    ///      "$ref": "#/components/schemas/NFType"
    ///    },
    ///    "subsChangeNotifyCorrelationId": {
    ///      "type": "string"
    ///    },
    ///    "subsChangeNotifyUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "supi": {
    ///      "$ref": "#/components/schemas/Supi"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfEventSubscription {
        #[serde(rename = "anyUE", default, skip_serializing_if = "Option::is_none")]
        pub any_ue: Option<bool>,
        #[serde(rename = "eventList")]
        pub event_list: Vec<AmfEvent>,
        #[serde(rename = "eventNotifyUri")]
        pub event_notify_uri: Uri,
        #[serde(
            rename = "excludeGpsiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub exclude_gpsi_list: Vec<Gpsi>,
        #[serde(
            rename = "excludeSupiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub exclude_supi_list: Vec<Supi>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub gpsi: Option<Gpsi>,
        #[serde(rename = "groupId", default, skip_serializing_if = "Option::is_none")]
        pub group_id: Option<GroupId>,
        #[serde(
            rename = "includeGpsiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub include_gpsi_list: Vec<Gpsi>,
        #[serde(
            rename = "includeSupiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub include_supi_list: Vec<Supi>,
        #[serde(rename = "nfId")]
        pub nf_id: NfInstanceId,
        #[serde(rename = "notifyCorrelationId")]
        pub notify_correlation_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub options: Option<AmfEventMode>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pei: Option<Pei>,
        #[serde(
            rename = "sourceNfType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub source_nf_type: Option<NfType>,
        #[serde(
            rename = "subsChangeNotifyCorrelationId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub subs_change_notify_correlation_id: Option<String>,
        #[serde(
            rename = "subsChangeNotifyUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub subs_change_notify_uri: Option<Uri>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub supi: Option<Supi>,
    }

    impl From<&AmfEventSubscription> for AmfEventSubscription {
        fn from(value: &AmfEventSubscription) -> Self {
            value.clone()
        }
    }

    ///Additional information received for an AMF event subscription, e.g.
    /// binding indications
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Additional information received for an AMF event
    /// subscription, e.g. binding indications",
    ///  "type": "object",
    ///  "properties": {
    ///    "aoiStateList": {
    ///      "description": "Map of subscribed Area of Interest (AoI) Event
    /// State in the old AMF. The JSON pointer to an AmfEventArea element in the
    /// areaList IE (or a PresenceInfo element in  presenceInfoList IE) of the
    /// AmfEvent data type shall be the key of the map.\n",
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/AreaOfInterestEventState"
    ///      }
    ///    },
    ///    "bindingInfo": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      },
    ///      "maxItems": 2,
    ///      "minItems": 1
    ///    },
    ///    "eventSyncInd": {
    ///      "type": "boolean"
    ///    },
    ///    "nfConsumerInfo": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "subscribingNfType": {
    ///      "$ref": "#/components/schemas/NFType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfEventSubscriptionAddInfo {
        ///Map of subscribed Area of Interest (AoI) Event State in the old AMF.
        /// The JSON pointer to an AmfEventArea element in the areaList IE (or a
        /// PresenceInfo element in  presenceInfoList IE) of the AmfEvent data
        /// type shall be the key of the map.
        #[serde(
            rename = "aoiStateList",
            default,
            skip_serializing_if = "::std::collections::HashMap::is_empty"
        )]
        pub aoi_state_list: ::std::collections::HashMap<String, AreaOfInterestEventState>,
        #[serde(rename = "bindingInfo", default, skip_serializing_if = "Vec::is_empty")]
        pub binding_info: Vec<String>,
        #[serde(
            rename = "eventSyncInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub event_sync_ind: Option<bool>,
        #[serde(
            rename = "nfConsumerInfo",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub nf_consumer_info: Vec<String>,
        #[serde(
            rename = "subscribingNfType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub subscribing_nf_type: Option<NfType>,
    }

    impl From<&AmfEventSubscriptionAddInfo> for AmfEventSubscriptionAddInfo {
        fn from(value: &AmfEventSubscriptionAddInfo) -> Self {
            value.clone()
        }
    }

    ///Individual AMF Event Subscription Information
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Individual AMF Event Subscription Information",
    ///  "type": "object",
    ///  "required": [
    ///    "refIdList",
    ///    "subId"
    ///  ],
    ///  "properties": {
    ///    "notifyCorrelationId": {
    ///      "type": "string"
    ///    },
    ///    "oldSubId": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "refIdList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ReferenceId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "subId": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfEventSubscriptionInfo {
        #[serde(
            rename = "notifyCorrelationId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub notify_correlation_id: Option<String>,
        #[serde(rename = "oldSubId", default, skip_serializing_if = "Option::is_none")]
        pub old_sub_id: Option<Uri>,
        #[serde(rename = "refIdList")]
        pub ref_id_list: Vec<ReferenceId>,
        #[serde(rename = "subId")]
        pub sub_id: Uri,
    }

    impl From<&AmfEventSubscriptionInfo> for AmfEventSubscriptionInfo {
        fn from(value: &AmfEventSubscriptionInfo) -> Self {
            value.clone()
        }
    }

    ///Describes how AMF should generate the report for the event
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes how AMF should generate the report for the
    /// event",
    ///  "type": "string",
    ///  "enum": [
    ///    "ONE_TIME",
    ///    "CONTINUOUS",
    ///    "PERIODIC"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AmfEventTrigger {
        #[serde(rename = "ONE_TIME")]
        OneTime,
        #[serde(rename = "CONTINUOUS")]
        Continuous,
        #[serde(rename = "PERIODIC")]
        Periodic,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&AmfEventTrigger> for AmfEventTrigger {
        fn from(value: &AmfEventTrigger) -> Self {
            value.clone()
        }
    }

    impl ToString for AmfEventTrigger {
        fn to_string(&self) -> String {
            match *self {
                Self::OneTime => "ONE_TIME".to_string(),
                Self::Continuous => "CONTINUOUS".to_string(),
                Self::Periodic => "PERIODIC".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for AmfEventTrigger {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ONE_TIME" => Ok(Self::OneTime),
                "CONTINUOUS" => Ok(Self::Continuous),
                "PERIODIC" => Ok(Self::Periodic),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AmfEventTrigger {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AmfEventTrigger {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AmfEventTrigger {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Describes the supported event types of Namf_EventExposure Service
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the supported event types of
    /// Namf_EventExposure Service",
    ///  "type": "string",
    ///  "enum": [
    ///    "LOCATION_REPORT",
    ///    "PRESENCE_IN_AOI_REPORT",
    ///    "TIMEZONE_REPORT",
    ///    "ACCESS_TYPE_REPORT",
    ///    "REGISTRATION_STATE_REPORT",
    ///    "CONNECTIVITY_STATE_REPORT",
    ///    "REACHABILITY_REPORT",
    ///    "COMMUNICATION_FAILURE_REPORT",
    ///    "UES_IN_AREA_REPORT",
    ///    "SUBSCRIPTION_ID_CHANGE",
    ///    "SUBSCRIPTION_ID_ADDITION",
    ///    "LOSS_OF_CONNECTIVITY",
    ///    "5GS_USER_STATE_REPORT",
    ///    "AVAILABILITY_AFTER_DDN_FAILURE",
    ///    "TYPE_ALLOCATION_CODE_REPORT",
    ///    "FREQUENT_MOBILITY_REGISTRATION_REPORT",
    ///    "SNSSAI_TA_MAPPING_REPORT",
    ///    "UE_LOCATION_TRENDS",
    ///    "UE_ACCESS_BEHAVIOR_TRENDS",
    ///    "UE_MM_TRANSACTION_REPORT"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AmfEventType {
        #[serde(rename = "LOCATION_REPORT")]
        LocationReport,
        #[serde(rename = "PRESENCE_IN_AOI_REPORT")]
        PresenceInAoiReport,
        #[serde(rename = "TIMEZONE_REPORT")]
        TimezoneReport,
        #[serde(rename = "ACCESS_TYPE_REPORT")]
        AccessTypeReport,
        #[serde(rename = "REGISTRATION_STATE_REPORT")]
        RegistrationStateReport,
        #[serde(rename = "CONNECTIVITY_STATE_REPORT")]
        ConnectivityStateReport,
        #[serde(rename = "REACHABILITY_REPORT")]
        ReachabilityReport,
        #[serde(rename = "COMMUNICATION_FAILURE_REPORT")]
        CommunicationFailureReport,
        #[serde(rename = "UES_IN_AREA_REPORT")]
        UesInAreaReport,
        #[serde(rename = "SUBSCRIPTION_ID_CHANGE")]
        SubscriptionIdChange,
        #[serde(rename = "SUBSCRIPTION_ID_ADDITION")]
        SubscriptionIdAddition,
        #[serde(rename = "LOSS_OF_CONNECTIVITY")]
        LossOfConnectivity,
        #[serde(rename = "5GS_USER_STATE_REPORT")]
        FiveGsUserStateReport,
        #[serde(rename = "AVAILABILITY_AFTER_DDN_FAILURE")]
        AvailabilityAfterDdnFailure,
        #[serde(rename = "TYPE_ALLOCATION_CODE_REPORT")]
        TypeAllocationCodeReport,
        #[serde(rename = "FREQUENT_MOBILITY_REGISTRATION_REPORT")]
        FrequentMobilityRegistrationReport,
        #[serde(rename = "SNSSAI_TA_MAPPING_REPORT")]
        SnssaiTaMappingReport,
        #[serde(rename = "UE_LOCATION_TRENDS")]
        UeLocationTrends,
        #[serde(rename = "UE_ACCESS_BEHAVIOR_TRENDS")]
        UeAccessBehaviorTrends,
        #[serde(rename = "UE_MM_TRANSACTION_REPORT")]
        UeMmTransactionReport,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&AmfEventType> for AmfEventType {
        fn from(value: &AmfEventType) -> Self {
            value.clone()
        }
    }

    impl ToString for AmfEventType {
        fn to_string(&self) -> String {
            match *self {
                Self::LocationReport => "LOCATION_REPORT".to_string(),
                Self::PresenceInAoiReport => "PRESENCE_IN_AOI_REPORT".to_string(),
                Self::TimezoneReport => "TIMEZONE_REPORT".to_string(),
                Self::AccessTypeReport => "ACCESS_TYPE_REPORT".to_string(),
                Self::RegistrationStateReport => "REGISTRATION_STATE_REPORT".to_string(),
                Self::ConnectivityStateReport => "CONNECTIVITY_STATE_REPORT".to_string(),
                Self::ReachabilityReport => "REACHABILITY_REPORT".to_string(),
                Self::CommunicationFailureReport => "COMMUNICATION_FAILURE_REPORT".to_string(),
                Self::UesInAreaReport => "UES_IN_AREA_REPORT".to_string(),
                Self::SubscriptionIdChange => "SUBSCRIPTION_ID_CHANGE".to_string(),
                Self::SubscriptionIdAddition => "SUBSCRIPTION_ID_ADDITION".to_string(),
                Self::LossOfConnectivity => "LOSS_OF_CONNECTIVITY".to_string(),
                Self::FiveGsUserStateReport => "5GS_USER_STATE_REPORT".to_string(),
                Self::AvailabilityAfterDdnFailure => "AVAILABILITY_AFTER_DDN_FAILURE".to_string(),
                Self::TypeAllocationCodeReport => "TYPE_ALLOCATION_CODE_REPORT".to_string(),
                Self::FrequentMobilityRegistrationReport => {
                    "FREQUENT_MOBILITY_REGISTRATION_REPORT".to_string()
                }
                Self::SnssaiTaMappingReport => "SNSSAI_TA_MAPPING_REPORT".to_string(),
                Self::UeLocationTrends => "UE_LOCATION_TRENDS".to_string(),
                Self::UeAccessBehaviorTrends => "UE_ACCESS_BEHAVIOR_TRENDS".to_string(),
                Self::UeMmTransactionReport => "UE_MM_TRANSACTION_REPORT".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for AmfEventType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "LOCATION_REPORT" => Ok(Self::LocationReport),
                "PRESENCE_IN_AOI_REPORT" => Ok(Self::PresenceInAoiReport),
                "TIMEZONE_REPORT" => Ok(Self::TimezoneReport),
                "ACCESS_TYPE_REPORT" => Ok(Self::AccessTypeReport),
                "REGISTRATION_STATE_REPORT" => Ok(Self::RegistrationStateReport),
                "CONNECTIVITY_STATE_REPORT" => Ok(Self::ConnectivityStateReport),
                "REACHABILITY_REPORT" => Ok(Self::ReachabilityReport),
                "COMMUNICATION_FAILURE_REPORT" => Ok(Self::CommunicationFailureReport),
                "UES_IN_AREA_REPORT" => Ok(Self::UesInAreaReport),
                "SUBSCRIPTION_ID_CHANGE" => Ok(Self::SubscriptionIdChange),
                "SUBSCRIPTION_ID_ADDITION" => Ok(Self::SubscriptionIdAddition),
                "LOSS_OF_CONNECTIVITY" => Ok(Self::LossOfConnectivity),
                "_5GS_USER_STATE_REPORT" => Ok(Self::FiveGsUserStateReport),
                "AVAILABILITY_AFTER_DDN_FAILURE" => Ok(Self::AvailabilityAfterDdnFailure),
                "TYPE_ALLOCATION_CODE_REPORT" => Ok(Self::TypeAllocationCodeReport),
                "FREQUENT_MOBILITY_REGISTRATION_REPORT" => {
                    Ok(Self::FrequentMobilityRegistrationReport)
                }
                "SNSSAI_TA_MAPPING_REPORT" => Ok(Self::SnssaiTaMappingReport),
                "UE_LOCATION_TRENDS" => Ok(Self::UeLocationTrends),
                "UE_ACCESS_BEHAVIOR_TRENDS" => Ok(Self::UeAccessBehaviorTrends),
                "UE_MM_TRANSACTION_REPORT" => Ok(Self::UeMmTransactionReport),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AmfEventType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AmfEventType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AmfEventType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///String identifying the AMF ID composed of AMF Region ID (8 bits), AMF
    /// Set ID (10 bits) and AMF  Pointer (6 bits) as specified in clause 2.10.1
    /// of 3GPP TS 23.003. It is encoded as a string of  6 hexadecimal
    /// characters (i.e., 24 bits).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String identifying the AMF ID composed of AMF Region ID
    /// (8 bits), AMF Set ID (10 bits) and AMF  Pointer (6 bits) as specified in
    /// clause 2.10.1 of 3GPP TS 23.003. It is encoded as a string of  6
    /// hexadecimal characters (i.e., 24 bits). \n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{6}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AmfId(String);
    impl ::std::ops::Deref for AmfId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AmfId> for String {
        fn from(value: AmfId) -> Self {
            value.0
        }
    }

    impl From<&AmfId> for AmfId {
        fn from(value: &AmfId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AmfId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{6}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{6}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AmfId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AmfId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AmfId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AmfId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Data within an AMF Status Change Notification request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within an AMF Status Change Notification request",
    ///  "type": "object",
    ///  "required": [
    ///    "amfStatusInfoList"
    ///  ],
    ///  "properties": {
    ///    "amfStatusInfoList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AmfStatusInfo"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfStatusChangeNotification {
        #[serde(rename = "amfStatusInfoList")]
        pub amf_status_info_list: Vec<AmfStatusInfo>,
    }

    impl From<&AmfStatusChangeNotification> for AmfStatusChangeNotification {
        fn from(value: &AmfStatusChangeNotification) -> Self {
            value.clone()
        }
    }

    ///AMF Status Information
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "AMF Status Information",
    ///  "type": "object",
    ///  "required": [
    ///    "guamiList",
    ///    "statusChange"
    ///  ],
    ///  "properties": {
    ///    "guamiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Guami"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "statusChange": {
    ///      "$ref": "#/components/schemas/StatusChange"
    ///    },
    ///    "targetAmfFailure": {
    ///      "$ref": "#/components/schemas/Fqdn"
    ///    },
    ///    "targetAmfRemoval": {
    ///      "$ref": "#/components/schemas/Fqdn"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfStatusInfo {
        #[serde(rename = "guamiList")]
        pub guami_list: Vec<Guami>,
        #[serde(rename = "statusChange")]
        pub status_change: StatusChange,
        #[serde(
            rename = "targetAmfFailure",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_amf_failure: Option<Fqdn>,
        #[serde(
            rename = "targetAmfRemoval",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_amf_removal: Option<Fqdn>,
    }

    impl From<&AmfStatusInfo> for AmfStatusInfo {
        fn from(value: &AmfStatusInfo) -> Self {
            value.clone()
        }
    }

    ///Document describing the modifications to AMF event subscription options
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Document describing the modifications to AMF event
    /// subscription options",
    ///  "type": "object",
    ///  "required": [
    ///    "op",
    ///    "path",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "notifFlag": {
    ///      "$ref": "#/components/schemas/NotificationFlag"
    ///    },
    ///    "op": {
    ///      "type": "string",
    ///      "enum": [
    ///        "replace"
    ///      ]
    ///    },
    ///    "path": {
    ///      "type": "string",
    ///      "pattern": "^(\\/options\\/expiry|\\/options\\/notifFlag)$"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfUpdateEventOptionItem {
        #[serde(rename = "notifFlag", default, skip_serializing_if = "Option::is_none")]
        pub notif_flag: Option<NotificationFlag>,
        pub op: AmfUpdateEventOptionItemOp,
        pub path: AmfUpdateEventOptionItemPath,
        pub value: DateTime,
    }

    impl From<&AmfUpdateEventOptionItem> for AmfUpdateEventOptionItem {
        fn from(value: &AmfUpdateEventOptionItem) -> Self {
            value.clone()
        }
    }

    ///AmfUpdateEventOptionItemOp
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "replace"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AmfUpdateEventOptionItemOp {
        #[serde(rename = "replace")]
        Replace,
    }

    impl From<&AmfUpdateEventOptionItemOp> for AmfUpdateEventOptionItemOp {
        fn from(value: &AmfUpdateEventOptionItemOp) -> Self {
            value.clone()
        }
    }

    impl ToString for AmfUpdateEventOptionItemOp {
        fn to_string(&self) -> String {
            match *self {
                Self::Replace => "replace".to_string(),
            }
        }
    }

    impl std::str::FromStr for AmfUpdateEventOptionItemOp {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "replace" => Ok(Self::Replace),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AmfUpdateEventOptionItemOp {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AmfUpdateEventOptionItemOp {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AmfUpdateEventOptionItemOp {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///AmfUpdateEventOptionItemPath
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^(\\/options\\/expiry|\\/options\\/notifFlag)$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AmfUpdateEventOptionItemPath(String);
    impl ::std::ops::Deref for AmfUpdateEventOptionItemPath {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AmfUpdateEventOptionItemPath> for String {
        fn from(value: AmfUpdateEventOptionItemPath) -> Self {
            value.0
        }
    }

    impl From<&AmfUpdateEventOptionItemPath> for AmfUpdateEventOptionItemPath {
        fn from(value: &AmfUpdateEventOptionItemPath) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AmfUpdateEventOptionItemPath {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^(\\/options\\/expiry|\\/options\\/notifFlag)$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err(
                    "doesn't match pattern \"^(\\/options\\/expiry|\\/options\\/notifFlag)$\""
                        .into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AmfUpdateEventOptionItemPath {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AmfUpdateEventOptionItemPath {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AmfUpdateEventOptionItemPath {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AmfUpdateEventOptionItemPath {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Document describing the modification(s) to an AMF Event Subscription
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Document describing the modification(s) to an AMF Event
    /// Subscription",
    ///  "type": "object",
    ///  "required": [
    ///    "op",
    ///    "path"
    ///  ],
    ///  "properties": {
    ///    "excludeGpsiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Gpsi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "excludeSupiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "includeGpsiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Gpsi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "includeSupiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "op": {
    ///      "type": "string",
    ///      "enum": [
    ///        "add",
    ///        "remove",
    ///        "replace"
    ///      ]
    ///    },
    ///    "path": {
    ///      "type": "string",
    ///      "pattern":
    /// "^\\/eventList\\/-|(\\/eventList\\/0|\\/eventList\\/[1-9][0-9]*){1}(\\/
    /// presenceInfoList\\/0|\\/presenceInfoList\\/[1-9][0-9]*)?|\\/
    /// excludeSupiList|\\/excludeGpsiList|\\/includeSupiList|\\/
    /// includeGpsiList$"
    ///    },
    ///    "presenceInfo": {
    ///      "$ref": "#/components/schemas/PresenceInfo"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/AmfEvent"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfUpdateEventSubscriptionItem {
        #[serde(
            rename = "excludeGpsiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub exclude_gpsi_list: Vec<Gpsi>,
        #[serde(
            rename = "excludeSupiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub exclude_supi_list: Vec<Supi>,
        #[serde(
            rename = "includeGpsiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub include_gpsi_list: Vec<Gpsi>,
        #[serde(
            rename = "includeSupiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub include_supi_list: Vec<Supi>,
        pub op: AmfUpdateEventSubscriptionItemOp,
        pub path: AmfUpdateEventSubscriptionItemPath,
        #[serde(
            rename = "presenceInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub presence_info: Option<PresenceInfo>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub value: Option<AmfEvent>,
    }

    impl From<&AmfUpdateEventSubscriptionItem> for AmfUpdateEventSubscriptionItem {
        fn from(value: &AmfUpdateEventSubscriptionItem) -> Self {
            value.clone()
        }
    }

    ///AmfUpdateEventSubscriptionItemOp
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "enum": [
    ///    "add",
    ///    "remove",
    ///    "replace"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AmfUpdateEventSubscriptionItemOp {
        #[serde(rename = "add")]
        Add,
        #[serde(rename = "remove")]
        Remove,
        #[serde(rename = "replace")]
        Replace,
    }

    impl From<&AmfUpdateEventSubscriptionItemOp> for AmfUpdateEventSubscriptionItemOp {
        fn from(value: &AmfUpdateEventSubscriptionItemOp) -> Self {
            value.clone()
        }
    }

    impl ToString for AmfUpdateEventSubscriptionItemOp {
        fn to_string(&self) -> String {
            match *self {
                Self::Add => "add".to_string(),
                Self::Remove => "remove".to_string(),
                Self::Replace => "replace".to_string(),
            }
        }
    }

    impl std::str::FromStr for AmfUpdateEventSubscriptionItemOp {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "add" => Ok(Self::Add),
                "remove" => Ok(Self::Remove),
                "replace" => Ok(Self::Replace),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AmfUpdateEventSubscriptionItemOp {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AmfUpdateEventSubscriptionItemOp {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AmfUpdateEventSubscriptionItemOp {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///AmfUpdateEventSubscriptionItemPath
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern":
    /// "^\\/eventList\\/-|(\\/eventList\\/0|\\/eventList\\/[1-9][0-9]*){1}(\\/
    /// presenceInfoList\\/0|\\/presenceInfoList\\/[1-9][0-9]*)?|\\/
    /// excludeSupiList|\\/excludeGpsiList|\\/includeSupiList|\\/
    /// includeGpsiList$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct AmfUpdateEventSubscriptionItemPath(String);
    impl ::std::ops::Deref for AmfUpdateEventSubscriptionItemPath {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AmfUpdateEventSubscriptionItemPath> for String {
        fn from(value: AmfUpdateEventSubscriptionItemPath) -> Self {
            value.0
        }
    }

    impl From<&AmfUpdateEventSubscriptionItemPath> for AmfUpdateEventSubscriptionItemPath {
        fn from(value: &AmfUpdateEventSubscriptionItemPath) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for AmfUpdateEventSubscriptionItemPath {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress :: Regex :: new ("^\\/eventList\\/-|(\\/eventList\\/0|\\/eventList\\/[1-9][0-9]*){1}(\\/presenceInfoList\\/0|\\/presenceInfoList\\/[1-9][0-9]*)?|\\/excludeSupiList|\\/excludeGpsiList|\\/includeSupiList|\\/includeGpsiList$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^\\/eventList\\/-|(\\/eventList\\/0|\\/eventList\\/[1-9][0-9]*){1}(\\/presenceInfoList\\/0|\\/presenceInfoList\\/[1-9][0-9]*)?|\\/excludeSupiList|\\/excludeGpsiList|\\/includeSupiList|\\/includeGpsiList$\"" . into ()) ; }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for AmfUpdateEventSubscriptionItemPath {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for AmfUpdateEventSubscriptionItemPath {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for AmfUpdateEventSubscriptionItemPath {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for AmfUpdateEventSubscriptionItemPath {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Represents a successful update on an AMF Event Subscription
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a successful update on an AMF Event
    /// Subscription",
    ///  "type": "object",
    ///  "required": [
    ///    "subscription"
    ///  ],
    ///  "properties": {
    ///    "reportList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AmfEventReport"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "subscription": {
    ///      "$ref": "#/components/schemas/AmfEventSubscription"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AmfUpdatedEventSubscription {
        #[serde(rename = "reportList", default, skip_serializing_if = "Vec::is_empty")]
        pub report_list: Vec<AmfEventReport>,
        pub subscription: AmfEventSubscription,
    }

    impl From<&AmfUpdatedEventSubscription> for AmfUpdatedEventSubscription {
        fn from(value: &AmfUpdatedEventSubscription) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - NUM_OF_SAMPLES: Number of data samples used for the generation of the
    ///   output analytics.
    /// - DATA_WINDOW: Data time window of the data samples.
    /// - DATA_STAT_PROPS: Dataset statistical properties of the data used to
    ///   generate the analytics.
    /// - STRATEGY: Output strategy used for the reporting of the analytics.
    /// - ACCURACY: Level of accuracy reached for the analytics.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- NUM_OF_SAMPLES: Number of data
    /// samples used for the generation of the output analytics.\n- DATA_WINDOW:
    /// Data time window of the data samples.\n- DATA_STAT_PROPS: Dataset
    /// statistical properties of the data used to generate the analytics.\n-
    /// STRATEGY: Output strategy used for the reporting of the analytics.\n-
    /// ACCURACY: Level of accuracy reached for the analytics.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "NUM_OF_SAMPLES",
    ///    "DATA_WINDOW",
    ///    "DATA_STAT_PROPS",
    ///    "STRATEGY",
    ///    "ACCURACY"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AnalyticsMetadata {
        #[serde(rename = "NUM_OF_SAMPLES")]
        NumOfSamples,
        #[serde(rename = "DATA_WINDOW")]
        DataWindow,
        #[serde(rename = "DATA_STAT_PROPS")]
        DataStatProps,
        #[serde(rename = "STRATEGY")]
        Strategy,
        #[serde(rename = "ACCURACY")]
        Accuracy,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&AnalyticsMetadata> for AnalyticsMetadata {
        fn from(value: &AnalyticsMetadata) -> Self {
            value.clone()
        }
    }

    impl ToString for AnalyticsMetadata {
        fn to_string(&self) -> String {
            match *self {
                Self::NumOfSamples => "NUM_OF_SAMPLES".to_string(),
                Self::DataWindow => "DATA_WINDOW".to_string(),
                Self::DataStatProps => "DATA_STAT_PROPS".to_string(),
                Self::Strategy => "STRATEGY".to_string(),
                Self::Accuracy => "ACCURACY".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for AnalyticsMetadata {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NUM_OF_SAMPLES" => Ok(Self::NumOfSamples),
                "DATA_WINDOW" => Ok(Self::DataWindow),
                "DATA_STAT_PROPS" => Ok(Self::DataStatProps),
                "STRATEGY" => Ok(Self::Strategy),
                "ACCURACY" => Ok(Self::Accuracy),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AnalyticsMetadata {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AnalyticsMetadata {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AnalyticsMetadata {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Contains analytics metadata information requested to be used during
    /// analytics generation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains analytics metadata information requested to be
    /// used during analytics generation.\n",
    ///  "type": "object",
    ///  "properties": {
    ///    "aggrNwdafIds": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NfInstanceId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "dataStatProps": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DatasetStatisticalProperty"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "dataWindow": {
    ///      "$ref": "#/components/schemas/TimeWindow"
    ///    },
    ///    "strategy": {
    ///      "$ref": "#/components/schemas/OutputStrategy"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AnalyticsMetadataIndication {
        #[serde(
            rename = "aggrNwdafIds",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub aggr_nwdaf_ids: Vec<NfInstanceId>,
        #[serde(
            rename = "dataStatProps",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub data_stat_props: Vec<DatasetStatisticalProperty>,
        #[serde(
            rename = "dataWindow",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub data_window: Option<TimeWindow>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub strategy: Option<OutputStrategy>,
    }

    impl From<&AnalyticsMetadataIndication> for AnalyticsMetadataIndication {
        fn from(value: &AnalyticsMetadataIndication) -> Self {
            value.clone()
        }
    }

    ///Contains analytics metadata information required for analytics
    /// aggregation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains analytics metadata information required for
    /// analytics aggregation.",
    ///  "type": "object",
    ///  "properties": {
    ///    "accuracy": {
    ///      "$ref": "#/components/schemas/Accuracy"
    ///    },
    ///    "dataStatProps": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DatasetStatisticalProperty"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "dataWindow": {
    ///      "$ref": "#/components/schemas/TimeWindow"
    ///    },
    ///    "numSamples": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "strategy": {
    ///      "$ref": "#/components/schemas/OutputStrategy"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AnalyticsMetadataInfo {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub accuracy: Option<Accuracy>,
        #[serde(
            rename = "dataStatProps",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub data_stat_props: Vec<DatasetStatisticalProperty>,
        #[serde(
            rename = "dataWindow",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub data_window: Option<TimeWindow>,
        #[serde(
            rename = "numSamples",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub num_samples: Option<Uinteger>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub strategy: Option<OutputStrategy>,
    }

    impl From<&AnalyticsMetadataInfo> for AnalyticsMetadataInfo {
        fn from(value: &AnalyticsMetadataInfo) -> Self {
            value.clone()
        }
    }

    ///Analytics subscriptions created in the NWDAF.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Analytics subscriptions created in the NWDAF.",
    ///  "type": "object",
    ///  "required": [
    ///    "nwdafSubscriptionList"
    ///  ],
    ///  "properties": {
    ///    "nwdafId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "nwdafSetId": {
    ///      "$ref": "#/components/schemas/NfSetId"
    ///    },
    ///    "nwdafSubscriptionList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NwdafSubscription"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AnalyticsSubscription {
        #[serde(rename = "nwdafId", default, skip_serializing_if = "Option::is_none")]
        pub nwdaf_id: Option<NfInstanceId>,
        #[serde(
            rename = "nwdafSetId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nwdaf_set_id: Option<NfSetId>,
        #[serde(rename = "nwdafSubscriptionList")]
        pub nwdaf_subscription_list: Vec<NwdafSubscription>,
    }

    impl From<&AnalyticsSubscription> for AnalyticsSubscription {
        fn from(value: &AnalyticsSubscription) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - NUM_OF_UE_REG: The number of UE registered. This value is only
    ///   applicable to NSI_LOAD_LEVEL event.
    /// - NUM_OF_PDU_SESS_ESTBL: The number of PDU sessions established. This
    ///   value is only applicable to NSI_LOAD_LEVEL event.
    /// - RES_USAGE: The current usage of the virtual resources assigned to the
    ///   NF instances belonging to a particular network slice instance. This
    ///   value is only applicable to NSI_LOAD_LEVEL event.
    /// - NUM_OF_EXCEED_RES_USAGE_LOAD_LEVEL_THR: The number of times the
    ///   resource usage threshold of the network slice instance is reached or
    ///   exceeded if a threshold value is provided by the consumer. This value
    ///   is only applicable to NSI_LOAD_LEVEL event.
    /// - PERIOD_OF_EXCEED_RES_USAGE_LOAD_LEVEL_THR: The time interval between
    ///   each time the threshold being met or exceeded on the network slice
    ///   (instance). This value is only applicable to NSI_LOAD_LEVEL event.
    /// - EXCEED_LOAD_LEVEL_THR_IND: Whether the Load Level Threshold is met or
    ///   exceeded by the statistics value. This value is only applicable to
    ///   NSI_LOAD_LEVEL event.
    /// - LIST_OF_TOP_APP_UL: The list of applications that contribute the most
    ///   to the traffic in the UL direction. This value is only applicable to
    ///   USER_DATA_CONGESTION event.
    /// - LIST_OF_TOP_APP_DL: The list of applications that contribute the most
    ///   to the traffic in the DL direction. This value is only applicable to
    ///   USER_DATA_CONGESTION event.
    /// - NF_STATUS: The availability status of the NF on the Analytics target
    ///   period, expressed as a percentage of time per status value
    ///   (registered, suspended, undiscoverable). This value is only applicable
    ///   to NF_LOAD event.
    /// - NF_RESOURCE_USAGE: The average usage of assigned resources (CPU,
    ///   memory, storage). This value is only applicable to NF_LOAD event.
    /// - NF_LOAD: The average load of the NF instance over the Analytics target
    ///   period. This value is only applicable to NF_LOAD event.
    /// - NF_PEAK_LOAD: The maximum load of the NF instance over the Analytics
    ///   target period. This value is only applicable to NF_LOAD event.
    /// - NF_LOAD_AVG_IN_AOI: The average load of the NF instances over the area
    ///   of interest. This value is only applicable to NF_LOAD event.
    /// - DISPER_AMOUNT: Indicates the dispersion amount of the reported data
    ///   volume or transaction dispersion type. This value is only applicable
    ///   to DISPERSION event.
    /// - DISPER_CLASS: Indicates the dispersion mobility class: fixed, camper,
    ///   traveller upon set its usage threshold, and/or the top-heavy class
    ///   upon set its percentile rating threshold. This value is only
    ///   applicable to DISPERSION event.
    /// - RANKING: Data/transaction usage ranking high (i.e.value 1), medium (2)
    ///   or low (3). This value is only applicable to DISPERSION event.
    /// - PERCENTILE_RANKING: Percentile ranking of the target UE in the
    ///   Cumulative Distribution Function of data usage for the population of
    ///   all UEs. This value is only applicable to DISPERSION event.
    /// - RSSI: Indicated the RSSI in the unit of dBm. This value is only
    ///   applicable to WLAN_PERFORMANCE event.
    /// - RTT: Indicates the RTT in the unit of millisecond. This value is only
    ///   applicable to WLAN_PERFORMANCE event.
    /// - TRAFFIC_INFO: Traffic information including UL/DL data rate and/or
    ///   Traffic volume. This value is only applicable to WLAN_PERFORMANCE
    ///   event.
    /// - NUMBER_OF_UES: Number of UEs observed for the SSID. This value is only
    ///   applicable to WLAN_PERFORMANCE event.
    /// - APP_LIST_FOR_UE_COMM: The analytics of the application list used by
    ///   UE. This value is only applicable to UE_COMM event.
    /// - N4_SESS_INACT_TIMER_FOR_UE_COMM: The N4 Session inactivity timer. This
    ///   value is only applicable to UE_COMM event.
    /// - AVG_TRAFFIC_RATE: Indicates average traffic rate. This value is only
    ///   applicable to DN_PERFORMANCE event.
    /// - MAX_TRAFFIC_RATE: Indicates maximum traffic rate. This value is only
    ///   applicable to DN_PERFORMANCE event.
    /// - AVG_PACKET_DELAY: Indicates average Packet Delay. This value is only
    ///   applicable to DN_PERFORMANCE event.
    /// - MAX_PACKET_DELAY: Indicates maximum Packet Delay. This value is only
    ///   applicable to DN_PERFORMANCE event.
    /// - AVG_PACKET_LOSS_RATE: Indicates average Loss Rate. This value is only
    ///   applicable to DN_PERFORMANCE event.
    /// - UE_LOCATION: Indicates UE location information. This value is only
    ///   applicable to SERVICE_EXPERIENCE event.
    /// - LIST_OF_HIGH_EXP_UE: Indicates list of high experienced UE. This value
    ///   is only applicable to SM_CONGESTION event.
    /// - LIST_OF_MEDIUM_EXP_UE: Indicates list of medium experienced UE. This
    ///   value is only applicable to SM_CONGESTION event.
    /// - LIST_OF_LOW_EXP_UE: Indicates list of low experienced UE. This value
    ///   is only applicable to SM_CONGESTION event.
    /// - AVG_UL_PKT_DROP_RATE: Indicates average uplink packet drop rate on
    ///   GTP-U path on N3. This value is only applicable to RED_TRANS_EXP
    ///   event.
    /// - VAR_UL_PKT_DROP_RATE: Indicates variance of uplink packet drop rate on
    ///   GTP-U path on N3. This value is only applicable to RED_TRANS_EXP
    ///   event.
    /// - AVG_DL_PKT_DROP_RATE: Indicates average downlink packet drop rate on
    ///   GTP-U path on N3. This value is only applicable to RED_TRANS_EXP
    ///   event.
    /// - VAR_DL_PKT_DROP_RATE: Indicates variance of downlink packet drop rate
    ///   on GTP-U path on N3. This value is only applicable to RED_TRANS_EXP
    ///   event.
    /// - AVG_UL_PKT_DELAY: Indicates average uplink packet delay round trip on
    ///   GTP-U path on N3. This value is only applicable to RED_TRANS_EXP
    ///   event.
    /// - VAR_UL_PKT_DELAY: Indicates variance uplink packet delay round trip on
    ///   GTP-U path on N3. This value is only applicable to RED_TRANS_EXP
    ///   event.
    /// - AVG_DL_PKT_DELAY: Indicates average downlink packet delay round trip
    ///   on GTP-U path on N3. This value is only applicable to RED_TRANS_EXP
    ///   event.
    /// - VAR_DL_PKT_DELAY: Indicates variance downlink packet delay round trip
    ///   on GTP-U path on N3. This value is only applicable to RED_TRANS_EXP
    ///   event.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- NUM_OF_UE_REG: The number of UE
    /// registered. This value is only applicable to NSI_LOAD_LEVEL event.\n-
    /// NUM_OF_PDU_SESS_ESTBL: The number of PDU sessions established. This
    /// value is only applicable to NSI_LOAD_LEVEL event.\n- RES_USAGE: The
    /// current usage of the virtual resources assigned to the NF instances
    /// belonging to a particular network slice instance. This value is only
    /// applicable to NSI_LOAD_LEVEL event.\n-
    /// NUM_OF_EXCEED_RES_USAGE_LOAD_LEVEL_THR: The number of times the resource
    /// usage threshold of the network slice instance is reached or exceeded if
    /// a threshold value is provided by the consumer. This value is only
    /// applicable to NSI_LOAD_LEVEL event.\n-
    /// PERIOD_OF_EXCEED_RES_USAGE_LOAD_LEVEL_THR: The time interval between
    /// each time the threshold being met or exceeded on the network slice
    /// (instance). This value is only applicable to NSI_LOAD_LEVEL event.\n-
    /// EXCEED_LOAD_LEVEL_THR_IND: Whether the Load Level Threshold is met or
    /// exceeded by the statistics value. This value is only applicable to
    /// NSI_LOAD_LEVEL event.\n- LIST_OF_TOP_APP_UL: The list of applications
    /// that contribute the most to the traffic in the UL direction. This value
    /// is only applicable to USER_DATA_CONGESTION event.\n- LIST_OF_TOP_APP_DL:
    /// The list of applications that contribute the most to the traffic in the
    /// DL direction. This value is only applicable to USER_DATA_CONGESTION
    /// event.\n- NF_STATUS: The availability status of the NF on the Analytics
    /// target period, expressed as a percentage of time per status value
    /// (registered, suspended, undiscoverable). This value is only applicable
    /// to NF_LOAD event.\n- NF_RESOURCE_USAGE: The average usage of assigned
    /// resources (CPU, memory, storage). This value is only applicable to
    /// NF_LOAD event.\n- NF_LOAD: The average load of the NF instance over the
    /// Analytics target period. This value is only applicable to NF_LOAD
    /// event.\n- NF_PEAK_LOAD: The maximum load of the NF instance over the
    /// Analytics target period. This value is only applicable to NF_LOAD
    /// event.\n- NF_LOAD_AVG_IN_AOI: The average load of the NF instances over
    /// the area of interest. This value is only applicable to NF_LOAD event.\n-
    /// DISPER_AMOUNT: Indicates the dispersion amount of the reported data
    /// volume or transaction dispersion type. This value is only applicable to
    /// DISPERSION event.\n- DISPER_CLASS: Indicates the dispersion mobility
    /// class: fixed, camper, traveller upon set its usage threshold, and/or the
    /// top-heavy class upon set its percentile rating threshold. This value is
    /// only applicable to DISPERSION event.\n- RANKING: Data/transaction usage
    /// ranking high (i.e.value 1), medium (2) or low (3). This value is only
    /// applicable to DISPERSION event.\n- PERCENTILE_RANKING: Percentile
    /// ranking of the target UE in the Cumulative Distribution Function of data
    /// usage for the population of all UEs. This value is only applicable to
    /// DISPERSION event.\n- RSSI: Indicated the RSSI in the unit of dBm. This
    /// value is only applicable to WLAN_PERFORMANCE event.\n- RTT: Indicates
    /// the RTT in the unit of millisecond. This value is only applicable to
    /// WLAN_PERFORMANCE event.\n- TRAFFIC_INFO: Traffic information including
    /// UL/DL data rate and/or Traffic volume. This value is only applicable to
    /// WLAN_PERFORMANCE event.\n- NUMBER_OF_UES: Number of UEs observed for the
    /// SSID. This value is only applicable to WLAN_PERFORMANCE event.\n-
    /// APP_LIST_FOR_UE_COMM: The analytics of the application list used by UE.
    /// This value is only applicable to UE_COMM event.\n-
    /// N4_SESS_INACT_TIMER_FOR_UE_COMM: The N4 Session inactivity timer. This
    /// value is only applicable to UE_COMM event.\n- AVG_TRAFFIC_RATE:
    /// Indicates average traffic rate. This value is only applicable to
    /// DN_PERFORMANCE event.\n- MAX_TRAFFIC_RATE: Indicates maximum traffic
    /// rate. This value is only applicable to DN_PERFORMANCE event.\n-
    /// AVG_PACKET_DELAY: Indicates average Packet Delay. This value is only
    /// applicable to DN_PERFORMANCE event.\n- MAX_PACKET_DELAY: Indicates
    /// maximum Packet Delay. This value is only applicable to DN_PERFORMANCE
    /// event.\n- AVG_PACKET_LOSS_RATE: Indicates average Loss Rate. This value
    /// is only applicable to DN_PERFORMANCE event.\n- UE_LOCATION: Indicates UE
    /// location information. This value is only applicable to
    /// SERVICE_EXPERIENCE event.\n- LIST_OF_HIGH_EXP_UE: Indicates list of high
    /// experienced UE. This value is only applicable to SM_CONGESTION event.\n-
    /// LIST_OF_MEDIUM_EXP_UE: Indicates list of medium experienced UE. This
    /// value is only applicable to SM_CONGESTION event.\n- LIST_OF_LOW_EXP_UE:
    /// Indicates list of low experienced UE. This value is only applicable to
    /// SM_CONGESTION event.\n- AVG_UL_PKT_DROP_RATE: Indicates average uplink
    /// packet drop rate on GTP-U path on N3. This value is only applicable to
    /// RED_TRANS_EXP event.\n- VAR_UL_PKT_DROP_RATE: Indicates variance of
    /// uplink packet drop rate on GTP-U path on N3. This value is only
    /// applicable to RED_TRANS_EXP event.\n- AVG_DL_PKT_DROP_RATE: Indicates
    /// average downlink packet drop rate on GTP-U path on N3. This value is
    /// only applicable to RED_TRANS_EXP event.\n- VAR_DL_PKT_DROP_RATE:
    /// Indicates variance of downlink packet drop rate on GTP-U path on N3.
    /// This value is only applicable to RED_TRANS_EXP event.\n-
    /// AVG_UL_PKT_DELAY: Indicates average uplink packet delay round trip on
    /// GTP-U path on N3. This value is only applicable to RED_TRANS_EXP
    /// event.\n- VAR_UL_PKT_DELAY: Indicates variance uplink packet delay round
    /// trip on GTP-U path on N3. This value is only applicable to RED_TRANS_EXP
    /// event.\n- AVG_DL_PKT_DELAY: Indicates average downlink packet delay
    /// round trip on GTP-U path on N3. This value is only applicable to
    /// RED_TRANS_EXP event.\n- VAR_DL_PKT_DELAY: Indicates variance downlink
    /// packet delay round trip on GTP-U path on N3. This value is only
    /// applicable to RED_TRANS_EXP event.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "NUM_OF_UE_REG",
    ///    "NUM_OF_PDU_SESS_ESTBL",
    ///    "RES_USAGE",
    ///    "NUM_OF_EXCEED_RES_USAGE_LOAD_LEVEL_THR",
    ///    "PERIOD_OF_EXCEED_RES_USAGE_LOAD_LEVEL_THR",
    ///    "EXCEED_LOAD_LEVEL_THR_IND",
    ///    "LIST_OF_TOP_APP_UL",
    ///    "LIST_OF_TOP_APP_DL",
    ///    "NF_STATUS",
    ///    "NF_RESOURCE_USAGE",
    ///    "NF_LOAD",
    ///    "NF_PEAK_LOAD",
    ///    "NF_LOAD_AVG_IN_AOI",
    ///    "DISPER_AMOUNT",
    ///    "DISPER_CLASS",
    ///    "RANKING",
    ///    "PERCENTILE_RANKING",
    ///    "RSSI",
    ///    "RTT",
    ///    "TRAFFIC_INFO",
    ///    "NUMBER_OF_UES",
    ///    "APP_LIST_FOR_UE_COMM",
    ///    "N4_SESS_INACT_TIMER_FOR_UE_COMM",
    ///    "AVG_TRAFFIC_RATE",
    ///    "MAX_TRAFFIC_RATE",
    ///    "AVG_PACKET_DELAY",
    ///    "MAX_PACKET_DELAY",
    ///    "AVG_PACKET_LOSS_RATE",
    ///    "UE_LOCATION",
    ///    "LIST_OF_HIGH_EXP_UE",
    ///    "LIST_OF_MEDIUM_EXP_UE",
    ///    "LIST_OF_LOW_EXP_UE",
    ///    "AVG_UL_PKT_DROP_RATE",
    ///    "VAR_UL_PKT_DROP_RATE",
    ///    "AVG_DL_PKT_DROP_RATE",
    ///    "VAR_DL_PKT_DROP_RATE",
    ///    "AVG_UL_PKT_DELAY",
    ///    "VAR_UL_PKT_DELAY",
    ///    "AVG_DL_PKT_DELAY",
    ///    "VAR_DL_PKT_DELAY"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AnalyticsSubset {
        #[serde(rename = "NUM_OF_UE_REG")]
        NumOfUeReg,
        #[serde(rename = "NUM_OF_PDU_SESS_ESTBL")]
        NumOfPduSessEstbl,
        #[serde(rename = "RES_USAGE")]
        ResUsage,
        #[serde(rename = "NUM_OF_EXCEED_RES_USAGE_LOAD_LEVEL_THR")]
        NumOfExceedResUsageLoadLevelThr,
        #[serde(rename = "PERIOD_OF_EXCEED_RES_USAGE_LOAD_LEVEL_THR")]
        PeriodOfExceedResUsageLoadLevelThr,
        #[serde(rename = "EXCEED_LOAD_LEVEL_THR_IND")]
        ExceedLoadLevelThrInd,
        #[serde(rename = "LIST_OF_TOP_APP_UL")]
        ListOfTopAppUl,
        #[serde(rename = "LIST_OF_TOP_APP_DL")]
        ListOfTopAppDl,
        #[serde(rename = "NF_STATUS")]
        NfStatus,
        #[serde(rename = "NF_RESOURCE_USAGE")]
        NfResourceUsage,
        #[serde(rename = "NF_LOAD")]
        NfLoad,
        #[serde(rename = "NF_PEAK_LOAD")]
        NfPeakLoad,
        #[serde(rename = "NF_LOAD_AVG_IN_AOI")]
        NfLoadAvgInAoi,
        #[serde(rename = "DISPER_AMOUNT")]
        DisperAmount,
        #[serde(rename = "DISPER_CLASS")]
        DisperClass,
        #[serde(rename = "RANKING")]
        Ranking,
        #[serde(rename = "PERCENTILE_RANKING")]
        PercentileRanking,
        #[serde(rename = "RSSI")]
        Rssi,
        #[serde(rename = "RTT")]
        Rtt,
        #[serde(rename = "TRAFFIC_INFO")]
        TrafficInfo,
        #[serde(rename = "NUMBER_OF_UES")]
        NumberOfUes,
        #[serde(rename = "APP_LIST_FOR_UE_COMM")]
        AppListForUeComm,
        #[serde(rename = "N4_SESS_INACT_TIMER_FOR_UE_COMM")]
        N4SessInactTimerForUeComm,
        #[serde(rename = "AVG_TRAFFIC_RATE")]
        AvgTrafficRate,
        #[serde(rename = "MAX_TRAFFIC_RATE")]
        MaxTrafficRate,
        #[serde(rename = "AVG_PACKET_DELAY")]
        AvgPacketDelay,
        #[serde(rename = "MAX_PACKET_DELAY")]
        MaxPacketDelay,
        #[serde(rename = "AVG_PACKET_LOSS_RATE")]
        AvgPacketLossRate,
        #[serde(rename = "UE_LOCATION")]
        UeLocation,
        #[serde(rename = "LIST_OF_HIGH_EXP_UE")]
        ListOfHighExpUe,
        #[serde(rename = "LIST_OF_MEDIUM_EXP_UE")]
        ListOfMediumExpUe,
        #[serde(rename = "LIST_OF_LOW_EXP_UE")]
        ListOfLowExpUe,
        #[serde(rename = "AVG_UL_PKT_DROP_RATE")]
        AvgUlPktDropRate,
        #[serde(rename = "VAR_UL_PKT_DROP_RATE")]
        VarUlPktDropRate,
        #[serde(rename = "AVG_DL_PKT_DROP_RATE")]
        AvgDlPktDropRate,
        #[serde(rename = "VAR_DL_PKT_DROP_RATE")]
        VarDlPktDropRate,
        #[serde(rename = "AVG_UL_PKT_DELAY")]
        AvgUlPktDelay,
        #[serde(rename = "VAR_UL_PKT_DELAY")]
        VarUlPktDelay,
        #[serde(rename = "AVG_DL_PKT_DELAY")]
        AvgDlPktDelay,
        #[serde(rename = "VAR_DL_PKT_DELAY")]
        VarDlPktDelay,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&AnalyticsSubset> for AnalyticsSubset {
        fn from(value: &AnalyticsSubset) -> Self {
            value.clone()
        }
    }

    impl ToString for AnalyticsSubset {
        fn to_string(&self) -> String {
            match *self {
                Self::NumOfUeReg => "NUM_OF_UE_REG".to_string(),
                Self::NumOfPduSessEstbl => "NUM_OF_PDU_SESS_ESTBL".to_string(),
                Self::ResUsage => "RES_USAGE".to_string(),
                Self::NumOfExceedResUsageLoadLevelThr => {
                    "NUM_OF_EXCEED_RES_USAGE_LOAD_LEVEL_THR".to_string()
                }
                Self::PeriodOfExceedResUsageLoadLevelThr => {
                    "PERIOD_OF_EXCEED_RES_USAGE_LOAD_LEVEL_THR".to_string()
                }
                Self::ExceedLoadLevelThrInd => "EXCEED_LOAD_LEVEL_THR_IND".to_string(),
                Self::ListOfTopAppUl => "LIST_OF_TOP_APP_UL".to_string(),
                Self::ListOfTopAppDl => "LIST_OF_TOP_APP_DL".to_string(),
                Self::NfStatus => "NF_STATUS".to_string(),
                Self::NfResourceUsage => "NF_RESOURCE_USAGE".to_string(),
                Self::NfLoad => "NF_LOAD".to_string(),
                Self::NfPeakLoad => "NF_PEAK_LOAD".to_string(),
                Self::NfLoadAvgInAoi => "NF_LOAD_AVG_IN_AOI".to_string(),
                Self::DisperAmount => "DISPER_AMOUNT".to_string(),
                Self::DisperClass => "DISPER_CLASS".to_string(),
                Self::Ranking => "RANKING".to_string(),
                Self::PercentileRanking => "PERCENTILE_RANKING".to_string(),
                Self::Rssi => "RSSI".to_string(),
                Self::Rtt => "RTT".to_string(),
                Self::TrafficInfo => "TRAFFIC_INFO".to_string(),
                Self::NumberOfUes => "NUMBER_OF_UES".to_string(),
                Self::AppListForUeComm => "APP_LIST_FOR_UE_COMM".to_string(),
                Self::N4SessInactTimerForUeComm => "N4_SESS_INACT_TIMER_FOR_UE_COMM".to_string(),
                Self::AvgTrafficRate => "AVG_TRAFFIC_RATE".to_string(),
                Self::MaxTrafficRate => "MAX_TRAFFIC_RATE".to_string(),
                Self::AvgPacketDelay => "AVG_PACKET_DELAY".to_string(),
                Self::MaxPacketDelay => "MAX_PACKET_DELAY".to_string(),
                Self::AvgPacketLossRate => "AVG_PACKET_LOSS_RATE".to_string(),
                Self::UeLocation => "UE_LOCATION".to_string(),
                Self::ListOfHighExpUe => "LIST_OF_HIGH_EXP_UE".to_string(),
                Self::ListOfMediumExpUe => "LIST_OF_MEDIUM_EXP_UE".to_string(),
                Self::ListOfLowExpUe => "LIST_OF_LOW_EXP_UE".to_string(),
                Self::AvgUlPktDropRate => "AVG_UL_PKT_DROP_RATE".to_string(),
                Self::VarUlPktDropRate => "VAR_UL_PKT_DROP_RATE".to_string(),
                Self::AvgDlPktDropRate => "AVG_DL_PKT_DROP_RATE".to_string(),
                Self::VarDlPktDropRate => "VAR_DL_PKT_DROP_RATE".to_string(),
                Self::AvgUlPktDelay => "AVG_UL_PKT_DELAY".to_string(),
                Self::VarUlPktDelay => "VAR_UL_PKT_DELAY".to_string(),
                Self::AvgDlPktDelay => "AVG_DL_PKT_DELAY".to_string(),
                Self::VarDlPktDelay => "VAR_DL_PKT_DELAY".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for AnalyticsSubset {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NUM_OF_UE_REG" => Ok(Self::NumOfUeReg),
                "NUM_OF_PDU_SESS_ESTBL" => Ok(Self::NumOfPduSessEstbl),
                "RES_USAGE" => Ok(Self::ResUsage),
                "NUM_OF_EXCEED_RES_USAGE_LOAD_LEVEL_THR" => {
                    Ok(Self::NumOfExceedResUsageLoadLevelThr)
                }
                "PERIOD_OF_EXCEED_RES_USAGE_LOAD_LEVEL_THR" => {
                    Ok(Self::PeriodOfExceedResUsageLoadLevelThr)
                }
                "EXCEED_LOAD_LEVEL_THR_IND" => Ok(Self::ExceedLoadLevelThrInd),
                "LIST_OF_TOP_APP_UL" => Ok(Self::ListOfTopAppUl),
                "LIST_OF_TOP_APP_DL" => Ok(Self::ListOfTopAppDl),
                "NF_STATUS" => Ok(Self::NfStatus),
                "NF_RESOURCE_USAGE" => Ok(Self::NfResourceUsage),
                "NF_LOAD" => Ok(Self::NfLoad),
                "NF_PEAK_LOAD" => Ok(Self::NfPeakLoad),
                "NF_LOAD_AVG_IN_AOI" => Ok(Self::NfLoadAvgInAoi),
                "DISPER_AMOUNT" => Ok(Self::DisperAmount),
                "DISPER_CLASS" => Ok(Self::DisperClass),
                "RANKING" => Ok(Self::Ranking),
                "PERCENTILE_RANKING" => Ok(Self::PercentileRanking),
                "RSSI" => Ok(Self::Rssi),
                "RTT" => Ok(Self::Rtt),
                "TRAFFIC_INFO" => Ok(Self::TrafficInfo),
                "NUMBER_OF_UES" => Ok(Self::NumberOfUes),
                "APP_LIST_FOR_UE_COMM" => Ok(Self::AppListForUeComm),
                "N4_SESS_INACT_TIMER_FOR_UE_COMM" => Ok(Self::N4SessInactTimerForUeComm),
                "AVG_TRAFFIC_RATE" => Ok(Self::AvgTrafficRate),
                "MAX_TRAFFIC_RATE" => Ok(Self::MaxTrafficRate),
                "AVG_PACKET_DELAY" => Ok(Self::AvgPacketDelay),
                "MAX_PACKET_DELAY" => Ok(Self::MaxPacketDelay),
                "AVG_PACKET_LOSS_RATE" => Ok(Self::AvgPacketLossRate),
                "UE_LOCATION" => Ok(Self::UeLocation),
                "LIST_OF_HIGH_EXP_UE" => Ok(Self::ListOfHighExpUe),
                "LIST_OF_MEDIUM_EXP_UE" => Ok(Self::ListOfMediumExpUe),
                "LIST_OF_LOW_EXP_UE" => Ok(Self::ListOfLowExpUe),
                "AVG_UL_PKT_DROP_RATE" => Ok(Self::AvgUlPktDropRate),
                "VAR_UL_PKT_DROP_RATE" => Ok(Self::VarUlPktDropRate),
                "AVG_DL_PKT_DROP_RATE" => Ok(Self::AvgDlPktDropRate),
                "VAR_DL_PKT_DROP_RATE" => Ok(Self::VarDlPktDropRate),
                "AVG_UL_PKT_DELAY" => Ok(Self::AvgUlPktDelay),
                "VAR_UL_PKT_DELAY" => Ok(Self::VarUlPktDelay),
                "AVG_DL_PKT_DELAY" => Ok(Self::AvgDlPktDelay),
                "VAR_DL_PKT_DELAY" => Ok(Self::VarDlPktDelay),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AnalyticsSubset {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AnalyticsSubset {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AnalyticsSubset {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates value of angle.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates value of angle.",
    ///  "type": "integer",
    ///  "maximum": 360.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Angle(pub i64);
    impl ::std::ops::Deref for Angle {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<Angle> for i64 {
        fn from(value: Angle) -> Self {
            value.0
        }
    }

    impl From<&Angle> for Angle {
        fn from(value: &Angle) -> Self {
            value.clone()
        }
    }

    impl From<i64> for Angle {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for Angle {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for Angle {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Angle {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Angle {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for Angle {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///"false" represents not applicable for all slices. "true" represents
    /// applicable for all slices.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "\"false\" represents not applicable for all slices.
    /// \"true\" represents applicable for all slices.\n",
    ///  "type": "boolean"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AnySlice(pub bool);
    impl ::std::ops::Deref for AnySlice {
        type Target = bool;
        fn deref(&self) -> &bool {
            &self.0
        }
    }

    impl From<AnySlice> for bool {
        fn from(value: AnySlice) -> Self {
            value.0
        }
    }

    impl From<&AnySlice> for AnySlice {
        fn from(value: &AnySlice) -> Self {
            value.clone()
        }
    }

    impl From<bool> for AnySlice {
        fn from(value: bool) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for AnySlice {
        type Err = <bool as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for AnySlice {
        type Error = <bool as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AnySlice {
        type Error = <bool as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AnySlice {
        type Error = <bool as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for AnySlice {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Represents the analytics of the application list used by UE.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the analytics of the application list used
    /// by UE.",
    ///  "type": "object",
    ///  "required": [
    ///    "appId"
    ///  ],
    ///  "properties": {
    ///    "appDur": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "appId": {
    ///      "$ref": "#/components/schemas/ApplicationId"
    ///    },
    ///    "occurRatio": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    },
    ///    "spatialValidity": {
    ///      "$ref": "#/components/schemas/NetworkAreaInfo"
    ///    },
    ///    "startTime": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AppListForUeComm {
        #[serde(rename = "appDur", default, skip_serializing_if = "Option::is_none")]
        pub app_dur: Option<DurationSec>,
        #[serde(rename = "appId")]
        pub app_id: ApplicationId,
        #[serde(
            rename = "occurRatio",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub occur_ratio: Option<SamplingRatio>,
        #[serde(
            rename = "spatialValidity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub spatial_validity: Option<NetworkAreaInfo>,
        #[serde(rename = "startTime", default, skip_serializing_if = "Option::is_none")]
        pub start_time: Option<DateTime>,
    }

    impl From<&AppListForUeComm> for AppListForUeComm {
        fn from(value: &AppListForUeComm) -> Self {
            value.clone()
        }
    }

    ///String providing an application identifier.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String providing an application identifier.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct ApplicationId(pub String);
    impl ::std::ops::Deref for ApplicationId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ApplicationId> for String {
        fn from(value: ApplicationId) -> Self {
            value.0
        }
    }

    impl From<&ApplicationId> for ApplicationId {
        fn from(value: &ApplicationId) -> Self {
            value.clone()
        }
    }

    impl From<String> for ApplicationId {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for ApplicationId {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for ApplicationId {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Application data volume per Application Id.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Application data volume per Application Id.",
    ///  "type": "object",
    ///  "required": [
    ///    "appId",
    ///    "appVolume"
    ///  ],
    ///  "properties": {
    ///    "appId": {
    ///      "$ref": "#/components/schemas/ApplicationId"
    ///    },
    ///    "appVolume": {
    ///      "$ref": "#/components/schemas/Volume"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ApplicationVolume {
        #[serde(rename = "appId")]
        pub app_id: ApplicationId,
        #[serde(rename = "appVolume")]
        pub app_volume: Volume,
    }

    impl From<&ApplicationVolume> for ApplicationVolume {
        fn from(value: &ApplicationVolume) -> Self {
            value.clone()
        }
    }

    ///Provides area information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Provides area information.",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "required": [
    ///        "tacs"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "areaCode"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "areaCode": {
    ///      "$ref": "#/components/schemas/AreaCode"
    ///    },
    ///    "tacs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Tac"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum Area {
        Variant0 {
            tacs: Vec<Tac>,
        },
        Variant1 {
            #[serde(rename = "areaCode")]
            area_code: AreaCode,
        },
    }

    impl From<&Area> for Area {
        fn from(value: &Area) -> Self {
            value.clone()
        }
    }

    ///Values are operator specific.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Values are operator specific.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct AreaCode(pub String);
    impl ::std::ops::Deref for AreaCode {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<AreaCode> for String {
        fn from(value: AreaCode) -> Self {
            value.0
        }
    }

    impl From<&AreaCode> for AreaCode {
        fn from(value: &AreaCode) -> Self {
            value.clone()
        }
    }

    impl From<String> for AreaCode {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for AreaCode {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for AreaCode {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Indicates the information of area based event reporting.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the information of area based event
    /// reporting.",
    ///  "type": "object",
    ///  "required": [
    ///    "areaDefinition"
    ///  ],
    ///  "properties": {
    ///    "areaDefinition": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ReportingArea"
    ///      },
    ///      "maxItems": 250,
    ///      "minItems": 1
    ///    },
    ///    "maximumInterval": {
    ///      "$ref": "#/components/schemas/MaximumInterval"
    ///    },
    ///    "minimumInterval": {
    ///      "$ref": "#/components/schemas/MinimumInterval"
    ///    },
    ///    "occurrenceInfo": {
    ///      "$ref": "#/components/schemas/OccurrenceInfo"
    ///    },
    ///    "reportingDuration": {
    ///      "$ref": "#/components/schemas/ReportingDuration"
    ///    },
    ///    "reportingLocationReq": {
    ///      "default": true,
    ///      "type": "boolean"
    ///    },
    ///    "samplingInterval": {
    ///      "$ref": "#/components/schemas/SamplingInterval"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AreaEventInfo {
        #[serde(rename = "areaDefinition")]
        pub area_definition: Vec<ReportingArea>,
        #[serde(
            rename = "maximumInterval",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub maximum_interval: Option<MaximumInterval>,
        #[serde(
            rename = "minimumInterval",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub minimum_interval: Option<MinimumInterval>,
        #[serde(
            rename = "occurrenceInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub occurrence_info: Option<OccurrenceInfo>,
        #[serde(
            rename = "reportingDuration",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub reporting_duration: Option<ReportingDuration>,
        #[serde(
            rename = "reportingLocationReq",
            default = "defaults::default_bool::<true>"
        )]
        pub reporting_location_req: bool,
        #[serde(
            rename = "samplingInterval",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub sampling_interval: Option<SamplingInterval>,
    }

    impl From<&AreaEventInfo> for AreaEventInfo {
        fn from(value: &AreaEventInfo) -> Self {
            value.clone()
        }
    }

    ///Event State of AoI event in old AMF
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Event State of AoI event in old AMF",
    ///  "type": "object",
    ///  "required": [
    ///    "presence"
    ///  ],
    ///  "properties": {
    ///    "individualPraIdList": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "presence": {
    ///      "$ref": "#/components/schemas/PresenceState"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AreaOfInterestEventState {
        #[serde(
            rename = "individualPraIdList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub individual_pra_id_list: Vec<String>,
        pub presence: PresenceState,
    }

    impl From<&AreaOfInterestEventState> for AreaOfInterestEventState {
        fn from(value: &AreaOfInterestEventState) -> Self {
            value.clone()
        }
    }

    ///Area of validity information for N2 information transfer
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Area of validity information for N2 information
    /// transfer",
    ///  "type": "object",
    ///  "required": [
    ///    "taiList"
    ///  ],
    ///  "properties": {
    ///    "taiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Tai"
    ///      },
    ///      "minItems": 0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AreaOfValidity {
        #[serde(rename = "taiList")]
        pub tai_list: Vec<Tai>,
    }

    impl From<&AreaOfValidity> for AreaOfValidity {
        fn from(value: &AreaOfValidity) -> Self {
            value.clone()
        }
    }

    ///Contain the area based on Cells or Tracking Areas.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contain the area based on Cells or Tracking Areas.",
    ///  "type": "object",
    ///  "properties": {
    ///    "eutraCellIdList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EutraCellId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "nrCellIdList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NrCellId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "tacInfoPerPlmn": {
    ///      "description": "A map (list of key-value pairs) where PlmnId
    /// converted to a string serves as key\n",
    ///      "type": "object",
    ///      "minProperties": 1,
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/TacInfo"
    ///      }
    ///    },
    ///    "tacList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Tac"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AreaScope {
        #[serde(
            rename = "eutraCellIdList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub eutra_cell_id_list: Vec<EutraCellId>,
        #[serde(
            rename = "nrCellIdList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub nr_cell_id_list: Vec<NrCellId>,
        ///A map (list of key-value pairs) where PlmnId converted to a string
        /// serves as key
        #[serde(
            rename = "tacInfoPerPlmn",
            default,
            skip_serializing_if = "::std::collections::HashMap::is_empty"
        )]
        pub tac_info_per_plmn: ::std::collections::HashMap<String, TacInfo>,
        #[serde(rename = "tacList", default, skip_serializing_if = "Vec::is_empty")]
        pub tac_list: Vec<Tac>,
    }

    impl From<&AreaScope> for AreaScope {
        fn from(value: &AreaScope) -> Self {
            value.clone()
        }
    }

    ///Integer value indicating the ARFCN applicable for a downlink, uplink or
    /// bi-directional (TDD) NR global frequency raster, as definition of
    /// "ARFCN-ValueNR" IE in clause 6.3.2 of 3GPP TS 38.331.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Integer value indicating the ARFCN applicable for a
    /// downlink, uplink or bi-directional (TDD) NR global frequency raster, as
    /// definition of \"ARFCN-ValueNR\" IE in clause 6.3.2 of 3GPP TS
    /// 38.331.\n",
    ///  "type": "integer",
    ///  "maximum": 3279165.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ArfcnValueNr(pub i64);
    impl ::std::ops::Deref for ArfcnValueNr {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<ArfcnValueNr> for i64 {
        fn from(value: ArfcnValueNr) -> Self {
            value.0
        }
    }

    impl From<&ArfcnValueNr> for ArfcnValueNr {
        fn from(value: &ArfcnValueNr) -> Self {
            value.clone()
        }
    }

    impl From<i64> for ArfcnValueNr {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for ArfcnValueNr {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for ArfcnValueNr {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ArfcnValueNr {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ArfcnValueNr {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for ArfcnValueNr {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Contains Allocation and Retention Priority information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains Allocation and Retention Priority
    /// information.",
    ///  "type": "object",
    ///  "required": [
    ///    "preemptCap",
    ///    "preemptVuln",
    ///    "priorityLevel"
    ///  ],
    ///  "properties": {
    ///    "preemptCap": {
    ///      "$ref": "#/components/schemas/PreemptionCapability"
    ///    },
    ///    "preemptVuln": {
    ///      "$ref": "#/components/schemas/PreemptionVulnerability"
    ///    },
    ///    "priorityLevel": {
    ///      "$ref": "#/components/schemas/ArpPriorityLevel"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Arp {
        #[serde(rename = "preemptCap")]
        pub preempt_cap: PreemptionCapability,
        #[serde(rename = "preemptVuln")]
        pub preempt_vuln: PreemptionVulnerability,
        #[serde(rename = "priorityLevel")]
        pub priority_level: ArpPriorityLevel,
    }

    impl From<&Arp> for Arp {
        fn from(value: &Arp) -> Self {
            value.clone()
        }
    }

    ///nullable true shall not be used for this attribute. Unsigned integer
    /// indicating the ARP Priority Level (see clause 5.7.2.2 of 3GPP TS 23.501,
    /// within the range 1 to 15.Values are ordered in decreasing order of
    /// priority, i.e. with 1 as the highest priority and 15 as the lowest
    /// priority.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "nullable true shall not be used for this attribute.
    /// Unsigned integer indicating the ARP Priority Level (see clause 5.7.2.2
    /// of 3GPP TS 23.501, within the range 1 to 15.Values are ordered in
    /// decreasing order of priority, i.e. with 1 as the highest priority and 15
    /// as the lowest priority. \n",
    ///  "type": [
    ///    "integer",
    ///    "null"
    ///  ],
    ///  "maximum": 15.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ArpPriorityLevel(pub Option<i64>);
    impl ::std::ops::Deref for ArpPriorityLevel {
        type Target = Option<i64>;
        fn deref(&self) -> &Option<i64> {
            &self.0
        }
    }

    impl From<ArpPriorityLevel> for Option<i64> {
        fn from(value: ArpPriorityLevel) -> Self {
            value.0
        }
    }

    impl From<&ArpPriorityLevel> for ArpPriorityLevel {
        fn from(value: &ArpPriorityLevel) -> Self {
            value.clone()
        }
    }

    impl From<Option<i64>> for ArpPriorityLevel {
        fn from(value: Option<i64>) -> Self {
            Self(value)
        }
    }

    ///Contains the 5G acess stratum time distribution parameters.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the 5G acess stratum time distribution
    /// parameters.",
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "properties": {
    ///    "asTimeDistInd": {
    ///      "type": "boolean"
    ///    },
    ///    "uuErrorBudget": {
    ///      "$ref": "#/components/schemas/UintegerRm"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AsTimeDistributionParam(pub Option<AsTimeDistributionParamInner>);
    impl ::std::ops::Deref for AsTimeDistributionParam {
        type Target = Option<AsTimeDistributionParamInner>;
        fn deref(&self) -> &Option<AsTimeDistributionParamInner> {
            &self.0
        }
    }

    impl From<AsTimeDistributionParam> for Option<AsTimeDistributionParamInner> {
        fn from(value: AsTimeDistributionParam) -> Self {
            value.0
        }
    }

    impl From<&AsTimeDistributionParam> for AsTimeDistributionParam {
        fn from(value: &AsTimeDistributionParam) -> Self {
            value.clone()
        }
    }

    impl From<Option<AsTimeDistributionParamInner>> for AsTimeDistributionParam {
        fn from(value: Option<AsTimeDistributionParamInner>) -> Self {
            Self(value)
        }
    }

    ///Contains the 5G acess stratum time distribution parameters.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the 5G acess stratum time distribution
    /// parameters.",
    ///  "type": "object",
    ///  "properties": {
    ///    "asTimeDistInd": {
    ///      "type": "boolean"
    ///    },
    ///    "uuErrorBudget": {
    ///      "$ref": "#/components/schemas/UintegerRm"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AsTimeDistributionParamInner {
        #[serde(
            rename = "asTimeDistInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub as_time_dist_ind: Option<bool>,
        #[serde(
            rename = "uuErrorBudget",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub uu_error_budget: Option<UintegerRm>,
    }

    impl From<&AsTimeDistributionParamInner> for AsTimeDistributionParamInner {
        fn from(value: &AsTimeDistributionParamInner) -> Self {
            value.clone()
        }
    }

    ///Data within an EBI assignment request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within an EBI assignment request",
    ///  "type": "object",
    ///  "required": [
    ///    "pduSessionId"
    ///  ],
    ///  "properties": {
    ///    "arpList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Arp"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "modifiedEbiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EbiArpMapping"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "oldGuami": {
    ///      "$ref": "#/components/schemas/Guami"
    ///    },
    ///    "pduSessionId": {
    ///      "$ref": "#/components/schemas/PduSessionId"
    ///    },
    ///    "releasedEbiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EpsBearerId"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AssignEbiData {
        #[serde(rename = "arpList", default, skip_serializing_if = "Vec::is_empty")]
        pub arp_list: Vec<Arp>,
        #[serde(
            rename = "modifiedEbiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub modified_ebi_list: Vec<EbiArpMapping>,
        #[serde(rename = "oldGuami", default, skip_serializing_if = "Option::is_none")]
        pub old_guami: Option<Guami>,
        #[serde(rename = "pduSessionId")]
        pub pdu_session_id: PduSessionId,
        #[serde(
            rename = "releasedEbiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub released_ebi_list: Vec<EpsBearerId>,
    }

    impl From<&AssignEbiData> for AssignEbiData {
        fn from(value: &AssignEbiData) -> Self {
            value.clone()
        }
    }

    ///Data within a failure response to the EBI assignment request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a failure response to the EBI assignment
    /// request",
    ///  "type": "object",
    ///  "required": [
    ///    "error",
    ///    "failureDetails"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "$ref": "#/components/schemas/ProblemDetails"
    ///    },
    ///    "failureDetails": {
    ///      "$ref": "#/components/schemas/AssignEbiFailed"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AssignEbiError {
        pub error: ProblemDetails,
        #[serde(rename = "failureDetails")]
        pub failure_details: AssignEbiFailed,
    }

    impl From<&AssignEbiError> for AssignEbiError {
        fn from(value: &AssignEbiError) -> Self {
            value.clone()
        }
    }

    ///Represents failed assignment of EBI(s)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents failed assignment of EBI(s)",
    ///  "type": "object",
    ///  "required": [
    ///    "pduSessionId"
    ///  ],
    ///  "properties": {
    ///    "failedArpList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Arp"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "pduSessionId": {
    ///      "$ref": "#/components/schemas/PduSessionId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AssignEbiFailed {
        #[serde(
            rename = "failedArpList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub failed_arp_list: Vec<Arp>,
        #[serde(rename = "pduSessionId")]
        pub pdu_session_id: PduSessionId,
    }

    impl From<&AssignEbiFailed> for AssignEbiFailed {
        fn from(value: &AssignEbiFailed) -> Self {
            value.clone()
        }
    }

    ///Data within a successful response to an EBI assignment request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a successful response to an EBI assignment
    /// request",
    ///  "type": "object",
    ///  "required": [
    ///    "assignedEbiList",
    ///    "pduSessionId"
    ///  ],
    ///  "properties": {
    ///    "assignedEbiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EbiArpMapping"
    ///      },
    ///      "minItems": 0
    ///    },
    ///    "failedArpList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Arp"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "modifiedEbiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EpsBearerId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "pduSessionId": {
    ///      "$ref": "#/components/schemas/PduSessionId"
    ///    },
    ///    "releasedEbiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EpsBearerId"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct AssignedEbiData {
        #[serde(rename = "assignedEbiList")]
        pub assigned_ebi_list: Vec<EbiArpMapping>,
        #[serde(
            rename = "failedArpList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub failed_arp_list: Vec<Arp>,
        #[serde(
            rename = "modifiedEbiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub modified_ebi_list: Vec<EpsBearerId>,
        #[serde(rename = "pduSessionId")]
        pub pdu_session_id: PduSessionId,
        #[serde(
            rename = "releasedEbiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub released_ebi_list: Vec<EpsBearerId>,
    }

    impl From<&AssignedEbiData> for AssignedEbiData {
        fn from(value: &AssignedEbiData) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - "EAP_SUCCESS": The NSSAA status is EAP-Success.
    /// - "EAP_FAILURE": The NSSAA status is EAP-Failure.
    /// - "PENDING": The NSSAA status is Pending.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- \"EAP_SUCCESS\": The NSSAA
    /// status is EAP-Success.\n- \"EAP_FAILURE\": The NSSAA status is
    /// EAP-Failure.\n- \"PENDING\": The NSSAA status is Pending. \n",
    ///  "type": "string",
    ///  "enum": [
    ///    "EAP_SUCCESS",
    ///    "EAP_FAILURE",
    ///    "PENDING"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum AuthStatus {
        #[serde(rename = "EAP_SUCCESS")]
        EapSuccess,
        #[serde(rename = "EAP_FAILURE")]
        EapFailure,
        #[serde(rename = "PENDING")]
        Pending,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&AuthStatus> for AuthStatus {
        fn from(value: &AuthStatus) -> Self {
            value.clone()
        }
    }

    impl ToString for AuthStatus {
        fn to_string(&self) -> String {
            match *self {
                Self::EapSuccess => "EAP_SUCCESS".to_string(),
                Self::EapFailure => "EAP_FAILURE".to_string(),
                Self::Pending => "PENDING".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for AuthStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EAP_SUCCESS" => Ok(Self::EapSuccess),
                "EAP_FAILURE" => Ok(Self::EapFailure),
                "PENDING" => Ok(Self::Pending),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for AuthStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for AuthStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for AuthStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Specifies the measured uncompensated atmospheric pressure.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Specifies the measured uncompensated atmospheric
    /// pressure.",
    ///  "type": "integer",
    ///  "maximum": 115000.0,
    ///  "minimum": 30000.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BarometricPressure(pub i64);
    impl ::std::ops::Deref for BarometricPressure {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<BarometricPressure> for i64 {
        fn from(value: BarometricPressure) -> Self {
            value.0
        }
    }

    impl From<&BarometricPressure> for BarometricPressure {
        fn from(value: &BarometricPressure) -> Self {
            value.clone()
        }
    }

    impl From<i64> for BarometricPressure {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for BarometricPressure {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for BarometricPressure {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for BarometricPressure {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for BarometricPressure {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for BarometricPressure {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Parameters "replaceableInd" and "rechargeableInd" are only included if
    /// the value of Parameter "batteryInd" is true.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Parameters \"replaceableInd\" and \"rechargeableInd\" are only included if the value of Parameter \"batteryInd\" is true.\n",
    ///  "type": "object",
    ///  "properties": {
    ///    "batteryInd": {
    ///      "description": "This IE shall indicate whether the UE is battery
    /// powered or not. true: the UE is battery powered; false or absent: the UE
    /// is not battery powered\n",
    ///      "type": "boolean"
    ///    },
    ///    "rechargeableInd": {
    ///      "description": "This IE shall indicate whether the battery of the
    /// UE is rechargeable or not. true: the battery of UE is rechargeable;
    /// false or absent: the battery of the UE is not rechargeable.\n",
    ///      "type": "boolean"
    ///    },
    ///    "replaceableInd": {
    ///      "description": "This IE shall indicate whether the battery of the
    /// UE is replaceable or not. true: the battery of the UE is replaceable;
    /// false or absent: the battery of the UE is not replaceable.\n",
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BatteryIndication {
        ///This IE shall indicate whether the UE is battery powered or not.
        /// true: the UE is battery powered; false or absent: the UE is not
        /// battery powered
        #[serde(
            rename = "batteryInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub battery_ind: Option<bool>,
        ///This IE shall indicate whether the battery of the UE is rechargeable
        /// or not. true: the battery of UE is rechargeable; false or absent:
        /// the battery of the UE is not rechargeable.
        #[serde(
            rename = "rechargeableInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub rechargeable_ind: Option<bool>,
        ///This IE shall indicate whether the battery of the UE is replaceable
        /// or not. true: the battery of the UE is replaceable; false or absent:
        /// the battery of the UE is not replaceable.
        #[serde(
            rename = "replaceableInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub replaceable_ind: Option<bool>,
    }

    impl From<&BatteryIndication> for BatteryIndication {
        fn from(value: &BatteryIndication) -> Self {
            value.clone()
        }
    }

    ///String representing a bit rate; the prefixes follow the standard symbols
    /// from The International System of Units, and represent x1000 multipliers,
    /// with the exception that prefix "K" is used to represent the standard
    /// symbol "k".
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String representing a bit rate; the prefixes follow the
    /// standard symbols from The International System of Units, and represent
    /// x1000 multipliers, with the exception that prefix \"K\" is used to
    /// represent the standard symbol \"k\".\n",
    ///  "type": "string",
    ///  "pattern": "^\\d+(\\.\\d+)? (bps|Kbps|Mbps|Gbps|Tbps)$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct BitRate(String);
    impl ::std::ops::Deref for BitRate {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<BitRate> for String {
        fn from(value: BitRate) -> Self {
            value.0
        }
    }

    impl From<&BitRate> for BitRate {
        fn from(value: &BitRate) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for BitRate {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^\\d+(\\.\\d+)? (bps|Kbps|Mbps|Gbps|Tbps)$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err(
                    "doesn't match pattern \"^\\d+(\\.\\d+)? (bps|Kbps|Mbps|Gbps|Tbps)$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for BitRate {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for BitRate {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for BitRate {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for BitRate {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Represents bandwidth requirements.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents bandwidth requirements.",
    ///  "type": "object",
    ///  "required": [
    ///    "appId"
    ///  ],
    ///  "properties": {
    ///    "appId": {
    ///      "$ref": "#/components/schemas/ApplicationId"
    ///    },
    ///    "marBwDl": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "marBwUl": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "mirBwDl": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "mirBwUl": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct BwRequirement {
        #[serde(rename = "appId")]
        pub app_id: ApplicationId,
        #[serde(rename = "marBwDl", default, skip_serializing_if = "Option::is_none")]
        pub mar_bw_dl: Option<BitRate>,
        #[serde(rename = "marBwUl", default, skip_serializing_if = "Option::is_none")]
        pub mar_bw_ul: Option<BitRate>,
        #[serde(rename = "mirBwDl", default, skip_serializing_if = "Option::is_none")]
        pub mir_bw_dl: Option<BitRate>,
        #[serde(rename = "mirBwUl", default, skip_serializing_if = "Option::is_none")]
        pub mir_bw_ul: Option<BitRate>,
    }

    impl From<&BwRequirement> for BwRequirement {
        fn from(value: &BwRequirement) -> Self {
            value.clone()
        }
    }

    ///string with format 'bytes' as defined in OpenAPI
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "string with format 'bytes' as defined in OpenAPI",
    ///  "type": "string",
    ///  "format": "byte"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct Bytes(pub String);
    impl ::std::ops::Deref for Bytes {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Bytes> for String {
        fn from(value: Bytes) -> Self {
            value.0
        }
    }

    impl From<&Bytes> for Bytes {
        fn from(value: &Bytes) -> Self {
            value.clone()
        }
    }

    impl From<String> for Bytes {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for Bytes {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for Bytes {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///String representing the C-MSISDN as defined in clause 18.7 of 3GPP TS
    /// 23.003.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String representing the C-MSISDN as defined in clause
    /// 18.7 of 3GPP TS 23.003.",
    ///  "type": "string",
    ///  "pattern": "^[0-9]{5,15}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct CMsisdn(String);
    impl ::std::ops::Deref for CMsisdn {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<CMsisdn> for String {
        fn from(value: CMsisdn) -> Self {
            value.0
        }
    }

    impl From<&CMsisdn> for CMsisdn {
        fn from(value: &CMsisdn) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CMsisdn {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9]{5,15}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9]{5,15}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CMsisdn {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for CMsisdn {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for CMsisdn {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CMsisdn {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///CagData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "cagInfos"
    ///  ],
    ///  "properties": {
    ///    "cagInfos": {
    ///      "description": "A map (list of key-value pairs where PlmnId serves
    /// as key) of CagInfo",
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/CagInfo"
    ///      }
    ///    },
    ///    "provisioningTime": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CagData {
        ///A map (list of key-value pairs where PlmnId serves as key) of
        /// CagInfo
        #[serde(rename = "cagInfos")]
        pub cag_infos: ::std::collections::HashMap<String, CagInfo>,
        #[serde(
            rename = "provisioningTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub provisioning_time: Option<DateTime>,
    }

    impl From<&CagData> for CagData {
        fn from(value: &CagData) -> Self {
            value.clone()
        }
    }

    ///String containing a Closed Access Group Identifier.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String containing a Closed Access Group Identifier.",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{8}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct CagId(String);
    impl ::std::ops::Deref for CagId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<CagId> for String {
        fn from(value: CagId) -> Self {
            value.0
        }
    }

    impl From<&CagId> for CagId {
        fn from(value: &CagId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CagId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{8}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{8}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CagId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for CagId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for CagId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CagId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///CagInfo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "allowedCagList"
    ///  ],
    ///  "properties": {
    ///    "allowedCagList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CagId"
    ///      }
    ///    },
    ///    "cagOnlyIndicator": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CagInfo {
        #[serde(rename = "allowedCagList")]
        pub allowed_cag_list: Vec<CagId>,
        #[serde(
            rename = "cagOnlyIndicator",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub cag_only_indicator: Option<bool>,
    }

    impl From<&CagInfo> for CagInfo {
        fn from(value: &CagInfo) -> Self {
            value.clone()
        }
    }

    ///Data within a Cancel Location Request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a Cancel Location Request",
    ///  "type": "object",
    ///  "required": [
    ///    "hgmlcCallBackURI",
    ///    "ldrReference",
    ///    "supi"
    ///  ],
    ///  "properties": {
    ///    "hgmlcCallBackURI": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "ldrReference": {
    ///      "$ref": "#/components/schemas/LdrReference"
    ///    },
    ///    "servingLMFIdentification": {
    ///      "$ref": "#/components/schemas/LMFIdentification"
    ///    },
    ///    "supi": {
    ///      "$ref": "#/components/schemas/Supi"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CancelPosInfo {
        #[serde(rename = "hgmlcCallBackURI")]
        pub hgmlc_call_back_uri: Uri,
        #[serde(rename = "ldrReference")]
        pub ldr_reference: LdrReference,
        #[serde(
            rename = "servingLMFIdentification",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub serving_lmf_identification: Option<LmfIdentification>,
        pub supi: Supi,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
    }

    impl From<&CancelPosInfo> for CancelPosInfo {
        fn from(value: &CancelPosInfo) -> Self {
            value.clone()
        }
    }

    ///Represents a list of candidate DNNs for replacement for an S-NSSAI.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a list of candidate DNNs for replacement for
    /// an S-NSSAI.",
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "required": [
    ///    "snssai"
    ///  ],
    ///  "properties": {
    ///    "dnns": {
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/Dnn"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CandidateForReplacement(pub Option<CandidateForReplacementInner>);
    impl ::std::ops::Deref for CandidateForReplacement {
        type Target = Option<CandidateForReplacementInner>;
        fn deref(&self) -> &Option<CandidateForReplacementInner> {
            &self.0
        }
    }

    impl From<CandidateForReplacement> for Option<CandidateForReplacementInner> {
        fn from(value: CandidateForReplacement) -> Self {
            value.0
        }
    }

    impl From<&CandidateForReplacement> for CandidateForReplacement {
        fn from(value: &CandidateForReplacement) -> Self {
            value.clone()
        }
    }

    impl From<Option<CandidateForReplacementInner>> for CandidateForReplacement {
        fn from(value: Option<CandidateForReplacementInner>) -> Self {
            Self(value)
        }
    }

    ///Represents a list of candidate DNNs for replacement for an S-NSSAI.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a list of candidate DNNs for replacement for
    /// an S-NSSAI.",
    ///  "type": "object",
    ///  "required": [
    ///    "snssai"
    ///  ],
    ///  "properties": {
    ///    "dnns": {
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/Dnn"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CandidateForReplacementInner {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dnns: Option<Vec<Dnn>>,
        pub snssai: Snssai,
    }

    impl From<&CandidateForReplacementInner> for CandidateForReplacementInner {
        fn from(value: &CandidateForReplacementInner) -> Self {
            value.clone()
        }
    }

    ///CE-mode-B Support Indicator.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "CE-mode-B Support Indicator.",
    ///  "type": "object",
    ///  "required": [
    ///    "ceModeBSupportInd"
    ///  ],
    ///  "properties": {
    ///    "ceModeBSupportInd": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CeModeBInd {
        #[serde(rename = "ceModeBSupportInd")]
        pub ce_mode_b_support_ind: bool,
    }

    impl From<&CeModeBInd> for CeModeBInd {
        fn from(value: &CeModeBInd) -> Self {
            value.clone()
        }
    }

    ///Contains a Cell Global Identification as defined in 3GPP TS 23.003,
    /// clause 4.3.1.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains a Cell Global Identification as defined in
    /// 3GPP TS 23.003, clause 4.3.1.",
    ///  "type": "object",
    ///  "required": [
    ///    "cellId",
    ///    "lac",
    ///    "plmnId"
    ///  ],
    ///  "properties": {
    ///    "cellId": {
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]{4}$"
    ///    },
    ///    "lac": {
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]{4}$"
    ///    },
    ///    "plmnId": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CellGlobalId {
        #[serde(rename = "cellId")]
        pub cell_id: CellGlobalIdCellId,
        pub lac: CellGlobalIdLac,
        #[serde(rename = "plmnId")]
        pub plmn_id: PlmnId,
    }

    impl From<&CellGlobalId> for CellGlobalId {
        fn from(value: &CellGlobalId) -> Self {
            value.clone()
        }
    }

    ///CellGlobalIdCellId
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{4}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct CellGlobalIdCellId(String);
    impl ::std::ops::Deref for CellGlobalIdCellId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<CellGlobalIdCellId> for String {
        fn from(value: CellGlobalIdCellId) -> Self {
            value.0
        }
    }

    impl From<&CellGlobalIdCellId> for CellGlobalIdCellId {
        fn from(value: &CellGlobalIdCellId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CellGlobalIdCellId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{4}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{4}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CellGlobalIdCellId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for CellGlobalIdCellId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for CellGlobalIdCellId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CellGlobalIdCellId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///CellGlobalIdLac
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{4}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct CellGlobalIdLac(String);
    impl ::std::ops::Deref for CellGlobalIdLac {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<CellGlobalIdLac> for String {
        fn from(value: CellGlobalIdLac) -> Self {
            value.0
        }
    }

    impl From<&CellGlobalIdLac> for CellGlobalIdLac {
        fn from(value: &CellGlobalIdLac) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CellGlobalIdLac {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{4}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{4}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CellGlobalIdLac {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for CellGlobalIdLac {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for CellGlobalIdLac {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CellGlobalIdLac {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Indicates the supported Ciphering Algorithm
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the supported Ciphering Algorithm",
    ///  "type": "string",
    ///  "enum": [
    ///    "NEA0",
    ///    "NEA1",
    ///    "NEA2",
    ///    "NEA3"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CipheringAlgorithm {
        #[serde(rename = "NEA0")]
        Nea0,
        #[serde(rename = "NEA1")]
        Nea1,
        #[serde(rename = "NEA2")]
        Nea2,
        #[serde(rename = "NEA3")]
        Nea3,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&CipheringAlgorithm> for CipheringAlgorithm {
        fn from(value: &CipheringAlgorithm) -> Self {
            value.clone()
        }
    }

    impl ToString for CipheringAlgorithm {
        fn to_string(&self) -> String {
            match *self {
                Self::Nea0 => "NEA0".to_string(),
                Self::Nea1 => "NEA1".to_string(),
                Self::Nea2 => "NEA2".to_string(),
                Self::Nea3 => "NEA3".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for CipheringAlgorithm {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NEA0" => Ok(Self::Nea0),
                "NEA1" => Ok(Self::Nea1),
                "NEA2" => Ok(Self::Nea2),
                "NEA3" => Ok(Self::Nea3),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for CipheringAlgorithm {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for CipheringAlgorithm {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for CipheringAlgorithm {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Contains the description of a circumstance.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the description of a circumstance.",
    ///  "type": "object",
    ///  "properties": {
    ///    "freq": {
    ///      "$ref": "#/components/schemas/Float"
    ///    },
    ///    "locArea": {
    ///      "$ref": "#/components/schemas/NetworkAreaInfo"
    ///    },
    ///    "tm": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "vol": {
    ///      "$ref": "#/components/schemas/Volume"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CircumstanceDescription {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub freq: Option<Float>,
        #[serde(rename = "locArea", default, skip_serializing_if = "Option::is_none")]
        pub loc_area: Option<NetworkAreaInfo>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub tm: Option<DateTime>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub vol: Option<Volume>,
    }

    impl From<&CircumstanceDescription> for CircumstanceDescription {
        fn from(value: &CircumstanceDescription) -> Self {
            value.clone()
        }
    }

    ///Indicates a Civic address.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates a Civic address.",
    ///  "type": "object",
    ///  "properties": {
    ///    "A1": {
    ///      "type": "string"
    ///    },
    ///    "A2": {
    ///      "type": "string"
    ///    },
    ///    "A3": {
    ///      "type": "string"
    ///    },
    ///    "A4": {
    ///      "type": "string"
    ///    },
    ///    "A5": {
    ///      "type": "string"
    ///    },
    ///    "A6": {
    ///      "type": "string"
    ///    },
    ///    "ADDCODE": {
    ///      "type": "string"
    ///    },
    ///    "BLD": {
    ///      "type": "string"
    ///    },
    ///    "FLR": {
    ///      "type": "string"
    ///    },
    ///    "HNO": {
    ///      "type": "string"
    ///    },
    ///    "HNS": {
    ///      "type": "string"
    ///    },
    ///    "LMK": {
    ///      "type": "string"
    ///    },
    ///    "LOC": {
    ///      "type": "string"
    ///    },
    ///    "NAM": {
    ///      "type": "string"
    ///    },
    ///    "PC": {
    ///      "type": "string"
    ///    },
    ///    "PCN": {
    ///      "type": "string"
    ///    },
    ///    "PLC": {
    ///      "type": "string"
    ///    },
    ///    "POBOX": {
    ///      "type": "string"
    ///    },
    ///    "POD": {
    ///      "type": "string"
    ///    },
    ///    "POM": {
    ///      "type": "string"
    ///    },
    ///    "PRD": {
    ///      "type": "string"
    ///    },
    ///    "PRM": {
    ///      "type": "string"
    ///    },
    ///    "RD": {
    ///      "type": "string"
    ///    },
    ///    "RDBR": {
    ///      "type": "string"
    ///    },
    ///    "RDSEC": {
    ///      "type": "string"
    ///    },
    ///    "RDSUBBR": {
    ///      "type": "string"
    ///    },
    ///    "ROOM": {
    ///      "type": "string"
    ///    },
    ///    "SEAT": {
    ///      "type": "string"
    ///    },
    ///    "STS": {
    ///      "type": "string"
    ///    },
    ///    "UNIT": {
    ///      "type": "string"
    ///    },
    ///    "country": {
    ///      "type": "string"
    ///    },
    ///    "method": {
    ///      "type": "string"
    ///    },
    ///    "providedBy": {
    ///      "type": "string"
    ///    },
    ///    "usageRules": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CivicAddress {
        #[serde(rename = "A1", default, skip_serializing_if = "Option::is_none")]
        pub a1: Option<String>,
        #[serde(rename = "A2", default, skip_serializing_if = "Option::is_none")]
        pub a2: Option<String>,
        #[serde(rename = "A3", default, skip_serializing_if = "Option::is_none")]
        pub a3: Option<String>,
        #[serde(rename = "A4", default, skip_serializing_if = "Option::is_none")]
        pub a4: Option<String>,
        #[serde(rename = "A5", default, skip_serializing_if = "Option::is_none")]
        pub a5: Option<String>,
        #[serde(rename = "A6", default, skip_serializing_if = "Option::is_none")]
        pub a6: Option<String>,
        #[serde(rename = "ADDCODE", default, skip_serializing_if = "Option::is_none")]
        pub addcode: Option<String>,
        #[serde(rename = "BLD", default, skip_serializing_if = "Option::is_none")]
        pub bld: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub country: Option<String>,
        #[serde(rename = "FLR", default, skip_serializing_if = "Option::is_none")]
        pub flr: Option<String>,
        #[serde(rename = "HNO", default, skip_serializing_if = "Option::is_none")]
        pub hno: Option<String>,
        #[serde(rename = "HNS", default, skip_serializing_if = "Option::is_none")]
        pub hns: Option<String>,
        #[serde(rename = "LMK", default, skip_serializing_if = "Option::is_none")]
        pub lmk: Option<String>,
        #[serde(rename = "LOC", default, skip_serializing_if = "Option::is_none")]
        pub loc: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub method: Option<String>,
        #[serde(rename = "NAM", default, skip_serializing_if = "Option::is_none")]
        pub nam: Option<String>,
        #[serde(rename = "PC", default, skip_serializing_if = "Option::is_none")]
        pub pc: Option<String>,
        #[serde(rename = "PCN", default, skip_serializing_if = "Option::is_none")]
        pub pcn: Option<String>,
        #[serde(rename = "PLC", default, skip_serializing_if = "Option::is_none")]
        pub plc: Option<String>,
        #[serde(rename = "POBOX", default, skip_serializing_if = "Option::is_none")]
        pub pobox: Option<String>,
        #[serde(rename = "POD", default, skip_serializing_if = "Option::is_none")]
        pub pod: Option<String>,
        #[serde(rename = "POM", default, skip_serializing_if = "Option::is_none")]
        pub pom: Option<String>,
        #[serde(rename = "PRD", default, skip_serializing_if = "Option::is_none")]
        pub prd: Option<String>,
        #[serde(rename = "PRM", default, skip_serializing_if = "Option::is_none")]
        pub prm: Option<String>,
        #[serde(
            rename = "providedBy",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub provided_by: Option<String>,
        #[serde(rename = "RD", default, skip_serializing_if = "Option::is_none")]
        pub rd: Option<String>,
        #[serde(rename = "RDBR", default, skip_serializing_if = "Option::is_none")]
        pub rdbr: Option<String>,
        #[serde(rename = "RDSEC", default, skip_serializing_if = "Option::is_none")]
        pub rdsec: Option<String>,
        #[serde(rename = "RDSUBBR", default, skip_serializing_if = "Option::is_none")]
        pub rdsubbr: Option<String>,
        #[serde(rename = "ROOM", default, skip_serializing_if = "Option::is_none")]
        pub room: Option<String>,
        #[serde(rename = "SEAT", default, skip_serializing_if = "Option::is_none")]
        pub seat: Option<String>,
        #[serde(rename = "STS", default, skip_serializing_if = "Option::is_none")]
        pub sts: Option<String>,
        #[serde(rename = "UNIT", default, skip_serializing_if = "Option::is_none")]
        pub unit: Option<String>,
        #[serde(
            rename = "usageRules",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub usage_rules: Option<String>,
    }

    impl From<&CivicAddress> for CivicAddress {
        fn from(value: &CivicAddress) -> Self {
            value.clone()
        }
    }

    ///Indicates the dispersion class criterion for fixed, camper and/or
    /// traveller UE, and/or the top-heavy UE dispersion class criterion.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the dispersion class criterion for fixed,
    /// camper and/or traveller UE, and/or the top-heavy UE dispersion class
    /// criterion.\n",
    ///  "type": "object",
    ///  "required": [
    ///    "classThreshold",
    ///    "disperClass",
    ///    "thresMatch"
    ///  ],
    ///  "properties": {
    ///    "classThreshold": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    },
    ///    "disperClass": {
    ///      "$ref": "#/components/schemas/DispersionClass"
    ///    },
    ///    "thresMatch": {
    ///      "$ref": "#/components/schemas/MatchingDirection"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ClassCriterion {
        #[serde(rename = "classThreshold")]
        pub class_threshold: SamplingRatio,
        #[serde(rename = "disperClass")]
        pub disper_class: DispersionClass,
        #[serde(rename = "thresMatch")]
        pub thres_match: MatchingDirection,
    }

    impl From<&ClassCriterion> for ClassCriterion {
        fn from(value: &ClassCriterion) -> Self {
            value.clone()
        }
    }

    ///Represents the connection management state of a UE for an access type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the connection management state of a UE for
    /// an access type",
    ///  "type": "object",
    ///  "required": [
    ///    "accessType",
    ///    "cmState"
    ///  ],
    ///  "properties": {
    ///    "accessType": {
    ///      "$ref": "#/components/schemas/AccessType"
    ///    },
    ///    "cmState": {
    ///      "$ref": "#/components/schemas/CmState"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CmInfo {
        #[serde(rename = "accessType")]
        pub access_type: AccessType,
        #[serde(rename = "cmState")]
        pub cm_state: CmState,
    }

    impl From<&CmInfo> for CmInfo {
        fn from(value: &CmInfo) -> Self {
            value.clone()
        }
    }

    ///Describes the connection management state of a UE
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the connection management state of a UE",
    ///  "type": "string",
    ///  "enum": [
    ///    "IDLE",
    ///    "CONNECTED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CmState {
        #[serde(rename = "IDLE")]
        Idle,
        #[serde(rename = "CONNECTED")]
        Connected,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&CmState> for CmState {
        fn from(value: &CmState) -> Self {
            value.clone()
        }
    }

    impl ToString for CmState {
        fn to_string(&self) -> String {
            match *self {
                Self::Idle => "IDLE".to_string(),
                Self::Connected => "CONNECTED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for CmState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "IDLE" => Ok(Self::Idle),
                "CONNECTED" => Ok(Self::Connected),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for CmState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for CmState {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for CmState {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///SMF derived CN assisted RAN parameters tuning
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "SMF derived CN assisted RAN parameters tuning",
    ///  "type": "object",
    ///  "properties": {
    ///    "batteryIndication": {
    ///      "$ref": "#/components/schemas/BatteryIndication"
    ///    },
    ///    "communicationDurationTime": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "periodicTime": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "scheduledCommunicationTime": {
    ///      "$ref": "#/components/schemas/ScheduledCommunicationTime"
    ///    },
    ///    "scheduledCommunicationType": {
    ///      "$ref": "#/components/schemas/ScheduledCommunicationType"
    ///    },
    ///    "stationaryIndication": {
    ///      "$ref": "#/components/schemas/StationaryIndication"
    ///    },
    ///    "trafficProfile": {
    ///      "$ref": "#/components/schemas/TrafficProfile"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CnAssistedRanPara {
        #[serde(
            rename = "batteryIndication",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub battery_indication: Option<BatteryIndication>,
        #[serde(
            rename = "communicationDurationTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub communication_duration_time: Option<DurationSec>,
        #[serde(
            rename = "periodicTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub periodic_time: Option<DurationSec>,
        #[serde(
            rename = "scheduledCommunicationTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub scheduled_communication_time: Option<ScheduledCommunicationTime>,
        #[serde(
            rename = "scheduledCommunicationType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub scheduled_communication_type: Option<ScheduledCommunicationType>,
        #[serde(
            rename = "stationaryIndication",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub stationary_indication: Option<StationaryIndication>,
        #[serde(
            rename = "trafficProfile",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub traffic_profile: Option<TrafficProfile>,
    }

    impl From<&CnAssistedRanPara> for CnAssistedRanPara {
        fn from(value: &CnAssistedRanPara) -> Self {
            value.clone()
        }
    }

    ///Contains the codeword
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the codeword",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct CodeWord(pub String);
    impl ::std::ops::Deref for CodeWord {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<CodeWord> for String {
        fn from(value: CodeWord) -> Self {
            value.0
        }
    }

    impl From<&CodeWord> for CodeWord {
        fn from(value: &CodeWord) -> Self {
            value.clone()
        }
    }

    impl From<String> for CodeWord {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for CodeWord {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for CodeWord {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///The enumeration CollectionPeriodRmmLteMdt defines Collection period for
    /// RRM measurements LTE for MDT in the trace. See 3GPP TS 32.422 for
    /// further description of the values. It shall comply with the provisions
    /// defined in table 5.6.3.15-1.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration CollectionPeriodRmmLteMdt defines
    /// Collection period for RRM measurements LTE for MDT in the trace. See
    /// 3GPP TS 32.422 for further description of the values. It shall comply
    /// with the provisions defined in table 5.6.3.15-1.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    1024,
    ///    1280,
    ///    2048,
    ///    2560,
    ///    5120,
    ///    10240,
    ///    60000
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CollectionPeriodRmmLteMdt {
        #[serde(rename = "1024")]
        NUM1024,
        #[serde(rename = "1280")]
        NUM1280,
        #[serde(rename = "2048")]
        NUM2048,
        #[serde(rename = "2560")]
        NUM2560,
        #[serde(rename = "5120")]
        NUM5120,
        #[serde(rename = "10240")]
        NUM10240,
        #[serde(rename = "60000")]
        NUM60000,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&CollectionPeriodRmmLteMdt> for CollectionPeriodRmmLteMdt {
        fn from(value: &CollectionPeriodRmmLteMdt) -> Self {
            value.clone()
        }
    }

    impl ToString for CollectionPeriodRmmLteMdt {
        fn to_string(&self) -> String {
            match *self {
                Self::NUM1024 => "1024".to_string(),
                Self::NUM1280 => "1280".to_string(),
                Self::NUM2048 => "2048".to_string(),
                Self::NUM2560 => "2560".to_string(),
                Self::NUM5120 => "5120".to_string(),
                Self::NUM10240 => "10240".to_string(),
                Self::NUM60000 => "60000".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for CollectionPeriodRmmLteMdt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "1024" => Ok(Self::NUM1024),
                "1280" => Ok(Self::NUM1280),
                "2048" => Ok(Self::NUM2048),
                "2560" => Ok(Self::NUM2560),
                "5120" => Ok(Self::NUM5120),
                "10240" => Ok(Self::NUM10240),
                "60000" => Ok(Self::NUM60000),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for CollectionPeriodRmmLteMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for CollectionPeriodRmmLteMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for CollectionPeriodRmmLteMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The enumeration CollectionPeriodRmmNrMdt defines Collection period for
    /// RRM measurements NR for MDT in the trace. See 3GPP TS 32.422 for further
    /// description of the values. It shall comply with the provisions defined
    /// in table 5.6.3.19-1
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration CollectionPeriodRmmNrMdt defines
    /// Collection period for RRM measurements NR for MDT in the trace. See 3GPP
    /// TS 32.422 for further description of the values. It shall comply with
    /// the provisions defined in table 5.6.3.19-1\n",
    ///  "type": "string",
    ///  "enum": [
    ///    1024,
    ///    2048,
    ///    5120,
    ///    10240,
    ///    60000
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CollectionPeriodRmmNrMdt {
        #[serde(rename = "1024")]
        NUM1024,
        #[serde(rename = "2048")]
        NUM2048,
        #[serde(rename = "5120")]
        NUM5120,
        #[serde(rename = "10240")]
        NUM10240,
        #[serde(rename = "60000")]
        NUM60000,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&CollectionPeriodRmmNrMdt> for CollectionPeriodRmmNrMdt {
        fn from(value: &CollectionPeriodRmmNrMdt) -> Self {
            value.clone()
        }
    }

    impl ToString for CollectionPeriodRmmNrMdt {
        fn to_string(&self) -> String {
            match *self {
                Self::NUM1024 => "1024".to_string(),
                Self::NUM2048 => "2048".to_string(),
                Self::NUM5120 => "5120".to_string(),
                Self::NUM10240 => "10240".to_string(),
                Self::NUM60000 => "60000".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for CollectionPeriodRmmNrMdt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "1024" => Ok(Self::NUM1024),
                "2048" => Ok(Self::NUM2048),
                "5120" => Ok(Self::NUM5120),
                "10240" => Ok(Self::NUM10240),
                "60000" => Ok(Self::NUM60000),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for CollectionPeriodRmmNrMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for CollectionPeriodRmmNrMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for CollectionPeriodRmmNrMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Describes a communication failure detected by AMF
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes a communication failure detected by AMF",
    ///  "type": "object",
    ///  "properties": {
    ///    "nasReleaseCode": {
    ///      "type": "string"
    ///    },
    ///    "ranReleaseCode": {
    ///      "$ref": "#/components/schemas/NgApCause"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CommunicationFailure {
        #[serde(
            rename = "nasReleaseCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nas_release_code: Option<String>,
        #[serde(
            rename = "ranReleaseCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ran_release_code: Option<NgApCause>,
    }

    impl From<&CommunicationFailure> for CommunicationFailure {
        fn from(value: &CommunicationFailure) -> Self {
            value.clone()
        }
    }

    ///Indicates value of confidence.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates value of confidence.",
    ///  "type": "integer",
    ///  "maximum": 100.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Confidence(pub i64);
    impl ::std::ops::Deref for Confidence {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<Confidence> for i64 {
        fn from(value: Confidence) -> Self {
            value.0
        }
    }

    impl From<&Confidence> for Confidence {
        fn from(value: &Confidence) -> Self {
            value.clone()
        }
    }

    impl From<i64> for Confidence {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for Confidence {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for Confidence {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Confidence {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Confidence {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for Confidence {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Contains the configured S-NSSAI(s) authorized by the NSSF in the serving
    /// PLMN and optional mapped home S-NSSAI
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the configured S-NSSAI(s) authorized by the
    /// NSSF in the serving PLMN and optional mapped home S-NSSAI",
    ///  "type": "object",
    ///  "required": [
    ///    "configuredSnssai"
    ///  ],
    ///  "properties": {
    ///    "configuredSnssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "mappedHomeSnssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ConfiguredSnssai {
        #[serde(rename = "configuredSnssai")]
        pub configured_snssai: Snssai,
        #[serde(
            rename = "mappedHomeSnssai",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub mapped_home_snssai: Option<Snssai>,
    }

    impl From<&ConfiguredSnssai> for ConfiguredSnssai {
        fn from(value: &ConfiguredSnssai) -> Self {
            value.clone()
        }
    }

    ///Represents the congestion information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the congestion information.",
    ///  "type": "object",
    ///  "required": [
    ///    "congType",
    ///    "nsi",
    ///    "timeIntev"
    ///  ],
    ///  "properties": {
    ///    "confidence": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "congType": {
    ///      "$ref": "#/components/schemas/CongestionType"
    ///    },
    ///    "nsi": {
    ///      "$ref": "#/components/schemas/ThresholdLevel"
    ///    },
    ///    "timeIntev": {
    ///      "$ref": "#/components/schemas/TimeWindow"
    ///    },
    ///    "topAppListDl": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TopApplication"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "topAppListUl": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TopApplication"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct CongestionInfo {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub confidence: Option<Uinteger>,
        #[serde(rename = "congType")]
        pub cong_type: CongestionType,
        pub nsi: ThresholdLevel,
        #[serde(rename = "timeIntev")]
        pub time_intev: TimeWindow,
        #[serde(
            rename = "topAppListDl",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub top_app_list_dl: Vec<TopApplication>,
        #[serde(
            rename = "topAppListUl",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub top_app_list_ul: Vec<TopApplication>,
    }

    impl From<&CongestionInfo> for CongestionInfo {
        fn from(value: &CongestionInfo) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - USER_PLANE: The congestion analytics type is User Plane.
    /// - CONTROL_PLANE: The congestion analytics type is Control Plane.
    /// - USER_AND_CONTROL_PLANE: The congestion analytics type is User Plane
    ///   and Control Plane.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- USER_PLANE: The congestion
    /// analytics type is User Plane.\n- CONTROL_PLANE: The congestion analytics
    /// type is Control Plane.\n- USER_AND_CONTROL_PLANE: The congestion
    /// analytics type is User Plane and Control Plane.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "USER_PLANE",
    ///    "CONTROL_PLANE",
    ///    "USER_AND_CONTROL_PLANE"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CongestionType {
        #[serde(rename = "USER_PLANE")]
        UserPlane,
        #[serde(rename = "CONTROL_PLANE")]
        ControlPlane,
        #[serde(rename = "USER_AND_CONTROL_PLANE")]
        UserAndControlPlane,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&CongestionType> for CongestionType {
        fn from(value: &CongestionType) -> Self {
            value.clone()
        }
    }

    impl ToString for CongestionType {
        fn to_string(&self) -> String {
            match *self {
                Self::UserPlane => "USER_PLANE".to_string(),
                Self::ControlPlane => "CONTROL_PLANE".to_string(),
                Self::UserAndControlPlane => "USER_AND_CONTROL_PLANE".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for CongestionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "USER_PLANE" => Ok(Self::UserPlane),
                "CONTROL_PLANE" => Ok(Self::ControlPlane),
                "USER_AND_CONTROL_PLANE" => Ok(Self::UserAndControlPlane),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for CongestionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for CongestionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for CongestionType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents the analytics consumer NF Information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the analytics consumer NF Information.",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "oneOf": [
    ///        {
    ///          "required": [
    ///            "nfId"
    ///          ]
    ///        },
    ///        {
    ///          "required": [
    ///            "nfSetId"
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "taiList"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "nfId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "nfSetId": {
    ///      "$ref": "#/components/schemas/NfSetId"
    ///    },
    ///    "taiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Tai"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum ConsumerNfInformation {
        Variant0(ConsumerNfInformationVariant0),
        Variant1 {
            #[serde(rename = "nfId", default, skip_serializing_if = "Option::is_none")]
            nf_id: Option<NfInstanceId>,
            #[serde(rename = "nfSetId", default, skip_serializing_if = "Option::is_none")]
            nf_set_id: Option<NfSetId>,
            #[serde(rename = "taiList")]
            tai_list: Vec<Tai>,
        },
    }

    impl From<&ConsumerNfInformation> for ConsumerNfInformation {
        fn from(value: &ConsumerNfInformation) -> Self {
            value.clone()
        }
    }

    impl From<ConsumerNfInformationVariant0> for ConsumerNfInformation {
        fn from(value: ConsumerNfInformationVariant0) -> Self {
            Self::Variant0(value)
        }
    }

    ///ConsumerNfInformationVariant0
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "type": "object",
    ///      "properties": {
    ///        "nfId": {
    ///          "$ref": "#/components/schemas/NfInstanceId"
    ///        },
    ///        "nfSetId": {
    ///          "$ref": "#/components/schemas/NfSetId"
    ///        },
    ///        "taiList": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/Tai"
    ///          },
    ///          "minItems": 1
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "oneOf": [
    ///        {
    ///          "required": [
    ///            "nfId"
    ///          ]
    ///        },
    ///        {
    ///          "required": [
    ///            "nfSetId"
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "not": {
    ///        "required": [
    ///          "taiList"
    ///        ]
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum ConsumerNfInformationVariant0 {
        Variant0 {
            #[serde(rename = "nfId")]
            nf_id: NfInstanceId,
            #[serde(rename = "taiList", default, skip_serializing_if = "Vec::is_empty")]
            tai_list: Vec<Tai>,
        },
        Variant1 {
            #[serde(rename = "nfSetId")]
            nf_set_id: NfSetId,
            #[serde(rename = "taiList", default, skip_serializing_if = "Vec::is_empty")]
            tai_list: Vec<Tai>,
        },
    }

    impl From<&ConsumerNfInformationVariant0> for ConsumerNfInformationVariant0 {
        fn from(value: &ConsumerNfInformationVariant0) -> Self {
            value.clone()
        }
    }

    ///It contains the Core Network type 5GC or EPC.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "It contains the Core Network type 5GC or EPC.",
    ///  "type": "string",
    ///  "enum": [
    ///    "5GC",
    ///    "EPC"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum CoreNetworkType {
        #[serde(rename = "5GC")]
        FiveGc,
        #[serde(rename = "EPC")]
        Epc,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&CoreNetworkType> for CoreNetworkType {
        fn from(value: &CoreNetworkType) -> Self {
            value.clone()
        }
    }

    impl ToString for CoreNetworkType {
        fn to_string(&self) -> String {
            match *self {
                Self::FiveGc => "5GC".to_string(),
                Self::Epc => "EPC".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for CoreNetworkType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "5GC" => Ok(Self::FiveGc),
                "EPC" => Ok(Self::Epc),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for CoreNetworkType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for CoreNetworkType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for CoreNetworkType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///LCS Correlation ID.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "LCS Correlation ID.",
    ///  "type": "string",
    ///  "maxLength": 255,
    ///  "minLength": 1
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct CorrelationId(String);
    impl ::std::ops::Deref for CorrelationId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<CorrelationId> for String {
        fn from(value: CorrelationId) -> Self {
            value.0
        }
    }

    impl From<&CorrelationId> for CorrelationId {
        fn from(value: &CorrelationId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for CorrelationId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 255usize {
                return Err("longer than 255 characters".into());
            }
            if value.len() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for CorrelationId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for CorrelationId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for CorrelationId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for CorrelationId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Possible values are:
    /// - UNIFORM_DIST_DATA: Indicates the use of data samples that are
    ///   uniformly distributed according to the different aspects of the
    ///   requested analytics.
    /// - NO_OUTLIERS: Indicates that the data samples shall disregard data
    ///   samples that are at the extreme boundaries of the value range.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- UNIFORM_DIST_DATA: Indicates
    /// the use of data samples that are uniformly distributed according to the
    /// different aspects of the requested analytics.\n- NO_OUTLIERS: Indicates
    /// that the data samples shall disregard data samples that are at the
    /// extreme boundaries of the value range.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "UNIFORM_DIST_DATA",
    ///    "NO_OUTLIERS"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum DatasetStatisticalProperty {
        #[serde(rename = "UNIFORM_DIST_DATA")]
        UniformDistData,
        #[serde(rename = "NO_OUTLIERS")]
        NoOutliers,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&DatasetStatisticalProperty> for DatasetStatisticalProperty {
        fn from(value: &DatasetStatisticalProperty) -> Self {
            value.clone()
        }
    }

    impl ToString for DatasetStatisticalProperty {
        fn to_string(&self) -> String {
            match *self {
                Self::UniformDistData => "UNIFORM_DIST_DATA".to_string(),
                Self::NoOutliers => "NO_OUTLIERS".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for DatasetStatisticalProperty {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "UNIFORM_DIST_DATA" => Ok(Self::UniformDistData),
                "NO_OUTLIERS" => Ok(Self::NoOutliers),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for DatasetStatisticalProperty {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for DatasetStatisticalProperty {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for DatasetStatisticalProperty {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///string with format 'date-time' as defined in OpenAPI.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "string with format 'date-time' as defined in OpenAPI.",
    ///  "type": "string",
    ///  "format": "date-time"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DateTime(pub chrono::DateTime<chrono::offset::Utc>);
    impl ::std::ops::Deref for DateTime {
        type Target = chrono::DateTime<chrono::offset::Utc>;
        fn deref(&self) -> &chrono::DateTime<chrono::offset::Utc> {
            &self.0
        }
    }

    impl From<DateTime> for chrono::DateTime<chrono::offset::Utc> {
        fn from(value: DateTime) -> Self {
            value.0
        }
    }

    impl From<&DateTime> for DateTime {
        fn from(value: &DateTime) -> Self {
            value.clone()
        }
    }

    impl From<chrono::DateTime<chrono::offset::Utc>> for DateTime {
        fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for DateTime {
        type Err = <chrono::DateTime<chrono::offset::Utc> as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for DateTime {
        type Error = <chrono::DateTime<chrono::offset::Utc> as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for DateTime {
        type Error = <chrono::DateTime<chrono::offset::Utc> as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for DateTime {
        type Error = <chrono::DateTime<chrono::offset::Utc> as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for DateTime {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///integer between and including 1 and 7 denoting a weekday. 1 shall
    /// indicate Monday, and the subsequent weekdays  shall be indicated with
    /// the next higher numbers. 7 shall indicate Sunday.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "integer between and including 1 and 7 denoting a
    /// weekday. 1 shall indicate Monday, and the subsequent weekdays  shall be
    /// indicated with the next higher numbers. 7 shall indicate Sunday.\n",
    ///  "type": "integer",
    ///  "maximum": 7.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DayOfWeek(pub i64);
    impl ::std::ops::Deref for DayOfWeek {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<DayOfWeek> for i64 {
        fn from(value: DayOfWeek) -> Self {
            value.0
        }
    }

    impl From<&DayOfWeek> for DayOfWeek {
        fn from(value: &DayOfWeek) -> Self {
            value.clone()
        }
    }

    impl From<i64> for DayOfWeek {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for DayOfWeek {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for DayOfWeek {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for DayOfWeek {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for DayOfWeek {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for DayOfWeek {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Contains a Traffic Descriptor.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains a Traffic Descriptor.",
    ///  "type": "object",
    ///  "properties": {
    ///    "ipv4Addr": {
    ///      "$ref": "#/components/schemas/Ipv4Addr"
    ///    },
    ///    "ipv6Addr": {
    ///      "$ref": "#/components/schemas/Ipv6Addr"
    ///    },
    ///    "macAddr": {
    ///      "$ref": "#/components/schemas/MacAddr48"
    ///    },
    ///    "portNumber": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DddTrafficDescriptor {
        #[serde(rename = "ipv4Addr", default, skip_serializing_if = "Option::is_none")]
        pub ipv4_addr: Option<Ipv4Addr>,
        #[serde(rename = "ipv6Addr", default, skip_serializing_if = "Option::is_none")]
        pub ipv6_addr: Option<Ipv6Addr>,
        #[serde(rename = "macAddr", default, skip_serializing_if = "Option::is_none")]
        pub mac_addr: Option<MacAddr48>,
        #[serde(
            rename = "portNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub port_number: Option<Uinteger>,
    }

    impl From<&DddTrafficDescriptor> for DddTrafficDescriptor {
        fn from(value: &DddTrafficDescriptor) -> Self {
            value.clone()
        }
    }

    ///Dispersion Area
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Dispersion Area",
    ///  "type": "object",
    ///  "properties": {
    ///    "ecgiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Ecgi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "n3gaInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "ncgiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Ncgi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "taiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Tai"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DispersionArea {
        #[serde(rename = "ecgiList", default, skip_serializing_if = "Vec::is_empty")]
        pub ecgi_list: Vec<Ecgi>,
        #[serde(rename = "n3gaInd", default)]
        pub n3ga_ind: bool,
        #[serde(rename = "ncgiList", default, skip_serializing_if = "Vec::is_empty")]
        pub ncgi_list: Vec<Ncgi>,
        #[serde(rename = "taiList", default, skip_serializing_if = "Vec::is_empty")]
        pub tai_list: Vec<Tai>,
    }

    impl From<&DispersionArea> for DispersionArea {
        fn from(value: &DispersionArea) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - FIXED: Dispersion class as fixed UE its data or transaction usage at a
    ///   location or a slice, is higher than its class threshold set for its
    ///   all data or transaction usage.
    /// - CAMPER: Dispersion class as camper UE, its data or transaction usage
    ///   at a location or a slice, is higher than its class threshold and lower
    ///   than the fixed class threshold set for its all data or transaction
    ///   usage..
    /// - TRAVELLER: Dispersion class as traveller UE, its data or transaction
    ///   usage at a location or a slice, is lower than the camper class
    ///   threshold set for its all data or transaction usage.
    /// - TOP_HEAVY: Dispersion class as Top_Heavy UE, who's dispersion
    ///   percentile rating at a location or a slice, is higher than its class
    ///   threshold.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- FIXED: Dispersion class as
    /// fixed UE its data or transaction usage at a location or a slice, is
    /// higher than its class threshold set for its all data or transaction
    /// usage.\n- CAMPER: Dispersion class as camper UE, its data or transaction
    /// usage at a location or a slice, is higher than its class threshold and
    /// lower than the fixed class threshold set for its all data or transaction
    /// usage..\n- TRAVELLER: Dispersion class as traveller UE, its data or
    /// transaction usage at a location or a slice, is lower than the camper
    /// class threshold set for its all data or transaction usage.\n- TOP_HEAVY:
    /// Dispersion class as Top_Heavy UE, who's dispersion percentile rating at
    /// a location or a slice, is higher than its class threshold.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "FIXED",
    ///    "CAMPER",
    ///    "TRAVELLER",
    ///    "TOP_HEAVY"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum DispersionClass {
        #[serde(rename = "FIXED")]
        Fixed,
        #[serde(rename = "CAMPER")]
        Camper,
        #[serde(rename = "TRAVELLER")]
        Traveller,
        #[serde(rename = "TOP_HEAVY")]
        TopHeavy,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&DispersionClass> for DispersionClass {
        fn from(value: &DispersionClass) -> Self {
            value.clone()
        }
    }

    impl ToString for DispersionClass {
        fn to_string(&self) -> String {
            match *self {
                Self::Fixed => "FIXED".to_string(),
                Self::Camper => "CAMPER".to_string(),
                Self::Traveller => "TRAVELLER".to_string(),
                Self::TopHeavy => "TOP_HEAVY".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for DispersionClass {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "FIXED" => Ok(Self::Fixed),
                "CAMPER" => Ok(Self::Camper),
                "TRAVELLER" => Ok(Self::Traveller),
                "TOP_HEAVY" => Ok(Self::TopHeavy),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for DispersionClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for DispersionClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for DispersionClass {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Dispersion collection per UE location or per slice.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Dispersion collection per UE location or per slice.",
    ///  "type": "object",
    ///  "allOf": [
    ///    {
    ///      "oneOf": [
    ///        {
    ///          "required": [
    ///            "ueLoc"
    ///          ]
    ///        },
    ///        {
    ///          "required": [
    ///            "snssai"
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "anyOf": [
    ///        {
    ///          "required": [
    ///            "disperAmount"
    ///          ]
    ///        },
    ///        {
    ///          "required": [
    ///            "disperClass"
    ///          ]
    ///        },
    ///        {
    ///          "required": [
    ///            "usageRank"
    ///          ]
    ///        },
    ///        {
    ///          "required": [
    ///            "percentileRank"
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "appVolumes": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ApplicationVolume"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "confidence": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "disperAmount": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "disperClass": {
    ///      "$ref": "#/components/schemas/DispersionClass"
    ///    },
    ///    "gpsis": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Gpsi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "percentileRank": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "supis": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "ueLoc": {
    ///      "$ref": "#/components/schemas/UserLocation"
    ///    },
    ///    "ueRatio": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    },
    ///    "usageRank": {
    ///      "description": "Integer where the allowed values correspond to 1,
    /// 2, 3 only.",
    ///      "type": "integer",
    ///      "maximum": 3.0,
    ///      "minimum": 1.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum DispersionCollection {
        Variant0(DispersionCollectionVariant0),
        Variant1(DispersionCollectionVariant1),
        Variant2(DispersionCollectionVariant2),
        Variant3(DispersionCollectionVariant3),
    }

    impl From<&DispersionCollection> for DispersionCollection {
        fn from(value: &DispersionCollection) -> Self {
            value.clone()
        }
    }

    impl From<DispersionCollectionVariant0> for DispersionCollection {
        fn from(value: DispersionCollectionVariant0) -> Self {
            Self::Variant0(value)
        }
    }

    impl From<DispersionCollectionVariant1> for DispersionCollection {
        fn from(value: DispersionCollectionVariant1) -> Self {
            Self::Variant1(value)
        }
    }

    impl From<DispersionCollectionVariant2> for DispersionCollection {
        fn from(value: DispersionCollectionVariant2) -> Self {
            Self::Variant2(value)
        }
    }

    impl From<DispersionCollectionVariant3> for DispersionCollection {
        fn from(value: DispersionCollectionVariant3) -> Self {
            Self::Variant3(value)
        }
    }

    ///DispersionCollectionVariant0
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "oneOf": [
    ///        {
    ///          "allOf": [
    ///            {},
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "type": "object",
    ///                  "properties": {
    ///                    "appVolumes": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/ApplicationVolume"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "confidence": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperAmount": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperClass": {
    ///                      "$ref": "#/components/schemas/DispersionClass"
    ///                    },
    ///                    "gpsis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Gpsi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "percentileRank": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "snssai": {
    ///                      "$ref": "#/components/schemas/Snssai"
    ///                    },
    ///                    "supis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Supi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "ueLoc": {
    ///                      "$ref": "#/components/schemas/UserLocation"
    ///                    },
    ///                    "ueRatio": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "usageRank": {
    ///                      "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                      "type": "integer",
    ///                      "maximum": 3.0,
    ///                      "minimum": 1.0
    ///                    }
    ///                  }
    ///                },
    ///                {
    ///                  "required": [
    ///                    "ueLoc"
    ///                  ]
    ///                },
    ///                {
    ///                  "not": {
    ///                    "required": [
    ///                      "snssai"
    ///                    ]
    ///                  }
    ///                }
    ///              ]
    ///            },
    ///            {
    ///              "not": {
    ///                "allOf": [
    ///                  {
    ///                    "type": "object",
    ///                    "properties": {
    ///                      "appVolumes": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref":
    /// "#/components/schemas/ApplicationVolume"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "confidence": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperAmount": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperClass": {
    ///                        "$ref": "#/components/schemas/DispersionClass"
    ///                      },
    ///                      "gpsis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Gpsi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "percentileRank": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "snssai": {
    ///                        "$ref": "#/components/schemas/Snssai"
    ///                      },
    ///                      "supis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Supi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "ueLoc": {
    ///                        "$ref": "#/components/schemas/UserLocation"
    ///                      },
    ///                      "ueRatio": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "usageRank": {
    ///                        "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                        "type": "integer",
    ///                        "maximum": 3.0,
    ///                        "minimum": 1.0
    ///                      }
    ///                    }
    ///                  },
    ///                  {
    ///                    "required": [
    ///                      "snssai"
    ///                    ]
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "required": [
    ///                        "ueLoc"
    ///                      ]
    ///                    }
    ///                  }
    ///                ]
    ///              }
    ///            }
    ///          ]
    ///        },
    ///        {
    ///          "allOf": [
    ///            {},
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "type": "object",
    ///                  "properties": {
    ///                    "appVolumes": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/ApplicationVolume"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "confidence": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperAmount": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperClass": {
    ///                      "$ref": "#/components/schemas/DispersionClass"
    ///                    },
    ///                    "gpsis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Gpsi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "percentileRank": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "snssai": {
    ///                      "$ref": "#/components/schemas/Snssai"
    ///                    },
    ///                    "supis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Supi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "ueLoc": {
    ///                      "$ref": "#/components/schemas/UserLocation"
    ///                    },
    ///                    "ueRatio": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "usageRank": {
    ///                      "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                      "type": "integer",
    ///                      "maximum": 3.0,
    ///                      "minimum": 1.0
    ///                    }
    ///                  }
    ///                },
    ///                {
    ///                  "required": [
    ///                    "snssai"
    ///                  ]
    ///                },
    ///                {
    ///                  "not": {
    ///                    "required": [
    ///                      "ueLoc"
    ///                    ]
    ///                  }
    ///                }
    ///              ]
    ///            },
    ///            {
    ///              "not": {
    ///                "allOf": [
    ///                  {
    ///                    "type": "object",
    ///                    "properties": {
    ///                      "appVolumes": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref":
    /// "#/components/schemas/ApplicationVolume"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "confidence": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperAmount": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperClass": {
    ///                        "$ref": "#/components/schemas/DispersionClass"
    ///                      },
    ///                      "gpsis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Gpsi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "percentileRank": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "snssai": {
    ///                        "$ref": "#/components/schemas/Snssai"
    ///                      },
    ///                      "supis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Supi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "ueLoc": {
    ///                        "$ref": "#/components/schemas/UserLocation"
    ///                      },
    ///                      "ueRatio": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "usageRank": {
    ///                        "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                        "type": "integer",
    ///                        "maximum": 3.0,
    ///                        "minimum": 1.0
    ///                      }
    ///                    }
    ///                  },
    ///                  {
    ///                    "required": [
    ///                      "ueLoc"
    ///                    ]
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "required": [
    ///                        "snssai"
    ///                      ]
    ///                    }
    ///                  }
    ///                ]
    ///              }
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "disperAmount"
    ///      ]
    ///    },
    ///    {
    ///      "not": {
    ///        "required": [
    ///          "disperClass"
    ///        ]
    ///      }
    ///    },
    ///    {
    ///      "not": {
    ///        "required": [
    ///          "usageRank"
    ///        ]
    ///      }
    ///    },
    ///    {
    ///      "not": {
    ///        "required": [
    ///          "percentileRank"
    ///        ]
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(deny_unknown_fields)]
    pub enum DispersionCollectionVariant0 {}
    impl From<&DispersionCollectionVariant0> for DispersionCollectionVariant0 {
        fn from(value: &DispersionCollectionVariant0) -> Self {
            value.clone()
        }
    }

    ///DispersionCollectionVariant1
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "oneOf": [
    ///        {
    ///          "allOf": [
    ///            {},
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "type": "object",
    ///                  "properties": {
    ///                    "appVolumes": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/ApplicationVolume"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "confidence": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperAmount": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperClass": {
    ///                      "$ref": "#/components/schemas/DispersionClass"
    ///                    },
    ///                    "gpsis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Gpsi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "percentileRank": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "snssai": {
    ///                      "$ref": "#/components/schemas/Snssai"
    ///                    },
    ///                    "supis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Supi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "ueLoc": {
    ///                      "$ref": "#/components/schemas/UserLocation"
    ///                    },
    ///                    "ueRatio": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "usageRank": {
    ///                      "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                      "type": "integer",
    ///                      "maximum": 3.0,
    ///                      "minimum": 1.0
    ///                    }
    ///                  }
    ///                },
    ///                {
    ///                  "required": [
    ///                    "ueLoc"
    ///                  ]
    ///                },
    ///                {
    ///                  "not": {
    ///                    "required": [
    ///                      "snssai"
    ///                    ]
    ///                  }
    ///                }
    ///              ]
    ///            },
    ///            {
    ///              "not": {
    ///                "allOf": [
    ///                  {
    ///                    "type": "object",
    ///                    "properties": {
    ///                      "appVolumes": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref":
    /// "#/components/schemas/ApplicationVolume"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "confidence": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperAmount": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperClass": {
    ///                        "$ref": "#/components/schemas/DispersionClass"
    ///                      },
    ///                      "gpsis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Gpsi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "percentileRank": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "snssai": {
    ///                        "$ref": "#/components/schemas/Snssai"
    ///                      },
    ///                      "supis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Supi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "ueLoc": {
    ///                        "$ref": "#/components/schemas/UserLocation"
    ///                      },
    ///                      "ueRatio": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "usageRank": {
    ///                        "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                        "type": "integer",
    ///                        "maximum": 3.0,
    ///                        "minimum": 1.0
    ///                      }
    ///                    }
    ///                  },
    ///                  {
    ///                    "required": [
    ///                      "snssai"
    ///                    ]
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "required": [
    ///                        "ueLoc"
    ///                      ]
    ///                    }
    ///                  }
    ///                ]
    ///              }
    ///            }
    ///          ]
    ///        },
    ///        {
    ///          "allOf": [
    ///            {},
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "type": "object",
    ///                  "properties": {
    ///                    "appVolumes": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/ApplicationVolume"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "confidence": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperAmount": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperClass": {
    ///                      "$ref": "#/components/schemas/DispersionClass"
    ///                    },
    ///                    "gpsis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Gpsi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "percentileRank": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "snssai": {
    ///                      "$ref": "#/components/schemas/Snssai"
    ///                    },
    ///                    "supis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Supi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "ueLoc": {
    ///                      "$ref": "#/components/schemas/UserLocation"
    ///                    },
    ///                    "ueRatio": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "usageRank": {
    ///                      "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                      "type": "integer",
    ///                      "maximum": 3.0,
    ///                      "minimum": 1.0
    ///                    }
    ///                  }
    ///                },
    ///                {
    ///                  "required": [
    ///                    "snssai"
    ///                  ]
    ///                },
    ///                {
    ///                  "not": {
    ///                    "required": [
    ///                      "ueLoc"
    ///                    ]
    ///                  }
    ///                }
    ///              ]
    ///            },
    ///            {
    ///              "not": {
    ///                "allOf": [
    ///                  {
    ///                    "type": "object",
    ///                    "properties": {
    ///                      "appVolumes": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref":
    /// "#/components/schemas/ApplicationVolume"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "confidence": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperAmount": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperClass": {
    ///                        "$ref": "#/components/schemas/DispersionClass"
    ///                      },
    ///                      "gpsis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Gpsi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "percentileRank": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "snssai": {
    ///                        "$ref": "#/components/schemas/Snssai"
    ///                      },
    ///                      "supis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Supi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "ueLoc": {
    ///                        "$ref": "#/components/schemas/UserLocation"
    ///                      },
    ///                      "ueRatio": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "usageRank": {
    ///                        "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                        "type": "integer",
    ///                        "maximum": 3.0,
    ///                        "minimum": 1.0
    ///                      }
    ///                    }
    ///                  },
    ///                  {
    ///                    "required": [
    ///                      "ueLoc"
    ///                    ]
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "required": [
    ///                        "snssai"
    ///                      ]
    ///                    }
    ///                  }
    ///                ]
    ///              }
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "disperClass"
    ///      ]
    ///    },
    ///    {
    ///      "not": {
    ///        "required": [
    ///          "disperAmount"
    ///        ]
    ///      }
    ///    },
    ///    {
    ///      "not": {
    ///        "required": [
    ///          "usageRank"
    ///        ]
    ///      }
    ///    },
    ///    {
    ///      "not": {
    ///        "required": [
    ///          "percentileRank"
    ///        ]
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(deny_unknown_fields)]
    pub enum DispersionCollectionVariant1 {}
    impl From<&DispersionCollectionVariant1> for DispersionCollectionVariant1 {
        fn from(value: &DispersionCollectionVariant1) -> Self {
            value.clone()
        }
    }

    ///DispersionCollectionVariant2
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "oneOf": [
    ///        {
    ///          "allOf": [
    ///            {},
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "type": "object",
    ///                  "properties": {
    ///                    "appVolumes": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/ApplicationVolume"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "confidence": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperAmount": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperClass": {
    ///                      "$ref": "#/components/schemas/DispersionClass"
    ///                    },
    ///                    "gpsis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Gpsi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "percentileRank": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "snssai": {
    ///                      "$ref": "#/components/schemas/Snssai"
    ///                    },
    ///                    "supis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Supi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "ueLoc": {
    ///                      "$ref": "#/components/schemas/UserLocation"
    ///                    },
    ///                    "ueRatio": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "usageRank": {
    ///                      "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                      "type": "integer",
    ///                      "maximum": 3.0,
    ///                      "minimum": 1.0
    ///                    }
    ///                  }
    ///                },
    ///                {
    ///                  "required": [
    ///                    "ueLoc"
    ///                  ]
    ///                },
    ///                {
    ///                  "not": {
    ///                    "required": [
    ///                      "snssai"
    ///                    ]
    ///                  }
    ///                }
    ///              ]
    ///            },
    ///            {
    ///              "not": {
    ///                "allOf": [
    ///                  {
    ///                    "type": "object",
    ///                    "properties": {
    ///                      "appVolumes": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref":
    /// "#/components/schemas/ApplicationVolume"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "confidence": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperAmount": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperClass": {
    ///                        "$ref": "#/components/schemas/DispersionClass"
    ///                      },
    ///                      "gpsis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Gpsi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "percentileRank": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "snssai": {
    ///                        "$ref": "#/components/schemas/Snssai"
    ///                      },
    ///                      "supis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Supi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "ueLoc": {
    ///                        "$ref": "#/components/schemas/UserLocation"
    ///                      },
    ///                      "ueRatio": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "usageRank": {
    ///                        "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                        "type": "integer",
    ///                        "maximum": 3.0,
    ///                        "minimum": 1.0
    ///                      }
    ///                    }
    ///                  },
    ///                  {
    ///                    "required": [
    ///                      "snssai"
    ///                    ]
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "required": [
    ///                        "ueLoc"
    ///                      ]
    ///                    }
    ///                  }
    ///                ]
    ///              }
    ///            }
    ///          ]
    ///        },
    ///        {
    ///          "allOf": [
    ///            {},
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "type": "object",
    ///                  "properties": {
    ///                    "appVolumes": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/ApplicationVolume"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "confidence": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperAmount": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperClass": {
    ///                      "$ref": "#/components/schemas/DispersionClass"
    ///                    },
    ///                    "gpsis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Gpsi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "percentileRank": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "snssai": {
    ///                      "$ref": "#/components/schemas/Snssai"
    ///                    },
    ///                    "supis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Supi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "ueLoc": {
    ///                      "$ref": "#/components/schemas/UserLocation"
    ///                    },
    ///                    "ueRatio": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "usageRank": {
    ///                      "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                      "type": "integer",
    ///                      "maximum": 3.0,
    ///                      "minimum": 1.0
    ///                    }
    ///                  }
    ///                },
    ///                {
    ///                  "required": [
    ///                    "snssai"
    ///                  ]
    ///                },
    ///                {
    ///                  "not": {
    ///                    "required": [
    ///                      "ueLoc"
    ///                    ]
    ///                  }
    ///                }
    ///              ]
    ///            },
    ///            {
    ///              "not": {
    ///                "allOf": [
    ///                  {
    ///                    "type": "object",
    ///                    "properties": {
    ///                      "appVolumes": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref":
    /// "#/components/schemas/ApplicationVolume"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "confidence": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperAmount": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperClass": {
    ///                        "$ref": "#/components/schemas/DispersionClass"
    ///                      },
    ///                      "gpsis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Gpsi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "percentileRank": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "snssai": {
    ///                        "$ref": "#/components/schemas/Snssai"
    ///                      },
    ///                      "supis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Supi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "ueLoc": {
    ///                        "$ref": "#/components/schemas/UserLocation"
    ///                      },
    ///                      "ueRatio": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "usageRank": {
    ///                        "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                        "type": "integer",
    ///                        "maximum": 3.0,
    ///                        "minimum": 1.0
    ///                      }
    ///                    }
    ///                  },
    ///                  {
    ///                    "required": [
    ///                      "ueLoc"
    ///                    ]
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "required": [
    ///                        "snssai"
    ///                      ]
    ///                    }
    ///                  }
    ///                ]
    ///              }
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "usageRank"
    ///      ]
    ///    },
    ///    {
    ///      "not": {
    ///        "required": [
    ///          "disperAmount"
    ///        ]
    ///      }
    ///    },
    ///    {
    ///      "not": {
    ///        "required": [
    ///          "disperClass"
    ///        ]
    ///      }
    ///    },
    ///    {
    ///      "not": {
    ///        "required": [
    ///          "percentileRank"
    ///        ]
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(deny_unknown_fields)]
    pub enum DispersionCollectionVariant2 {}
    impl From<&DispersionCollectionVariant2> for DispersionCollectionVariant2 {
        fn from(value: &DispersionCollectionVariant2) -> Self {
            value.clone()
        }
    }

    ///DispersionCollectionVariant3
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "oneOf": [
    ///        {
    ///          "allOf": [
    ///            {},
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "type": "object",
    ///                  "properties": {
    ///                    "appVolumes": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/ApplicationVolume"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "confidence": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperAmount": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperClass": {
    ///                      "$ref": "#/components/schemas/DispersionClass"
    ///                    },
    ///                    "gpsis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Gpsi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "percentileRank": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "snssai": {
    ///                      "$ref": "#/components/schemas/Snssai"
    ///                    },
    ///                    "supis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Supi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "ueLoc": {
    ///                      "$ref": "#/components/schemas/UserLocation"
    ///                    },
    ///                    "ueRatio": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "usageRank": {
    ///                      "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                      "type": "integer",
    ///                      "maximum": 3.0,
    ///                      "minimum": 1.0
    ///                    }
    ///                  }
    ///                },
    ///                {
    ///                  "required": [
    ///                    "ueLoc"
    ///                  ]
    ///                },
    ///                {
    ///                  "not": {
    ///                    "required": [
    ///                      "snssai"
    ///                    ]
    ///                  }
    ///                }
    ///              ]
    ///            },
    ///            {
    ///              "not": {
    ///                "allOf": [
    ///                  {
    ///                    "type": "object",
    ///                    "properties": {
    ///                      "appVolumes": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref":
    /// "#/components/schemas/ApplicationVolume"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "confidence": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperAmount": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperClass": {
    ///                        "$ref": "#/components/schemas/DispersionClass"
    ///                      },
    ///                      "gpsis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Gpsi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "percentileRank": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "snssai": {
    ///                        "$ref": "#/components/schemas/Snssai"
    ///                      },
    ///                      "supis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Supi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "ueLoc": {
    ///                        "$ref": "#/components/schemas/UserLocation"
    ///                      },
    ///                      "ueRatio": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "usageRank": {
    ///                        "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                        "type": "integer",
    ///                        "maximum": 3.0,
    ///                        "minimum": 1.0
    ///                      }
    ///                    }
    ///                  },
    ///                  {
    ///                    "required": [
    ///                      "snssai"
    ///                    ]
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "required": [
    ///                        "ueLoc"
    ///                      ]
    ///                    }
    ///                  }
    ///                ]
    ///              }
    ///            }
    ///          ]
    ///        },
    ///        {
    ///          "allOf": [
    ///            {},
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "type": "object",
    ///                  "properties": {
    ///                    "appVolumes": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/ApplicationVolume"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "confidence": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperAmount": {
    ///                      "$ref": "#/components/schemas/Uinteger"
    ///                    },
    ///                    "disperClass": {
    ///                      "$ref": "#/components/schemas/DispersionClass"
    ///                    },
    ///                    "gpsis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Gpsi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "percentileRank": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "snssai": {
    ///                      "$ref": "#/components/schemas/Snssai"
    ///                    },
    ///                    "supis": {
    ///                      "type": "array",
    ///                      "items": {
    ///                        "$ref": "#/components/schemas/Supi"
    ///                      },
    ///                      "minItems": 1
    ///                    },
    ///                    "ueLoc": {
    ///                      "$ref": "#/components/schemas/UserLocation"
    ///                    },
    ///                    "ueRatio": {
    ///                      "$ref": "#/components/schemas/SamplingRatio"
    ///                    },
    ///                    "usageRank": {
    ///                      "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                      "type": "integer",
    ///                      "maximum": 3.0,
    ///                      "minimum": 1.0
    ///                    }
    ///                  }
    ///                },
    ///                {
    ///                  "required": [
    ///                    "snssai"
    ///                  ]
    ///                },
    ///                {
    ///                  "not": {
    ///                    "required": [
    ///                      "ueLoc"
    ///                    ]
    ///                  }
    ///                }
    ///              ]
    ///            },
    ///            {
    ///              "not": {
    ///                "allOf": [
    ///                  {
    ///                    "type": "object",
    ///                    "properties": {
    ///                      "appVolumes": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref":
    /// "#/components/schemas/ApplicationVolume"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "confidence": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperAmount": {
    ///                        "$ref": "#/components/schemas/Uinteger"
    ///                      },
    ///                      "disperClass": {
    ///                        "$ref": "#/components/schemas/DispersionClass"
    ///                      },
    ///                      "gpsis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Gpsi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "percentileRank": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "snssai": {
    ///                        "$ref": "#/components/schemas/Snssai"
    ///                      },
    ///                      "supis": {
    ///                        "type": "array",
    ///                        "items": {
    ///                          "$ref": "#/components/schemas/Supi"
    ///                        },
    ///                        "minItems": 1
    ///                      },
    ///                      "ueLoc": {
    ///                        "$ref": "#/components/schemas/UserLocation"
    ///                      },
    ///                      "ueRatio": {
    ///                        "$ref": "#/components/schemas/SamplingRatio"
    ///                      },
    ///                      "usageRank": {
    ///                        "description": "Integer where the allowed values
    /// correspond to 1, 2, 3 only.",
    ///                        "type": "integer",
    ///                        "maximum": 3.0,
    ///                        "minimum": 1.0
    ///                      }
    ///                    }
    ///                  },
    ///                  {
    ///                    "required": [
    ///                      "ueLoc"
    ///                    ]
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "required": [
    ///                        "snssai"
    ///                      ]
    ///                    }
    ///                  }
    ///                ]
    ///              }
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "percentileRank"
    ///      ]
    ///    },
    ///    {
    ///      "not": {
    ///        "required": [
    ///          "disperAmount"
    ///        ]
    ///      }
    ///    },
    ///    {
    ///      "not": {
    ///        "required": [
    ///          "disperClass"
    ///        ]
    ///      }
    ///    },
    ///    {
    ///      "not": {
    ///        "required": [
    ///          "usageRank"
    ///        ]
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(deny_unknown_fields)]
    pub enum DispersionCollectionVariant3 {}
    impl From<&DispersionCollectionVariant3> for DispersionCollectionVariant3 {
        fn from(value: &DispersionCollectionVariant3) -> Self {
            value.clone()
        }
    }

    ///Represents the Dispersion information. When subscribed event is
    /// "DISPERSION", the "disperInfos" attribute shall be included.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the Dispersion information. When subscribed
    /// event is \"DISPERSION\", the \"disperInfos\" attribute shall be
    /// included.\n",
    ///  "type": "object",
    ///  "required": [
    ///    "disperCollects",
    ///    "disperType",
    ///    "tsDuration",
    ///    "tsStart"
    ///  ],
    ///  "properties": {
    ///    "disperCollects": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DispersionCollection"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "disperType": {
    ///      "$ref": "#/components/schemas/DispersionType"
    ///    },
    ///    "tsDuration": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "tsStart": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DispersionInfo {
        #[serde(rename = "disperCollects")]
        pub disper_collects: Vec<DispersionCollection>,
        #[serde(rename = "disperType")]
        pub disper_type: DispersionType,
        #[serde(rename = "tsDuration")]
        pub ts_duration: DurationSec,
        #[serde(rename = "tsStart")]
        pub ts_start: DateTime,
    }

    impl From<&DispersionInfo> for DispersionInfo {
        fn from(value: &DispersionInfo) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - TIME_SLOT_START: Indicates the order of time slot start.
    /// - DISPERSION: Indicates the order of data/transaction dispersion.
    /// - CLASSIFICATION: Indicates the order of data/transaction
    ///   classification.
    /// - RANKING: Indicates the order of data/transaction ranking.
    /// - PERCENTILE_RANKING: Indicates the order of data/transaction percentile
    ///   ranking.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- TIME_SLOT_START: Indicates the
    /// order of time slot start.\n- DISPERSION: Indicates the order of
    /// data/transaction dispersion.\n- CLASSIFICATION: Indicates the order of
    /// data/transaction classification.\n- RANKING: Indicates the order of
    /// data/transaction ranking.\n- PERCENTILE_RANKING: Indicates the order of
    /// data/transaction percentile ranking.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "TIME_SLOT_START",
    ///    "DISPERSION",
    ///    "CLASSIFICATION",
    ///    "RANKING",
    ///    "PERCENTILE_RANKING"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum DispersionOrderingCriterion {
        #[serde(rename = "TIME_SLOT_START")]
        TimeSlotStart,
        #[serde(rename = "DISPERSION")]
        Dispersion,
        #[serde(rename = "CLASSIFICATION")]
        Classification,
        #[serde(rename = "RANKING")]
        Ranking,
        #[serde(rename = "PERCENTILE_RANKING")]
        PercentileRanking,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&DispersionOrderingCriterion> for DispersionOrderingCriterion {
        fn from(value: &DispersionOrderingCriterion) -> Self {
            value.clone()
        }
    }

    impl ToString for DispersionOrderingCriterion {
        fn to_string(&self) -> String {
            match *self {
                Self::TimeSlotStart => "TIME_SLOT_START".to_string(),
                Self::Dispersion => "DISPERSION".to_string(),
                Self::Classification => "CLASSIFICATION".to_string(),
                Self::Ranking => "RANKING".to_string(),
                Self::PercentileRanking => "PERCENTILE_RANKING".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for DispersionOrderingCriterion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TIME_SLOT_START" => Ok(Self::TimeSlotStart),
                "DISPERSION" => Ok(Self::Dispersion),
                "CLASSIFICATION" => Ok(Self::Classification),
                "RANKING" => Ok(Self::Ranking),
                "PERCENTILE_RANKING" => Ok(Self::PercentileRanking),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for DispersionOrderingCriterion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for DispersionOrderingCriterion {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for DispersionOrderingCriterion {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents the dispersion analytics requirements.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the dispersion analytics requirements.",
    ///  "type": "object",
    ///  "required": [
    ///    "disperType"
    ///  ],
    ///  "properties": {
    ///    "classCriters": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ClassCriterion"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "dispOrderCriter": {
    ///      "$ref": "#/components/schemas/DispersionOrderingCriterion"
    ///    },
    ///    "disperType": {
    ///      "$ref": "#/components/schemas/DispersionType"
    ///    },
    ///    "order": {
    ///      "$ref": "#/components/schemas/MatchingDirection"
    ///    },
    ///    "rankCriters": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RankingCriterion"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DispersionRequirement {
        #[serde(
            rename = "classCriters",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub class_criters: Vec<ClassCriterion>,
        #[serde(
            rename = "dispOrderCriter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub disp_order_criter: Option<DispersionOrderingCriterion>,
        #[serde(rename = "disperType")]
        pub disper_type: DispersionType,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub order: Option<MatchingDirection>,
        #[serde(rename = "rankCriters", default, skip_serializing_if = "Vec::is_empty")]
        pub rank_criters: Vec<RankingCriterion>,
    }

    impl From<&DispersionRequirement> for DispersionRequirement {
        fn from(value: &DispersionRequirement) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    ///  - DVDA: Data Volume Dispersion Analytics.
    ///  - TDA: Transactions Dispersion Analytics.
    ///  - DVDA_AND_TDA: Data Volume Dispersion Analytics and Transactions
    ///    Dispersion Analytics.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n  - DVDA: Data Volume Dispersion
    /// Analytics.\n  - TDA: Transactions Dispersion Analytics.\n  -
    /// DVDA_AND_TDA: Data Volume Dispersion Analytics and Transactions
    /// Dispersion Analytics.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "DVDA",
    ///    "TDA",
    ///    "DVDA_AND_TDA"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum DispersionType {
        #[serde(rename = "DVDA")]
        Dvda,
        #[serde(rename = "TDA")]
        Tda,
        #[serde(rename = "DVDA_AND_TDA")]
        DvdaAndTda,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&DispersionType> for DispersionType {
        fn from(value: &DispersionType) -> Self {
            value.clone()
        }
    }

    impl ToString for DispersionType {
        fn to_string(&self) -> String {
            match *self {
                Self::Dvda => "DVDA".to_string(),
                Self::Tda => "TDA".to_string(),
                Self::DvdaAndTda => "DVDA_AND_TDA".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for DispersionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DVDA" => Ok(Self::Dvda),
                "TDA" => Ok(Self::Tda),
                "DVDA_AND_TDA" => Ok(Self::DvdaAndTda),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for DispersionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for DispersionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for DispersionType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents DN performance for the application.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents DN performance for the application.",
    ///  "type": "object",
    ///  "required": [
    ///    "perfData"
    ///  ],
    ///  "properties": {
    ///    "appServerInsAddr": {
    ///      "$ref": "#/components/schemas/AddrFqdn"
    ///    },
    ///    "dnai": {
    ///      "$ref": "#/components/schemas/Dnai"
    ///    },
    ///    "perfData": {
    ///      "$ref": "#/components/schemas/PerfData"
    ///    },
    ///    "spatialValidCon": {
    ///      "$ref": "#/components/schemas/NetworkAreaInfo"
    ///    },
    ///    "temporalValidCon": {
    ///      "$ref": "#/components/schemas/TimeWindow"
    ///    },
    ///    "upfInfo": {
    ///      "$ref": "#/components/schemas/UpfInformation"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DnPerf {
        #[serde(
            rename = "appServerInsAddr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub app_server_ins_addr: Option<AddrFqdn>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dnai: Option<Dnai>,
        #[serde(rename = "perfData")]
        pub perf_data: PerfData,
        #[serde(
            rename = "spatialValidCon",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub spatial_valid_con: Option<NetworkAreaInfo>,
        #[serde(
            rename = "temporalValidCon",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub temporal_valid_con: Option<TimeWindow>,
        #[serde(rename = "upfInfo", default, skip_serializing_if = "Option::is_none")]
        pub upf_info: Option<UpfInformation>,
    }

    impl From<&DnPerf> for DnPerf {
        fn from(value: &DnPerf) -> Self {
            value.clone()
        }
    }

    ///Represents DN performance information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents DN performance information.",
    ///  "type": "object",
    ///  "required": [
    ///    "dnPerf"
    ///  ],
    ///  "properties": {
    ///    "appId": {
    ///      "$ref": "#/components/schemas/ApplicationId"
    ///    },
    ///    "confidence": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "dnPerf": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DnPerf"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "dnn": {
    ///      "$ref": "#/components/schemas/Dnn"
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DnPerfInfo {
        #[serde(rename = "appId", default, skip_serializing_if = "Option::is_none")]
        pub app_id: Option<ApplicationId>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub confidence: Option<Uinteger>,
        #[serde(rename = "dnPerf")]
        pub dn_perf: Vec<DnPerf>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dnn: Option<Dnn>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub snssai: Option<Snssai>,
    }

    impl From<&DnPerfInfo> for DnPerfInfo {
        fn from(value: &DnPerfInfo) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - AVERAGE_TRAFFIC_RATE: Indicates the average traffic rate.
    /// - MAXIMUM_TRAFFIC_RATE: Indicates the maximum traffic rate.
    /// - AVERAGE_PACKET_DELAY: Indicates the average packet delay.
    /// - MAXIMUM_PACKET_DELAY: Indicates the maximum packet delay.
    /// - AVERAGE_PACKET_LOSS_RATE: Indicates the average packet loss rate.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- AVERAGE_TRAFFIC_RATE: Indicates the average traffic rate.\n- MAXIMUM_TRAFFIC_RATE: Indicates the maximum traffic rate.\n- AVERAGE_PACKET_DELAY: Indicates the average packet delay.\n- MAXIMUM_PACKET_DELAY: Indicates the maximum packet delay.\n- AVERAGE_PACKET_LOSS_RATE: Indicates the average packet loss rate.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "AVERAGE_TRAFFIC_RATE",
    ///    "MAXIMUM_TRAFFIC_RATE",
    ///    "AVERAGE_PACKET_DELAY",
    ///    "MAXIMUM_PACKET_DELAY",
    ///    "AVERAGE_PACKET_LOSS_RATE"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum DnPerfOrderingCriterion {
        #[serde(rename = "AVERAGE_TRAFFIC_RATE")]
        AverageTrafficRate,
        #[serde(rename = "MAXIMUM_TRAFFIC_RATE")]
        MaximumTrafficRate,
        #[serde(rename = "AVERAGE_PACKET_DELAY")]
        AveragePacketDelay,
        #[serde(rename = "MAXIMUM_PACKET_DELAY")]
        MaximumPacketDelay,
        #[serde(rename = "AVERAGE_PACKET_LOSS_RATE")]
        AveragePacketLossRate,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&DnPerfOrderingCriterion> for DnPerfOrderingCriterion {
        fn from(value: &DnPerfOrderingCriterion) -> Self {
            value.clone()
        }
    }

    impl ToString for DnPerfOrderingCriterion {
        fn to_string(&self) -> String {
            match *self {
                Self::AverageTrafficRate => "AVERAGE_TRAFFIC_RATE".to_string(),
                Self::MaximumTrafficRate => "MAXIMUM_TRAFFIC_RATE".to_string(),
                Self::AveragePacketDelay => "AVERAGE_PACKET_DELAY".to_string(),
                Self::MaximumPacketDelay => "MAXIMUM_PACKET_DELAY".to_string(),
                Self::AveragePacketLossRate => "AVERAGE_PACKET_LOSS_RATE".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for DnPerfOrderingCriterion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AVERAGE_TRAFFIC_RATE" => Ok(Self::AverageTrafficRate),
                "MAXIMUM_TRAFFIC_RATE" => Ok(Self::MaximumTrafficRate),
                "AVERAGE_PACKET_DELAY" => Ok(Self::AveragePacketDelay),
                "MAXIMUM_PACKET_DELAY" => Ok(Self::MaximumPacketDelay),
                "AVERAGE_PACKET_LOSS_RATE" => Ok(Self::AveragePacketLossRate),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for DnPerfOrderingCriterion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for DnPerfOrderingCriterion {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for DnPerfOrderingCriterion {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents other DN performance analytics requirements.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents other DN performance analytics
    /// requirements.",
    ///  "type": "object",
    ///  "properties": {
    ///    "dnPerfOrderCriter": {
    ///      "$ref": "#/components/schemas/DnPerfOrderingCriterion"
    ///    },
    ///    "order": {
    ///      "$ref": "#/components/schemas/MatchingDirection"
    ///    },
    ///    "reportThresholds": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ThresholdLevel"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DnPerformanceReq {
        #[serde(
            rename = "dnPerfOrderCriter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub dn_perf_order_criter: Option<DnPerfOrderingCriterion>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub order: Option<MatchingDirection>,
        #[serde(
            rename = "reportThresholds",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub report_thresholds: Vec<ThresholdLevel>,
    }

    impl From<&DnPerformanceReq> for DnPerformanceReq {
        fn from(value: &DnPerformanceReq) -> Self {
            value.clone()
        }
    }

    ///DNAI (Data network access identifier), see clause 5.6.7 of 3GPP TS
    /// 23.501.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "DNAI (Data network access identifier), see clause 5.6.7
    /// of 3GPP TS 23.501.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct Dnai(pub String);
    impl ::std::ops::Deref for Dnai {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Dnai> for String {
        fn from(value: Dnai) -> Self {
            value.0
        }
    }

    impl From<&Dnai> for Dnai {
        fn from(value: &Dnai) -> Self {
            value.clone()
        }
    }

    impl From<String> for Dnai {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for Dnai {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for Dnai {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///String representing a Data Network as defined in clause 9A of 3GPP TS
    /// 23.003;  it shall contain either a DNN Network Identifier, or a full DNN
    /// with both the Network  Identifier and Operator Identifier, as specified
    /// in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded as string in
    /// which the labels are separated by dots  (e.g. "Label1.Label2.Label3").
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String representing a Data Network as defined in clause
    /// 9A of 3GPP TS 23.003;  it shall contain either a DNN Network Identifier,
    /// or a full DNN with both the Network  Identifier and Operator Identifier,
    /// as specified in 3GPP TS 23.003 clause 9.1.1 and 9.1.2. It shall be coded
    /// as string in which the labels are separated by dots  (e.g.
    /// \"Label1.Label2.Label3\").\n",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct Dnn(pub String);
    impl ::std::ops::Deref for Dnn {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Dnn> for String {
        fn from(value: Dnn) -> Self {
            value.0
        }
    }

    impl From<&Dnn> for Dnn {
        fn from(value: &Dnn) -> Self {
            value.clone()
        }
    }

    impl From<String> for Dnn {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for Dnn {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for Dnn {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///DrxParameter
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "$ref": "#/components/schemas/Bytes"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DrxParameter(pub Bytes);
    impl ::std::ops::Deref for DrxParameter {
        type Target = Bytes;
        fn deref(&self) -> &Bytes {
            &self.0
        }
    }

    impl From<DrxParameter> for Bytes {
        fn from(value: DrxParameter) -> Self {
            value.0
        }
    }

    impl From<&DrxParameter> for DrxParameter {
        fn from(value: &DrxParameter) -> Self {
            value.clone()
        }
    }

    impl From<Bytes> for DrxParameter {
        fn from(value: Bytes) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for DrxParameter {
        type Err = <Bytes as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for DrxParameter {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for DrxParameter {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for DrxParameter {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for DrxParameter {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///indicating a time in seconds.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "indicating a time in seconds.",
    ///  "type": "integer"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct DurationSec(pub i64);
    impl ::std::ops::Deref for DurationSec {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<DurationSec> for i64 {
        fn from(value: DurationSec) -> Self {
            value.0
        }
    }

    impl From<&DurationSec> for DurationSec {
        fn from(value: &DurationSec) -> Self {
            value.clone()
        }
    }

    impl From<i64> for DurationSec {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for DurationSec {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for DurationSec {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for DurationSec {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for DurationSec {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for DurationSec {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///E164Number
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[0-9]{1,15}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct E164Number(String);
    impl ::std::ops::Deref for E164Number {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<E164Number> for String {
        fn from(value: E164Number) -> Self {
            value.0
        }
    }

    impl From<&E164Number> for E164Number {
        fn from(value: &E164Number) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for E164Number {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9]{1,15}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9]{1,15}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for E164Number {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for E164Number {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for E164Number {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for E164Number {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///This represents the identifier of the eNB ID as specified in clause
    /// 9.2.1.37 of  3GPP TS 36.413. The string shall be formatted with the
    /// following pattern
    /// '^('MacroeNB-[A-Fa-f0-9]{5}|LMacroeNB-[A-Fa-f0-9]{6}|SMacroeNB-[A-Fa-f0-9]{5}
    /// |HomeeNB-[A-Fa-f0-9]{7})$'. The value of the eNB ID shall be encoded in
    /// hexadecimal representation. Each character in the  string shall take a
    /// value of "0" to "9", "a" to "f" or "A" to "F" and shall represent 4
    /// bits.  The padding 0 shall be added to make multiple nibbles, so the
    /// most significant character  representing the padding 0 if required
    /// together with the 4 most significant bits of the eNB ID  shall appear
    /// first in the string, and the character representing the 4 least
    /// significant bit  of the eNB ID (to form a nibble) shall appear last in
    /// the string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This represents the identifier of the eNB ID as
    /// specified in clause 9.2.1.37 of  3GPP TS 36.413. The string shall be
    /// formatted with the following pattern
    /// '^('MacroeNB-[A-Fa-f0-9]{5}|LMacroeNB-[A-Fa-f0-9]{6}|SMacroeNB-[A-Fa-f0-9]{5}
    /// |HomeeNB-[A-Fa-f0-9]{7})$'. The value of the eNB ID shall be encoded in
    /// hexadecimal representation. Each character in the  string shall take a
    /// value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall
    /// represent 4 bits.  The padding 0 shall be added to make multiple
    /// nibbles, so the most significant character  representing the padding 0
    /// if required together with the 4 most significant bits of the eNB ID
    /// shall appear first in the string, and the character representing the 4
    /// least significant bit  of the eNB ID (to form a nibble) shall appear
    /// last in the string.\n",
    ///  "type": "string",
    ///  "pattern":
    /// "^(MacroeNB-[A-Fa-f0-9]{5}|LMacroeNB-[A-Fa-f0-9]{6}|SMacroeNB-[A-Fa-f0-9]{5}|HomeeNB-[A-Fa-f0-9]{7})$"
    ///
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ENbId(String);
    impl ::std::ops::Deref for ENbId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ENbId> for String {
        fn from(value: ENbId) -> Self {
            value.0
        }
    }

    impl From<&ENbId> for ENbId {
        fn from(value: &ENbId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ENbId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress :: Regex :: new ("^(MacroeNB-[A-Fa-f0-9]{5}|LMacroeNB-[A-Fa-f0-9]{6}|SMacroeNB-[A-Fa-f0-9]{5}|HomeeNB-[A-Fa-f0-9]{7})$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(MacroeNB-[A-Fa-f0-9]{5}|LMacroeNB-[A-Fa-f0-9]{6}|SMacroeNB-[A-Fa-f0-9]{5}|HomeeNB-[A-Fa-f0-9]{7})$\"" . into ()) ; }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ENbId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ENbId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ENbId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ENbId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///EBI to ARP mapping
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "EBI to ARP mapping",
    ///  "type": "object",
    ///  "required": [
    ///    "arp",
    ///    "epsBearerId"
    ///  ],
    ///  "properties": {
    ///    "arp": {
    ///      "$ref": "#/components/schemas/Arp"
    ///    },
    ///    "epsBearerId": {
    ///      "$ref": "#/components/schemas/EpsBearerId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EbiArpMapping {
        pub arp: Arp,
        #[serde(rename = "epsBearerId")]
        pub eps_bearer_id: EpsBearerId,
    }

    impl From<&EbiArpMapping> for EbiArpMapping {
        fn from(value: &EbiArpMapping) -> Self {
            value.clone()
        }
    }

    ///Enhanced Coverage Restriction Data for WB-N1 mode
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Enhanced Coverage Restriction Data for WB-N1 mode",
    ///  "type": "object",
    ///  "required": [
    ///    "ecModeBRestricted"
    ///  ],
    ///  "properties": {
    ///    "ecModeARestricted": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "ecModeBRestricted": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EcRestrictionDataWb {
        #[serde(rename = "ecModeARestricted", default)]
        pub ec_mode_a_restricted: bool,
        #[serde(rename = "ecModeBRestricted")]
        pub ec_mode_b_restricted: bool,
    }

    impl From<&EcRestrictionDataWb> for EcRestrictionDataWb {
        fn from(value: &EcRestrictionDataWb) -> Self {
            value.clone()
        }
    }

    ///Contains the ECGI (E-UTRAN Cell Global Identity), as described in 3GPP
    /// 23.003
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the ECGI (E-UTRAN Cell Global Identity), as
    /// described in 3GPP 23.003",
    ///  "type": "object",
    ///  "required": [
    ///    "eutraCellId",
    ///    "plmnId"
    ///  ],
    ///  "properties": {
    ///    "eutraCellId": {
    ///      "$ref": "#/components/schemas/EutraCellId"
    ///    },
    ///    "nid": {
    ///      "$ref": "#/components/schemas/Nid"
    ///    },
    ///    "plmnId": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Ecgi {
        #[serde(rename = "eutraCellId")]
        pub eutra_cell_id: EutraCellId,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub nid: Option<Nid>,
        #[serde(rename = "plmnId")]
        pub plmn_id: PlmnId,
    }

    impl From<&Ecgi> for Ecgi {
        fn from(value: &Ecgi) -> Self {
            value.clone()
        }
    }

    ///Ellipsoid Arc.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Ellipsoid Arc.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GADShape"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "confidence",
    ///        "includedAngle",
    ///        "innerRadius",
    ///        "offsetAngle",
    ///        "point",
    ///        "uncertaintyRadius"
    ///      ],
    ///      "properties": {
    ///        "confidence": {
    ///          "$ref": "#/components/schemas/Confidence"
    ///        },
    ///        "includedAngle": {
    ///          "$ref": "#/components/schemas/Angle"
    ///        },
    ///        "innerRadius": {
    ///          "$ref": "#/components/schemas/InnerRadius"
    ///        },
    ///        "offsetAngle": {
    ///          "$ref": "#/components/schemas/Angle"
    ///        },
    ///        "point": {
    ///          "$ref": "#/components/schemas/GeographicalCoordinates"
    ///        },
    ///        "uncertaintyRadius": {
    ///          "$ref": "#/components/schemas/Uncertainty"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EllipsoidArc {
        pub confidence: Confidence,
        #[serde(rename = "includedAngle")]
        pub included_angle: Angle,
        #[serde(rename = "innerRadius")]
        pub inner_radius: InnerRadius,
        #[serde(rename = "offsetAngle")]
        pub offset_angle: Angle,
        pub point: GeographicalCoordinates,
        pub shape: SupportedGadShapes,
        #[serde(rename = "uncertaintyRadius")]
        pub uncertainty_radius: Uncertainty,
    }

    impl From<&EllipsoidArc> for EllipsoidArc {
        fn from(value: &EllipsoidArc) -> Self {
            value.clone()
        }
    }

    ///Data within the Enable Group Reachability Request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within the Enable Group Reachability Request",
    ///  "type": "object",
    ///  "required": [
    ///    "tmgi",
    ///    "ueInfoList"
    ///  ],
    ///  "properties": {
    ///    "5qi": {
    ///      "$ref": "#/components/schemas/5Qi"
    ///    },
    ///    "arp": {
    ///      "$ref": "#/components/schemas/Arp"
    ///    },
    ///    "mbsServiceAreaInfoList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/MbsServiceAreaInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "reachabilityNotifyUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    },
    ///    "tmgi": {
    ///      "$ref": "#/components/schemas/Tmgi"
    ///    },
    ///    "ueInfoList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UeInfo"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EnableGroupReachabilityReqData {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub arp: Option<Arp>,
        #[serde(rename = "5qi", default, skip_serializing_if = "Option::is_none")]
        pub five_qi: Option<_5qi>,
        #[serde(
            rename = "mbsServiceAreaInfoList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub mbs_service_area_info_list: Vec<MbsServiceAreaInfo>,
        #[serde(
            rename = "reachabilityNotifyUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub reachability_notify_uri: Option<Uri>,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
        pub tmgi: Tmgi,
        #[serde(rename = "ueInfoList")]
        pub ue_info_list: Vec<UeInfo>,
    }

    impl From<&EnableGroupReachabilityReqData> for EnableGroupReachabilityReqData {
        fn from(value: &EnableGroupReachabilityReqData) -> Self {
            value.clone()
        }
    }

    ///Data within the Enable Group Reachability Response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within the Enable Group Reachability Response",
    ///  "type": "object",
    ///  "properties": {
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    },
    ///    "ueConnectedList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EnableGroupReachabilityRspData {
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
        #[serde(
            rename = "ueConnectedList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub ue_connected_list: Vec<Supi>,
    }

    impl From<&EnableGroupReachabilityRspData> for EnableGroupReachabilityRspData {
        fn from(value: &EnableGroupReachabilityRspData) -> Self {
            value.clone()
        }
    }

    ///Data within the Enable UE Reachability Request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within the Enable UE Reachability Request",
    ///  "type": "object",
    ///  "required": [
    ///    "reachability"
    ///  ],
    ///  "properties": {
    ///    "extBufSupport": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "oldGuami": {
    ///      "$ref": "#/components/schemas/Guami"
    ///    },
    ///    "reachability": {
    ///      "$ref": "#/components/schemas/UeReachability"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EnableUeReachabilityReqData {
        #[serde(rename = "extBufSupport", default)]
        pub ext_buf_support: bool,
        #[serde(rename = "oldGuami", default, skip_serializing_if = "Option::is_none")]
        pub old_guami: Option<Guami>,
        pub reachability: UeReachability,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
    }

    impl From<&EnableUeReachabilityReqData> for EnableUeReachabilityReqData {
        fn from(value: &EnableUeReachabilityReqData) -> Self {
            value.clone()
        }
    }

    ///Data within the Enable UE Reachability Response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within the Enable UE Reachability Response",
    ///  "type": "object",
    ///  "required": [
    ///    "reachability"
    ///  ],
    ///  "properties": {
    ///    "reachability": {
    ///      "$ref": "#/components/schemas/UeReachability"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EnableUeReachabilityRspData {
        pub reachability: UeReachability,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
    }

    impl From<&EnableUeReachabilityRspData> for EnableUeReachabilityRspData {
        fn from(value: &EnableUeReachabilityRspData) -> Self {
            value.clone()
        }
    }

    ///EPS Bearer Identifier
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "EPS Bearer Identifier",
    ///  "type": "integer",
    ///  "maximum": 15.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EpsBearerId(pub i64);
    impl ::std::ops::Deref for EpsBearerId {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<EpsBearerId> for i64 {
        fn from(value: EpsBearerId) -> Self {
            value.0
        }
    }

    impl From<&EpsBearerId> for EpsBearerId {
        fn from(value: &EpsBearerId) -> Self {
            value.clone()
        }
    }

    impl From<i64> for EpsBearerId {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for EpsBearerId {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for EpsBearerId {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for EpsBearerId {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for EpsBearerId {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for EpsBearerId {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///EpsInterworkingInfo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "epsIwkPgws": {
    ///      "description": "A map (list of key-value pairs where Dnn serves as
    /// key) of EpsIwkPgws",
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/EpsIwkPgw"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EpsInterworkingInfo {
        ///A map (list of key-value pairs where Dnn serves as key) of
        /// EpsIwkPgws
        #[serde(
            rename = "epsIwkPgws",
            default,
            skip_serializing_if = "::std::collections::HashMap::is_empty"
        )]
        pub eps_iwk_pgws: ::std::collections::HashMap<String, EpsIwkPgw>,
    }

    impl From<&EpsInterworkingInfo> for EpsInterworkingInfo {
        fn from(value: &EpsInterworkingInfo) -> Self {
            value.clone()
        }
    }

    ///EpsIwkPgw
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "pgwFqdn",
    ///    "smfInstanceId"
    ///  ],
    ///  "properties": {
    ///    "pgwFqdn": {
    ///      "$ref": "#/components/schemas/Fqdn"
    ///    },
    ///    "plmnId": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    },
    ///    "smfInstanceId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EpsIwkPgw {
        #[serde(rename = "pgwFqdn")]
        pub pgw_fqdn: Fqdn,
        #[serde(rename = "plmnId", default, skip_serializing_if = "Option::is_none")]
        pub plmn_id: Option<PlmnId>,
        #[serde(rename = "smfInstanceId")]
        pub smf_instance_id: NfInstanceId,
    }

    impl From<&EpsIwkPgw> for EpsIwkPgw {
        fn from(value: &EpsIwkPgw) -> Self {
            value.clone()
        }
    }

    ///Indicates the supported EPS NAS Ciphering Algorithm
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the supported EPS NAS Ciphering Algorithm",
    ///  "type": "string",
    ///  "enum": [
    ///    "EEA0",
    ///    "EEA1",
    ///    "EEA2",
    ///    "EEA3"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EpsNasCipheringAlgorithm {
        #[serde(rename = "EEA0")]
        Eea0,
        #[serde(rename = "EEA1")]
        Eea1,
        #[serde(rename = "EEA2")]
        Eea2,
        #[serde(rename = "EEA3")]
        Eea3,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&EpsNasCipheringAlgorithm> for EpsNasCipheringAlgorithm {
        fn from(value: &EpsNasCipheringAlgorithm) -> Self {
            value.clone()
        }
    }

    impl ToString for EpsNasCipheringAlgorithm {
        fn to_string(&self) -> String {
            match *self {
                Self::Eea0 => "EEA0".to_string(),
                Self::Eea1 => "EEA1".to_string(),
                Self::Eea2 => "EEA2".to_string(),
                Self::Eea3 => "EEA3".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for EpsNasCipheringAlgorithm {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EEA0" => Ok(Self::Eea0),
                "EEA1" => Ok(Self::Eea1),
                "EEA2" => Ok(Self::Eea2),
                "EEA3" => Ok(Self::Eea3),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for EpsNasCipheringAlgorithm {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for EpsNasCipheringAlgorithm {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for EpsNasCipheringAlgorithm {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates the supported EPS NAS Integrity Algorithm
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the supported EPS NAS Integrity Algorithm",
    ///  "type": "string",
    ///  "enum": [
    ///    "EIA0",
    ///    "EIA1",
    ///    "EIA2",
    ///    "EIA3"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum EpsNasIntegrityAlgorithm {
        #[serde(rename = "EIA0")]
        Eia0,
        #[serde(rename = "EIA1")]
        Eia1,
        #[serde(rename = "EIA2")]
        Eia2,
        #[serde(rename = "EIA3")]
        Eia3,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&EpsNasIntegrityAlgorithm> for EpsNasIntegrityAlgorithm {
        fn from(value: &EpsNasIntegrityAlgorithm) -> Self {
            value.clone()
        }
    }

    impl ToString for EpsNasIntegrityAlgorithm {
        fn to_string(&self) -> String {
            match *self {
                Self::Eia0 => "EIA0".to_string(),
                Self::Eia1 => "EIA1".to_string(),
                Self::Eia2 => "EIA2".to_string(),
                Self::Eia3 => "EIA3".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for EpsNasIntegrityAlgorithm {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EIA0" => Ok(Self::Eia0),
                "EIA1" => Ok(Self::Eia1),
                "EIA2" => Ok(Self::Eia2),
                "EIA3" => Ok(Self::Eia3),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for EpsNasIntegrityAlgorithm {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for EpsNasIntegrityAlgorithm {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for EpsNasIntegrityAlgorithm {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates the EPS NAS Security Mode
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the EPS NAS Security Mode",
    ///  "type": "object",
    ///  "required": [
    ///    "cipheringAlgorithm",
    ///    "integrityAlgorithm"
    ///  ],
    ///  "properties": {
    ///    "cipheringAlgorithm": {
    ///      "$ref": "#/components/schemas/EpsNasCipheringAlgorithm"
    ///    },
    ///    "integrityAlgorithm": {
    ///      "$ref": "#/components/schemas/EpsNasIntegrityAlgorithm"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EpsNasSecurityMode {
        #[serde(rename = "cipheringAlgorithm")]
        pub ciphering_algorithm: EpsNasCipheringAlgorithm,
        #[serde(rename = "integrityAlgorithm")]
        pub integrity_algorithm: EpsNasIntegrityAlgorithm,
    }

    impl From<&EpsNasSecurityMode> for EpsNasSecurityMode {
        fn from(value: &EpsNasSecurityMode) -> Self {
            value.clone()
        }
    }

    ///Identifies an Ethernet flow.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identifies an Ethernet flow.",
    ///  "type": "object",
    ///  "required": [
    ///    "ethType"
    ///  ],
    ///  "properties": {
    ///    "destMacAddr": {
    ///      "$ref": "#/components/schemas/MacAddr48"
    ///    },
    ///    "destMacAddrEnd": {
    ///      "$ref": "#/components/schemas/MacAddr48"
    ///    },
    ///    "ethType": {
    ///      "type": "string"
    ///    },
    ///    "fDesc": {
    ///      "$ref": "#/components/schemas/FlowDescription"
    ///    },
    ///    "fDir": {
    ///      "$ref": "#/components/schemas/FlowDirection"
    ///    },
    ///    "sourceMacAddr": {
    ///      "$ref": "#/components/schemas/MacAddr48"
    ///    },
    ///    "srcMacAddrEnd": {
    ///      "$ref": "#/components/schemas/MacAddr48"
    ///    },
    ///    "vlanTags": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      },
    ///      "maxItems": 2,
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EthFlowDescription {
        #[serde(
            rename = "destMacAddr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub dest_mac_addr: Option<MacAddr48>,
        #[serde(
            rename = "destMacAddrEnd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub dest_mac_addr_end: Option<MacAddr48>,
        #[serde(rename = "ethType")]
        pub eth_type: String,
        #[serde(rename = "fDesc", default, skip_serializing_if = "Option::is_none")]
        pub f_desc: Option<FlowDescription>,
        #[serde(rename = "fDir", default, skip_serializing_if = "Option::is_none")]
        pub f_dir: Option<FlowDirection>,
        #[serde(
            rename = "sourceMacAddr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub source_mac_addr: Option<MacAddr48>,
        #[serde(
            rename = "srcMacAddrEnd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub src_mac_addr_end: Option<MacAddr48>,
        #[serde(rename = "vlanTags", default, skip_serializing_if = "Vec::is_empty")]
        pub vlan_tags: Vec<String>,
    }

    impl From<&EthFlowDescription> for EthFlowDescription {
        fn from(value: &EthFlowDescription) -> Self {
            value.clone()
        }
    }

    ///28-bit string identifying an E-UTRA Cell Id as specified in clause
    /// 9.3.1.9 of  3GPP TS 38.413, in hexadecimal representation. Each
    /// character in the string shall take a  value of "0" to "9", "a" to "f" or
    /// "A" to "F" and shall represent 4 bits. The most  significant character
    /// representing the 4 most significant bits of the Cell Id shall appear
    /// first in the string, and the character representing the 4 least
    /// significant bit of the  Cell Id shall appear last in the string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "28-bit string identifying an E-UTRA Cell Id as
    /// specified in clause 9.3.1.9 of  3GPP TS 38.413, in hexadecimal
    /// representation. Each character in the string shall take a  value of
    /// \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4
    /// bits. The most  significant character representing the 4 most
    /// significant bits of the Cell Id shall appear  first in the string, and
    /// the character representing the 4 least significant bit of the  Cell Id
    /// shall appear last in the string. \n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{7}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct EutraCellId(String);
    impl ::std::ops::Deref for EutraCellId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<EutraCellId> for String {
        fn from(value: EutraCellId) -> Self {
            value.0
        }
    }

    impl From<&EutraCellId> for EutraCellId {
        fn from(value: &EutraCellId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EutraCellId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{7}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{7}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EutraCellId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for EutraCellId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for EutraCellId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EutraCellId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Contains the E-UTRA user location.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the E-UTRA user location.",
    ///  "type": "object",
    ///  "required": [
    ///    "ecgi",
    ///    "tai"
    ///  ],
    ///  "properties": {
    ///    "ageOfLocationInformation": {
    ///      "description": "The value represents the elapsed time in minutes
    /// since the last network contact of the mobile station.  Value \"0\"
    /// indicates that the location information was obtained after a successful
    /// paging procedure for Active Location Retrieval when the UE is in idle
    /// mode or after a successful NG-RAN location reporting procedure with the
    /// eNB when the UE is in connected mode.  Any other value than \"0\"
    /// indicates that the location information is the last known one.  See 3GPP
    /// TS 29.002 clause 17.7.8.\n",
    ///      "type": "integer",
    ///      "maximum": 32767.0,
    ///      "minimum": 0.0
    ///    },
    ///    "ecgi": {
    ///      "$ref": "#/components/schemas/Ecgi"
    ///    },
    ///    "geodeticInformation": {
    ///      "description": "Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763 (1999) [24] clause 3.88.2. Only the description of an ellipsoid point with uncertainty circle is allowed to be used.\n",
    ///      "type": "string",
    ///      "pattern": "^[0-9A-F]{20}$"
    ///    },
    ///    "geographicalInformation": {
    ///      "description": "Refer to geographical Information. See 3GPP TS
    /// 23.032 clause 7.3.2. Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.\n",
    ///      "type": "string",
    ///      "pattern": "^[0-9A-F]{16}$"
    ///    },
    ///    "globalENbId": {
    ///      "$ref": "#/components/schemas/GlobalRanNodeId"
    ///    },
    ///    "globalNgenbId": {
    ///      "$ref": "#/components/schemas/GlobalRanNodeId"
    ///    },
    ///    "ignoreEcgi": {
    ///      "description": "This flag when present shall indicate that the Ecgi
    /// shall be ignored When present, it shall be set as follows: - true: ecgi
    /// shall be ignored. - false (default): ecgi shall not be ignored.\n",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "ignoreTai": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "tai": {
    ///      "$ref": "#/components/schemas/Tai"
    ///    },
    ///    "ueLocationTimestamp": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EutraLocation {
        ///The value represents the elapsed time in minutes since the last
        /// network contact of the mobile station.  Value "0" indicates that the
        /// location information was obtained after a successful paging
        /// procedure for Active Location Retrieval when the UE is in idle mode
        /// or after a successful NG-RAN location reporting procedure with the
        /// eNB when the UE is in connected mode.  Any other value than "0"
        /// indicates that the location information is the last known one.  See
        /// 3GPP TS 29.002 clause 17.7.8.
        #[serde(
            rename = "ageOfLocationInformation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub age_of_location_information: Option<i64>,
        pub ecgi: Ecgi,
        ///Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763
        /// (1999) [24] clause 3.88.2. Only the description of an ellipsoid
        /// point with uncertainty circle is allowed to be used.
        #[serde(
            rename = "geodeticInformation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub geodetic_information: Option<EutraLocationGeodeticInformation>,
        ///Refer to geographical Information. See 3GPP TS 23.032 clause 7.3.2.
        /// Only the description of an ellipsoid point with uncertainty circle
        /// is allowed to be used.
        #[serde(
            rename = "geographicalInformation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub geographical_information: Option<EutraLocationGeographicalInformation>,
        #[serde(
            rename = "globalENbId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub global_e_nb_id: Option<GlobalRanNodeId>,
        #[serde(
            rename = "globalNgenbId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub global_ngenb_id: Option<GlobalRanNodeId>,
        ///This flag when present shall indicate that the Ecgi shall be ignored
        /// When present, it shall be set as follows: - true: ecgi shall be
        /// ignored. - false (default): ecgi shall not be ignored.
        #[serde(rename = "ignoreEcgi", default)]
        pub ignore_ecgi: bool,
        #[serde(rename = "ignoreTai", default)]
        pub ignore_tai: bool,
        pub tai: Tai,
        #[serde(
            rename = "ueLocationTimestamp",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_location_timestamp: Option<DateTime>,
    }

    impl From<&EutraLocation> for EutraLocation {
        fn from(value: &EutraLocation) -> Self {
            value.clone()
        }
    }

    ///Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763
    /// (1999) [24] clause 3.88.2. Only the description of an ellipsoid point
    /// with uncertainty circle is allowed to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763 (1999) [24] clause 3.88.2. Only the description of an ellipsoid point with uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{20}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct EutraLocationGeodeticInformation(String);
    impl ::std::ops::Deref for EutraLocationGeodeticInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<EutraLocationGeodeticInformation> for String {
        fn from(value: EutraLocationGeodeticInformation) -> Self {
            value.0
        }
    }

    impl From<&EutraLocationGeodeticInformation> for EutraLocationGeodeticInformation {
        fn from(value: &EutraLocationGeodeticInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EutraLocationGeodeticInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{20}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EutraLocationGeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for EutraLocationGeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for EutraLocationGeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EutraLocationGeodeticInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Refer to geographical Information. See 3GPP TS 23.032 clause 7.3.2. Only
    /// the description of an ellipsoid point with uncertainty circle is allowed
    /// to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refer to geographical Information. See 3GPP TS 23.032
    /// clause 7.3.2. Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{16}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct EutraLocationGeographicalInformation(String);
    impl ::std::ops::Deref for EutraLocationGeographicalInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<EutraLocationGeographicalInformation> for String {
        fn from(value: EutraLocationGeographicalInformation) -> Self {
            value.0
        }
    }

    impl From<&EutraLocationGeographicalInformation> for EutraLocationGeographicalInformation {
        fn from(value: &EutraLocationGeographicalInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for EutraLocationGeographicalInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{16}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for EutraLocationGeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for EutraLocationGeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for EutraLocationGeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for EutraLocationGeographicalInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Represents a notification on events that occurred.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a notification on events that occurred.",
    ///  "type": "object",
    ///  "required": [
    ///    "event"
    ///  ],
    ///  "properties": {
    ///    "abnorBehavrs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AbnormalBehaviour"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "anaMetaInfo": {
    ///      "$ref": "#/components/schemas/AnalyticsMetadataInfo"
    ///    },
    ///    "disperInfos": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DispersionInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "dnPerfInfos": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DnPerfInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "event": {
    ///      "$ref": "#/components/schemas/NwdafEvent"
    ///    },
    ///    "expiry": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "failNotifyCode": {
    ///      "$ref": "#/components/schemas/NwdafFailureCode"
    ///    },
    ///    "nfLoadLevelInfos": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NfLoadLevelInformation"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "nsiLoadLevelInfos": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NsiLoadLevelInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "nwPerfs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NetworkPerfInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "qosSustainInfos": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/QosSustainabilityInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "redTransInfos": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RedundantTransmissionExpInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "rvWaitTime": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "sliceLoadLevelInfo": {
    ///      "$ref": "#/components/schemas/SliceLoadLevelInformation"
    ///    },
    ///    "smccExps": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SmcceInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "start": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "svcExps": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ServiceExperienceInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "timeStampGen": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "ueComms": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UeCommunication"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "ueMobs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UeMobility"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "userDataCongInfos": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UserDataCongestionInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "wlanInfos": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/WlanPerformanceInfo"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EventNotification {
        #[serde(
            rename = "abnorBehavrs",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub abnor_behavrs: Vec<AbnormalBehaviour>,
        #[serde(
            rename = "anaMetaInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ana_meta_info: Option<AnalyticsMetadataInfo>,
        #[serde(rename = "disperInfos", default, skip_serializing_if = "Vec::is_empty")]
        pub disper_infos: Vec<DispersionInfo>,
        #[serde(rename = "dnPerfInfos", default, skip_serializing_if = "Vec::is_empty")]
        pub dn_perf_infos: Vec<DnPerfInfo>,
        pub event: NwdafEvent,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub expiry: Option<DateTime>,
        #[serde(
            rename = "failNotifyCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub fail_notify_code: Option<NwdafFailureCode>,
        #[serde(
            rename = "nfLoadLevelInfos",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub nf_load_level_infos: Vec<NfLoadLevelInformation>,
        #[serde(
            rename = "nsiLoadLevelInfos",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub nsi_load_level_infos: Vec<NsiLoadLevelInfo>,
        #[serde(rename = "nwPerfs", default, skip_serializing_if = "Vec::is_empty")]
        pub nw_perfs: Vec<NetworkPerfInfo>,
        #[serde(
            rename = "qosSustainInfos",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub qos_sustain_infos: Vec<QosSustainabilityInfo>,
        #[serde(
            rename = "redTransInfos",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub red_trans_infos: Vec<RedundantTransmissionExpInfo>,
        #[serde(
            rename = "rvWaitTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub rv_wait_time: Option<DurationSec>,
        #[serde(
            rename = "sliceLoadLevelInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub slice_load_level_info: Option<SliceLoadLevelInformation>,
        #[serde(rename = "smccExps", default, skip_serializing_if = "Vec::is_empty")]
        pub smcc_exps: Vec<SmcceInfo>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start: Option<DateTime>,
        #[serde(rename = "svcExps", default, skip_serializing_if = "Vec::is_empty")]
        pub svc_exps: Vec<ServiceExperienceInfo>,
        #[serde(
            rename = "timeStampGen",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub time_stamp_gen: Option<DateTime>,
        #[serde(rename = "ueComms", default, skip_serializing_if = "Vec::is_empty")]
        pub ue_comms: Vec<UeCommunication>,
        #[serde(rename = "ueMobs", default, skip_serializing_if = "Vec::is_empty")]
        pub ue_mobs: Vec<UeMobility>,
        #[serde(
            rename = "userDataCongInfos",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub user_data_cong_infos: Vec<UserDataCongestionInfo>,
        #[serde(rename = "wlanInfos", default, skip_serializing_if = "Vec::is_empty")]
        pub wlan_infos: Vec<WlanPerformanceInfo>,
    }

    impl From<&EventNotification> for EventNotification {
        fn from(value: &EventNotification) -> Self {
            value.clone()
        }
    }

    ///Represents the type of reporting that the subscription requires.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the type of reporting that the subscription
    /// requires.",
    ///  "type": "object",
    ///  "properties": {
    ///    "accPerSubset": {
    ///      "description": "Each element indicates the preferred accuracy level
    /// per analytics subset. It may be present if the \"listOfAnaSubsets\"
    /// attribute is present in the subscription request when the subscription
    /// event is NF_LOAD, UE_COMM, DISPERSION, NETWORK_PERFORMANCE,
    /// WLAN_PERFORMANCE, DN_PERFORMANCE or SERVICE_EXPERIENCE.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Accuracy"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "accuracy": {
    ///      "$ref": "#/components/schemas/Accuracy"
    ///    },
    ///    "anaMeta": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AnalyticsMetadata"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "anaMetaInd": {
    ///      "$ref": "#/components/schemas/AnalyticsMetadataIndication"
    ///    },
    ///    "endTs": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "histAnaTimePeriod": {
    ///      "$ref": "#/components/schemas/TimeWindow"
    ///    },
    ///    "maxObjectNbr": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "maxSupiNbr": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "offsetPeriod": {
    ///      "description": "Offset period in units of seconds to the reporting
    /// time, if the value is negative means statistics in the past offset
    /// period, otherwise a positive value means prediction in the future offset
    /// period. May be present if the \"repPeriod\" attribute is included within
    /// the \"evtReq\" attribute.\n",
    ///      "type": "integer"
    ///    },
    ///    "sampRatio": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    },
    ///    "startTs": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "timeAnaNeeded": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EventReportingRequirement {
        ///Each element indicates the preferred accuracy level per analytics
        /// subset. It may be present if the "listOfAnaSubsets" attribute is
        /// present in the subscription request when the subscription event is
        /// NF_LOAD, UE_COMM, DISPERSION, NETWORK_PERFORMANCE, WLAN_PERFORMANCE,
        /// DN_PERFORMANCE or SERVICE_EXPERIENCE.
        #[serde(
            rename = "accPerSubset",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub acc_per_subset: Vec<Accuracy>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub accuracy: Option<Accuracy>,
        #[serde(rename = "anaMeta", default, skip_serializing_if = "Vec::is_empty")]
        pub ana_meta: Vec<AnalyticsMetadata>,
        #[serde(
            rename = "anaMetaInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ana_meta_ind: Option<AnalyticsMetadataIndication>,
        #[serde(rename = "endTs", default, skip_serializing_if = "Option::is_none")]
        pub end_ts: Option<DateTime>,
        #[serde(
            rename = "histAnaTimePeriod",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub hist_ana_time_period: Option<TimeWindow>,
        #[serde(
            rename = "maxObjectNbr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_object_nbr: Option<Uinteger>,
        #[serde(
            rename = "maxSupiNbr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_supi_nbr: Option<Uinteger>,
        ///Offset period in units of seconds to the reporting time, if the
        /// value is negative means statistics in the past offset period,
        /// otherwise a positive value means prediction in the future offset
        /// period. May be present if the "repPeriod" attribute is included
        /// within the "evtReq" attribute.
        #[serde(
            rename = "offsetPeriod",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub offset_period: Option<i64>,
        #[serde(rename = "sampRatio", default, skip_serializing_if = "Option::is_none")]
        pub samp_ratio: Option<SamplingRatio>,
        #[serde(rename = "startTs", default, skip_serializing_if = "Option::is_none")]
        pub start_ts: Option<DateTime>,
        #[serde(
            rename = "timeAnaNeeded",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub time_ana_needed: Option<DateTime>,
    }

    impl From<&EventReportingRequirement> for EventReportingRequirement {
        fn from(value: &EventReportingRequirement) -> Self {
            value.clone()
        }
    }

    ///Represents a subscription to a single event.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a subscription to a single event.",
    ///  "type": "object",
    ///  "required": [
    ///    "event"
    ///  ],
    ///  "properties": {
    ///    "anySlice": {
    ///      "$ref": "#/components/schemas/AnySlice"
    ///    },
    ///    "appIds": {
    ///      "description": "Identification(s) of application to which the
    /// subscription applies.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ApplicationId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "appServerAddrs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AddrFqdn"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "bwRequs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/BwRequirement"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "congThresholds": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ThresholdLevel"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "disperReqs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DispersionRequirement"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "dnPerfReqs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DnPerformanceReq"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "dnais": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Dnai"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "dnns": {
    ///      "description": "Identification(s) of DNN to which the subscription
    /// applies.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Dnn"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "event": {
    ///      "$ref": "#/components/schemas/NwdafEvent"
    ///    },
    ///    "excepRequs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Exception"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "exptAnaType": {
    ///      "$ref": "#/components/schemas/ExpectedAnalyticsType"
    ///    },
    ///    "exptUeBehav": {
    ///      "$ref": "#/components/schemas/ExpectedUeBehaviourData"
    ///    },
    ///    "extraReportReq": {
    ///      "$ref": "#/components/schemas/EventReportingRequirement"
    ///    },
    ///    "ladnDnns": {
    ///      "description": "Identification(s) of LADN DNN to indicate the LADN
    /// service area as the AOI.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Dnn"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "listOfAnaSubsets": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AnalyticsSubset"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "loadLevelThreshold": {
    ///      "description": "Indicates that the NWDAF shall report the
    /// corresponding network slice load level to the NF service consumer where
    /// the load level of the network slice identified by snssais is
    /// reached.\n",
    ///      "type": "integer"
    ///    },
    ///    "matchingDir": {
    ///      "$ref": "#/components/schemas/MatchingDirection"
    ///    },
    ///    "maxTopAppDlNbr": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "maxTopAppUlNbr": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "networkArea": {
    ///      "$ref": "#/components/schemas/NetworkAreaInfo"
    ///    },
    ///    "nfInstanceIds": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NfInstanceId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "nfLoadLvlThds": {
    ///      "description": "Shall be supplied in order to start reporting when
    /// an average load level is reached.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ThresholdLevel"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "nfSetIds": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NfSetId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "nfTypes": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NFType"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "notificationMethod": {
    ///      "$ref": "#/components/schemas/NotificationMethod"
    ///    },
    ///    "nsiIdInfos": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NsiIdInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "nsiLevelThrds": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Uinteger"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "nwPerfRequs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NetworkPerfRequirement"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "qosFlowRetThds": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RetainabilityThreshold"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "qosRequ": {
    ///      "$ref": "#/components/schemas/QosRequirement"
    ///    },
    ///    "ranUeThrouThds": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/BitRate"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "ratFreqs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RatFreqInformation"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "redTransReqs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RedundantTransmissionExpReq"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "repetitionPeriod": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "snssaia": {
    ///      "description": "Identification(s) of network slice to which the
    /// subscription applies. It corresponds to snssais in the data model
    /// definition of 3GPP TS 29.520.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Snssai"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "tgtUe": {
    ///      "$ref": "#/components/schemas/TargetUeInformation"
    ///    },
    ///    "upfInfo": {
    ///      "$ref": "#/components/schemas/UpfInformation"
    ///    },
    ///    "visitedAreas": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NetworkAreaInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "wlanReqs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/WlanPerformanceReq"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct EventSubscription {
        #[serde(rename = "anySlice", default, skip_serializing_if = "Option::is_none")]
        pub any_slice: Option<AnySlice>,
        ///Identification(s) of application to which the subscription applies.
        #[serde(rename = "appIds", default, skip_serializing_if = "Vec::is_empty")]
        pub app_ids: Vec<ApplicationId>,
        #[serde(
            rename = "appServerAddrs",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub app_server_addrs: Vec<AddrFqdn>,
        #[serde(rename = "bwRequs", default, skip_serializing_if = "Vec::is_empty")]
        pub bw_requs: Vec<BwRequirement>,
        #[serde(
            rename = "congThresholds",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub cong_thresholds: Vec<ThresholdLevel>,
        #[serde(rename = "disperReqs", default, skip_serializing_if = "Vec::is_empty")]
        pub disper_reqs: Vec<DispersionRequirement>,
        #[serde(rename = "dnPerfReqs", default, skip_serializing_if = "Vec::is_empty")]
        pub dn_perf_reqs: Vec<DnPerformanceReq>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub dnais: Vec<Dnai>,
        ///Identification(s) of DNN to which the subscription applies.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub dnns: Vec<Dnn>,
        pub event: NwdafEvent,
        #[serde(rename = "excepRequs", default, skip_serializing_if = "Vec::is_empty")]
        pub excep_requs: Vec<Exception>,
        #[serde(
            rename = "exptAnaType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub expt_ana_type: Option<ExpectedAnalyticsType>,
        #[serde(
            rename = "exptUeBehav",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub expt_ue_behav: Option<ExpectedUeBehaviourData>,
        #[serde(
            rename = "extraReportReq",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub extra_report_req: Option<EventReportingRequirement>,
        ///Identification(s) of LADN DNN to indicate the LADN service area as
        /// the AOI.
        #[serde(rename = "ladnDnns", default, skip_serializing_if = "Vec::is_empty")]
        pub ladn_dnns: Vec<Dnn>,
        #[serde(
            rename = "listOfAnaSubsets",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub list_of_ana_subsets: Vec<AnalyticsSubset>,
        ///Indicates that the NWDAF shall report the corresponding network
        /// slice load level to the NF service consumer where the load level of
        /// the network slice identified by snssais is reached.
        #[serde(
            rename = "loadLevelThreshold",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub load_level_threshold: Option<i64>,
        #[serde(
            rename = "matchingDir",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub matching_dir: Option<MatchingDirection>,
        #[serde(
            rename = "maxTopAppDlNbr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_top_app_dl_nbr: Option<Uinteger>,
        #[serde(
            rename = "maxTopAppUlNbr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_top_app_ul_nbr: Option<Uinteger>,
        #[serde(
            rename = "networkArea",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub network_area: Option<NetworkAreaInfo>,
        #[serde(
            rename = "nfInstanceIds",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub nf_instance_ids: Vec<NfInstanceId>,
        ///Shall be supplied in order to start reporting when an average load
        /// level is reached.
        #[serde(
            rename = "nfLoadLvlThds",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub nf_load_lvl_thds: Vec<ThresholdLevel>,
        #[serde(rename = "nfSetIds", default, skip_serializing_if = "Vec::is_empty")]
        pub nf_set_ids: Vec<NfSetId>,
        #[serde(rename = "nfTypes", default, skip_serializing_if = "Vec::is_empty")]
        pub nf_types: Vec<NfType>,
        #[serde(
            rename = "notificationMethod",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub notification_method: Option<NotificationMethod>,
        #[serde(rename = "nsiIdInfos", default, skip_serializing_if = "Vec::is_empty")]
        pub nsi_id_infos: Vec<NsiIdInfo>,
        #[serde(
            rename = "nsiLevelThrds",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub nsi_level_thrds: Vec<Uinteger>,
        #[serde(rename = "nwPerfRequs", default, skip_serializing_if = "Vec::is_empty")]
        pub nw_perf_requs: Vec<NetworkPerfRequirement>,
        #[serde(
            rename = "qosFlowRetThds",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub qos_flow_ret_thds: Vec<RetainabilityThreshold>,
        #[serde(rename = "qosRequ", default, skip_serializing_if = "Option::is_none")]
        pub qos_requ: Option<QosRequirement>,
        #[serde(
            rename = "ranUeThrouThds",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub ran_ue_throu_thds: Vec<BitRate>,
        #[serde(rename = "ratFreqs", default, skip_serializing_if = "Vec::is_empty")]
        pub rat_freqs: Vec<RatFreqInformation>,
        #[serde(
            rename = "redTransReqs",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub red_trans_reqs: Vec<RedundantTransmissionExpReq>,
        #[serde(
            rename = "repetitionPeriod",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub repetition_period: Option<DurationSec>,
        ///Identification(s) of network slice to which the subscription
        /// applies. It corresponds to snssais in the data model definition of
        /// 3GPP TS 29.520.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub snssaia: Vec<Snssai>,
        #[serde(rename = "tgtUe", default, skip_serializing_if = "Option::is_none")]
        pub tgt_ue: Option<TargetUeInformation>,
        #[serde(rename = "upfInfo", default, skip_serializing_if = "Option::is_none")]
        pub upf_info: Option<UpfInformation>,
        #[serde(
            rename = "visitedAreas",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub visited_areas: Vec<NetworkAreaInfo>,
        #[serde(rename = "wlanReqs", default, skip_serializing_if = "Vec::is_empty")]
        pub wlan_reqs: Vec<WlanPerformanceReq>,
    }

    impl From<&EventSubscription> for EventSubscription {
        fn from(value: &EventSubscription) -> Self {
            value.clone()
        }
    }

    ///Represents the Exception information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the Exception information.",
    ///  "type": "object",
    ///  "required": [
    ///    "excepId"
    ///  ],
    ///  "properties": {
    ///    "excepId": {
    ///      "$ref": "#/components/schemas/ExceptionId"
    ///    },
    ///    "excepLevel": {
    ///      "type": "integer"
    ///    },
    ///    "excepTrend": {
    ///      "$ref": "#/components/schemas/ExceptionTrend"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Exception {
        #[serde(rename = "excepId")]
        pub excep_id: ExceptionId,
        #[serde(
            rename = "excepLevel",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub excep_level: Option<i64>,
        #[serde(
            rename = "excepTrend",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub excep_trend: Option<ExceptionTrend>,
    }

    impl From<&Exception> for Exception {
        fn from(value: &Exception) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - UNEXPECTED_UE_LOCATION: Unexpected UE location
    /// - UNEXPECTED_LONG_LIVE_FLOW: Unexpected long-live rate flows
    /// - UNEXPECTED_LARGE_RATE_FLOW: Unexpected large rate flows
    /// - UNEXPECTED_WAKEUP: Unexpected wakeup
    /// - SUSPICION_OF_DDOS_ATTACK: Suspicion of DDoS attack
    /// - WRONG_DESTINATION_ADDRESS: Wrong destination address
    /// - TOO_FREQUENT_SERVICE_ACCESS: Too frequent Service Access
    /// - UNEXPECTED_RADIO_LINK_FAILURES: Unexpected radio link failures
    /// - PING_PONG_ACROSS_CELLS: Ping-ponging across neighbouring cells
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- UNEXPECTED_UE_LOCATION:
    /// Unexpected UE location\n- UNEXPECTED_LONG_LIVE_FLOW: Unexpected
    /// long-live rate flows\n- UNEXPECTED_LARGE_RATE_FLOW: Unexpected large
    /// rate flows\n- UNEXPECTED_WAKEUP: Unexpected wakeup\n-
    /// SUSPICION_OF_DDOS_ATTACK: Suspicion of DDoS attack\n-
    /// WRONG_DESTINATION_ADDRESS: Wrong destination address\n-
    /// TOO_FREQUENT_SERVICE_ACCESS: Too frequent Service Access\n-
    /// UNEXPECTED_RADIO_LINK_FAILURES: Unexpected radio link failures\n-
    /// PING_PONG_ACROSS_CELLS: Ping-ponging across neighbouring cells\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "UNEXPECTED_UE_LOCATION",
    ///    "UNEXPECTED_LONG_LIVE_FLOW",
    ///    "UNEXPECTED_LARGE_RATE_FLOW",
    ///    "UNEXPECTED_WAKEUP",
    ///    "SUSPICION_OF_DDOS_ATTACK",
    ///    "WRONG_DESTINATION_ADDRESS",
    ///    "TOO_FREQUENT_SERVICE_ACCESS",
    ///    "UNEXPECTED_RADIO_LINK_FAILURES",
    ///    "PING_PONG_ACROSS_CELLS"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ExceptionId {
        #[serde(rename = "UNEXPECTED_UE_LOCATION")]
        UnexpectedUeLocation,
        #[serde(rename = "UNEXPECTED_LONG_LIVE_FLOW")]
        UnexpectedLongLiveFlow,
        #[serde(rename = "UNEXPECTED_LARGE_RATE_FLOW")]
        UnexpectedLargeRateFlow,
        #[serde(rename = "UNEXPECTED_WAKEUP")]
        UnexpectedWakeup,
        #[serde(rename = "SUSPICION_OF_DDOS_ATTACK")]
        SuspicionOfDdosAttack,
        #[serde(rename = "WRONG_DESTINATION_ADDRESS")]
        WrongDestinationAddress,
        #[serde(rename = "TOO_FREQUENT_SERVICE_ACCESS")]
        TooFrequentServiceAccess,
        #[serde(rename = "UNEXPECTED_RADIO_LINK_FAILURES")]
        UnexpectedRadioLinkFailures,
        #[serde(rename = "PING_PONG_ACROSS_CELLS")]
        PingPongAcrossCells,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&ExceptionId> for ExceptionId {
        fn from(value: &ExceptionId) -> Self {
            value.clone()
        }
    }

    impl ToString for ExceptionId {
        fn to_string(&self) -> String {
            match *self {
                Self::UnexpectedUeLocation => "UNEXPECTED_UE_LOCATION".to_string(),
                Self::UnexpectedLongLiveFlow => "UNEXPECTED_LONG_LIVE_FLOW".to_string(),
                Self::UnexpectedLargeRateFlow => "UNEXPECTED_LARGE_RATE_FLOW".to_string(),
                Self::UnexpectedWakeup => "UNEXPECTED_WAKEUP".to_string(),
                Self::SuspicionOfDdosAttack => "SUSPICION_OF_DDOS_ATTACK".to_string(),
                Self::WrongDestinationAddress => "WRONG_DESTINATION_ADDRESS".to_string(),
                Self::TooFrequentServiceAccess => "TOO_FREQUENT_SERVICE_ACCESS".to_string(),
                Self::UnexpectedRadioLinkFailures => "UNEXPECTED_RADIO_LINK_FAILURES".to_string(),
                Self::PingPongAcrossCells => "PING_PONG_ACROSS_CELLS".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for ExceptionId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "UNEXPECTED_UE_LOCATION" => Ok(Self::UnexpectedUeLocation),
                "UNEXPECTED_LONG_LIVE_FLOW" => Ok(Self::UnexpectedLongLiveFlow),
                "UNEXPECTED_LARGE_RATE_FLOW" => Ok(Self::UnexpectedLargeRateFlow),
                "UNEXPECTED_WAKEUP" => Ok(Self::UnexpectedWakeup),
                "SUSPICION_OF_DDOS_ATTACK" => Ok(Self::SuspicionOfDdosAttack),
                "WRONG_DESTINATION_ADDRESS" => Ok(Self::WrongDestinationAddress),
                "TOO_FREQUENT_SERVICE_ACCESS" => Ok(Self::TooFrequentServiceAccess),
                "UNEXPECTED_RADIO_LINK_FAILURES" => Ok(Self::UnexpectedRadioLinkFailures),
                "PING_PONG_ACROSS_CELLS" => Ok(Self::PingPongAcrossCells),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ExceptionId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ExceptionId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ExceptionId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Possible values are:
    /// - UP: Up trend of the exception level.
    /// - DOWN: Down trend of the exception level.
    /// - UNKNOW: Unknown trend of the exception level.
    /// - STABLE: Stable trend of the exception level.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- UP: Up trend of the exception
    /// level.\n- DOWN: Down trend of the exception level.\n- UNKNOW: Unknown
    /// trend of the exception level.\n- STABLE: Stable trend of the exception
    /// level.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "UP",
    ///    "DOWN",
    ///    "UNKNOW",
    ///    "STABLE"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ExceptionTrend {
        #[serde(rename = "UP")]
        Up,
        #[serde(rename = "DOWN")]
        Down,
        #[serde(rename = "UNKNOW")]
        Unknow,
        #[serde(rename = "STABLE")]
        Stable,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&ExceptionTrend> for ExceptionTrend {
        fn from(value: &ExceptionTrend) -> Self {
            value.clone()
        }
    }

    impl ToString for ExceptionTrend {
        fn to_string(&self) -> String {
            match *self {
                Self::Up => "UP".to_string(),
                Self::Down => "DOWN".to_string(),
                Self::Unknow => "UNKNOW".to_string(),
                Self::Stable => "STABLE".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for ExceptionTrend {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "UP" => Ok(Self::Up),
                "DOWN" => Ok(Self::Down),
                "UNKNOW" => Ok(Self::Unknow),
                "STABLE" => Ok(Self::Stable),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ExceptionTrend {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ExceptionTrend {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ExceptionTrend {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Possible values are:
    /// - MOBILITY: Mobility related abnormal behaviour analytics is expected by
    ///   the consumer.
    /// - COMMUN: Communication related abnormal behaviour analytics is expected
    ///   by the consumer.
    /// - MOBILITY_AND_COMMUN: Both mobility and communication related abnormal
    ///   behaviour analytics is expected by the consumer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- MOBILITY: Mobility related abnormal behaviour analytics is expected by the consumer.\n- COMMUN: Communication related abnormal behaviour analytics is expected by the consumer.\n- MOBILITY_AND_COMMUN: Both mobility and communication related abnormal behaviour analytics is expected by the consumer.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "MOBILITY",
    ///    "COMMUN",
    ///    "MOBILITY_AND_COMMUN"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ExpectedAnalyticsType {
        #[serde(rename = "MOBILITY")]
        Mobility,
        #[serde(rename = "COMMUN")]
        Commun,
        #[serde(rename = "MOBILITY_AND_COMMUN")]
        MobilityAndCommun,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&ExpectedAnalyticsType> for ExpectedAnalyticsType {
        fn from(value: &ExpectedAnalyticsType) -> Self {
            value.clone()
        }
    }

    impl ToString for ExpectedAnalyticsType {
        fn to_string(&self) -> String {
            match *self {
                Self::Mobility => "MOBILITY".to_string(),
                Self::Commun => "COMMUN".to_string(),
                Self::MobilityAndCommun => "MOBILITY_AND_COMMUN".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for ExpectedAnalyticsType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "MOBILITY" => Ok(Self::Mobility),
                "COMMUN" => Ok(Self::Commun),
                "MOBILITY_AND_COMMUN" => Ok(Self::MobilityAndCommun),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ExpectedAnalyticsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ExpectedAnalyticsType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ExpectedAnalyticsType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents the expected UE behavior (e.g. UE moving trajectory) and its
    /// validity period
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the expected UE behavior (e.g. UE moving
    /// trajectory) and its validity period",
    ///  "type": "object",
    ///  "required": [
    ///    "expMoveTrajectory",
    ///    "validityTime"
    ///  ],
    ///  "properties": {
    ///    "expMoveTrajectory": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UserLocation"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "validityTime": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ExpectedUeBehavior {
        #[serde(rename = "expMoveTrajectory")]
        pub exp_move_trajectory: Vec<UserLocation>,
        #[serde(rename = "validityTime")]
        pub validity_time: DateTime,
    }

    impl From<&ExpectedUeBehavior> for ExpectedUeBehavior {
        fn from(value: &ExpectedUeBehavior) -> Self {
            value.clone()
        }
    }

    ///ExpectedUeBehaviourData
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "batteryIndication": {
    ///      "$ref": "#/components/schemas/BatteryIndication"
    ///    },
    ///    "communicationDurationTime": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "expectedUmts": {
    ///      "description": "Identifies the UE's expected geographical movement.
    /// The attribute is only applicable in 5G.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LocationArea"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "periodicTime": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "scheduledCommunicationTime": {
    ///      "$ref": "#/components/schemas/ScheduledCommunicationTime"
    ///    },
    ///    "scheduledCommunicationType": {
    ///      "$ref": "#/components/schemas/ScheduledCommunicationType"
    ///    },
    ///    "stationaryIndication": {
    ///      "$ref": "#/components/schemas/StationaryIndication"
    ///    },
    ///    "trafficProfile": {
    ///      "$ref": "#/components/schemas/TrafficProfile"
    ///    },
    ///    "validityTime": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ExpectedUeBehaviourData {
        #[serde(
            rename = "batteryIndication",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub battery_indication: Option<BatteryIndication>,
        #[serde(
            rename = "communicationDurationTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub communication_duration_time: Option<DurationSec>,
        ///Identifies the UE's expected geographical movement. The attribute is
        /// only applicable in 5G.
        #[serde(
            rename = "expectedUmts",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub expected_umts: Vec<LocationArea>,
        #[serde(
            rename = "periodicTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub periodic_time: Option<DurationSec>,
        #[serde(
            rename = "scheduledCommunicationTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub scheduled_communication_time: Option<ScheduledCommunicationTime>,
        #[serde(
            rename = "scheduledCommunicationType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub scheduled_communication_type: Option<ScheduledCommunicationType>,
        #[serde(
            rename = "stationaryIndication",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub stationary_indication: Option<StationaryIndication>,
        #[serde(
            rename = "trafficProfile",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub traffic_profile: Option<TrafficProfile>,
        #[serde(
            rename = "validityTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub validity_time: Option<DateTime>,
    }

    impl From<&ExpectedUeBehaviourData> for ExpectedUeBehaviourData {
        fn from(value: &ExpectedUeBehaviourData) -> Self {
            value.clone()
        }
    }

    ///AMF event subscription extended with additional information received for
    /// the subscription
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "AMF event subscription extended with additional
    /// information received for the subscription",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/schemas-AmfEventSubscription"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AmfEventSubscriptionAddInfo"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ExtAmfEventSubscription {
        #[serde(rename = "anyUE", default, skip_serializing_if = "Option::is_none")]
        pub any_ue: Option<bool>,
        ///Map of subscribed Area of Interest (AoI) Event State in the old AMF.
        /// The JSON pointer to an AmfEventArea element in the areaList IE (or a
        /// PresenceInfo element in  presenceInfoList IE) of the AmfEvent data
        /// type shall be the key of the map.
        #[serde(
            rename = "aoiStateList",
            default,
            skip_serializing_if = "::std::collections::HashMap::is_empty"
        )]
        pub aoi_state_list: ::std::collections::HashMap<String, AreaOfInterestEventState>,
        #[serde(rename = "bindingInfo", default, skip_serializing_if = "Vec::is_empty")]
        pub binding_info: Vec<String>,
        #[serde(rename = "eventList")]
        pub event_list: Vec<SchemasAmfEvent>,
        #[serde(rename = "eventNotifyUri")]
        pub event_notify_uri: Uri,
        #[serde(
            rename = "eventSyncInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub event_sync_ind: Option<bool>,
        #[serde(
            rename = "excludeGpsiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub exclude_gpsi_list: Vec<Gpsi>,
        #[serde(
            rename = "excludeSupiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub exclude_supi_list: Vec<Supi>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub gpsi: Option<Gpsi>,
        #[serde(rename = "groupId", default, skip_serializing_if = "Option::is_none")]
        pub group_id: Option<GroupId>,
        #[serde(
            rename = "includeGpsiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub include_gpsi_list: Vec<Gpsi>,
        #[serde(
            rename = "includeSupiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub include_supi_list: Vec<Supi>,
        #[serde(
            rename = "nfConsumerInfo",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub nf_consumer_info: Vec<String>,
        #[serde(rename = "nfId")]
        pub nf_id: NfInstanceId,
        #[serde(rename = "notifyCorrelationId")]
        pub notify_correlation_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub options: Option<SchemasAmfEventMode>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pei: Option<Pei>,
        #[serde(
            rename = "sourceNfType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub source_nf_type: Option<NfType>,
        #[serde(
            rename = "subsChangeNotifyCorrelationId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub subs_change_notify_correlation_id: Option<String>,
        #[serde(
            rename = "subsChangeNotifyUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub subs_change_notify_uri: Option<Uri>,
        #[serde(
            rename = "subscribingNfType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub subscribing_nf_type: Option<NfType>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub supi: Option<Supi>,
    }

    impl From<&ExtAmfEventSubscription> for ExtAmfEventSubscription {
        fn from(value: &ExtAmfEventSubscription) -> Self {
            value.clone()
        }
    }

    ///The sdRanges and wildcardSd attributes shall be exclusive from each
    /// other. If one of these attributes is present,  the sd attribute shall
    /// also be present and it shall contain one Slice Differentiator value
    /// within the range of SD  (if the sdRanges attribute is present) or with
    /// any value (if the wildcardSd attribute is present).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The sdRanges and wildcardSd attributes shall be
    /// exclusive from each other. If one of these attributes is present,  the
    /// sd attribute shall also be present and it shall contain one Slice
    /// Differentiator value within the range of SD  (if the sdRanges attribute
    /// is present) or with any value (if the wildcardSd attribute is
    /// present).\n",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/SnssaiExtension"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ExtSnssai {
        ///3-octet string, representing the Slice Differentiator, in
        /// hexadecimal representation. Each character in the string shall take
        /// a value of "0" to "9", "a" to "f" or "A" to "F" and shall represent
        /// 4 bits. The most significant character representing the 4 most
        /// significant bits of the SD shall appear first in the string, and the
        /// character representing the 4 least significant bit of the SD shall
        /// appear last in the string. This is an optional parameter that
        /// complements the Slice/Service type(s) to allow to  differentiate
        /// amongst multiple Network Slices of the same Slice/Service type. This
        /// IE shall be absent if no SD value is associated with the SST.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sd: Option<ExtSnssaiSd>,
        ///Unsigned integer, within the range 0 to 255, representing the
        /// Slice/Service Type.  It indicates the expected Network Slice
        /// behaviour in terms of features and services. Values 0 to 127
        /// correspond to the standardized SST range. Values 128 to 255
        /// correspond  to the Operator-specific range. See clause 28.4.2 of
        /// 3GPP TS 23.003. Standardized values are defined in clause 5.15.2.2
        /// of 3GPP TS 23.501.
        pub sst: u8,
    }

    impl From<&ExtSnssai> for ExtSnssai {
        fn from(value: &ExtSnssai) -> Self {
            value.clone()
        }
    }

    ///3-octet string, representing the Slice Differentiator, in hexadecimal
    /// representation. Each character in the string shall take a value of "0"
    /// to "9", "a" to "f" or "A" to "F" and shall represent 4 bits. The most
    /// significant character representing the 4 most significant bits of the SD
    /// shall appear first in the string, and the character representing the 4
    /// least significant bit of the SD shall appear last in the string. This is
    /// an optional parameter that complements the Slice/Service type(s) to
    /// allow to  differentiate amongst multiple Network Slices of the same
    /// Slice/Service type. This IE shall be absent if no SD value is associated
    /// with the SST.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "3-octet string, representing the Slice Differentiator,
    /// in hexadecimal representation. Each character in the string shall take a
    /// value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall
    /// represent 4 bits. The most significant character representing the 4 most
    /// significant bits of the SD shall appear first in the string, and the
    /// character representing the 4 least significant bit of the SD shall
    /// appear last in the string. This is an optional parameter that
    /// complements the Slice/Service type(s) to allow to  differentiate amongst
    /// multiple Network Slices of the same Slice/Service type. This IE shall be
    /// absent if no SD value is associated with the SST.\n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{6}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ExtSnssaiSd(String);
    impl ::std::ops::Deref for ExtSnssaiSd {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ExtSnssaiSd> for String {
        fn from(value: ExtSnssaiSd) -> Self {
            value.0
        }
    }

    impl From<&ExtSnssaiSd> for ExtSnssaiSd {
        fn from(value: &ExtSnssaiSd) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ExtSnssaiSd {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{6}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{6}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ExtSnssaiSd {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ExtSnssaiSd {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ExtSnssaiSd {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ExtSnssaiSd {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Contains the external client identification
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the external client identification",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct ExternalClientIdentification(pub String);
    impl ::std::ops::Deref for ExternalClientIdentification {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ExternalClientIdentification> for String {
        fn from(value: ExternalClientIdentification) -> Self {
            value.0
        }
    }

    impl From<&ExternalClientIdentification> for ExternalClientIdentification {
        fn from(value: &ExternalClientIdentification) -> Self {
            value.clone()
        }
    }

    impl From<String> for ExternalClientIdentification {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for ExternalClientIdentification {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for ExternalClientIdentification {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Indicates types of External Clients.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates types of External Clients.",
    ///  "type": "string",
    ///  "enum": [
    ///    "EMERGENCY_SERVICES",
    ///    "VALUE_ADDED_SERVICES",
    ///    "PLMN_OPERATOR_SERVICES",
    ///    "LAWFUL_INTERCEPT_SERVICES",
    ///    "PLMN_OPERATOR_BROADCAST_SERVICES",
    ///    "PLMN_OPERATOR_OM",
    ///    "PLMN_OPERATOR_ANONYMOUS_STATISTICS",
    ///    "PLMN_OPERATOR_TARGET_MS_SERVICE_SUPPORT"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ExternalClientType {
        #[serde(rename = "EMERGENCY_SERVICES")]
        EmergencyServices,
        #[serde(rename = "VALUE_ADDED_SERVICES")]
        ValueAddedServices,
        #[serde(rename = "PLMN_OPERATOR_SERVICES")]
        PlmnOperatorServices,
        #[serde(rename = "LAWFUL_INTERCEPT_SERVICES")]
        LawfulInterceptServices,
        #[serde(rename = "PLMN_OPERATOR_BROADCAST_SERVICES")]
        PlmnOperatorBroadcastServices,
        #[serde(rename = "PLMN_OPERATOR_OM")]
        PlmnOperatorOm,
        #[serde(rename = "PLMN_OPERATOR_ANONYMOUS_STATISTICS")]
        PlmnOperatorAnonymousStatistics,
        #[serde(rename = "PLMN_OPERATOR_TARGET_MS_SERVICE_SUPPORT")]
        PlmnOperatorTargetMsServiceSupport,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&ExternalClientType> for ExternalClientType {
        fn from(value: &ExternalClientType) -> Self {
            value.clone()
        }
    }

    impl ToString for ExternalClientType {
        fn to_string(&self) -> String {
            match *self {
                Self::EmergencyServices => "EMERGENCY_SERVICES".to_string(),
                Self::ValueAddedServices => "VALUE_ADDED_SERVICES".to_string(),
                Self::PlmnOperatorServices => "PLMN_OPERATOR_SERVICES".to_string(),
                Self::LawfulInterceptServices => "LAWFUL_INTERCEPT_SERVICES".to_string(),
                Self::PlmnOperatorBroadcastServices => {
                    "PLMN_OPERATOR_BROADCAST_SERVICES".to_string()
                }
                Self::PlmnOperatorOm => "PLMN_OPERATOR_OM".to_string(),
                Self::PlmnOperatorAnonymousStatistics => {
                    "PLMN_OPERATOR_ANONYMOUS_STATISTICS".to_string()
                }
                Self::PlmnOperatorTargetMsServiceSupport => {
                    "PLMN_OPERATOR_TARGET_MS_SERVICE_SUPPORT".to_string()
                }
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for ExternalClientType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EMERGENCY_SERVICES" => Ok(Self::EmergencyServices),
                "VALUE_ADDED_SERVICES" => Ok(Self::ValueAddedServices),
                "PLMN_OPERATOR_SERVICES" => Ok(Self::PlmnOperatorServices),
                "LAWFUL_INTERCEPT_SERVICES" => Ok(Self::LawfulInterceptServices),
                "PLMN_OPERATOR_BROADCAST_SERVICES" => Ok(Self::PlmnOperatorBroadcastServices),
                "PLMN_OPERATOR_OM" => Ok(Self::PlmnOperatorOm),
                "PLMN_OPERATOR_ANONYMOUS_STATISTICS" => Ok(Self::PlmnOperatorAnonymousStatistics),
                "PLMN_OPERATOR_TARGET_MS_SERVICE_SUPPORT" => {
                    Ok(Self::PlmnOperatorTargetMsServiceSupport)
                }
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ExternalClientType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ExternalClientType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ExternalClientType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Contains information on the event for which the subscription is not
    /// successful.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains information on the event for which the
    /// subscription is not successful.",
    ///  "type": "object",
    ///  "required": [
    ///    "event",
    ///    "failureCode"
    ///  ],
    ///  "properties": {
    ///    "event": {
    ///      "$ref": "#/components/schemas/NwdafEvent"
    ///    },
    ///    "failureCode": {
    ///      "$ref": "#/components/schemas/NwdafFailureCode"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct FailureEventInfo {
        pub event: NwdafEvent,
        #[serde(rename = "failureCode")]
        pub failure_code: NwdafFailureCode,
    }

    impl From<&FailureEventInfo> for FailureEventInfo {
        fn from(value: &FailureEventInfo) -> Self {
            value.clone()
        }
    }

    ///Specifies the positioning fix type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Specifies the positioning fix type.",
    ///  "type": "string",
    ///  "enum": [
    ///    "CARRIER_PHASE_FLOAT",
    ///    "CARRIER_PHASE_FIX"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum FixType {
        #[serde(rename = "CARRIER_PHASE_FLOAT")]
        CarrierPhaseFloat,
        #[serde(rename = "CARRIER_PHASE_FIX")]
        CarrierPhaseFix,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&FixType> for FixType {
        fn from(value: &FixType) -> Self {
            value.clone()
        }
    }

    impl ToString for FixType {
        fn to_string(&self) -> String {
            match *self {
                Self::CarrierPhaseFloat => "CARRIER_PHASE_FLOAT".to_string(),
                Self::CarrierPhaseFix => "CARRIER_PHASE_FIX".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for FixType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "CARRIER_PHASE_FLOAT" => Ok(Self::CarrierPhaseFloat),
                "CARRIER_PHASE_FIX" => Ok(Self::CarrierPhaseFix),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for FixType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for FixType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for FixType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Float
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "string with format 'float' as defined in OpenAPI.",
    ///  "type": "number",
    ///  "format": "float"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Float(pub f32);
    impl ::std::ops::Deref for Float {
        type Target = f32;
        fn deref(&self) -> &f32 {
            &self.0
        }
    }

    impl From<Float> for f32 {
        fn from(value: Float) -> Self {
            value.0
        }
    }

    impl From<&Float> for Float {
        fn from(value: &Float) -> Self {
            value.clone()
        }
    }

    impl From<f32> for Float {
        fn from(value: f32) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for Float {
        type Err = <f32 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for Float {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Float {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Float {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for Float {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Defines a packet filter of an IP flow.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Defines a packet filter of an IP flow.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct FlowDescription(pub String);
    impl ::std::ops::Deref for FlowDescription {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<FlowDescription> for String {
        fn from(value: FlowDescription) -> Self {
            value.0
        }
    }

    impl From<&FlowDescription> for FlowDescription {
        fn from(value: &FlowDescription) -> Self {
            value.clone()
        }
    }

    impl From<String> for FlowDescription {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for FlowDescription {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for FlowDescription {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Possible values are
    /// - DOWNLINK: The corresponding filter applies for traffic to the UE.
    /// - UPLINK: The corresponding filter applies for traffic from the UE.
    /// - BIDIRECTIONAL: The corresponding filter applies for traffic both to
    ///   and from the UE.
    /// - UNSPECIFIED: The corresponding filter applies for traffic to the UE
    ///   (downlink), but has no specific direction declared. The service data
    ///   flow detection shall apply the filter for uplink traffic as if the
    ///   filter was bidirectional. The PCF shall not use the value UNSPECIFIED
    ///   in filters created by the network in NW-initiated procedures. The PCF
    ///   shall only include the value UNSPECIFIED in filters in UE-initiated
    ///   procedures if the same value is received from the SMF.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are\n- DOWNLINK: The corresponding
    /// filter applies for traffic to the UE.\n- UPLINK: The corresponding
    /// filter applies for traffic from the UE.\n- BIDIRECTIONAL: The
    /// corresponding filter applies for traffic both to and from the UE.\n-
    /// UNSPECIFIED: The corresponding filter applies for traffic to the UE
    /// (downlink), but has no specific direction declared. The service data
    /// flow detection shall apply the filter for uplink traffic as if the
    /// filter was bidirectional. The PCF shall not use the value UNSPECIFIED in
    /// filters created by the network in NW-initiated procedures. The PCF shall
    /// only include the value UNSPECIFIED in filters in UE-initiated procedures
    /// if the same value is received from the SMF.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "DOWNLINK",
    ///    "UPLINK",
    ///    "BIDIRECTIONAL",
    ///    "UNSPECIFIED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum FlowDirection {
        #[serde(rename = "DOWNLINK")]
        Downlink,
        #[serde(rename = "UPLINK")]
        Uplink,
        #[serde(rename = "BIDIRECTIONAL")]
        Bidirectional,
        #[serde(rename = "UNSPECIFIED")]
        Unspecified,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&FlowDirection> for FlowDirection {
        fn from(value: &FlowDirection) -> Self {
            value.clone()
        }
    }

    impl ToString for FlowDirection {
        fn to_string(&self) -> String {
            match *self {
                Self::Downlink => "DOWNLINK".to_string(),
                Self::Uplink => "UPLINK".to_string(),
                Self::Bidirectional => "BIDIRECTIONAL".to_string(),
                Self::Unspecified => "UNSPECIFIED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for FlowDirection {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DOWNLINK" => Ok(Self::Downlink),
                "UPLINK" => Ok(Self::Uplink),
                "BIDIRECTIONAL" => Ok(Self::Bidirectional),
                "UNSPECIFIED" => Ok(Self::Unspecified),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for FlowDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for FlowDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for FlowDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents IP flow information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents IP flow information.",
    ///  "type": "object",
    ///  "required": [
    ///    "flowId"
    ///  ],
    ///  "properties": {
    ///    "flowDescriptions": {
    ///      "description": "Indicates the packet filters of the IP flow. Refer
    /// to clause 5.3.8 of 3GPP TS 29.214 for encoding. It shall contain UL
    /// and/or DL IP flow description.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      },
    ///      "maxItems": 2,
    ///      "minItems": 1
    ///    },
    ///    "flowId": {
    ///      "description": "Indicates the IP flow identifier.",
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct FlowInfo {
        ///Indicates the packet filters of the IP flow. Refer to clause 5.3.8
        /// of 3GPP TS 29.214 for encoding. It shall contain UL and/or DL IP
        /// flow description.
        #[serde(
            rename = "flowDescriptions",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub flow_descriptions: Vec<String>,
        ///Indicates the IP flow identifier.
        #[serde(rename = "flowId")]
        pub flow_id: i64,
    }

    impl From<&FlowInfo> for FlowInfo {
        fn from(value: &FlowInfo) -> Self {
            value.clone()
        }
    }

    ///Fully Qualified Domain Name
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Fully Qualified Domain Name",
    ///  "type": "string",
    ///  "maxLength": 253,
    ///  "minLength": 4,
    ///  "pattern":
    /// "^([0-9A-Za-z]([-0-9A-Za-z]{0,61}[0-9A-Za-z])?\\.)+[A-Za-z]{2,63}\\.?$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct Fqdn(String);
    impl ::std::ops::Deref for Fqdn {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Fqdn> for String {
        fn from(value: Fqdn) -> Self {
            value.0
        }
    }

    impl From<&Fqdn> for Fqdn {
        fn from(value: &Fqdn) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Fqdn {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 253usize {
                return Err("longer than 253 characters".into());
            }
            if value.len() < 4usize {
                return Err("shorter than 4 characters".into());
            }
            if regress::Regex::new(
                "^([0-9A-Za-z]([-0-9A-Za-z]{0,61}[0-9A-Za-z])?\\.)+[A-Za-z]{2,63}\\.?$",
            )
            .unwrap()
            .find(value)
            .is_none()
            {
                return Err ("doesn't match pattern \"^([0-9A-Za-z]([-0-9A-Za-z]{0,61}[0-9A-Za-z])?\\.)+[A-Za-z]{2,63}\\.?$\"" . into ()) ;
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Fqdn {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for Fqdn {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for Fqdn {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Fqdn {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Provides the G-NB identifier.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Provides the G-NB identifier.",
    ///  "type": "object",
    ///  "required": [
    ///    "bitLength",
    ///    "gNBValue"
    ///  ],
    ///  "properties": {
    ///    "bitLength": {
    ///      "description": "Unsigned integer representing the bit length of the
    /// gNB ID as defined in clause 9.3.1.6 of 3GPP TS 38.413 [11], within the
    /// range 22 to 32.\n",
    ///      "type": "integer",
    ///      "maximum": 32.0,
    ///      "minimum": 22.0
    ///    },
    ///    "gNBValue": {
    ///      "description": "This represents the identifier of the gNB. The
    /// value of the gNB ID shall be encoded in hexadecimal representation. Each
    /// character in the string shall take a value of \"0\" to \"9\", \"a\" to
    /// \"f\" or \"A\" to \"F\" and shall represent 4 bits. The padding 0 shall
    /// be added to make multiple nibbles,  the most significant character
    /// representing the padding 0 if required together with the 4 most
    /// significant bits of the gNB ID shall appear first in the string, and the
    /// character representing the 4 least significant bit of the gNB ID shall
    /// appear last in the string.\n",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]{6,8}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GNbId {
        ///Unsigned integer representing the bit length of the gNB ID as
        /// defined in clause 9.3.1.6 of 3GPP TS 38.413 [11], within the range
        /// 22 to 32.
        #[serde(rename = "bitLength")]
        pub bit_length: i64,
        ///This represents the identifier of the gNB. The value of the gNB ID
        /// shall be encoded in hexadecimal representation. Each character in
        /// the string shall take a value of "0" to "9", "a" to "f" or "A" to
        /// "F" and shall represent 4 bits. The padding 0 shall be added to make
        /// multiple nibbles,  the most significant character representing the
        /// padding 0 if required together with the 4 most significant bits of
        /// the gNB ID shall appear first in the string, and the character
        /// representing the 4 least significant bit of the gNB ID shall appear
        /// last in the string.
        #[serde(rename = "gNBValue")]
        pub g_nb_value: GNbIdGNbValue,
    }

    impl From<&GNbId> for GNbId {
        fn from(value: &GNbId) -> Self {
            value.clone()
        }
    }

    ///This represents the identifier of the gNB. The value of the gNB ID shall
    /// be encoded in hexadecimal representation. Each character in the string
    /// shall take a value of "0" to "9", "a" to "f" or "A" to "F" and shall
    /// represent 4 bits. The padding 0 shall be added to make multiple nibbles,
    /// the most significant character representing the padding 0 if required
    /// together with the 4 most significant bits of the gNB ID shall appear
    /// first in the string, and the character representing the 4 least
    /// significant bit of the gNB ID shall appear last in the string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This represents the identifier of the gNB. The value of
    /// the gNB ID shall be encoded in hexadecimal representation. Each
    /// character in the string shall take a value of \"0\" to \"9\", \"a\" to
    /// \"f\" or \"A\" to \"F\" and shall represent 4 bits. The padding 0 shall
    /// be added to make multiple nibbles,  the most significant character
    /// representing the padding 0 if required together with the 4 most
    /// significant bits of the gNB ID shall appear first in the string, and the
    /// character representing the 4 least significant bit of the gNB ID shall
    /// appear last in the string.\n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{6,8}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GNbIdGNbValue(String);
    impl ::std::ops::Deref for GNbIdGNbValue {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<GNbIdGNbValue> for String {
        fn from(value: GNbIdGNbValue) -> Self {
            value.0
        }
    }

    impl From<&GNbIdGNbValue> for GNbIdGNbValue {
        fn from(value: &GNbIdGNbValue) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for GNbIdGNbValue {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{6,8}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{6,8}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for GNbIdGNbValue {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for GNbIdGNbValue {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for GNbIdGNbValue {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for GNbIdGNbValue {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Common base type for GAD shapes.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Common base type for GAD shapes.",
    ///  "type": "object",
    ///  "required": [
    ///    "shape"
    ///  ],
    ///  "properties": {
    ///    "shape": {
    ///      "$ref": "#/components/schemas/SupportedGADShapes"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GadShape {
        pub shape: SupportedGadShapes,
    }

    impl From<&GadShape> for GadShape {
        fn from(value: &GadShape) -> Self {
            value.clone()
        }
    }

    ///Global Cable Identifier uniquely identifying the connection between the
    /// 5G-CRG or FN-CRG to the 5GS. See clause 28.15.4 of 3GPP TS 23.003. This
    /// shall be encoded as a string per clause 28.15.4 of 3GPP TS 23.003, and
    /// compliant with the syntax specified  in clause 2.2  of IETF RFC 7542 for
    /// the username part of a NAI. The GCI value is specified in CableLabs
    /// WR-TR-5WWC-ARCH.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Global Cable Identifier uniquely identifying the
    /// connection between the 5G-CRG or FN-CRG to the 5GS. See clause 28.15.4
    /// of 3GPP TS 23.003. This shall be encoded as a string per clause 28.15.4
    /// of 3GPP TS 23.003, and compliant with the syntax specified  in clause
    /// 2.2  of IETF RFC 7542 for the username part of a NAI. The GCI value is
    /// specified in CableLabs WR-TR-5WWC-ARCH.\n",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct Gci(pub String);
    impl ::std::ops::Deref for Gci {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Gci> for String {
        fn from(value: Gci) -> Self {
            value.0
        }
    }

    impl From<&Gci> for Gci {
        fn from(value: &Gci) -> Self {
            value.clone()
        }
    }

    impl From<String> for Gci {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for Gci {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for Gci {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Geographic area specified by different shape.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Geographic area specified by different shape.",
    ///  "anyOf": [
    ///    {
    ///      "$ref": "#/components/schemas/Point"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PointUncertaintyCircle"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PointUncertaintyEllipse"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/Polygon"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PointAltitude"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/PointAltitudeUncertainty"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/EllipsoidArc"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GeographicArea {
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        pub subtype_0: Option<Point>,
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        pub subtype_1: Option<PointUncertaintyCircle>,
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        pub subtype_2: Option<PointUncertaintyEllipse>,
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        pub subtype_3: Option<Polygon>,
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        pub subtype_4: Option<PointAltitude>,
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        pub subtype_5: Option<PointAltitudeUncertainty>,
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        pub subtype_6: Option<EllipsoidArc>,
    }

    impl From<&GeographicArea> for GeographicArea {
        fn from(value: &GeographicArea) -> Self {
            value.clone()
        }
    }

    ///Geographical coordinates.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Geographical coordinates.",
    ///  "type": "object",
    ///  "required": [
    ///    "lat",
    ///    "lon"
    ///  ],
    ///  "properties": {
    ///    "lat": {
    ///      "type": "number",
    ///      "format": "double",
    ///      "maximum": 90.0,
    ///      "minimum": -90.0
    ///    },
    ///    "lon": {
    ///      "type": "number",
    ///      "format": "double",
    ///      "maximum": 180.0,
    ///      "minimum": -180.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GeographicalCoordinates {
        pub lat: f64,
        pub lon: f64,
    }

    impl From<&GeographicalCoordinates> for GeographicalCoordinates {
        fn from(value: &GeographicalCoordinates) -> Self {
            value.clone()
        }
    }

    ///Exactly one of cgi, sai or lai shall be present.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Exactly one of cgi, sai or lai shall be present.",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "required": [
    ///        "cgi"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "sai"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "lai"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "ageOfLocationInformation": {
    ///      "description": "The value represents the elapsed time in minutes since the last network contact of the mobile station. Value \"0\" indicates that the location information was obtained after a successful paging procedure for  Active Location Retrieval when the UE is in idle mode or after a successful location reporting procedure the UE is in connected mode. Any other value than \"0\" indicates that the location information is the last known one. See 3GPP TS 29.002 clause 17.7.8.\n",
    ///      "type": "integer",
    ///      "maximum": 32767.0,
    ///      "minimum": 0.0
    ///    },
    ///    "cgi": {
    ///      "$ref": "#/components/schemas/CellGlobalId"
    ///    },
    ///    "geodeticInformation": {
    ///      "description": "Refers to Calling Geodetic Location.See ITU-T
    /// Recommendation Q.763 (1999) clause 3.88.2.  Only the description of an
    /// ellipsoid point with uncertainty circle is allowed to be used.\n",
    ///      "type": "string",
    ///      "pattern": "^[0-9A-F]{20}$"
    ///    },
    ///    "geographicalInformation": {
    ///      "description": "Refer to geographical Information.See 3GPP TS
    /// 23.032 clause 7.3.2. Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.\n",
    ///      "type": "string",
    ///      "pattern": "^[0-9A-F]{16}$"
    ///    },
    ///    "lai": {
    ///      "$ref": "#/components/schemas/LocationAreaId"
    ///    },
    ///    "locationNumber": {
    ///      "description": "Location number within the PLMN. See 3GPP TS
    /// 23.003, clause 4.5.",
    ///      "type": "string"
    ///    },
    ///    "mscNumber": {
    ///      "description": "MSC number. See 3GPP TS 23.003 clause 5.1.",
    ///      "type": "string"
    ///    },
    ///    "rai": {
    ///      "$ref": "#/components/schemas/RoutingAreaId"
    ///    },
    ///    "sai": {
    ///      "$ref": "#/components/schemas/ServiceAreaId"
    ///    },
    ///    "ueLocationTimestamp": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "vlrNumber": {
    ///      "description": "VLR number. See 3GPP TS 23.003 clause 5.1.",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum GeraLocation {
        Variant0 {
            ///The value represents the elapsed time in minutes since the last
            /// network contact of the mobile station. Value "0" indicates that
            /// the location information was obtained after a successful paging
            /// procedure for  Active Location Retrieval when the UE is in idle
            /// mode or after a successful location reporting procedure the UE
            /// is in connected mode. Any other value than "0" indicates that
            /// the location information is the last known one. See 3GPP TS
            /// 29.002 clause 17.7.8.
            #[serde(
                rename = "ageOfLocationInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            age_of_location_information: Option<i64>,
            cgi: CellGlobalId,
            ///Refers to Calling Geodetic Location.See ITU-T Recommendation
            /// Q.763 (1999) clause 3.88.2.  Only the description of an
            /// ellipsoid point with uncertainty circle is allowed to be used.
            #[serde(
                rename = "geodeticInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            geodetic_information: Option<GeraLocationVariant0GeodeticInformation>,
            ///Refer to geographical Information.See 3GPP TS 23.032 clause
            /// 7.3.2. Only the description of an ellipsoid point with
            /// uncertainty circle is allowed to be used.
            #[serde(
                rename = "geographicalInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            geographical_information: Option<GeraLocationVariant0GeographicalInformation>,
            ///Location number within the PLMN. See 3GPP TS 23.003, clause 4.5.
            #[serde(
                rename = "locationNumber",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            location_number: Option<String>,
            ///MSC number. See 3GPP TS 23.003 clause 5.1.
            #[serde(rename = "mscNumber", default, skip_serializing_if = "Option::is_none")]
            msc_number: Option<String>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            rai: Option<RoutingAreaId>,
            #[serde(
                rename = "ueLocationTimestamp",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            ue_location_timestamp: Option<DateTime>,
            ///VLR number. See 3GPP TS 23.003 clause 5.1.
            #[serde(rename = "vlrNumber", default, skip_serializing_if = "Option::is_none")]
            vlr_number: Option<String>,
        },
        Variant1 {
            ///The value represents the elapsed time in minutes since the last
            /// network contact of the mobile station. Value "0" indicates that
            /// the location information was obtained after a successful paging
            /// procedure for  Active Location Retrieval when the UE is in idle
            /// mode or after a successful location reporting procedure the UE
            /// is in connected mode. Any other value than "0" indicates that
            /// the location information is the last known one. See 3GPP TS
            /// 29.002 clause 17.7.8.
            #[serde(
                rename = "ageOfLocationInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            age_of_location_information: Option<i64>,
            ///Refers to Calling Geodetic Location.See ITU-T Recommendation
            /// Q.763 (1999) clause 3.88.2.  Only the description of an
            /// ellipsoid point with uncertainty circle is allowed to be used.
            #[serde(
                rename = "geodeticInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            geodetic_information: Option<GeraLocationVariant1GeodeticInformation>,
            ///Refer to geographical Information.See 3GPP TS 23.032 clause
            /// 7.3.2. Only the description of an ellipsoid point with
            /// uncertainty circle is allowed to be used.
            #[serde(
                rename = "geographicalInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            geographical_information: Option<GeraLocationVariant1GeographicalInformation>,
            ///Location number within the PLMN. See 3GPP TS 23.003, clause 4.5.
            #[serde(
                rename = "locationNumber",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            location_number: Option<String>,
            ///MSC number. See 3GPP TS 23.003 clause 5.1.
            #[serde(rename = "mscNumber", default, skip_serializing_if = "Option::is_none")]
            msc_number: Option<String>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            rai: Option<RoutingAreaId>,
            sai: ServiceAreaId,
            #[serde(
                rename = "ueLocationTimestamp",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            ue_location_timestamp: Option<DateTime>,
            ///VLR number. See 3GPP TS 23.003 clause 5.1.
            #[serde(rename = "vlrNumber", default, skip_serializing_if = "Option::is_none")]
            vlr_number: Option<String>,
        },
        Variant2 {
            ///The value represents the elapsed time in minutes since the last
            /// network contact of the mobile station. Value "0" indicates that
            /// the location information was obtained after a successful paging
            /// procedure for  Active Location Retrieval when the UE is in idle
            /// mode or after a successful location reporting procedure the UE
            /// is in connected mode. Any other value than "0" indicates that
            /// the location information is the last known one. See 3GPP TS
            /// 29.002 clause 17.7.8.
            #[serde(
                rename = "ageOfLocationInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            age_of_location_information: Option<i64>,
            ///Refers to Calling Geodetic Location.See ITU-T Recommendation
            /// Q.763 (1999) clause 3.88.2.  Only the description of an
            /// ellipsoid point with uncertainty circle is allowed to be used.
            #[serde(
                rename = "geodeticInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            geodetic_information: Option<GeraLocationVariant2GeodeticInformation>,
            ///Refer to geographical Information.See 3GPP TS 23.032 clause
            /// 7.3.2. Only the description of an ellipsoid point with
            /// uncertainty circle is allowed to be used.
            #[serde(
                rename = "geographicalInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            geographical_information: Option<GeraLocationVariant2GeographicalInformation>,
            lai: LocationAreaId,
            ///Location number within the PLMN. See 3GPP TS 23.003, clause 4.5.
            #[serde(
                rename = "locationNumber",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            location_number: Option<String>,
            ///MSC number. See 3GPP TS 23.003 clause 5.1.
            #[serde(rename = "mscNumber", default, skip_serializing_if = "Option::is_none")]
            msc_number: Option<String>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            rai: Option<RoutingAreaId>,
            #[serde(
                rename = "ueLocationTimestamp",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            ue_location_timestamp: Option<DateTime>,
            ///VLR number. See 3GPP TS 23.003 clause 5.1.
            #[serde(rename = "vlrNumber", default, skip_serializing_if = "Option::is_none")]
            vlr_number: Option<String>,
        },
    }

    impl From<&GeraLocation> for GeraLocation {
        fn from(value: &GeraLocation) -> Self {
            value.clone()
        }
    }

    ///Refers to Calling Geodetic Location.See ITU-T Recommendation Q.763
    /// (1999) clause 3.88.2.  Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refers to Calling Geodetic Location.See ITU-T
    /// Recommendation Q.763 (1999) clause 3.88.2.  Only the description of an
    /// ellipsoid point with uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{20}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GeraLocationVariant0GeodeticInformation(String);
    impl ::std::ops::Deref for GeraLocationVariant0GeodeticInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<GeraLocationVariant0GeodeticInformation> for String {
        fn from(value: GeraLocationVariant0GeodeticInformation) -> Self {
            value.0
        }
    }

    impl From<&GeraLocationVariant0GeodeticInformation> for GeraLocationVariant0GeodeticInformation {
        fn from(value: &GeraLocationVariant0GeodeticInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for GeraLocationVariant0GeodeticInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{20}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for GeraLocationVariant0GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for GeraLocationVariant0GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for GeraLocationVariant0GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for GeraLocationVariant0GeodeticInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Refer to geographical Information.See 3GPP TS 23.032 clause 7.3.2. Only
    /// the description of an ellipsoid point with uncertainty circle is allowed
    /// to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refer to geographical Information.See 3GPP TS 23.032
    /// clause 7.3.2. Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{16}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GeraLocationVariant0GeographicalInformation(String);
    impl ::std::ops::Deref for GeraLocationVariant0GeographicalInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<GeraLocationVariant0GeographicalInformation> for String {
        fn from(value: GeraLocationVariant0GeographicalInformation) -> Self {
            value.0
        }
    }

    impl From<&GeraLocationVariant0GeographicalInformation>
        for GeraLocationVariant0GeographicalInformation
    {
        fn from(value: &GeraLocationVariant0GeographicalInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for GeraLocationVariant0GeographicalInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{16}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for GeraLocationVariant0GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for GeraLocationVariant0GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for GeraLocationVariant0GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for GeraLocationVariant0GeographicalInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Refers to Calling Geodetic Location.See ITU-T Recommendation Q.763
    /// (1999) clause 3.88.2.  Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refers to Calling Geodetic Location.See ITU-T
    /// Recommendation Q.763 (1999) clause 3.88.2.  Only the description of an
    /// ellipsoid point with uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{20}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GeraLocationVariant1GeodeticInformation(String);
    impl ::std::ops::Deref for GeraLocationVariant1GeodeticInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<GeraLocationVariant1GeodeticInformation> for String {
        fn from(value: GeraLocationVariant1GeodeticInformation) -> Self {
            value.0
        }
    }

    impl From<&GeraLocationVariant1GeodeticInformation> for GeraLocationVariant1GeodeticInformation {
        fn from(value: &GeraLocationVariant1GeodeticInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for GeraLocationVariant1GeodeticInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{20}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for GeraLocationVariant1GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for GeraLocationVariant1GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for GeraLocationVariant1GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for GeraLocationVariant1GeodeticInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Refer to geographical Information.See 3GPP TS 23.032 clause 7.3.2. Only
    /// the description of an ellipsoid point with uncertainty circle is allowed
    /// to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refer to geographical Information.See 3GPP TS 23.032
    /// clause 7.3.2. Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{16}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GeraLocationVariant1GeographicalInformation(String);
    impl ::std::ops::Deref for GeraLocationVariant1GeographicalInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<GeraLocationVariant1GeographicalInformation> for String {
        fn from(value: GeraLocationVariant1GeographicalInformation) -> Self {
            value.0
        }
    }

    impl From<&GeraLocationVariant1GeographicalInformation>
        for GeraLocationVariant1GeographicalInformation
    {
        fn from(value: &GeraLocationVariant1GeographicalInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for GeraLocationVariant1GeographicalInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{16}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for GeraLocationVariant1GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for GeraLocationVariant1GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for GeraLocationVariant1GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for GeraLocationVariant1GeographicalInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Refers to Calling Geodetic Location.See ITU-T Recommendation Q.763
    /// (1999) clause 3.88.2.  Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refers to Calling Geodetic Location.See ITU-T
    /// Recommendation Q.763 (1999) clause 3.88.2.  Only the description of an
    /// ellipsoid point with uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{20}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GeraLocationVariant2GeodeticInformation(String);
    impl ::std::ops::Deref for GeraLocationVariant2GeodeticInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<GeraLocationVariant2GeodeticInformation> for String {
        fn from(value: GeraLocationVariant2GeodeticInformation) -> Self {
            value.0
        }
    }

    impl From<&GeraLocationVariant2GeodeticInformation> for GeraLocationVariant2GeodeticInformation {
        fn from(value: &GeraLocationVariant2GeodeticInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for GeraLocationVariant2GeodeticInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{20}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for GeraLocationVariant2GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for GeraLocationVariant2GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for GeraLocationVariant2GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for GeraLocationVariant2GeodeticInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Refer to geographical Information.See 3GPP TS 23.032 clause 7.3.2. Only
    /// the description of an ellipsoid point with uncertainty circle is allowed
    /// to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refer to geographical Information.See 3GPP TS 23.032
    /// clause 7.3.2. Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{16}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GeraLocationVariant2GeographicalInformation(String);
    impl ::std::ops::Deref for GeraLocationVariant2GeographicalInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<GeraLocationVariant2GeographicalInformation> for String {
        fn from(value: GeraLocationVariant2GeographicalInformation) -> Self {
            value.0
        }
    }

    impl From<&GeraLocationVariant2GeographicalInformation>
        for GeraLocationVariant2GeographicalInformation
    {
        fn from(value: &GeraLocationVariant2GeographicalInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for GeraLocationVariant2GeographicalInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{16}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for GeraLocationVariant2GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for GeraLocationVariant2GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for GeraLocationVariant2GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for GeraLocationVariant2GeographicalInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///One of the six attributes n3IwfId, gNbIdm, ngeNbId, wagfId, tngfId,
    /// eNbId shall be present.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "One of the six attributes n3IwfId, gNbIdm, ngeNbId,
    /// wagfId, tngfId, eNbId shall be present.\n",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "required": [
    ///        "n3IwfId"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "gNbId"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "ngeNbId"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "wagfId"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "tngfId"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "eNbId"
    ///      ]
    ///    }
    ///  ],
    ///  "required": [
    ///    "plmnId"
    ///  ],
    ///  "properties": {
    ///    "eNbId": {
    ///      "$ref": "#/components/schemas/ENbId"
    ///    },
    ///    "gNbId": {
    ///      "$ref": "#/components/schemas/GNbId"
    ///    },
    ///    "n3IwfId": {
    ///      "$ref": "#/components/schemas/N3IwfId"
    ///    },
    ///    "ngeNbId": {
    ///      "$ref": "#/components/schemas/NgeNbId"
    ///    },
    ///    "nid": {
    ///      "$ref": "#/components/schemas/Nid"
    ///    },
    ///    "plmnId": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    },
    ///    "tngfId": {
    ///      "$ref": "#/components/schemas/TngfId"
    ///    },
    ///    "wagfId": {
    ///      "$ref": "#/components/schemas/WAgfId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum GlobalRanNodeId {
        Variant0 {
            #[serde(rename = "n3IwfId")]
            n3_iwf_id: N3IwfId,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            nid: Option<Nid>,
            #[serde(rename = "plmnId")]
            plmn_id: PlmnId,
        },
        Variant1 {
            #[serde(rename = "gNbId")]
            g_nb_id: GNbId,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            nid: Option<Nid>,
            #[serde(rename = "plmnId")]
            plmn_id: PlmnId,
        },
        Variant2 {
            #[serde(rename = "ngeNbId")]
            nge_nb_id: NgeNbId,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            nid: Option<Nid>,
            #[serde(rename = "plmnId")]
            plmn_id: PlmnId,
        },
        Variant3 {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            nid: Option<Nid>,
            #[serde(rename = "plmnId")]
            plmn_id: PlmnId,
            #[serde(rename = "wagfId")]
            wagf_id: WAgfId,
        },
        Variant4 {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            nid: Option<Nid>,
            #[serde(rename = "plmnId")]
            plmn_id: PlmnId,
            #[serde(rename = "tngfId")]
            tngf_id: TngfId,
        },
        Variant5 {
            #[serde(rename = "eNbId")]
            e_nb_id: ENbId,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            nid: Option<Nid>,
            #[serde(rename = "plmnId")]
            plmn_id: PlmnId,
        },
    }

    impl From<&GlobalRanNodeId> for GlobalRanNodeId {
        fn from(value: &GlobalRanNodeId) -> Self {
            value.clone()
        }
    }

    ///Global Navigation Satellite System (GNSS) ID.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Global Navigation Satellite System (GNSS) ID.",
    ///  "type": "string",
    ///  "enum": [
    ///    "GPS",
    ///    "GALILEO",
    ///    "SBAS",
    ///    "MODERNIZED_GPS",
    ///    "QZSS",
    ///    "GLONASS",
    ///    "BDS",
    ///    "NAVIC"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum GnssId {
        #[serde(rename = "GPS")]
        Gps,
        #[serde(rename = "GALILEO")]
        Galileo,
        #[serde(rename = "SBAS")]
        Sbas,
        #[serde(rename = "MODERNIZED_GPS")]
        ModernizedGps,
        #[serde(rename = "QZSS")]
        Qzss,
        #[serde(rename = "GLONASS")]
        Glonass,
        #[serde(rename = "BDS")]
        Bds,
        #[serde(rename = "NAVIC")]
        Navic,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&GnssId> for GnssId {
        fn from(value: &GnssId) -> Self {
            value.clone()
        }
    }

    impl ToString for GnssId {
        fn to_string(&self) -> String {
            match *self {
                Self::Gps => "GPS".to_string(),
                Self::Galileo => "GALILEO".to_string(),
                Self::Sbas => "SBAS".to_string(),
                Self::ModernizedGps => "MODERNIZED_GPS".to_string(),
                Self::Qzss => "QZSS".to_string(),
                Self::Glonass => "GLONASS".to_string(),
                Self::Bds => "BDS".to_string(),
                Self::Navic => "NAVIC".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for GnssId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "GPS" => Ok(Self::Gps),
                "GALILEO" => Ok(Self::Galileo),
                "SBAS" => Ok(Self::Sbas),
                "MODERNIZED_GPS" => Ok(Self::ModernizedGps),
                "QZSS" => Ok(Self::Qzss),
                "GLONASS" => Ok(Self::Glonass),
                "BDS" => Ok(Self::Bds),
                "NAVIC" => Ok(Self::Navic),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for GnssId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for GnssId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for GnssId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates the usage of a Global Navigation Satellite System (GNSS)
    /// positioning method.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the usage of a Global Navigation Satellite
    /// System (GNSS) positioning method.",
    ///  "type": "object",
    ///  "required": [
    ///    "gnss",
    ///    "mode",
    ///    "usage"
    ///  ],
    ///  "properties": {
    ///    "gnss": {
    ///      "$ref": "#/components/schemas/GnssId"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/PositioningMode"
    ///    },
    ///    "usage": {
    ///      "$ref": "#/components/schemas/Usage"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct GnssPositioningMethodAndUsage {
        pub gnss: GnssId,
        pub mode: PositioningMode,
        pub usage: Usage,
    }

    impl From<&GnssPositioningMethodAndUsage> for GnssPositioningMethodAndUsage {
        fn from(value: &GnssPositioningMethodAndUsage) -> Self {
            value.clone()
        }
    }

    ///String identifying a Gpsi shall contain either an External Id or an
    /// MSISDN.  It shall be formatted as follows -External Identifier=
    /// "extid-'extid', where 'extid'  shall be formatted according to clause
    /// 19.7.2 of 3GPP TS 23.003 that describes an  External Identifier.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String identifying a Gpsi shall contain either an
    /// External Id or an MSISDN.  It shall be formatted as follows -External
    /// Identifier= \"extid-'extid', where 'extid'  shall be formatted according
    /// to clause 19.7.2 of 3GPP TS 23.003 that describes an  External
    /// Identifier. \n",
    ///  "type": "string",
    ///  "pattern": "^(msisdn-[0-9]{5,15}|extid-[^@]+@[^@]+|.+)$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct Gpsi(String);
    impl ::std::ops::Deref for Gpsi {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Gpsi> for String {
        fn from(value: Gpsi) -> Self {
            value.0
        }
    }

    impl From<&Gpsi> for Gpsi {
        fn from(value: &Gpsi) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Gpsi {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^(msisdn-[0-9]{5,15}|extid-[^@]+@[^@]+|.+)$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err(
                    "doesn't match pattern \"^(msisdn-[0-9]{5,15}|extid-[^@]+@[^@]+|.+)$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Gpsi {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for Gpsi {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for Gpsi {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Gpsi {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///String identifying a group of devices network internal globally unique
    /// ID which identifies a set of IMSIs, as specified in clause 19.9 of 3GPP
    /// TS 23.003.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String identifying a group of devices network internal
    /// globally unique ID which identifies a set of IMSIs, as specified in
    /// clause 19.9 of 3GPP TS 23.003. \n",
    ///  "type": "string",
    ///  "pattern":
    /// "^[A-Fa-f0-9]{8}-[0-9]{3}-[0-9]{2,3}-([A-Fa-f0-9][A-Fa-f0-9]){1,10}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct GroupId(String);
    impl ::std::ops::Deref for GroupId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<GroupId> for String {
        fn from(value: GroupId) -> Self {
            value.0
        }
    }

    impl From<&GroupId> for GroupId {
        fn from(value: &GroupId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for GroupId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new(
                "^[A-Fa-f0-9]{8}-[0-9]{3}-[0-9]{2,3}-([A-Fa-f0-9][A-Fa-f0-9]){1,10}$",
            )
            .unwrap()
            .find(value)
            .is_none()
            {
                return Err ("doesn't match pattern \"^[A-Fa-f0-9]{8}-[0-9]{3}-[0-9]{2,3}-([A-Fa-f0-9][A-Fa-f0-9]){1,10}$\"" . into ()) ;
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for GroupId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for GroupId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for GroupId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for GroupId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Globally Unique AMF Identifier constructed out of PLMN, Network and AMF
    /// identity.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Globally Unique AMF Identifier constructed out of PLMN,
    /// Network and AMF identity.",
    ///  "type": "object",
    ///  "required": [
    ///    "amfId",
    ///    "plmnId"
    ///  ],
    ///  "properties": {
    ///    "amfId": {
    ///      "$ref": "#/components/schemas/AmfId"
    ///    },
    ///    "plmnId": {
    ///      "$ref": "#/components/schemas/PlmnIdNid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Guami {
        #[serde(rename = "amfId")]
        pub amf_id: AmfId,
        #[serde(rename = "plmnId")]
        pub plmn_id: PlmnIdNid,
    }

    impl From<&Guami> for Guami {
        fn from(value: &Guami) -> Self {
            value.clone()
        }
    }

    ///This IE represents the identifier of the HFC node Id as specified in
    /// CableLabs WR-TR-5WWC-ARCH. It is provisioned by the wireline operator as
    /// part of wireline operations and may contain up to six characters.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This IE represents the identifier of the HFC node Id as
    /// specified in CableLabs WR-TR-5WWC-ARCH. It is provisioned by the
    /// wireline operator as part of wireline operations and may contain up to
    /// six characters.\n",
    ///  "type": "string",
    ///  "maxLength": 6
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct HfcNId(String);
    impl ::std::ops::Deref for HfcNId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<HfcNId> for String {
        fn from(value: HfcNId) -> Self {
            value.0
        }
    }

    impl From<&HfcNId> for HfcNId {
        fn from(value: &HfcNId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for HfcNId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 6usize {
                return Err("longer than 6 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for HfcNId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for HfcNId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for HfcNId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for HfcNId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///REpresents the HFC Node Identifer received over NGAP.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "REpresents the HFC Node Identifer received over NGAP.",
    ///  "type": "object",
    ///  "required": [
    ///    "hfcNId"
    ///  ],
    ///  "properties": {
    ///    "hfcNId": {
    ///      "$ref": "#/components/schemas/HfcNId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HfcNodeId {
        #[serde(rename = "hfcNId")]
        pub hfc_n_id: HfcNId,
    }

    impl From<&HfcNodeId> for HfcNodeId {
        fn from(value: &HfcNodeId) -> Self {
            value.clone()
        }
    }

    ///High Accuracy GNSS Positioning Metrics.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "High Accuracy GNSS Positioning Metrics.",
    ///  "type": "object",
    ///  "properties": {
    ///    "age": {
    ///      "type": "integer",
    ///      "maximum": 99.0,
    ///      "minimum": 0.0
    ///    },
    ///    "fixType": {
    ///      "$ref": "#/components/schemas/FixType"
    ///    },
    ///    "hdopi": {
    ///      "type": "integer",
    ///      "maximum": 256.0,
    ///      "minimum": 1.0
    ///    },
    ///    "nrOfUsedSatellites": {
    ///      "type": "integer",
    ///      "maximum": 64.0,
    ///      "minimum": 0.0
    ///    },
    ///    "pdopi": {
    ///      "type": "integer",
    ///      "maximum": 256.0,
    ///      "minimum": 1.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HighAccuracyGnssMetrics {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub age: Option<i64>,
        #[serde(rename = "fixType", default, skip_serializing_if = "Option::is_none")]
        pub fix_type: Option<FixType>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hdopi: Option<i64>,
        #[serde(
            rename = "nrOfUsedSatellites",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nr_of_used_satellites: Option<i64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pdopi: Option<i64>,
    }

    impl From<&HighAccuracyGnssMetrics> for HighAccuracyGnssMetrics {
        fn from(value: &HighAccuracyGnssMetrics) -> Self {
            value.clone()
        }
    }

    ///Contains the Horizontal Protection Level
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the Horizontal Protection Level",
    ///  "type": "integer",
    ///  "maximum": 50000.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HorizontalProtectionLevel(pub i64);
    impl ::std::ops::Deref for HorizontalProtectionLevel {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<HorizontalProtectionLevel> for i64 {
        fn from(value: HorizontalProtectionLevel) -> Self {
            value.0
        }
    }

    impl From<&HorizontalProtectionLevel> for HorizontalProtectionLevel {
        fn from(value: &HorizontalProtectionLevel) -> Self {
            value.clone()
        }
    }

    impl From<i64> for HorizontalProtectionLevel {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for HorizontalProtectionLevel {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for HorizontalProtectionLevel {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for HorizontalProtectionLevel {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for HorizontalProtectionLevel {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for HorizontalProtectionLevel {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///HorizontalSpeed
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates value of horizontal speed.",
    ///  "type": "number",
    ///  "format": "float",
    ///  "maximum": 2047.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HorizontalSpeed(pub f32);
    impl ::std::ops::Deref for HorizontalSpeed {
        type Target = f32;
        fn deref(&self) -> &f32 {
            &self.0
        }
    }

    impl From<HorizontalSpeed> for f32 {
        fn from(value: HorizontalSpeed) -> Self {
            value.0
        }
    }

    impl From<&HorizontalSpeed> for HorizontalSpeed {
        fn from(value: &HorizontalSpeed) -> Self {
            value.clone()
        }
    }

    impl From<f32> for HorizontalSpeed {
        fn from(value: f32) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for HorizontalSpeed {
        type Err = <f32 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for HorizontalSpeed {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for HorizontalSpeed {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for HorizontalSpeed {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for HorizontalSpeed {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Horizontal velocity.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Horizontal velocity.",
    ///  "type": "object",
    ///  "required": [
    ///    "bearing",
    ///    "hSpeed"
    ///  ],
    ///  "properties": {
    ///    "bearing": {
    ///      "$ref": "#/components/schemas/Angle"
    ///    },
    ///    "hSpeed": {
    ///      "$ref": "#/components/schemas/HorizontalSpeed"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HorizontalVelocity {
        pub bearing: Angle,
        #[serde(rename = "hSpeed")]
        pub h_speed: HorizontalSpeed,
    }

    impl From<&HorizontalVelocity> for HorizontalVelocity {
        fn from(value: &HorizontalVelocity) -> Self {
            value.clone()
        }
    }

    ///Horizontal velocity with speed uncertainty.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Horizontal velocity with speed uncertainty.",
    ///  "type": "object",
    ///  "required": [
    ///    "bearing",
    ///    "hSpeed",
    ///    "hUncertainty"
    ///  ],
    ///  "properties": {
    ///    "bearing": {
    ///      "$ref": "#/components/schemas/Angle"
    ///    },
    ///    "hSpeed": {
    ///      "$ref": "#/components/schemas/HorizontalSpeed"
    ///    },
    ///    "hUncertainty": {
    ///      "$ref": "#/components/schemas/SpeedUncertainty"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HorizontalVelocityWithUncertainty {
        pub bearing: Angle,
        #[serde(rename = "hSpeed")]
        pub h_speed: HorizontalSpeed,
        #[serde(rename = "hUncertainty")]
        pub h_uncertainty: SpeedUncertainty,
    }

    impl From<&HorizontalVelocityWithUncertainty> for HorizontalVelocityWithUncertainty {
        fn from(value: &HorizontalVelocityWithUncertainty) -> Self {
            value.clone()
        }
    }

    ///Horizontal and vertical velocity.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Horizontal and vertical velocity.",
    ///  "type": "object",
    ///  "required": [
    ///    "bearing",
    ///    "hSpeed",
    ///    "vDirection",
    ///    "vSpeed"
    ///  ],
    ///  "properties": {
    ///    "bearing": {
    ///      "$ref": "#/components/schemas/Angle"
    ///    },
    ///    "hSpeed": {
    ///      "$ref": "#/components/schemas/HorizontalSpeed"
    ///    },
    ///    "vDirection": {
    ///      "$ref": "#/components/schemas/VerticalDirection"
    ///    },
    ///    "vSpeed": {
    ///      "$ref": "#/components/schemas/VerticalSpeed"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HorizontalWithVerticalVelocity {
        pub bearing: Angle,
        #[serde(rename = "hSpeed")]
        pub h_speed: HorizontalSpeed,
        #[serde(rename = "vDirection")]
        pub v_direction: VerticalDirection,
        #[serde(rename = "vSpeed")]
        pub v_speed: VerticalSpeed,
    }

    impl From<&HorizontalWithVerticalVelocity> for HorizontalWithVerticalVelocity {
        fn from(value: &HorizontalWithVerticalVelocity) -> Self {
            value.clone()
        }
    }

    ///Horizontal and vertical velocity with speed uncertainty.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Horizontal and vertical velocity with speed
    /// uncertainty.",
    ///  "type": "object",
    ///  "required": [
    ///    "bearing",
    ///    "hSpeed",
    ///    "hUncertainty",
    ///    "vDirection",
    ///    "vSpeed",
    ///    "vUncertainty"
    ///  ],
    ///  "properties": {
    ///    "bearing": {
    ///      "$ref": "#/components/schemas/Angle"
    ///    },
    ///    "hSpeed": {
    ///      "$ref": "#/components/schemas/HorizontalSpeed"
    ///    },
    ///    "hUncertainty": {
    ///      "$ref": "#/components/schemas/SpeedUncertainty"
    ///    },
    ///    "vDirection": {
    ///      "$ref": "#/components/schemas/VerticalDirection"
    ///    },
    ///    "vSpeed": {
    ///      "$ref": "#/components/schemas/VerticalSpeed"
    ///    },
    ///    "vUncertainty": {
    ///      "$ref": "#/components/schemas/SpeedUncertainty"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct HorizontalWithVerticalVelocityAndUncertainty {
        pub bearing: Angle,
        #[serde(rename = "hSpeed")]
        pub h_speed: HorizontalSpeed,
        #[serde(rename = "hUncertainty")]
        pub h_uncertainty: SpeedUncertainty,
        #[serde(rename = "vDirection")]
        pub v_direction: VerticalDirection,
        #[serde(rename = "vSpeed")]
        pub v_speed: VerticalSpeed,
        #[serde(rename = "vUncertainty")]
        pub v_uncertainty: SpeedUncertainty,
    }

    impl From<&HorizontalWithVerticalVelocityAndUncertainty>
        for HorizontalWithVerticalVelocityAndUncertainty
    {
        fn from(value: &HorizontalWithVerticalVelocityAndUncertainty) -> Self {
            value.clone()
        }
    }

    ///Represents the idle status indication.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the idle status indication.",
    ///  "type": "object",
    ///  "properties": {
    ///    "activeTime": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "edrxCycleLength": {
    ///      "type": "integer"
    ///    },
    ///    "subsRegTimer": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "suggestedNumOfDlPackets": {
    ///      "type": "integer"
    ///    },
    ///    "timeStamp": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct IdleStatusIndication {
        #[serde(
            rename = "activeTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub active_time: Option<DurationSec>,
        #[serde(
            rename = "edrxCycleLength",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub edrx_cycle_length: Option<i64>,
        #[serde(
            rename = "subsRegTimer",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub subs_reg_timer: Option<DurationSec>,
        #[serde(
            rename = "suggestedNumOfDlPackets",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub suggested_num_of_dl_packets: Option<i64>,
        #[serde(rename = "timeStamp", default, skip_serializing_if = "Option::is_none")]
        pub time_stamp: Option<DateTime>,
    }

    impl From<&IdleStatusIndication> for IdleStatusIndication {
        fn from(value: &IdleStatusIndication) -> Self {
            value.clone()
        }
    }

    ///Immediate MDT Configuration
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Immediate MDT Configuration",
    ///  "type": "object",
    ///  "required": [
    ///    "jobType"
    ///  ],
    ///  "properties": {
    ///    "addPositioningMethodList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PositioningMethodMdt"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "areaScope": {
    ///      "$ref": "#/components/schemas/AreaScope"
    ///    },
    ///    "collectionPeriodRmmLte": {
    ///      "$ref": "#/components/schemas/CollectionPeriodRmmLteMdt"
    ///    },
    ///    "collectionPeriodRmmNr": {
    ///      "$ref": "#/components/schemas/CollectionPeriodRmmNrMdt"
    ///    },
    ///    "eventThresholdRsrp": {
    ///      "type": "integer",
    ///      "maximum": 97.0,
    ///      "minimum": 0.0
    ///    },
    ///    "eventThresholdRsrpNr": {
    ///      "type": "integer",
    ///      "maximum": 127.0,
    ///      "minimum": 0.0
    ///    },
    ///    "eventThresholdRsrq": {
    ///      "type": "integer",
    ///      "maximum": 34.0,
    ///      "minimum": 0.0
    ///    },
    ///    "eventThresholdRsrqNr": {
    ///      "type": "integer",
    ///      "maximum": 127.0,
    ///      "minimum": 0.0
    ///    },
    ///    "jobType": {
    ///      "$ref": "#/components/schemas/JobType"
    ///    },
    ///    "mdtAllowedPlmnIdList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PlmnId"
    ///      },
    ///      "maxItems": 16,
    ///      "minItems": 1
    ///    },
    ///    "measurementLteList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/MeasurementLteForMdt"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "measurementNrList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/MeasurementNrForMdt"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "measurementPeriodLte": {
    ///      "$ref": "#/components/schemas/MeasurementPeriodLteMdt"
    ///    },
    ///    "positioningMethod": {
    ///      "$ref": "#/components/schemas/PositioningMethodMdt"
    ///    },
    ///    "reportAmount": {
    ///      "$ref": "#/components/schemas/ReportAmountMdt"
    ///    },
    ///    "reportInterval": {
    ///      "$ref": "#/components/schemas/ReportIntervalMdt"
    ///    },
    ///    "reportIntervalNr": {
    ///      "$ref": "#/components/schemas/ReportIntervalNrMdt"
    ///    },
    ///    "reportingTriggerList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ReportingTrigger"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "sensorMeasurementList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SensorMeasurement"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ImmediateMdtConf {
        #[serde(
            rename = "addPositioningMethodList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub add_positioning_method_list: Vec<PositioningMethodMdt>,
        #[serde(rename = "areaScope", default, skip_serializing_if = "Option::is_none")]
        pub area_scope: Option<AreaScope>,
        #[serde(
            rename = "collectionPeriodRmmLte",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub collection_period_rmm_lte: Option<CollectionPeriodRmmLteMdt>,
        #[serde(
            rename = "collectionPeriodRmmNr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub collection_period_rmm_nr: Option<CollectionPeriodRmmNrMdt>,
        #[serde(
            rename = "eventThresholdRsrp",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub event_threshold_rsrp: Option<i64>,
        #[serde(
            rename = "eventThresholdRsrpNr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub event_threshold_rsrp_nr: Option<i64>,
        #[serde(
            rename = "eventThresholdRsrq",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub event_threshold_rsrq: Option<i64>,
        #[serde(
            rename = "eventThresholdRsrqNr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub event_threshold_rsrq_nr: Option<i64>,
        #[serde(rename = "jobType")]
        pub job_type: JobType,
        #[serde(
            rename = "mdtAllowedPlmnIdList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub mdt_allowed_plmn_id_list: Vec<PlmnId>,
        #[serde(
            rename = "measurementLteList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub measurement_lte_list: Vec<MeasurementLteForMdt>,
        #[serde(
            rename = "measurementNrList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub measurement_nr_list: Vec<MeasurementNrForMdt>,
        #[serde(
            rename = "measurementPeriodLte",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub measurement_period_lte: Option<MeasurementPeriodLteMdt>,
        #[serde(
            rename = "positioningMethod",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub positioning_method: Option<PositioningMethodMdt>,
        #[serde(
            rename = "reportAmount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub report_amount: Option<ReportAmountMdt>,
        #[serde(
            rename = "reportInterval",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub report_interval: Option<ReportIntervalMdt>,
        #[serde(
            rename = "reportIntervalNr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub report_interval_nr: Option<ReportIntervalNrMdt>,
        #[serde(
            rename = "reportingTriggerList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub reporting_trigger_list: Vec<ReportingTrigger>,
        #[serde(
            rename = "sensorMeasurementList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub sensor_measurement_list: Vec<SensorMeasurement>,
    }

    impl From<&ImmediateMdtConf> for ImmediateMdtConf {
        fn from(value: &ImmediateMdtConf) -> Self {
            value.clone()
        }
    }

    ///Indicates value of the inner radius.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates value of the inner radius.",
    ///  "type": "integer",
    ///  "format": "int32",
    ///  "maximum": 327675.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InnerRadius(pub i64);
    impl ::std::ops::Deref for InnerRadius {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<InnerRadius> for i64 {
        fn from(value: InnerRadius) -> Self {
            value.0
        }
    }

    impl From<&InnerRadius> for InnerRadius {
        fn from(value: &InnerRadius) -> Self {
            value.clone()
        }
    }

    impl From<i64> for InnerRadius {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for InnerRadius {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for InnerRadius {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for InnerRadius {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for InnerRadius {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for InnerRadius {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Indicates the supported Integrity Algorithm
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the supported Integrity Algorithm",
    ///  "type": "string",
    ///  "enum": [
    ///    "NIA0",
    ///    "NIA1",
    ///    "NIA2",
    ///    "NIA3"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum IntegrityAlgorithm {
        #[serde(rename = "NIA0")]
        Nia0,
        #[serde(rename = "NIA1")]
        Nia1,
        #[serde(rename = "NIA2")]
        Nia2,
        #[serde(rename = "NIA3")]
        Nia3,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&IntegrityAlgorithm> for IntegrityAlgorithm {
        fn from(value: &IntegrityAlgorithm) -> Self {
            value.clone()
        }
    }

    impl ToString for IntegrityAlgorithm {
        fn to_string(&self) -> String {
            match *self {
                Self::Nia0 => "NIA0".to_string(),
                Self::Nia1 => "NIA1".to_string(),
                Self::Nia2 => "NIA2".to_string(),
                Self::Nia3 => "NIA3".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for IntegrityAlgorithm {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NIA0" => Ok(Self::Nia0),
                "NIA1" => Ok(Self::Nia1),
                "NIA2" => Ok(Self::Nia2),
                "NIA3" => Ok(Self::Nia3),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for IntegrityAlgorithm {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for IntegrityAlgorithm {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for IntegrityAlgorithm {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///integrity requirements.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "integrity requirements.",
    ///  "type": "object",
    ///  "properties": {
    ///    "alertLimit": {
    ///      "$ref": "#/components/schemas/AlertLimit"
    ///    },
    ///    "targetIntegrityRisk": {
    ///      "$ref": "#/components/schemas/TargetIntegrityRisk"
    ///    },
    ///    "timeToAlert": {
    ///      "$ref": "#/components/schemas/TimeToAlert"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct IntegrityRequirements {
        #[serde(
            rename = "alertLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub alert_limit: Option<AlertLimit>,
        #[serde(
            rename = "targetIntegrityRisk",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_integrity_risk: Option<TargetIntegrityRisk>,
        #[serde(
            rename = "timeToAlert",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub time_to_alert: Option<TimeToAlert>,
    }

    impl From<&IntegrityRequirements> for IntegrityRequirements {
        fn from(value: &IntegrityRequirements) -> Self {
            value.clone()
        }
    }

    ///It contains an invalid parameter and a related description.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "It contains an invalid parameter and a related
    /// description.",
    ///  "type": "object",
    ///  "required": [
    ///    "param"
    ///  ],
    ///  "properties": {
    ///    "param": {
    ///      "description": "If the invalid parameter is an attribute in a JSON
    /// body, this IE shall contain the  attribute's name and shall be encoded
    /// as a JSON Pointer. If the invalid parameter is  an HTTP header, this IE
    /// shall be formatted as the concatenation of the string \"header \"  plus
    /// the name of such header. If the invalid parameter is a query parameter,
    /// this IE  shall be formatted as the concatenation of the string \"query
    /// \" plus the name of such  query parameter. If the invalid parameter is a
    /// variable part in the path of a resource  URI, this IE shall contain the
    /// name of the variable, including the symbols \"{\" and \"}\"  used in
    /// OpenAPI specification as the notation to represent variable path
    /// segments.\n",
    ///      "type": "string"
    ///    },
    ///    "reason": {
    ///      "description": "A human-readable reason, e.g. \"must be a positive
    /// integer\". In cases involving failed  operations in a PATCH request, the
    /// reason string should identify the operation that  failed using the
    /// operation's array index to assist in correlation of the invalid
    /// parameter with the failed operation, e.g.\" Replacement value invalid
    /// for attribute  (failed operation index= 4)\"\n",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct InvalidParam {
        ///If the invalid parameter is an attribute in a JSON body, this IE
        /// shall contain the  attribute's name and shall be encoded as a JSON
        /// Pointer. If the invalid parameter is  an HTTP header, this IE shall
        /// be formatted as the concatenation of the string "header "  plus the
        /// name of such header. If the invalid parameter is a query parameter,
        /// this IE  shall be formatted as the concatenation of the string
        /// "query " plus the name of such  query parameter. If the invalid
        /// parameter is a variable part in the path of a resource  URI, this IE
        /// shall contain the name of the variable, including the symbols "{"
        /// and "}"  used in OpenAPI specification as the notation to represent
        /// variable path segments.
        pub param: String,
        ///A human-readable reason, e.g. "must be a positive integer". In cases
        /// involving failed  operations in a PATCH request, the reason string
        /// should identify the operation that  failed using the operation's
        /// array index to assist in correlation of the invalid  parameter with
        /// the failed operation, e.g." Replacement value invalid for attribute
        /// (failed operation index= 4)"
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reason: Option<String>,
    }

    impl From<&InvalidParam> for InvalidParam {
        fn from(value: &InvalidParam) -> Self {
            value.clone()
        }
    }

    ///Contains an IP adresse.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains an IP adresse.",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "required": [
    ///        "ipv4Addr"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "ipv6Addr"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "ipv6Prefix"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "ipv4Addr": {
    ///      "$ref": "#/components/schemas/Ipv4Addr"
    ///    },
    ///    "ipv6Addr": {
    ///      "$ref": "#/components/schemas/Ipv6Addr"
    ///    },
    ///    "ipv6Prefix": {
    ///      "$ref": "#/components/schemas/Ipv6Prefix"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum IpAddr {
        Variant0 {
            #[serde(rename = "ipv4Addr")]
            ipv4_addr: Ipv4Addr,
        },
        Variant1 {
            #[serde(rename = "ipv6Addr")]
            ipv6_addr: Ipv6Addr,
        },
        Variant2 {
            #[serde(rename = "ipv6Prefix")]
            ipv6_prefix: Ipv6Prefix,
        },
    }

    impl From<&IpAddr> for IpAddr {
        fn from(value: &IpAddr) -> Self {
            value.clone()
        }
    }

    ///IpAddress
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "required": [
    ///        "ipv4Addr"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "ipv6Addr"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "ipv6Prefix"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "ipv4Addr": {
    ///      "$ref": "#/components/schemas/Ipv4Addr"
    ///    },
    ///    "ipv6Addr": {
    ///      "$ref": "#/components/schemas/Ipv6Addr"
    ///    },
    ///    "ipv6Prefix": {
    ///      "$ref": "#/components/schemas/Ipv6Prefix"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum IpAddress {
        Variant0 {
            #[serde(rename = "ipv4Addr")]
            ipv4_addr: Ipv4Addr,
        },
        Variant1 {
            #[serde(rename = "ipv6Addr")]
            ipv6_addr: Ipv6Addr,
        },
        Variant2 {
            #[serde(rename = "ipv6Prefix")]
            ipv6_prefix: Ipv6Prefix,
        },
    }

    impl From<&IpAddress> for IpAddress {
        fn from(value: &IpAddress) -> Self {
            value.clone()
        }
    }

    ///Contains the description of an Uplink and/or Downlink Ethernet flow.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the description of an Uplink and/or Downlink
    /// Ethernet flow.",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "required": [
    ///        "ipTrafficFilter"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "ethTrafficFilter"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "ethTrafficFilter": {
    ///      "$ref": "#/components/schemas/EthFlowDescription"
    ///    },
    ///    "ipTrafficFilter": {
    ///      "$ref": "#/components/schemas/FlowDescription"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum IpEthFlowDescription {
        Variant0 {
            #[serde(rename = "ipTrafficFilter")]
            ip_traffic_filter: FlowDescription,
        },
        Variant1 {
            #[serde(rename = "ethTrafficFilter")]
            eth_traffic_filter: EthFlowDescription,
        },
    }

    impl From<&IpEthFlowDescription> for IpEthFlowDescription {
        fn from(value: &IpEthFlowDescription) -> Self {
            value.clone()
        }
    }

    ///String identifying a IPv4 address formatted in the 'dotted decimal'
    /// notation as defined in RFC 1166.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String identifying a IPv4 address formatted in the
    /// 'dotted decimal' notation as defined in RFC 1166.\n",
    ///  "examples": [
    ///    "198.51.100.1"
    ///  ],
    ///  "type": "string",
    ///  "pattern":
    /// "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.
    /// ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct Ipv4Addr(String);
    impl ::std::ops::Deref for Ipv4Addr {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Ipv4Addr> for String {
        fn from(value: Ipv4Addr) -> Self {
            value.0
        }
    }

    impl From<&Ipv4Addr> for Ipv4Addr {
        fn from(value: &Ipv4Addr) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Ipv4Addr {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress :: Regex :: new ("^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$\"" . into ()) ; }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Ipv4Addr {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for Ipv4Addr {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for Ipv4Addr {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Ipv4Addr {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///String identifying an IPv6 address formatted according to clause 4 of
    /// RFC5952. The mixed IPv4 IPv6 notation according to clause 5 of RFC5952
    /// shall not be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String identifying an IPv6 address formatted according
    /// to clause 4 of RFC5952. The mixed IPv4 IPv6 notation according to clause
    /// 5 of RFC5952 shall not be used.\n",
    ///  "examples": [
    ///    "2001:db8:85a3::8a2e:370:7334"
    ///  ],
    ///  "type": "string",
    ///  "pattern":
    /// "(?=.*^((:|(0?|([1-9a-f][0-9a-f]{0,3}))):)((0?|([1-9a-f][0-9a-f]{0,3})):
    /// ){0,6}(:|(0?|([1-9a-f][0-9a-f]{0,3})))$)(?=.*^((([^:]+:){7}([^:
    /// ]+))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?))$)"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct Ipv6Addr(String);
    impl ::std::ops::Deref for Ipv6Addr {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Ipv6Addr> for String {
        fn from(value: Ipv6Addr) -> Self {
            value.0
        }
    }

    impl From<&Ipv6Addr> for Ipv6Addr {
        fn from(value: &Ipv6Addr) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Ipv6Addr {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress :: Regex :: new ("(?=.*^((:|(0?|([1-9a-f][0-9a-f]{0,3}))):)((0?|([1-9a-f][0-9a-f]{0,3})):){0,6}(:|(0?|([1-9a-f][0-9a-f]{0,3})))$)(?=.*^((([^:]+:){7}([^:]+))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?))$)") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"(?=.*^((:|(0?|([1-9a-f][0-9a-f]{0,3}))):)((0?|([1-9a-f][0-9a-f]{0,3})):){0,6}(:|(0?|([1-9a-f][0-9a-f]{0,3})))$)(?=.*^((([^:]+:){7}([^:]+))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?))$)\"" . into ()) ; }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Ipv6Addr {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for Ipv6Addr {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for Ipv6Addr {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Ipv6Addr {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///String identifying an IPv6 address prefix formatted according to clause
    /// 4 of RFC 5952. IPv6Prefix data type may contain an individual /128 IPv6
    /// address.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String identifying an IPv6 address prefix formatted
    /// according to clause 4 of RFC 5952. IPv6Prefix data type may contain an
    /// individual /128 IPv6 address.\n",
    ///  "examples": [
    ///    "2001:db8:abcd:12::0/64"
    ///  ],
    ///  "type": "string",
    ///  "pattern":
    /// "(?=.*^((:|(0?|([1-9a-f][0-9a-f]{0,3}))):)((0?|([1-9a-f][0-9a-f]{0,3})):
    /// ){0,6}(:|(0?|([1-9a-f][0-9a-f]{0,3})))(\\/
    /// (([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))$)(?=.*^((([^:]+:){7}([^:
    /// ]+))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?))(\\/.+)$)"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct Ipv6Prefix(String);
    impl ::std::ops::Deref for Ipv6Prefix {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Ipv6Prefix> for String {
        fn from(value: Ipv6Prefix) -> Self {
            value.0
        }
    }

    impl From<&Ipv6Prefix> for Ipv6Prefix {
        fn from(value: &Ipv6Prefix) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Ipv6Prefix {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress :: Regex :: new ("(?=.*^((:|(0?|([1-9a-f][0-9a-f]{0,3}))):)((0?|([1-9a-f][0-9a-f]{0,3})):){0,6}(:|(0?|([1-9a-f][0-9a-f]{0,3})))(\\/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))$)(?=.*^((([^:]+:){7}([^:]+))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?))(\\/.+)$)") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"(?=.*^((:|(0?|([1-9a-f][0-9a-f]{0,3}))):)((0?|([1-9a-f][0-9a-f]{0,3})):){0,6}(:|(0?|([1-9a-f][0-9a-f]{0,3})))(\\/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))$)(?=.*^((([^:]+:){7}([^:]+))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?))(\\/.+)$)\"" . into ()) ; }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Ipv6Prefix {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for Ipv6Prefix {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for Ipv6Prefix {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Ipv6Prefix {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The enumeration JobType defines Job Type in the trace. See 3GPP TS
    /// 32.422 for further  description of the values. It shall comply with the
    /// provisions defined in table 5.6.3.3-1.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration JobType defines Job Type in the trace.
    /// See 3GPP TS 32.422 for further  description of the values. It shall
    /// comply with the provisions defined in table 5.6.3.3-1.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "IMMEDIATE_MDT_ONLY",
    ///    "LOGGED_MDT_ONLY",
    ///    "TRACE_ONLY",
    ///    "IMMEDIATE_MDT_AND_TRACE",
    ///    "RLF_REPORTS_ONLY",
    ///    "RCEF_REPORTS_ONLY",
    ///    "LOGGED_MBSFN_MDT"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum JobType {
        #[serde(rename = "IMMEDIATE_MDT_ONLY")]
        ImmediateMdtOnly,
        #[serde(rename = "LOGGED_MDT_ONLY")]
        LoggedMdtOnly,
        #[serde(rename = "TRACE_ONLY")]
        TraceOnly,
        #[serde(rename = "IMMEDIATE_MDT_AND_TRACE")]
        ImmediateMdtAndTrace,
        #[serde(rename = "RLF_REPORTS_ONLY")]
        RlfReportsOnly,
        #[serde(rename = "RCEF_REPORTS_ONLY")]
        RcefReportsOnly,
        #[serde(rename = "LOGGED_MBSFN_MDT")]
        LoggedMbsfnMdt,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&JobType> for JobType {
        fn from(value: &JobType) -> Self {
            value.clone()
        }
    }

    impl ToString for JobType {
        fn to_string(&self) -> String {
            match *self {
                Self::ImmediateMdtOnly => "IMMEDIATE_MDT_ONLY".to_string(),
                Self::LoggedMdtOnly => "LOGGED_MDT_ONLY".to_string(),
                Self::TraceOnly => "TRACE_ONLY".to_string(),
                Self::ImmediateMdtAndTrace => "IMMEDIATE_MDT_AND_TRACE".to_string(),
                Self::RlfReportsOnly => "RLF_REPORTS_ONLY".to_string(),
                Self::RcefReportsOnly => "RCEF_REPORTS_ONLY".to_string(),
                Self::LoggedMbsfnMdt => "LOGGED_MBSFN_MDT".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for JobType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "IMMEDIATE_MDT_ONLY" => Ok(Self::ImmediateMdtOnly),
                "LOGGED_MDT_ONLY" => Ok(Self::LoggedMdtOnly),
                "TRACE_ONLY" => Ok(Self::TraceOnly),
                "IMMEDIATE_MDT_AND_TRACE" => Ok(Self::ImmediateMdtAndTrace),
                "RLF_REPORTS_ONLY" => Ok(Self::RlfReportsOnly),
                "RCEF_REPORTS_ONLY" => Ok(Self::RcefReportsOnly),
                "LOGGED_MBSFN_MDT" => Ok(Self::LoggedMbsfnMdt),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for JobType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for JobType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for JobType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents the Kamf or K'amf
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the Kamf or K'amf",
    ///  "type": "object",
    ///  "required": [
    ///    "keyType",
    ///    "keyVal"
    ///  ],
    ///  "properties": {
    ///    "keyType": {
    ///      "$ref": "#/components/schemas/KeyAmfType"
    ///    },
    ///    "keyVal": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct KeyAmf {
        #[serde(rename = "keyType")]
        pub key_type: KeyAmfType,
        #[serde(rename = "keyVal")]
        pub key_val: String,
    }

    impl From<&KeyAmf> for KeyAmf {
        fn from(value: &KeyAmf) -> Self {
            value.clone()
        }
    }

    ///Indicates the Kamf type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the Kamf type",
    ///  "type": "string",
    ///  "enum": [
    ///    "KAMF",
    ///    "KPRIMEAMF"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum KeyAmfType {
        #[serde(rename = "KAMF")]
        Kamf,
        #[serde(rename = "KPRIMEAMF")]
        Kprimeamf,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&KeyAmfType> for KeyAmfType {
        fn from(value: &KeyAmfType) -> Self {
            value.clone()
        }
    }

    impl ToString for KeyAmfType {
        fn to_string(&self) -> String {
            match *self {
                Self::Kamf => "KAMF".to_string(),
                Self::Kprimeamf => "KPRIMEAMF".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for KeyAmfType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "KAMF" => Ok(Self::Kamf),
                "KPRIMEAMF" => Ok(Self::Kprimeamf),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for KeyAmfType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for KeyAmfType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for KeyAmfType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///LADN Information
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "LADN Information",
    ///  "type": "object",
    ///  "required": [
    ///    "ladn"
    ///  ],
    ///  "properties": {
    ///    "ladn": {
    ///      "type": "string"
    ///    },
    ///    "presence": {
    ///      "$ref": "#/components/schemas/PresenceState"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LadnInfo {
        pub ladn: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub presence: Option<PresenceState>,
    }

    impl From<&LadnInfo> for LadnInfo {
        fn from(value: &LadnInfo) -> Self {
            value.clone()
        }
    }

    ///Indicates priority of the LCS client.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates priority of the LCS client.",
    ///  "type": "string",
    ///  "enum": [
    ///    "HIGHEST_PRIORITY",
    ///    "NORMAL_PRIORITY"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LcsPriority {
        #[serde(rename = "HIGHEST_PRIORITY")]
        HighestPriority,
        #[serde(rename = "NORMAL_PRIORITY")]
        NormalPriority,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&LcsPriority> for LcsPriority {
        fn from(value: &LcsPriority) -> Self {
            value.clone()
        }
    }

    impl ToString for LcsPriority {
        fn to_string(&self) -> String {
            match *self {
                Self::HighestPriority => "HIGHEST_PRIORITY".to_string(),
                Self::NormalPriority => "NORMAL_PRIORITY".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for LcsPriority {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "HIGHEST_PRIORITY" => Ok(Self::HighestPriority),
                "NORMAL_PRIORITY" => Ok(Self::NormalPriority),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for LcsPriority {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LcsPriority {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LcsPriority {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Specifies LCS QoS class.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Specifies LCS QoS class.",
    ///  "type": "string",
    ///  "enum": [
    ///    "BEST_EFFORT",
    ///    "ASSURED",
    ///    "MULTIPLE_QOS"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LcsQosClass {
        #[serde(rename = "BEST_EFFORT")]
        BestEffort,
        #[serde(rename = "ASSURED")]
        Assured,
        #[serde(rename = "MULTIPLE_QOS")]
        MultipleQos,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&LcsQosClass> for LcsQosClass {
        fn from(value: &LcsQosClass) -> Self {
            value.clone()
        }
    }

    impl ToString for LcsQosClass {
        fn to_string(&self) -> String {
            match *self {
                Self::BestEffort => "BEST_EFFORT".to_string(),
                Self::Assured => "ASSURED".to_string(),
                Self::MultipleQos => "MULTIPLE_QOS".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for LcsQosClass {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "BEST_EFFORT" => Ok(Self::BestEffort),
                "ASSURED" => Ok(Self::Assured),
                "MULTIPLE_QOS" => Ok(Self::MultipleQos),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for LcsQosClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LcsQosClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LcsQosClass {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Possible values are:
    /// - "LOCATION_ALLOWED_WITH_NOTIFICATION": Location allowed with
    ///   notification
    /// - "LOCATION_ALLOWED_WITHOUT_NOTIFICATION": Location allowed without
    ///   notification
    /// - "LOCATION_ALLOWED_WITHOUT_RESPONSE": Location with notification and
    ///   privacy verification; location allowed if no response
    /// - "LOCATION_RESTRICTED_WITHOUT_RESPONSE": Location with notification and
    ///   privacy
    ///  verification; location restricted if no response
    /// - "NOTIFICATION_ONLY": Notification only
    /// - "NOTIFICATION_AND_VERIFICATION_ONLY": Notification and privacy
    ///   verification only
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n-
    /// \"LOCATION_ALLOWED_WITH_NOTIFICATION\": Location allowed with
    /// notification\n- \"LOCATION_ALLOWED_WITHOUT_NOTIFICATION\": Location
    /// allowed without notification\n- \"LOCATION_ALLOWED_WITHOUT_RESPONSE\":
    /// Location with notification and privacy\n   verification; location
    /// allowed if no response\n- \"LOCATION_RESTRICTED_WITHOUT_RESPONSE\":
    /// Location with notification and privacy\n  verification; location
    /// restricted if no response\n- \"NOTIFICATION_ONLY\": Notification only\n-
    /// \"NOTIFICATION_AND_VERIFICATION_ONLY\": Notification and privacy
    /// verification only\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "LOCATION_ALLOWED_WITH_NOTIFICATION",
    ///    "LOCATION_ALLOWED_WITHOUT_NOTIFICATION",
    ///    "LOCATION_ALLOWED_WITHOUT_RESPONSE",
    ///    "LOCATION_RESTRICTED_WITHOUT_RESPONSE",
    ///    "NOTIFICATION_ONLY",
    ///    "NOTIFICATION_AND_VERIFICATION_ONLY"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LcsServiceAuth {
        #[serde(rename = "LOCATION_ALLOWED_WITH_NOTIFICATION")]
        LocationAllowedWithNotification,
        #[serde(rename = "LOCATION_ALLOWED_WITHOUT_NOTIFICATION")]
        LocationAllowedWithoutNotification,
        #[serde(rename = "LOCATION_ALLOWED_WITHOUT_RESPONSE")]
        LocationAllowedWithoutResponse,
        #[serde(rename = "LOCATION_RESTRICTED_WITHOUT_RESPONSE")]
        LocationRestrictedWithoutResponse,
        #[serde(rename = "NOTIFICATION_ONLY")]
        NotificationOnly,
        #[serde(rename = "NOTIFICATION_AND_VERIFICATION_ONLY")]
        NotificationAndVerificationOnly,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&LcsServiceAuth> for LcsServiceAuth {
        fn from(value: &LcsServiceAuth) -> Self {
            value.clone()
        }
    }

    impl ToString for LcsServiceAuth {
        fn to_string(&self) -> String {
            match *self {
                Self::LocationAllowedWithNotification => {
                    "LOCATION_ALLOWED_WITH_NOTIFICATION".to_string()
                }
                Self::LocationAllowedWithoutNotification => {
                    "LOCATION_ALLOWED_WITHOUT_NOTIFICATION".to_string()
                }
                Self::LocationAllowedWithoutResponse => {
                    "LOCATION_ALLOWED_WITHOUT_RESPONSE".to_string()
                }
                Self::LocationRestrictedWithoutResponse => {
                    "LOCATION_RESTRICTED_WITHOUT_RESPONSE".to_string()
                }
                Self::NotificationOnly => "NOTIFICATION_ONLY".to_string(),
                Self::NotificationAndVerificationOnly => {
                    "NOTIFICATION_AND_VERIFICATION_ONLY".to_string()
                }
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for LcsServiceAuth {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "LOCATION_ALLOWED_WITH_NOTIFICATION" => Ok(Self::LocationAllowedWithNotification),
                "LOCATION_ALLOWED_WITHOUT_NOTIFICATION" => {
                    Ok(Self::LocationAllowedWithoutNotification)
                }
                "LOCATION_ALLOWED_WITHOUT_RESPONSE" => Ok(Self::LocationAllowedWithoutResponse),
                "LOCATION_RESTRICTED_WITHOUT_RESPONSE" => {
                    Ok(Self::LocationRestrictedWithoutResponse)
                }
                "NOTIFICATION_ONLY" => Ok(Self::NotificationOnly),
                "NOTIFICATION_AND_VERIFICATION_ONLY" => Ok(Self::NotificationAndVerificationOnly),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for LcsServiceAuth {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LcsServiceAuth {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LcsServiceAuth {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///LCS service type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "LCS service type.",
    ///  "type": "integer",
    ///  "maximum": 127.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LcsServiceType(pub i64);
    impl ::std::ops::Deref for LcsServiceType {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<LcsServiceType> for i64 {
        fn from(value: LcsServiceType) -> Self {
            value.0
        }
    }

    impl From<&LcsServiceType> for LcsServiceType {
        fn from(value: &LcsServiceType) -> Self {
            value.clone()
        }
    }

    impl From<i64> for LcsServiceType {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for LcsServiceType {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for LcsServiceType {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LcsServiceType {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LcsServiceType {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for LcsServiceType {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///LDR Reference.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "LDR Reference.",
    ///  "type": "string",
    ///  "maxLength": 510,
    ///  "minLength": 2
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct LdrReference(String);
    impl ::std::ops::Deref for LdrReference {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<LdrReference> for String {
        fn from(value: LdrReference) -> Self {
            value.0
        }
    }

    impl From<&LdrReference> for LdrReference {
        fn from(value: &LdrReference) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LdrReference {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if value.len() > 510usize {
                return Err("longer than 510 characters".into());
            }
            if value.len() < 2usize {
                return Err("shorter than 2 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LdrReference {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for LdrReference {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for LdrReference {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LdrReference {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Indicates LDR types.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates LDR types.",
    ///  "type": "string",
    ///  "enum": [
    ///    "UE_AVAILABLE",
    ///    "PERIODIC",
    ///    "ENTERING_INTO_AREA",
    ///    "LEAVING_FROM_AREA",
    ///    "BEING_INSIDE_AREA",
    ///    "MOTION"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LdrType {
        #[serde(rename = "UE_AVAILABLE")]
        UeAvailable,
        #[serde(rename = "PERIODIC")]
        Periodic,
        #[serde(rename = "ENTERING_INTO_AREA")]
        EnteringIntoArea,
        #[serde(rename = "LEAVING_FROM_AREA")]
        LeavingFromArea,
        #[serde(rename = "BEING_INSIDE_AREA")]
        BeingInsideArea,
        #[serde(rename = "MOTION")]
        Motion,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&LdrType> for LdrType {
        fn from(value: &LdrType) -> Self {
            value.clone()
        }
    }

    impl ToString for LdrType {
        fn to_string(&self) -> String {
            match *self {
                Self::UeAvailable => "UE_AVAILABLE".to_string(),
                Self::Periodic => "PERIODIC".to_string(),
                Self::EnteringIntoArea => "ENTERING_INTO_AREA".to_string(),
                Self::LeavingFromArea => "LEAVING_FROM_AREA".to_string(),
                Self::BeingInsideArea => "BEING_INSIDE_AREA".to_string(),
                Self::Motion => "MOTION".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for LdrType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "UE_AVAILABLE" => Ok(Self::UeAvailable),
                "PERIODIC" => Ok(Self::Periodic),
                "ENTERING_INTO_AREA" => Ok(Self::EnteringIntoArea),
                "LEAVING_FROM_AREA" => Ok(Self::LeavingFromArea),
                "BEING_INSIDE_AREA" => Ok(Self::BeingInsideArea),
                "MOTION" => Ok(Self::Motion),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for LdrType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LdrType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LdrType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Possible values are:
    /// - DSL: Identifies a DSL line
    /// - PON: Identifies a PON line
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- DSL: Identifies a DSL line\n-
    /// PON: Identifies a PON line\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "DSL",
    ///    "PON"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LineType {
        #[serde(rename = "DSL")]
        Dsl,
        #[serde(rename = "PON")]
        Pon,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&LineType> for LineType {
        fn from(value: &LineType) -> Self {
            value.clone()
        }
    }

    impl ToString for LineType {
        fn to_string(&self) -> String {
            match *self {
                Self::Dsl => "DSL".to_string(),
                Self::Pon => "PON".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for LineType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DSL" => Ok(Self::Dsl),
                "PON" => Ok(Self::Pon),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for LineType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LineType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LineType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Minimum straight line distance moved by a UE to trigger a motion event
    /// report.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Minimum straight line distance moved by a UE to trigger
    /// a motion event report.",
    ///  "type": "integer",
    ///  "maximum": 10000.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LinearDistance(pub i64);
    impl ::std::ops::Deref for LinearDistance {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<LinearDistance> for i64 {
        fn from(value: LinearDistance) -> Self {
            value.0
        }
    }

    impl From<&LinearDistance> for LinearDistance {
        fn from(value: &LinearDistance) -> Self {
            value.clone()
        }
    }

    impl From<i64> for LinearDistance {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for LinearDistance {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for LinearDistance {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LinearDistance {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LinearDistance {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for LinearDistance {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///LMF identification.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "LMF identification.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct LmfIdentification(pub String);
    impl ::std::ops::Deref for LmfIdentification {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<LmfIdentification> for String {
        fn from(value: LmfIdentification) -> Self {
            value.0
        }
    }

    impl From<&LmfIdentification> for LmfIdentification {
        fn from(value: &LmfIdentification) -> Self {
            value.clone()
        }
    }

    impl From<String> for LmfIdentification {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for LmfIdentification {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for LmfIdentification {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Load level information of the network slice and the optionally
    /// associated network slice instance.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Load level information of the network slice and the
    /// optionally associated network slice instance.\n",
    ///  "type": "integer"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LoadLevelInformation(pub i64);
    impl ::std::ops::Deref for LoadLevelInformation {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<LoadLevelInformation> for i64 {
        fn from(value: LoadLevelInformation) -> Self {
            value.0
        }
    }

    impl From<&LoadLevelInformation> for LoadLevelInformation {
        fn from(value: &LoadLevelInformation) -> Self {
            value.clone()
        }
    }

    impl From<i64> for LoadLevelInformation {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for LoadLevelInformation {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for LoadLevelInformation {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LoadLevelInformation {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LoadLevelInformation {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for LoadLevelInformation {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Local 2D point with uncertainty ellipse
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Local 2D point with uncertainty ellipse",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GADShape"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "confidence",
    ///        "localOrigin",
    ///        "point",
    ///        "uncertaintyEllipse"
    ///      ],
    ///      "properties": {
    ///        "confidence": {
    ///          "$ref": "#/components/schemas/Confidence"
    ///        },
    ///        "localOrigin": {
    ///          "$ref": "#/components/schemas/LocalOrigin"
    ///        },
    ///        "point": {
    ///          "$ref": "#/components/schemas/RelativeCartesianLocation"
    ///        },
    ///        "uncertaintyEllipse": {
    ///          "$ref": "#/components/schemas/UncertaintyEllipse"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Local2dPointUncertaintyEllipse {
        pub confidence: Confidence,
        #[serde(rename = "localOrigin")]
        pub local_origin: LocalOrigin,
        pub point: RelativeCartesianLocation,
        pub shape: SupportedGadShapes,
        #[serde(rename = "uncertaintyEllipse")]
        pub uncertainty_ellipse: UncertaintyEllipse,
    }

    impl From<&Local2dPointUncertaintyEllipse> for Local2dPointUncertaintyEllipse {
        fn from(value: &Local2dPointUncertaintyEllipse) -> Self {
            value.clone()
        }
    }

    ///Local 3D point with uncertainty ellipsoid
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Local 3D point with uncertainty ellipsoid",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GADShape"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "confidence",
    ///        "localOrigin",
    ///        "point",
    ///        "uncertaintyEllipsoid"
    ///      ],
    ///      "properties": {
    ///        "confidence": {
    ///          "$ref": "#/components/schemas/Confidence"
    ///        },
    ///        "localOrigin": {
    ///          "$ref": "#/components/schemas/LocalOrigin"
    ///        },
    ///        "point": {
    ///          "$ref": "#/components/schemas/RelativeCartesianLocation"
    ///        },
    ///        "uncertaintyEllipsoid": {
    ///          "$ref": "#/components/schemas/UncertaintyEllipsoid"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Local3dPointUncertaintyEllipsoid {
        pub confidence: Confidence,
        #[serde(rename = "localOrigin")]
        pub local_origin: LocalOrigin,
        pub point: RelativeCartesianLocation,
        pub shape: SupportedGadShapes,
        #[serde(rename = "uncertaintyEllipsoid")]
        pub uncertainty_ellipsoid: UncertaintyEllipsoid,
    }

    impl From<&Local3dPointUncertaintyEllipsoid> for Local3dPointUncertaintyEllipsoid {
        fn from(value: &Local3dPointUncertaintyEllipsoid) -> Self {
            value.clone()
        }
    }

    ///Local area specified by different shape
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Local area specified by different shape",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/Local2dPointUncertaintyEllipse"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/Local3dPointUncertaintyEllipsoid"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum LocalArea {
        Local2dPointUncertaintyEllipse(Local2dPointUncertaintyEllipse),
        Local3dPointUncertaintyEllipsoid(Local3dPointUncertaintyEllipsoid),
    }

    impl From<&LocalArea> for LocalArea {
        fn from(value: &LocalArea) -> Self {
            value.clone()
        }
    }

    impl From<Local2dPointUncertaintyEllipse> for LocalArea {
        fn from(value: Local2dPointUncertaintyEllipse) -> Self {
            Self::Local2dPointUncertaintyEllipse(value)
        }
    }

    impl From<Local3dPointUncertaintyEllipsoid> for LocalArea {
        fn from(value: Local3dPointUncertaintyEllipsoid) -> Self {
            Self::Local3dPointUncertaintyEllipsoid(value)
        }
    }

    ///Indicates a Local origin in a reference system
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates a Local origin in a reference system",
    ///  "type": "object",
    ///  "properties": {
    ///    "coordinateId": {
    ///      "type": "string"
    ///    },
    ///    "point": {
    ///      "$ref": "#/components/schemas/GeographicalCoordinates"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LocalOrigin {
        #[serde(
            rename = "coordinateId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub coordinate_id: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub point: Option<GeographicalCoordinates>,
    }

    impl From<&LocalOrigin> for LocalOrigin {
        fn from(value: &LocalOrigin) -> Self {
            value.clone()
        }
    }

    ///LocationArea
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "properties": {
    ///    "civicAddresses": {
    ///      "description": "Identifies a list of civic addresses of the user
    /// where the UE is located.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CivicAddress"
    ///      },
    ///      "minItems": 0
    ///    },
    ///    "geographicAreas": {
    ///      "description": "Identifies a list of geographic area of the user
    /// where the UE is located.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GeographicArea"
    ///      },
    ///      "minItems": 0
    ///    },
    ///    "nwAreaInfo": {
    ///      "$ref": "#/components/schemas/schemas-NetworkAreaInfo"
    ///    },
    ///    "umtTime": {
    ///      "$ref": "#/components/schemas/UmtTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LocationArea {
        ///Identifies a list of civic addresses of the user where the UE is
        /// located.
        #[serde(
            rename = "civicAddresses",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub civic_addresses: Vec<CivicAddress>,
        ///Identifies a list of geographic area of the user where the UE is
        /// located.
        #[serde(
            rename = "geographicAreas",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub geographic_areas: Vec<GeographicArea>,
        #[serde(
            rename = "nwAreaInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nw_area_info: Option<SchemasNetworkAreaInfo>,
        #[serde(rename = "umtTime", default, skip_serializing_if = "Option::is_none")]
        pub umt_time: Option<UmtTime>,
    }

    impl From<&LocationArea> for LocationArea {
        fn from(value: &LocationArea) -> Self {
            value.clone()
        }
    }

    ///Contains a Location area identification as defined in 3GPP TS 23.003,
    /// clause 4.1.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains a Location area identification as defined in
    /// 3GPP TS 23.003, clause 4.1.",
    ///  "type": "object",
    ///  "required": [
    ///    "lac",
    ///    "plmnId"
    ///  ],
    ///  "properties": {
    ///    "lac": {
    ///      "description": "Location Area Code.",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]{4}$"
    ///    },
    ///    "plmnId": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LocationAreaId {
        ///Location Area Code.
        pub lac: LocationAreaIdLac,
        #[serde(rename = "plmnId")]
        pub plmn_id: PlmnId,
    }

    impl From<&LocationAreaId> for LocationAreaId {
        fn from(value: &LocationAreaId) -> Self {
            value.clone()
        }
    }

    ///Location Area Code.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Location Area Code.",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{4}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct LocationAreaIdLac(String);
    impl ::std::ops::Deref for LocationAreaIdLac {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<LocationAreaIdLac> for String {
        fn from(value: LocationAreaIdLac) -> Self {
            value.0
        }
    }

    impl From<&LocationAreaIdLac> for LocationAreaIdLac {
        fn from(value: &LocationAreaIdLac) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for LocationAreaIdLac {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{4}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{4}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for LocationAreaIdLac {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for LocationAreaIdLac {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for LocationAreaIdLac {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for LocationAreaIdLac {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Type of events initiating location procedures
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type of events initiating location procedures",
    ///  "type": "string",
    ///  "enum": [
    ///    "EMERGENCY_CALL_ORIGINATION",
    ///    "EMERGENCY_CALL_RELEASE",
    ///    "EMERGENCY_CALL_HANDOVER",
    ///    "ACTIVATION_OF_DEFERRED_LOCATION",
    ///    "UE_MOBILITY_FOR_DEFERRED_LOCATION",
    ///    "CANCELLATION_OF_DEFERRED_LOCATION"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LocationEvent {
        #[serde(rename = "EMERGENCY_CALL_ORIGINATION")]
        EmergencyCallOrigination,
        #[serde(rename = "EMERGENCY_CALL_RELEASE")]
        EmergencyCallRelease,
        #[serde(rename = "EMERGENCY_CALL_HANDOVER")]
        EmergencyCallHandover,
        #[serde(rename = "ACTIVATION_OF_DEFERRED_LOCATION")]
        ActivationOfDeferredLocation,
        #[serde(rename = "UE_MOBILITY_FOR_DEFERRED_LOCATION")]
        UeMobilityForDeferredLocation,
        #[serde(rename = "CANCELLATION_OF_DEFERRED_LOCATION")]
        CancellationOfDeferredLocation,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&LocationEvent> for LocationEvent {
        fn from(value: &LocationEvent) -> Self {
            value.clone()
        }
    }

    impl ToString for LocationEvent {
        fn to_string(&self) -> String {
            match *self {
                Self::EmergencyCallOrigination => "EMERGENCY_CALL_ORIGINATION".to_string(),
                Self::EmergencyCallRelease => "EMERGENCY_CALL_RELEASE".to_string(),
                Self::EmergencyCallHandover => "EMERGENCY_CALL_HANDOVER".to_string(),
                Self::ActivationOfDeferredLocation => "ACTIVATION_OF_DEFERRED_LOCATION".to_string(),
                Self::UeMobilityForDeferredLocation => {
                    "UE_MOBILITY_FOR_DEFERRED_LOCATION".to_string()
                }
                Self::CancellationOfDeferredLocation => {
                    "CANCELLATION_OF_DEFERRED_LOCATION".to_string()
                }
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for LocationEvent {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EMERGENCY_CALL_ORIGINATION" => Ok(Self::EmergencyCallOrigination),
                "EMERGENCY_CALL_RELEASE" => Ok(Self::EmergencyCallRelease),
                "EMERGENCY_CALL_HANDOVER" => Ok(Self::EmergencyCallHandover),
                "ACTIVATION_OF_DEFERRED_LOCATION" => Ok(Self::ActivationOfDeferredLocation),
                "UE_MOBILITY_FOR_DEFERRED_LOCATION" => Ok(Self::UeMobilityForDeferredLocation),
                "CANCELLATION_OF_DEFERRED_LOCATION" => Ok(Self::CancellationOfDeferredLocation),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for LocationEvent {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LocationEvent {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LocationEvent {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Describes the supported filters of LOCATION_REPORT event type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the supported filters of LOCATION_REPORT
    /// event type",
    ///  "type": "string",
    ///  "enum": [
    ///    "TAI",
    ///    "CELL_ID",
    ///    "RAN_NODE",
    ///    "N3IWF",
    ///    "UE_IP",
    ///    "UDP_PORT",
    ///    "TNAP_ID",
    ///    "GLI",
    ///    "TWAP_ID"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LocationFilter {
        #[serde(rename = "TAI")]
        Tai,
        #[serde(rename = "CELL_ID")]
        CellId,
        #[serde(rename = "RAN_NODE")]
        RanNode,
        #[serde(rename = "N3IWF")]
        N3iwf,
        #[serde(rename = "UE_IP")]
        UeIp,
        #[serde(rename = "UDP_PORT")]
        UdpPort,
        #[serde(rename = "TNAP_ID")]
        TnapId,
        #[serde(rename = "GLI")]
        Gli,
        #[serde(rename = "TWAP_ID")]
        TwapId,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&LocationFilter> for LocationFilter {
        fn from(value: &LocationFilter) -> Self {
            value.clone()
        }
    }

    impl ToString for LocationFilter {
        fn to_string(&self) -> String {
            match *self {
                Self::Tai => "TAI".to_string(),
                Self::CellId => "CELL_ID".to_string(),
                Self::RanNode => "RAN_NODE".to_string(),
                Self::N3iwf => "N3IWF".to_string(),
                Self::UeIp => "UE_IP".to_string(),
                Self::UdpPort => "UDP_PORT".to_string(),
                Self::TnapId => "TNAP_ID".to_string(),
                Self::Gli => "GLI".to_string(),
                Self::TwapId => "TWAP_ID".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for LocationFilter {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TAI" => Ok(Self::Tai),
                "CELL_ID" => Ok(Self::CellId),
                "RAN_NODE" => Ok(Self::RanNode),
                "N3IWF" => Ok(Self::N3iwf),
                "UE_IP" => Ok(Self::UeIp),
                "UDP_PORT" => Ok(Self::UdpPort),
                "TNAP_ID" => Ok(Self::TnapId),
                "GLI" => Ok(Self::Gli),
                "TWAP_ID" => Ok(Self::TwapId),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for LocationFilter {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LocationFilter {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LocationFilter {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents UE location information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents UE location information.",
    ///  "type": "object",
    ///  "required": [
    ///    "loc"
    ///  ],
    ///  "properties": {
    ///    "confidence": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "loc": {
    ///      "$ref": "#/components/schemas/UserLocation"
    ///    },
    ///    "ratio": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LocationInfo {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub confidence: Option<Uinteger>,
        pub loc: UserLocation,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ratio: Option<SamplingRatio>,
    }

    impl From<&LocationInfo> for LocationInfo {
        fn from(value: &LocationInfo) -> Self {
            value.clone()
        }
    }

    ///The result of location privacy verification by UE
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The result of location privacy verification by UE",
    ///  "type": "string",
    ///  "enum": [
    ///    "LOCATION_ALLOWED",
    ///    "LOCATION_NOT_ALLOWED",
    ///    "RESPONSE_TIME_OUT"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LocationPrivacyVerResult {
        #[serde(rename = "LOCATION_ALLOWED")]
        LocationAllowed,
        #[serde(rename = "LOCATION_NOT_ALLOWED")]
        LocationNotAllowed,
        #[serde(rename = "RESPONSE_TIME_OUT")]
        ResponseTimeOut,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&LocationPrivacyVerResult> for LocationPrivacyVerResult {
        fn from(value: &LocationPrivacyVerResult) -> Self {
            value.clone()
        }
    }

    impl ToString for LocationPrivacyVerResult {
        fn to_string(&self) -> String {
            match *self {
                Self::LocationAllowed => "LOCATION_ALLOWED".to_string(),
                Self::LocationNotAllowed => "LOCATION_NOT_ALLOWED".to_string(),
                Self::ResponseTimeOut => "RESPONSE_TIME_OUT".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for LocationPrivacyVerResult {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "LOCATION_ALLOWED" => Ok(Self::LocationAllowed),
                "LOCATION_NOT_ALLOWED" => Ok(Self::LocationNotAllowed),
                "RESPONSE_TIME_OUT" => Ok(Self::ResponseTimeOut),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for LocationPrivacyVerResult {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LocationPrivacyVerResult {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LocationPrivacyVerResult {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///QoS of Location request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "QoS of Location request.",
    ///  "type": "object",
    ///  "properties": {
    ///    "hAccuracy": {
    ///      "$ref": "#/components/schemas/schemas-Accuracy"
    ///    },
    ///    "lcsQosClass": {
    ///      "$ref": "#/components/schemas/LcsQosClass"
    ///    },
    ///    "minorLocQoses": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/MinorLocationQoS"
    ///      },
    ///      "maxItems": 2,
    ///      "minItems": 1
    ///    },
    ///    "responseTime": {
    ///      "$ref": "#/components/schemas/ResponseTime"
    ///    },
    ///    "vAccuracy": {
    ///      "$ref": "#/components/schemas/schemas-Accuracy"
    ///    },
    ///    "verticalRequested": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LocationQoS {
        #[serde(rename = "hAccuracy", default, skip_serializing_if = "Option::is_none")]
        pub h_accuracy: Option<SchemasAccuracy>,
        #[serde(
            rename = "lcsQosClass",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub lcs_qos_class: Option<LcsQosClass>,
        #[serde(
            rename = "minorLocQoses",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub minor_loc_qoses: Vec<MinorLocationQoS>,
        #[serde(
            rename = "responseTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub response_time: Option<ResponseTime>,
        #[serde(rename = "vAccuracy", default, skip_serializing_if = "Option::is_none")]
        pub v_accuracy: Option<SchemasAccuracy>,
        #[serde(
            rename = "verticalRequested",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub vertical_requested: Option<bool>,
    }

    impl From<&LocationQoS> for LocationQoS {
        fn from(value: &LocationQoS) -> Self {
            value.clone()
        }
    }

    ///Type of location measurement requested
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Type of location measurement requested",
    ///  "type": "string",
    ///  "enum": [
    ///    "CURRENT_LOCATION",
    ///    "CURRENT_OR_LAST_KNOWN_LOCATION",
    ///    "NOTIFICATION_VERIFICATION_ONLY",
    ///    "DEFERRED_LOCATION"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LocationType {
        #[serde(rename = "CURRENT_LOCATION")]
        CurrentLocation,
        #[serde(rename = "CURRENT_OR_LAST_KNOWN_LOCATION")]
        CurrentOrLastKnownLocation,
        #[serde(rename = "NOTIFICATION_VERIFICATION_ONLY")]
        NotificationVerificationOnly,
        #[serde(rename = "DEFERRED_LOCATION")]
        DeferredLocation,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&LocationType> for LocationType {
        fn from(value: &LocationType) -> Self {
            value.clone()
        }
    }

    impl ToString for LocationType {
        fn to_string(&self) -> String {
            match *self {
                Self::CurrentLocation => "CURRENT_LOCATION".to_string(),
                Self::CurrentOrLastKnownLocation => "CURRENT_OR_LAST_KNOWN_LOCATION".to_string(),
                Self::NotificationVerificationOnly => "NOTIFICATION_VERIFICATION_ONLY".to_string(),
                Self::DeferredLocation => "DEFERRED_LOCATION".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for LocationType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "CURRENT_LOCATION" => Ok(Self::CurrentLocation),
                "CURRENT_OR_LAST_KNOWN_LOCATION" => Ok(Self::CurrentOrLastKnownLocation),
                "NOTIFICATION_VERIFICATION_ONLY" => Ok(Self::NotificationVerificationOnly),
                "DEFERRED_LOCATION" => Ok(Self::DeferredLocation),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for LocationType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LocationType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LocationType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Describes the reason for loss of connectivity
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the reason for loss of connectivity",
    ///  "type": "string",
    ///  "enum": [
    ///    "DEREGISTERED",
    ///    "MAX_DETECTION_TIME_EXPIRED",
    ///    "PURGED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum LossOfConnectivityReason {
        #[serde(rename = "DEREGISTERED")]
        Deregistered,
        #[serde(rename = "MAX_DETECTION_TIME_EXPIRED")]
        MaxDetectionTimeExpired,
        #[serde(rename = "PURGED")]
        Purged,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&LossOfConnectivityReason> for LossOfConnectivityReason {
        fn from(value: &LossOfConnectivityReason) -> Self {
            value.clone()
        }
    }

    impl ToString for LossOfConnectivityReason {
        fn to_string(&self) -> String {
            match *self {
                Self::Deregistered => "DEREGISTERED".to_string(),
                Self::MaxDetectionTimeExpired => "MAX_DETECTION_TIME_EXPIRED".to_string(),
                Self::Purged => "PURGED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for LossOfConnectivityReason {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DEREGISTERED" => Ok(Self::Deregistered),
                "MAX_DETECTION_TIME_EXPIRED" => Ok(Self::MaxDetectionTimeExpired),
                "PURGED" => Ok(Self::Purged),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for LossOfConnectivityReason {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for LossOfConnectivityReason {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for LossOfConnectivityReason {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///LTE-M Indication.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "LTE-M Indication.",
    ///  "type": "object",
    ///  "required": [
    ///    "lteCatMInd"
    ///  ],
    ///  "properties": {
    ///    "lteCatMInd": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LteMInd {
        #[serde(rename = "lteCatMInd")]
        pub lte_cat_m_ind: bool,
    }

    impl From<&LteMInd> for LteMInd {
        fn from(value: &LteMInd) -> Self {
            value.clone()
        }
    }

    ///Contains LTE V2X services authorized information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains LTE V2X services authorized information.",
    ///  "type": "object",
    ///  "properties": {
    ///    "pedestrianUeAuth": {
    ///      "$ref": "#/components/schemas/UeAuth"
    ///    },
    ///    "vehicleUeAuth": {
    ///      "$ref": "#/components/schemas/UeAuth"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct LteV2xAuth {
        #[serde(
            rename = "pedestrianUeAuth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pedestrian_ue_auth: Option<UeAuth>,
        #[serde(
            rename = "vehicleUeAuth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub vehicle_ue_auth: Option<UeAuth>,
    }

    impl From<&LteV2xAuth> for LteV2xAuth {
        fn from(value: &LteV2xAuth) -> Self {
            value.clone()
        }
    }

    ///String identifying a MAC address formatted in the hexadecimal notation
    /// according to clause 1.1 and clause 2.1 of RFC 7042.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String identifying a MAC address formatted in the
    /// hexadecimal notation according to clause 1.1 and clause 2.1 of RFC
    /// 7042.\n",
    ///  "type": "string",
    ///  "pattern": "^([0-9a-fA-F]{2})((-[0-9a-fA-F]{2}){5})$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct MacAddr48(String);
    impl ::std::ops::Deref for MacAddr48 {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<MacAddr48> for String {
        fn from(value: MacAddr48) -> Self {
            value.0
        }
    }

    impl From<&MacAddr48> for MacAddr48 {
        fn from(value: &MacAddr48) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for MacAddr48 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^([0-9a-fA-F]{2})((-[0-9a-fA-F]{2}){5})$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err(
                    "doesn't match pattern \"^([0-9a-fA-F]{2})((-[0-9a-fA-F]{2}){5})$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for MacAddr48 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for MacAddr48 {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for MacAddr48 {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for MacAddr48 {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Possible values are:
    /// - ASCENDING: Threshold is crossed in ascending direction.
    /// - DESCENDING: Threshold is crossed in descending direction.
    /// - CROSSED: Threshold is crossed either in ascending or descending
    ///   direction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- ASCENDING: Threshold is crossed
    /// in ascending direction.\n- DESCENDING: Threshold is crossed in
    /// descending direction.\n- CROSSED: Threshold is crossed either in
    /// ascending or descending direction.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "ASCENDING",
    ///    "DESCENDING",
    ///    "CROSSED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MatchingDirection {
        #[serde(rename = "ASCENDING")]
        Ascending,
        #[serde(rename = "DESCENDING")]
        Descending,
        #[serde(rename = "CROSSED")]
        Crossed,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&MatchingDirection> for MatchingDirection {
        fn from(value: &MatchingDirection) -> Self {
            value.clone()
        }
    }

    impl ToString for MatchingDirection {
        fn to_string(&self) -> String {
            match *self {
                Self::Ascending => "ASCENDING".to_string(),
                Self::Descending => "DESCENDING".to_string(),
                Self::Crossed => "CROSSED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for MatchingDirection {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ASCENDING" => Ok(Self::Ascending),
                "DESCENDING" => Ok(Self::Descending),
                "CROSSED" => Ok(Self::Crossed),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for MatchingDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for MatchingDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for MatchingDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Maximum interval between event reports.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Maximum interval between event reports.",
    ///  "type": "integer",
    ///  "maximum": 86400.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MaximumInterval(pub i64);
    impl ::std::ops::Deref for MaximumInterval {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<MaximumInterval> for i64 {
        fn from(value: MaximumInterval) -> Self {
            value.0
        }
    }

    impl From<&MaximumInterval> for MaximumInterval {
        fn from(value: &MaximumInterval) -> Self {
            value.clone()
        }
    }

    impl From<i64> for MaximumInterval {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for MaximumInterval {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for MaximumInterval {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for MaximumInterval {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for MaximumInterval {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for MaximumInterval {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///MBS Service Area
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "MBS Service Area",
    ///  "type": "object",
    ///  "anyOf": [
    ///    {
    ///      "required": [
    ///        "ncgiList"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "taiList"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "ncgiList": {
    ///      "description": "List of NR cell Ids",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NcgiTai"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "taiList": {
    ///      "description": "List of tracking area Ids",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Tai"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum MbsServiceArea {
        Variant0 {
            ///List of NR cell Ids
            #[serde(rename = "ncgiList")]
            ncgi_list: Vec<NcgiTai>,
        },
        Variant1 {
            ///List of tracking area Ids
            #[serde(rename = "taiList")]
            tai_list: Vec<Tai>,
        },
    }

    impl From<&MbsServiceArea> for MbsServiceArea {
        fn from(value: &MbsServiceArea) -> Self {
            value.clone()
        }
    }

    ///MBS Service Area Information for location dependent MBS session
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "MBS Service Area Information for location dependent MBS
    /// session",
    ///  "type": "object",
    ///  "required": [
    ///    "areaSessionId",
    ///    "mbsServiceArea"
    ///  ],
    ///  "properties": {
    ///    "areaSessionId": {
    ///      "$ref": "#/components/schemas/Uint16"
    ///    },
    ///    "mbsServiceArea": {
    ///      "$ref": "#/components/schemas/MbsServiceArea"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MbsServiceAreaInfo {
        #[serde(rename = "areaSessionId")]
        pub area_session_id: Uint16,
        #[serde(rename = "mbsServiceArea")]
        pub mbs_service_area: MbsServiceArea,
    }

    impl From<&MbsServiceAreaInfo> for MbsServiceAreaInfo {
        fn from(value: &MbsServiceAreaInfo) -> Self {
            value.clone()
        }
    }

    ///Mobile Country Code part of the PLMN, comprising 3 digits, as defined in
    /// clause 9.3.3.5 of 3GPP TS 38.413.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Mobile Country Code part of the PLMN, comprising 3
    /// digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413. \n",
    ///  "type": "string",
    ///  "pattern": "^\\d{3}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct Mcc(String);
    impl ::std::ops::Deref for Mcc {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Mcc> for String {
        fn from(value: Mcc) -> Self {
            value.0
        }
    }

    impl From<&Mcc> for Mcc {
        fn from(value: &Mcc) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Mcc {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^\\d{3}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^\\d{3}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Mcc {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for Mcc {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for Mcc {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Mcc {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The enumeration MeasurementLteForMdt defines Measurements used for MDT
    /// in LTE in the trace. See 3GPP TS 32.422 for further description of the
    /// values. It shall comply with the provisions defined in table 5.6.3.5-1.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration MeasurementLteForMdt defines
    /// Measurements used for MDT in LTE in the trace. See 3GPP TS 32.422 for
    /// further description of the values. It shall comply with the provisions
    /// defined in table 5.6.3.5-1.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "M1",
    ///    "M2",
    ///    "M3",
    ///    "M4_DL",
    ///    "M4_UL",
    ///    "M5_DL",
    ///    "M5_UL",
    ///    "M6_DL",
    ///    "M6_UL",
    ///    "M7_DL",
    ///    "M7_UL",
    ///    "M8",
    ///    "M9"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MeasurementLteForMdt {
        M1,
        M2,
        M3,
        #[serde(rename = "M4_DL")]
        M4Dl,
        #[serde(rename = "M4_UL")]
        M4Ul,
        #[serde(rename = "M5_DL")]
        M5Dl,
        #[serde(rename = "M5_UL")]
        M5Ul,
        #[serde(rename = "M6_DL")]
        M6Dl,
        #[serde(rename = "M6_UL")]
        M6Ul,
        #[serde(rename = "M7_DL")]
        M7Dl,
        #[serde(rename = "M7_UL")]
        M7Ul,
        M8,
        M9,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&MeasurementLteForMdt> for MeasurementLteForMdt {
        fn from(value: &MeasurementLteForMdt) -> Self {
            value.clone()
        }
    }

    impl ToString for MeasurementLteForMdt {
        fn to_string(&self) -> String {
            match *self {
                Self::M1 => "M1".to_string(),
                Self::M2 => "M2".to_string(),
                Self::M3 => "M3".to_string(),
                Self::M4Dl => "M4_DL".to_string(),
                Self::M4Ul => "M4_UL".to_string(),
                Self::M5Dl => "M5_DL".to_string(),
                Self::M5Ul => "M5_UL".to_string(),
                Self::M6Dl => "M6_DL".to_string(),
                Self::M6Ul => "M6_UL".to_string(),
                Self::M7Dl => "M7_DL".to_string(),
                Self::M7Ul => "M7_UL".to_string(),
                Self::M8 => "M8".to_string(),
                Self::M9 => "M9".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for MeasurementLteForMdt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "M1" => Ok(Self::M1),
                "M2" => Ok(Self::M2),
                "M3" => Ok(Self::M3),
                "M4_DL" => Ok(Self::M4Dl),
                "M4_UL" => Ok(Self::M4Ul),
                "M5_DL" => Ok(Self::M5Dl),
                "M5_UL" => Ok(Self::M5Ul),
                "M6_DL" => Ok(Self::M6Dl),
                "M6_UL" => Ok(Self::M6Ul),
                "M7_DL" => Ok(Self::M7Dl),
                "M7_UL" => Ok(Self::M7Ul),
                "M8" => Ok(Self::M8),
                "M9" => Ok(Self::M9),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for MeasurementLteForMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for MeasurementLteForMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for MeasurementLteForMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The enumeration MeasurementNrForMdt defines Measurements used for MDT in
    /// NR in the trace. See 3GPP TS 32.422 for further description of the
    /// values. It shall comply with the provisions defined in table5.6.3.6-1.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration MeasurementNrForMdt defines
    /// Measurements used for MDT in NR in the trace. See 3GPP TS 32.422 for
    /// further description of the values. It shall comply with the provisions
    /// defined in table5.6.3.6-1.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "M1",
    ///    "M2",
    ///    "M3",
    ///    "M4_DL",
    ///    "M4_UL",
    ///    "M5_DL",
    ///    "M5_UL",
    ///    "M6_DL",
    ///    "M6_UL",
    ///    "M7_DL",
    ///    "M7_UL",
    ///    "M8",
    ///    "M9"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MeasurementNrForMdt {
        M1,
        M2,
        M3,
        #[serde(rename = "M4_DL")]
        M4Dl,
        #[serde(rename = "M4_UL")]
        M4Ul,
        #[serde(rename = "M5_DL")]
        M5Dl,
        #[serde(rename = "M5_UL")]
        M5Ul,
        #[serde(rename = "M6_DL")]
        M6Dl,
        #[serde(rename = "M6_UL")]
        M6Ul,
        #[serde(rename = "M7_DL")]
        M7Dl,
        #[serde(rename = "M7_UL")]
        M7Ul,
        M8,
        M9,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&MeasurementNrForMdt> for MeasurementNrForMdt {
        fn from(value: &MeasurementNrForMdt) -> Self {
            value.clone()
        }
    }

    impl ToString for MeasurementNrForMdt {
        fn to_string(&self) -> String {
            match *self {
                Self::M1 => "M1".to_string(),
                Self::M2 => "M2".to_string(),
                Self::M3 => "M3".to_string(),
                Self::M4Dl => "M4_DL".to_string(),
                Self::M4Ul => "M4_UL".to_string(),
                Self::M5Dl => "M5_DL".to_string(),
                Self::M5Ul => "M5_UL".to_string(),
                Self::M6Dl => "M6_DL".to_string(),
                Self::M6Ul => "M6_UL".to_string(),
                Self::M7Dl => "M7_DL".to_string(),
                Self::M7Ul => "M7_UL".to_string(),
                Self::M8 => "M8".to_string(),
                Self::M9 => "M9".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for MeasurementNrForMdt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "M1" => Ok(Self::M1),
                "M2" => Ok(Self::M2),
                "M3" => Ok(Self::M3),
                "M4_DL" => Ok(Self::M4Dl),
                "M4_UL" => Ok(Self::M4Ul),
                "M5_DL" => Ok(Self::M5Dl),
                "M5_UL" => Ok(Self::M5Ul),
                "M6_DL" => Ok(Self::M6Dl),
                "M6_UL" => Ok(Self::M6Ul),
                "M7_DL" => Ok(Self::M7Dl),
                "M7_UL" => Ok(Self::M7Ul),
                "M8" => Ok(Self::M8),
                "M9" => Ok(Self::M9),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for MeasurementNrForMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for MeasurementNrForMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for MeasurementNrForMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The enumeration MeasurementPeriodLteMdt defines Measurement period LTE
    /// for MDT in the trace.  See 3GPP TS 32.422 for further description of the
    /// values. It shall comply with the provisions defined in table 5.6.3.16-1.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration MeasurementPeriodLteMdt defines
    /// Measurement period LTE for MDT in the trace.  See 3GPP TS 32.422 for
    /// further description of the values. It shall comply with the provisions
    /// defined in table 5.6.3.16-1.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    1024,
    ///    1280,
    ///    2048,
    ///    2560,
    ///    5120,
    ///    10240,
    ///    60000
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum MeasurementPeriodLteMdt {
        #[serde(rename = "1024")]
        NUM1024,
        #[serde(rename = "1280")]
        NUM1280,
        #[serde(rename = "2048")]
        NUM2048,
        #[serde(rename = "2560")]
        NUM2560,
        #[serde(rename = "5120")]
        NUM5120,
        #[serde(rename = "10240")]
        NUM10240,
        #[serde(rename = "60000")]
        NUM60000,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&MeasurementPeriodLteMdt> for MeasurementPeriodLteMdt {
        fn from(value: &MeasurementPeriodLteMdt) -> Self {
            value.clone()
        }
    }

    impl ToString for MeasurementPeriodLteMdt {
        fn to_string(&self) -> String {
            match *self {
                Self::NUM1024 => "1024".to_string(),
                Self::NUM1280 => "1280".to_string(),
                Self::NUM2048 => "2048".to_string(),
                Self::NUM2560 => "2560".to_string(),
                Self::NUM5120 => "5120".to_string(),
                Self::NUM10240 => "10240".to_string(),
                Self::NUM60000 => "60000".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for MeasurementPeriodLteMdt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "1024" => Ok(Self::NUM1024),
                "1280" => Ok(Self::NUM1280),
                "2048" => Ok(Self::NUM2048),
                "2560" => Ok(Self::NUM2560),
                "5120" => Ok(Self::NUM5120),
                "10240" => Ok(Self::NUM10240),
                "60000" => Ok(Self::NUM60000),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for MeasurementPeriodLteMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for MeasurementPeriodLteMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for MeasurementPeriodLteMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Minimum interval between event reports.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Minimum interval between event reports.",
    ///  "type": "integer",
    ///  "maximum": 32767.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MinimumInterval(pub i64);
    impl ::std::ops::Deref for MinimumInterval {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<MinimumInterval> for i64 {
        fn from(value: MinimumInterval) -> Self {
            value.0
        }
    }

    impl From<&MinimumInterval> for MinimumInterval {
        fn from(value: &MinimumInterval) -> Self {
            value.clone()
        }
    }

    impl From<i64> for MinimumInterval {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for MinimumInterval {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for MinimumInterval {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for MinimumInterval {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for MinimumInterval {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for MinimumInterval {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Contain Minor Location QoS.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contain Minor Location QoS.",
    ///  "type": "object",
    ///  "properties": {
    ///    "hAccuracy": {
    ///      "$ref": "#/components/schemas/schemas-Accuracy"
    ///    },
    ///    "vAccuracy": {
    ///      "$ref": "#/components/schemas/schemas-Accuracy"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MinorLocationQoS {
        #[serde(rename = "hAccuracy", default, skip_serializing_if = "Option::is_none")]
        pub h_accuracy: Option<SchemasAccuracy>,
        #[serde(rename = "vAccuracy", default, skip_serializing_if = "Option::is_none")]
        pub v_accuracy: Option<SchemasAccuracy>,
    }

    impl From<&MinorLocationQoS> for MinorLocationQoS {
        fn from(value: &MinorLocationQoS) -> Self {
            value.clone()
        }
    }

    ///Represents a Mobility Management Context in UE Context
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a Mobility Management Context in UE
    /// Context",
    ///  "type": "object",
    ///  "required": [
    ///    "accessType"
    ///  ],
    ///  "properties": {
    ///    "accessType": {
    ///      "$ref": "#/components/schemas/AccessType"
    ///    },
    ///    "allowedHomeNssai": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Snssai"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "allowedNssai": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Snssai"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "anN2ApId": {
    ///      "type": "integer"
    ///    },
    ///    "epsNasSecurityMode": {
    ///      "$ref": "#/components/schemas/EpsNasSecurityMode"
    ///    },
    ///    "expectedUEbehavior": {
    ///      "$ref": "#/components/schemas/ExpectedUeBehavior"
    ///    },
    ///    "manAssiUeRadioCapId": {
    ///      "$ref": "#/components/schemas/Bytes"
    ///    },
    ///    "n3IwfId": {
    ///      "$ref": "#/components/schemas/GlobalRanNodeId"
    ///    },
    ///    "nasDownlinkCount": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "nasSecurityMode": {
    ///      "$ref": "#/components/schemas/NasSecurityMode"
    ///    },
    ///    "nasUplinkCount": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "nsInstanceList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NsiId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "nssaaStatusList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NssaaStatus"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "nssaiMappingList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NssaiMapping"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "pendingNssaiMappingList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NssaiMapping"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "plmnAssiUeRadioCapId": {
    ///      "$ref": "#/components/schemas/Bytes"
    ///    },
    ///    "s1UeNetworkCapability": {
    ///      "$ref": "#/components/schemas/Bytes"
    ///    },
    ///    "tngfId": {
    ///      "$ref": "#/components/schemas/GlobalRanNodeId"
    ///    },
    ///    "ucmfDicEntryId": {
    ///      "type": "string"
    ///    },
    ///    "ueDifferentiationInfo": {
    ///      "$ref": "#/components/schemas/UeDifferentiationInfo"
    ///    },
    ///    "ueSecurityCapability": {
    ///      "$ref": "#/components/schemas/Bytes"
    ///    },
    ///    "uuaaMmStatus": {
    ///      "$ref": "#/components/schemas/UuaaMmStatus"
    ///    },
    ///    "wagfId": {
    ///      "$ref": "#/components/schemas/GlobalRanNodeId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MmContext {
        #[serde(rename = "accessType")]
        pub access_type: AccessType,
        #[serde(
            rename = "allowedHomeNssai",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub allowed_home_nssai: Vec<Snssai>,
        #[serde(
            rename = "allowedNssai",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub allowed_nssai: Vec<Snssai>,
        #[serde(rename = "anN2ApId", default, skip_serializing_if = "Option::is_none")]
        pub an_n2_ap_id: Option<i64>,
        #[serde(
            rename = "epsNasSecurityMode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub eps_nas_security_mode: Option<EpsNasSecurityMode>,
        #[serde(
            rename = "expectedUEbehavior",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub expected_u_ebehavior: Option<ExpectedUeBehavior>,
        #[serde(
            rename = "manAssiUeRadioCapId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub man_assi_ue_radio_cap_id: Option<Bytes>,
        #[serde(rename = "n3IwfId", default, skip_serializing_if = "Option::is_none")]
        pub n3_iwf_id: Option<GlobalRanNodeId>,
        #[serde(
            rename = "nasDownlinkCount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nas_downlink_count: Option<Uinteger>,
        #[serde(
            rename = "nasSecurityMode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nas_security_mode: Option<NasSecurityMode>,
        #[serde(
            rename = "nasUplinkCount",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nas_uplink_count: Option<Uinteger>,
        #[serde(
            rename = "nsInstanceList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub ns_instance_list: Vec<NsiId>,
        #[serde(
            rename = "nssaaStatusList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub nssaa_status_list: Vec<NssaaStatus>,
        #[serde(
            rename = "nssaiMappingList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub nssai_mapping_list: Vec<NssaiMapping>,
        #[serde(
            rename = "pendingNssaiMappingList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub pending_nssai_mapping_list: Vec<NssaiMapping>,
        #[serde(
            rename = "plmnAssiUeRadioCapId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub plmn_assi_ue_radio_cap_id: Option<Bytes>,
        #[serde(
            rename = "s1UeNetworkCapability",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub s1_ue_network_capability: Option<Bytes>,
        #[serde(rename = "tngfId", default, skip_serializing_if = "Option::is_none")]
        pub tngf_id: Option<GlobalRanNodeId>,
        #[serde(
            rename = "ucmfDicEntryId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ucmf_dic_entry_id: Option<String>,
        #[serde(
            rename = "ueDifferentiationInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_differentiation_info: Option<UeDifferentiationInfo>,
        #[serde(
            rename = "ueSecurityCapability",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_security_capability: Option<Bytes>,
        #[serde(
            rename = "uuaaMmStatus",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub uuaa_mm_status: Option<UuaaMmStatus>,
        #[serde(rename = "wagfId", default, skip_serializing_if = "Option::is_none")]
        pub wagf_id: Option<GlobalRanNodeId>,
    }

    impl From<&MmContext> for MmContext {
        fn from(value: &MmContext) -> Self {
            value.clone()
        }
    }

    ///UE MM Transaction Report Item per Location
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "UE MM Transaction Report Item per Location",
    ///  "type": "object",
    ///  "required": [
    ///    "timestamp",
    ///    "transactions"
    ///  ],
    ///  "properties": {
    ///    "ecgi": {
    ///      "$ref": "#/components/schemas/Ecgi"
    ///    },
    ///    "n3gaLocation": {
    ///      "$ref": "#/components/schemas/N3gaLocation"
    ///    },
    ///    "ncgi": {
    ///      "$ref": "#/components/schemas/Ncgi"
    ///    },
    ///    "tai": {
    ///      "$ref": "#/components/schemas/Tai"
    ///    },
    ///    "timestamp": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "transactions": {
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MmTransactionLocationReportItem {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ecgi: Option<Ecgi>,
        #[serde(
            rename = "n3gaLocation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n3ga_location: Option<N3gaLocation>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ncgi: Option<Ncgi>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub tai: Option<Tai>,
        pub timestamp: DateTime,
        pub transactions: i64,
    }

    impl From<&MmTransactionLocationReportItem> for MmTransactionLocationReportItem {
        fn from(value: &MmTransactionLocationReportItem) -> Self {
            value.clone()
        }
    }

    ///UE MM Transaction Report Item per Slice
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "UE MM Transaction Report Item per Slice",
    ///  "type": "object",
    ///  "required": [
    ///    "timestamp",
    ///    "transactions"
    ///  ],
    ///  "properties": {
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "timestamp": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "transactions": {
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MmTransactionSliceReportItem {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub snssai: Option<Snssai>,
        pub timestamp: DateTime,
        pub transactions: i64,
    }

    impl From<&MmTransactionSliceReportItem> for MmTransactionSliceReportItem {
        fn from(value: &MmTransactionSliceReportItem) -> Self {
            value.clone()
        }
    }

    ///Mobile Network Code part of the PLMN, comprising 2 or 3 digits, as
    /// defined in clause 9.3.3.5 of 3GPP TS 38.413.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Mobile Network Code part of the PLMN, comprising 2 or 3
    /// digits, as defined in clause 9.3.3.5 of 3GPP TS 38.413.",
    ///  "type": "string",
    ///  "pattern": "^\\d{2,3}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct Mnc(String);
    impl ::std::ops::Deref for Mnc {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Mnc> for String {
        fn from(value: Mnc) -> Self {
            value.0
        }
    }

    impl From<&Mnc> for Mnc {
        fn from(value: &Mnc) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Mnc {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^\\d{2,3}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^\\d{2,3}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Mnc {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for Mnc {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for Mnc {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Mnc {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Contain the MO Exception Data Counter.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contain the MO Exception Data Counter.",
    ///  "type": "object",
    ///  "required": [
    ///    "counter"
    ///  ],
    ///  "properties": {
    ///    "counter": {
    ///      "description": "Unsigned integer identifying the MO Exception Data
    /// Counter, as specified in clause 5.31.14.3 of 3GPP TS 23.501.\n",
    ///      "type": "integer"
    ///    },
    ///    "timeStamp": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MoExpDataCounter {
        ///Unsigned integer identifying the MO Exception Data Counter, as
        /// specified in clause 5.31.14.3 of 3GPP TS 23.501.
        pub counter: i64,
        #[serde(rename = "timeStamp", default, skip_serializing_if = "Option::is_none")]
        pub time_stamp: Option<DateTime>,
    }

    impl From<&MoExpDataCounter> for MoExpDataCounter {
        fn from(value: &MoExpDataCounter) -> Self {
            value.clone()
        }
    }

    ///Indicates the information of motion based event reporting.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the information of motion based event
    /// reporting.",
    ///  "type": "object",
    ///  "required": [
    ///    "linearDistance"
    ///  ],
    ///  "properties": {
    ///    "linearDistance": {
    ///      "$ref": "#/components/schemas/LinearDistance"
    ///    },
    ///    "maximumInterval": {
    ///      "$ref": "#/components/schemas/MaximumInterval"
    ///    },
    ///    "minimumInterval": {
    ///      "$ref": "#/components/schemas/MinimumInterval"
    ///    },
    ///    "occurrenceInfo": {
    ///      "$ref": "#/components/schemas/OccurrenceInfo"
    ///    },
    ///    "reportingDuration": {
    ///      "$ref": "#/components/schemas/ReportingDuration"
    ///    },
    ///    "reportingLocationReq": {
    ///      "default": true,
    ///      "type": "boolean"
    ///    },
    ///    "samplingInterval": {
    ///      "$ref": "#/components/schemas/SamplingInterval"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MotionEventInfo {
        #[serde(rename = "linearDistance")]
        pub linear_distance: LinearDistance,
        #[serde(
            rename = "maximumInterval",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub maximum_interval: Option<MaximumInterval>,
        #[serde(
            rename = "minimumInterval",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub minimum_interval: Option<MinimumInterval>,
        #[serde(
            rename = "occurrenceInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub occurrence_info: Option<OccurrenceInfo>,
        #[serde(
            rename = "reportingDuration",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub reporting_duration: Option<ReportingDuration>,
        #[serde(
            rename = "reportingLocationReq",
            default = "defaults::default_bool::<true>"
        )]
        pub reporting_location_req: bool,
        #[serde(
            rename = "samplingInterval",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub sampling_interval: Option<SamplingInterval>,
    }

    impl From<&MotionEventInfo> for MotionEventInfo {
        fn from(value: &MotionEventInfo) -> Self {
            value.clone()
        }
    }

    ///MsClassmark2
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "$ref": "#/components/schemas/Bytes"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct MsClassmark2(pub Bytes);
    impl ::std::ops::Deref for MsClassmark2 {
        type Target = Bytes;
        fn deref(&self) -> &Bytes {
            &self.0
        }
    }

    impl From<MsClassmark2> for Bytes {
        fn from(value: MsClassmark2) -> Self {
            value.0
        }
    }

    impl From<&MsClassmark2> for MsClassmark2 {
        fn from(value: &MsClassmark2) -> Self {
            value.clone()
        }
    }

    impl From<Bytes> for MsClassmark2 {
        fn from(value: Bytes) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for MsClassmark2 {
        type Err = <Bytes as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for MsClassmark2 {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for MsClassmark2 {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for MsClassmark2 {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for MsClassmark2 {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Enumeration for N1 Message Class
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Enumeration for N1 Message Class",
    ///  "type": "string",
    ///  "enum": [
    ///    "5GMM",
    ///    "SM",
    ///    "LPP",
    ///    "SMS",
    ///    "UPDP",
    ///    "LCS"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum N1MessageClass {
        #[serde(rename = "5GMM")]
        FiveGmm,
        #[serde(rename = "SM")]
        Sm,
        #[serde(rename = "LPP")]
        Lpp,
        #[serde(rename = "SMS")]
        Sms,
        #[serde(rename = "UPDP")]
        Updp,
        #[serde(rename = "LCS")]
        Lcs,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&N1MessageClass> for N1MessageClass {
        fn from(value: &N1MessageClass) -> Self {
            value.clone()
        }
    }

    impl ToString for N1MessageClass {
        fn to_string(&self) -> String {
            match *self {
                Self::FiveGmm => "5GMM".to_string(),
                Self::Sm => "SM".to_string(),
                Self::Lpp => "LPP".to_string(),
                Self::Sms => "SMS".to_string(),
                Self::Updp => "UPDP".to_string(),
                Self::Lcs => "LCS".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for N1MessageClass {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "5GMM" => Ok(Self::FiveGmm),
                "SM" => Ok(Self::Sm),
                "LPP" => Ok(Self::Lpp),
                "SMS" => Ok(Self::Sms),
                "UPDP" => Ok(Self::Updp),
                "LCS" => Ok(Self::Lcs),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for N1MessageClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for N1MessageClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for N1MessageClass {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///N1 Message container
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "N1 Message container",
    ///  "type": "object",
    ///  "required": [
    ///    "n1MessageClass",
    ///    "n1MessageContent"
    ///  ],
    ///  "properties": {
    ///    "n1MessageClass": {
    ///      "$ref": "#/components/schemas/N1MessageClass"
    ///    },
    ///    "n1MessageContent": {
    ///      "$ref": "#/components/schemas/RefToBinaryData"
    ///    },
    ///    "nfId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "serviceInstanceId": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N1MessageContainer {
        #[serde(rename = "n1MessageClass")]
        pub n1_message_class: N1MessageClass,
        #[serde(rename = "n1MessageContent")]
        pub n1_message_content: RefToBinaryData,
        #[serde(rename = "nfId", default, skip_serializing_if = "Option::is_none")]
        pub nf_id: Option<NfInstanceId>,
        #[serde(
            rename = "serviceInstanceId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub service_instance_id: Option<String>,
    }

    impl From<&N1MessageContainer> for N1MessageContainer {
        fn from(value: &N1MessageContainer) -> Self {
            value.clone()
        }
    }

    ///Data within a N1 message notification request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a N1 message notification request",
    ///  "type": "object",
    ///  "required": [
    ///    "n1MessageContainer"
    ///  ],
    ///  "properties": {
    ///    "cIoT5GSOptimisation": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "ecgi": {
    ///      "$ref": "#/components/schemas/Ecgi"
    ///    },
    ///    "guami": {
    ///      "$ref": "#/components/schemas/Guami"
    ///    },
    ///    "lcsCorrelationId": {
    ///      "$ref": "#/components/schemas/CorrelationID"
    ///    },
    ///    "n1MessageContainer": {
    ///      "$ref": "#/components/schemas/N1MessageContainer"
    ///    },
    ///    "n1NotifySubscriptionId": {
    ///      "type": "string"
    ///    },
    ///    "ncgi": {
    ///      "$ref": "#/components/schemas/Ncgi"
    ///    },
    ///    "newLmfIdentification": {
    ///      "$ref": "#/components/schemas/LMFIdentification"
    ///    },
    ///    "registrationCtxtContainer": {
    ///      "$ref": "#/components/schemas/RegistrationContextContainer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N1MessageNotification {
        #[serde(rename = "cIoT5GSOptimisation", default)]
        pub c_io_t5gs_optimisation: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ecgi: Option<Ecgi>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub guami: Option<Guami>,
        #[serde(
            rename = "lcsCorrelationId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub lcs_correlation_id: Option<CorrelationId>,
        #[serde(rename = "n1MessageContainer")]
        pub n1_message_container: N1MessageContainer,
        #[serde(
            rename = "n1NotifySubscriptionId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n1_notify_subscription_id: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ncgi: Option<Ncgi>,
        #[serde(
            rename = "newLmfIdentification",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub new_lmf_identification: Option<LmfIdentification>,
        #[serde(
            rename = "registrationCtxtContainer",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub registration_ctxt_container: Option<RegistrationContextContainer>,
    }

    impl From<&N1MessageNotification> for N1MessageNotification {
        fn from(value: &N1MessageNotification) -> Self {
            value.clone()
        }
    }

    ///Enumeration for N1N2Message Transfer Cause
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Enumeration for N1N2Message Transfer Cause",
    ///  "type": "string",
    ///  "enum": [
    ///    "ATTEMPTING_TO_REACH_UE",
    ///    "N1_N2_TRANSFER_INITIATED",
    ///    "WAITING_FOR_ASYNCHRONOUS_TRANSFER",
    ///    "UE_NOT_RESPONDING",
    ///    "N1_MSG_NOT_TRANSFERRED",
    ///    "N2_MSG_NOT_TRANSFERRED",
    ///    "UE_NOT_REACHABLE_FOR_SESSION",
    ///    "TEMPORARY_REJECT_REGISTRATION_ONGOING",
    ///    "TEMPORARY_REJECT_HANDOVER_ONGOING",
    ///    "REJECTION_DUE_TO_PAGING_RESTRICTION",
    ///    "AN_NOT_RESPONDING",
    ///    "FAILURE_CAUSE_UNSPECIFIED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum N1n2MessageTransferCause {
        #[serde(rename = "ATTEMPTING_TO_REACH_UE")]
        AttemptingToReachUe,
        #[serde(rename = "N1_N2_TRANSFER_INITIATED")]
        N1N2TransferInitiated,
        #[serde(rename = "WAITING_FOR_ASYNCHRONOUS_TRANSFER")]
        WaitingForAsynchronousTransfer,
        #[serde(rename = "UE_NOT_RESPONDING")]
        UeNotResponding,
        #[serde(rename = "N1_MSG_NOT_TRANSFERRED")]
        N1MsgNotTransferred,
        #[serde(rename = "N2_MSG_NOT_TRANSFERRED")]
        N2MsgNotTransferred,
        #[serde(rename = "UE_NOT_REACHABLE_FOR_SESSION")]
        UeNotReachableForSession,
        #[serde(rename = "TEMPORARY_REJECT_REGISTRATION_ONGOING")]
        TemporaryRejectRegistrationOngoing,
        #[serde(rename = "TEMPORARY_REJECT_HANDOVER_ONGOING")]
        TemporaryRejectHandoverOngoing,
        #[serde(rename = "REJECTION_DUE_TO_PAGING_RESTRICTION")]
        RejectionDueToPagingRestriction,
        #[serde(rename = "AN_NOT_RESPONDING")]
        AnNotResponding,
        #[serde(rename = "FAILURE_CAUSE_UNSPECIFIED")]
        FailureCauseUnspecified,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&N1n2MessageTransferCause> for N1n2MessageTransferCause {
        fn from(value: &N1n2MessageTransferCause) -> Self {
            value.clone()
        }
    }

    impl ToString for N1n2MessageTransferCause {
        fn to_string(&self) -> String {
            match *self {
                Self::AttemptingToReachUe => "ATTEMPTING_TO_REACH_UE".to_string(),
                Self::N1N2TransferInitiated => "N1_N2_TRANSFER_INITIATED".to_string(),
                Self::WaitingForAsynchronousTransfer => {
                    "WAITING_FOR_ASYNCHRONOUS_TRANSFER".to_string()
                }
                Self::UeNotResponding => "UE_NOT_RESPONDING".to_string(),
                Self::N1MsgNotTransferred => "N1_MSG_NOT_TRANSFERRED".to_string(),
                Self::N2MsgNotTransferred => "N2_MSG_NOT_TRANSFERRED".to_string(),
                Self::UeNotReachableForSession => "UE_NOT_REACHABLE_FOR_SESSION".to_string(),
                Self::TemporaryRejectRegistrationOngoing => {
                    "TEMPORARY_REJECT_REGISTRATION_ONGOING".to_string()
                }
                Self::TemporaryRejectHandoverOngoing => {
                    "TEMPORARY_REJECT_HANDOVER_ONGOING".to_string()
                }
                Self::RejectionDueToPagingRestriction => {
                    "REJECTION_DUE_TO_PAGING_RESTRICTION".to_string()
                }
                Self::AnNotResponding => "AN_NOT_RESPONDING".to_string(),
                Self::FailureCauseUnspecified => "FAILURE_CAUSE_UNSPECIFIED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for N1n2MessageTransferCause {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ATTEMPTING_TO_REACH_UE" => Ok(Self::AttemptingToReachUe),
                "N1_N2_TRANSFER_INITIATED" => Ok(Self::N1N2TransferInitiated),
                "WAITING_FOR_ASYNCHRONOUS_TRANSFER" => Ok(Self::WaitingForAsynchronousTransfer),
                "UE_NOT_RESPONDING" => Ok(Self::UeNotResponding),
                "N1_MSG_NOT_TRANSFERRED" => Ok(Self::N1MsgNotTransferred),
                "N2_MSG_NOT_TRANSFERRED" => Ok(Self::N2MsgNotTransferred),
                "UE_NOT_REACHABLE_FOR_SESSION" => Ok(Self::UeNotReachableForSession),
                "TEMPORARY_REJECT_REGISTRATION_ONGOING" => {
                    Ok(Self::TemporaryRejectRegistrationOngoing)
                }
                "TEMPORARY_REJECT_HANDOVER_ONGOING" => Ok(Self::TemporaryRejectHandoverOngoing),
                "REJECTION_DUE_TO_PAGING_RESTRICTION" => Ok(Self::RejectionDueToPagingRestriction),
                "AN_NOT_RESPONDING" => Ok(Self::AnNotResponding),
                "FAILURE_CAUSE_UNSPECIFIED" => Ok(Self::FailureCauseUnspecified),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for N1n2MessageTransferCause {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for N1n2MessageTransferCause {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for N1n2MessageTransferCause {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Data within a N1/N2 Message Transfer Error response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a N1/N2 Message Transfer Error response",
    ///  "type": "object",
    ///  "required": [
    ///    "error"
    ///  ],
    ///  "properties": {
    ///    "errInfo": {
    ///      "$ref": "#/components/schemas/N1N2MsgTxfrErrDetail"
    ///    },
    ///    "error": {
    ///      "$ref": "#/components/schemas/ProblemDetails"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N1n2MessageTransferError {
        #[serde(rename = "errInfo", default, skip_serializing_if = "Option::is_none")]
        pub err_info: Option<N1n2MsgTxfrErrDetail>,
        pub error: ProblemDetails,
    }

    impl From<&N1n2MessageTransferError> for N1n2MessageTransferError {
        fn from(value: &N1n2MessageTransferError) -> Self {
            value.clone()
        }
    }

    ///Data within a N1/N2 message transfer request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a N1/N2 message transfer request",
    ///  "type": "object",
    ///  "properties": {
    ///    "5qi": {
    ///      "$ref": "#/components/schemas/5Qi"
    ///    },
    ///    "areaOfValidity": {
    ///      "$ref": "#/components/schemas/AreaOfValidity"
    ///    },
    ///    "arp": {
    ///      "$ref": "#/components/schemas/Arp"
    ///    },
    ///    "extBufSupport": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "lastMsgIndication": {
    ///      "type": "boolean"
    ///    },
    ///    "lcsCorrelationId": {
    ///      "$ref": "#/components/schemas/CorrelationID"
    ///    },
    ///    "maAcceptedInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "mtData": {
    ///      "$ref": "#/components/schemas/RefToBinaryData"
    ///    },
    ///    "n1MessageContainer": {
    ///      "$ref": "#/components/schemas/N1MessageContainer"
    ///    },
    ///    "n1n2FailureTxfNotifURI": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "n2InfoContainer": {
    ///      "$ref": "#/components/schemas/N2InfoContainer"
    ///    },
    ///    "nfId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "oldGuami": {
    ///      "$ref": "#/components/schemas/Guami"
    ///    },
    ///    "pduSessionId": {
    ///      "$ref": "#/components/schemas/PduSessionId"
    ///    },
    ///    "ppi": {
    ///      "$ref": "#/components/schemas/Ppi"
    ///    },
    ///    "skipInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "smfReallocationInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    },
    ///    "targetAccess": {
    ///      "$ref": "#/components/schemas/AccessType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N1n2MessageTransferReqData {
        #[serde(
            rename = "areaOfValidity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub area_of_validity: Option<AreaOfValidity>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub arp: Option<Arp>,
        #[serde(rename = "extBufSupport", default)]
        pub ext_buf_support: bool,
        #[serde(rename = "5qi", default, skip_serializing_if = "Option::is_none")]
        pub five_qi: Option<_5qi>,
        #[serde(
            rename = "lastMsgIndication",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub last_msg_indication: Option<bool>,
        #[serde(
            rename = "lcsCorrelationId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub lcs_correlation_id: Option<CorrelationId>,
        #[serde(rename = "maAcceptedInd", default)]
        pub ma_accepted_ind: bool,
        #[serde(rename = "mtData", default, skip_serializing_if = "Option::is_none")]
        pub mt_data: Option<RefToBinaryData>,
        #[serde(
            rename = "n1MessageContainer",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n1_message_container: Option<N1MessageContainer>,
        #[serde(
            rename = "n1n2FailureTxfNotifURI",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n1n2_failure_txf_notif_uri: Option<Uri>,
        #[serde(
            rename = "n2InfoContainer",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n2_info_container: Option<N2InfoContainer>,
        #[serde(rename = "nfId", default, skip_serializing_if = "Option::is_none")]
        pub nf_id: Option<NfInstanceId>,
        #[serde(rename = "oldGuami", default, skip_serializing_if = "Option::is_none")]
        pub old_guami: Option<Guami>,
        #[serde(
            rename = "pduSessionId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pdu_session_id: Option<PduSessionId>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ppi: Option<Ppi>,
        #[serde(rename = "skipInd", default)]
        pub skip_ind: bool,
        #[serde(rename = "smfReallocationInd", default)]
        pub smf_reallocation_ind: bool,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
        #[serde(
            rename = "targetAccess",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_access: Option<AccessType>,
    }

    impl From<&N1n2MessageTransferReqData> for N1n2MessageTransferReqData {
        fn from(value: &N1n2MessageTransferReqData) -> Self {
            value.clone()
        }
    }

    ///Data within a N1/N2 message transfer response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a N1/N2 message transfer response",
    ///  "type": "object",
    ///  "required": [
    ///    "cause"
    ///  ],
    ///  "properties": {
    ///    "cause": {
    ///      "$ref": "#/components/schemas/N1N2MessageTransferCause"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N1n2MessageTransferRspData {
        pub cause: N1n2MessageTransferCause,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
    }

    impl From<&N1n2MessageTransferRspData> for N1n2MessageTransferRspData {
        fn from(value: &N1n2MessageTransferRspData) -> Self {
            value.clone()
        }
    }

    ///N1/N2 Message Transfer Error Details
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "N1/N2 Message Transfer Error Details",
    ///  "type": "object",
    ///  "properties": {
    ///    "highestPrioArp": {
    ///      "$ref": "#/components/schemas/Arp"
    ///    },
    ///    "maxWaitingTime": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "retryAfter": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N1n2MsgTxfrErrDetail {
        #[serde(
            rename = "highestPrioArp",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub highest_prio_arp: Option<Arp>,
        #[serde(
            rename = "maxWaitingTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_waiting_time: Option<DurationSec>,
        #[serde(
            rename = "retryAfter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub retry_after: Option<Uinteger>,
    }

    impl From<&N1n2MsgTxfrErrDetail> for N1n2MsgTxfrErrDetail {
        fn from(value: &N1n2MsgTxfrErrDetail) -> Self {
            value.clone()
        }
    }

    ///Data within a N1/N2 Message Transfer Failure Notification request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a N1/N2 Message Transfer Failure
    /// Notification request",
    ///  "type": "object",
    ///  "required": [
    ///    "cause",
    ///    "n1n2MsgDataUri"
    ///  ],
    ///  "properties": {
    ///    "cause": {
    ///      "$ref": "#/components/schemas/N1N2MessageTransferCause"
    ///    },
    ///    "n1n2MsgDataUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N1n2MsgTxfrFailureNotification {
        pub cause: N1n2MessageTransferCause,
        #[serde(rename = "n1n2MsgDataUri")]
        pub n1n2_msg_data_uri: Uri,
    }

    impl From<&N1n2MsgTxfrFailureNotification> for N1n2MsgTxfrFailureNotification {
        fn from(value: &N1n2MsgTxfrFailureNotification) -> Self {
            value.clone()
        }
    }

    ///N2 information container
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "N2 information container",
    ///  "type": "object",
    ///  "required": [
    ///    "n2InformationClass"
    ///  ],
    ///  "properties": {
    ///    "n2InformationClass": {
    ///      "$ref": "#/components/schemas/N2InformationClass"
    ///    },
    ///    "nrppaInfo": {
    ///      "$ref": "#/components/schemas/NrppaInformation"
    ///    },
    ///    "proseInfo": {
    ///      "$ref": "#/components/schemas/ProSeInformation"
    ///    },
    ///    "pwsInfo": {
    ///      "$ref": "#/components/schemas/PwsInformation"
    ///    },
    ///    "ranInfo": {
    ///      "$ref": "#/components/schemas/N2RanInformation"
    ///    },
    ///    "smInfo": {
    ///      "$ref": "#/components/schemas/N2SmInformation"
    ///    },
    ///    "v2xInfo": {
    ///      "$ref": "#/components/schemas/V2xInformation"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N2InfoContainer {
        #[serde(rename = "n2InformationClass")]
        pub n2_information_class: N2InformationClass,
        #[serde(rename = "nrppaInfo", default, skip_serializing_if = "Option::is_none")]
        pub nrppa_info: Option<NrppaInformation>,
        #[serde(rename = "proseInfo", default, skip_serializing_if = "Option::is_none")]
        pub prose_info: Option<ProSeInformation>,
        #[serde(rename = "pwsInfo", default, skip_serializing_if = "Option::is_none")]
        pub pws_info: Option<PwsInformation>,
        #[serde(rename = "ranInfo", default, skip_serializing_if = "Option::is_none")]
        pub ran_info: Option<N2RanInformation>,
        #[serde(rename = "smInfo", default, skip_serializing_if = "Option::is_none")]
        pub sm_info: Option<N2SmInformation>,
        #[serde(rename = "v2xInfo", default, skip_serializing_if = "Option::is_none")]
        pub v2x_info: Option<V2xInformation>,
    }

    impl From<&N2InfoContainer> for N2InfoContainer {
        fn from(value: &N2InfoContainer) -> Self {
            value.clone()
        }
    }

    ///Represents a transparent N2 information content to be relayed by AMF
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a transparent N2 information content to be
    /// relayed by AMF",
    ///  "type": "object",
    ///  "required": [
    ///    "ngapData"
    ///  ],
    ///  "properties": {
    ///    "ngapData": {
    ///      "$ref": "#/components/schemas/RefToBinaryData"
    ///    },
    ///    "ngapIeType": {
    ///      "$ref": "#/components/schemas/NgapIeType"
    ///    },
    ///    "ngapMessageType": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N2InfoContent {
        #[serde(rename = "ngapData")]
        pub ngap_data: RefToBinaryData,
        #[serde(
            rename = "ngapIeType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ngap_ie_type: Option<NgapIeType>,
        #[serde(
            rename = "ngapMessageType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ngap_message_type: Option<Uinteger>,
    }

    impl From<&N2InfoContent> for N2InfoContent {
        fn from(value: &N2InfoContent) -> Self {
            value.clone()
        }
    }

    ///Data within a N2 information notification response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a N2 information notification response",
    ///  "type": "object",
    ///  "properties": {
    ///    "secRatDataUsageList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/N2SmInformation"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N2InfoNotificationRspData {
        #[serde(
            rename = "secRatDataUsageList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub sec_rat_data_usage_list: Vec<N2SmInformation>,
    }

    impl From<&N2InfoNotificationRspData> for N2InfoNotificationRspData {
        fn from(value: &N2InfoNotificationRspData) -> Self {
            value.clone()
        }
    }

    ///N2 Information Notify Reason
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "N2 Information Notify Reason",
    ///  "type": "string",
    ///  "enum": [
    ///    "HANDOVER_COMPLETED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum N2InfoNotifyReason {
        #[serde(rename = "HANDOVER_COMPLETED")]
        HandoverCompleted,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&N2InfoNotifyReason> for N2InfoNotifyReason {
        fn from(value: &N2InfoNotifyReason) -> Self {
            value.clone()
        }
    }

    impl ToString for N2InfoNotifyReason {
        fn to_string(&self) -> String {
            match *self {
                Self::HandoverCompleted => "HANDOVER_COMPLETED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for N2InfoNotifyReason {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "HANDOVER_COMPLETED" => Ok(Self::HandoverCompleted),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for N2InfoNotifyReason {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for N2InfoNotifyReason {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for N2InfoNotifyReason {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Enumeration for N2 Information Class
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Enumeration for N2 Information Class",
    ///  "type": "string",
    ///  "enum": [
    ///    "SM",
    ///    "NRPPa",
    ///    "PWS",
    ///    "PWS-BCAL",
    ///    "PWS-RF",
    ///    "RAN",
    ///    "V2X",
    ///    "PROSE"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum N2InformationClass {
        #[serde(rename = "SM")]
        Sm,
        #[serde(rename = "NRPPa")]
        NrpPa,
        #[serde(rename = "PWS")]
        Pws,
        #[serde(rename = "PWS-BCAL")]
        PwsBcal,
        #[serde(rename = "PWS-RF")]
        PwsRf,
        #[serde(rename = "RAN")]
        Ran,
        #[serde(rename = "V2X")]
        V2x,
        #[serde(rename = "PROSE")]
        Prose,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&N2InformationClass> for N2InformationClass {
        fn from(value: &N2InformationClass) -> Self {
            value.clone()
        }
    }

    impl ToString for N2InformationClass {
        fn to_string(&self) -> String {
            match *self {
                Self::Sm => "SM".to_string(),
                Self::NrpPa => "NRPPa".to_string(),
                Self::Pws => "PWS".to_string(),
                Self::PwsBcal => "PWS-BCAL".to_string(),
                Self::PwsRf => "PWS-RF".to_string(),
                Self::Ran => "RAN".to_string(),
                Self::V2x => "V2X".to_string(),
                Self::Prose => "PROSE".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for N2InformationClass {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SM" => Ok(Self::Sm),
                "NRPPa" => Ok(Self::NrpPa),
                "PWS" => Ok(Self::Pws),
                "PWS-BCAL" => Ok(Self::PwsBcal),
                "PWS-RF" => Ok(Self::PwsRf),
                "RAN" => Ok(Self::Ran),
                "V2X" => Ok(Self::V2x),
                "PROSE" => Ok(Self::Prose),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for N2InformationClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for N2InformationClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for N2InformationClass {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Data within a N2 information notification request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a N2 information notification request",
    ///  "type": "object",
    ///  "required": [
    ///    "n2NotifySubscriptionId"
    ///  ],
    ///  "properties": {
    ///    "anN2IPv4Addr": {
    ///      "$ref": "#/components/schemas/Ipv4Addr"
    ///    },
    ///    "anN2IPv6Addr": {
    ///      "$ref": "#/components/schemas/Ipv6Addr"
    ///    },
    ///    "guami": {
    ///      "$ref": "#/components/schemas/Guami"
    ///    },
    ///    "initialAmfName": {
    ///      "$ref": "#/components/schemas/Fqdn"
    ///    },
    ///    "lcsCorrelationId": {
    ///      "$ref": "#/components/schemas/CorrelationID"
    ///    },
    ///    "n2InfoContainer": {
    ///      "$ref": "#/components/schemas/N2InfoContainer"
    ///    },
    ///    "n2NotifySubscriptionId": {
    ///      "type": "string"
    ///    },
    ///    "notifyReason": {
    ///      "$ref": "#/components/schemas/N2InfoNotifyReason"
    ///    },
    ///    "notifySourceNgRan": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "ranNodeId": {
    ///      "$ref": "#/components/schemas/GlobalRanNodeId"
    ///    },
    ///    "smfChangeInfoList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SmfChangeInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "toReleaseSessionList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PduSessionId"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N2InformationNotification {
        #[serde(
            rename = "anN2IPv4Addr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub an_n2i_pv4_addr: Option<Ipv4Addr>,
        #[serde(
            rename = "anN2IPv6Addr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub an_n2i_pv6_addr: Option<Ipv6Addr>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub guami: Option<Guami>,
        #[serde(
            rename = "initialAmfName",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub initial_amf_name: Option<Fqdn>,
        #[serde(
            rename = "lcsCorrelationId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub lcs_correlation_id: Option<CorrelationId>,
        #[serde(
            rename = "n2InfoContainer",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n2_info_container: Option<N2InfoContainer>,
        #[serde(rename = "n2NotifySubscriptionId")]
        pub n2_notify_subscription_id: String,
        #[serde(
            rename = "notifyReason",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub notify_reason: Option<N2InfoNotifyReason>,
        #[serde(rename = "notifySourceNgRan", default)]
        pub notify_source_ng_ran: bool,
        #[serde(rename = "ranNodeId", default, skip_serializing_if = "Option::is_none")]
        pub ran_node_id: Option<GlobalRanNodeId>,
        #[serde(
            rename = "smfChangeInfoList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub smf_change_info_list: Vec<SmfChangeInfo>,
        #[serde(
            rename = "toReleaseSessionList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub to_release_session_list: Vec<PduSessionId>,
    }

    impl From<&N2InformationNotification> for N2InformationNotification {
        fn from(value: &N2InformationNotification) -> Self {
            value.clone()
        }
    }

    ///Data within a failure response for a non-UE related N2 Information
    /// Transfer
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a failure response for a non-UE related N2
    /// Information Transfer",
    ///  "type": "object",
    ///  "required": [
    ///    "error"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "$ref": "#/components/schemas/ProblemDetails"
    ///    },
    ///    "pwsErrorInfo": {
    ///      "$ref": "#/components/schemas/PWSErrorData"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N2InformationTransferError {
        pub error: ProblemDetails,
        #[serde(
            rename = "pwsErrorInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pws_error_info: Option<PwsErrorData>,
    }

    impl From<&N2InformationTransferError> for N2InformationTransferError {
        fn from(value: &N2InformationTransferError) -> Self {
            value.clone()
        }
    }

    ///Data within a N2 Information Transfer request containing the N2
    /// information requested to be transferred to 5G AN
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a N2 Information Transfer request
    /// containing the N2 information requested to be transferred to 5G AN",
    ///  "type": "object",
    ///  "required": [
    ///    "n2Information"
    ///  ],
    ///  "properties": {
    ///    "globalRanNodeList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GlobalRanNodeId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "n2Information": {
    ///      "$ref": "#/components/schemas/N2InfoContainer"
    ///    },
    ///    "ratSelector": {
    ///      "$ref": "#/components/schemas/RatSelector"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    },
    ///    "taiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Tai"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N2InformationTransferReqData {
        #[serde(
            rename = "globalRanNodeList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub global_ran_node_list: Vec<GlobalRanNodeId>,
        #[serde(rename = "n2Information")]
        pub n2_information: N2InfoContainer,
        #[serde(
            rename = "ratSelector",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub rat_selector: Option<RatSelector>,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
        #[serde(rename = "taiList", default, skip_serializing_if = "Vec::is_empty")]
        pub tai_list: Vec<Tai>,
    }

    impl From<&N2InformationTransferReqData> for N2InformationTransferReqData {
        fn from(value: &N2InformationTransferReqData) -> Self {
            value.clone()
        }
    }

    ///Describes the result of N2 information transfer by AMF to the AN
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the result of N2 information transfer by AMF
    /// to the AN",
    ///  "type": "string",
    ///  "enum": [
    ///    "N2_INFO_TRANSFER_INITIATED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum N2InformationTransferResult {
        #[serde(rename = "N2_INFO_TRANSFER_INITIATED")]
        N2InfoTransferInitiated,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&N2InformationTransferResult> for N2InformationTransferResult {
        fn from(value: &N2InformationTransferResult) -> Self {
            value.clone()
        }
    }

    impl ToString for N2InformationTransferResult {
        fn to_string(&self) -> String {
            match *self {
                Self::N2InfoTransferInitiated => "N2_INFO_TRANSFER_INITIATED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for N2InformationTransferResult {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "N2_INFO_TRANSFER_INITIATED" => Ok(Self::N2InfoTransferInitiated),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for N2InformationTransferResult {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for N2InformationTransferResult {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for N2InformationTransferResult {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Data within a successful response to the N2 Information Transfer request
    /// to transfer N2 Information to the AN
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a successful response to the N2 Information
    /// Transfer request to transfer N2 Information to the AN",
    ///  "type": "object",
    ///  "required": [
    ///    "result"
    ///  ],
    ///  "properties": {
    ///    "pwsRspData": {
    ///      "$ref": "#/components/schemas/PWSResponseData"
    ///    },
    ///    "result": {
    ///      "$ref": "#/components/schemas/N2InformationTransferResult"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N2InformationTransferRspData {
        #[serde(
            rename = "pwsRspData",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pws_rsp_data: Option<PwsResponseData>,
        pub result: N2InformationTransferResult,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
    }

    impl From<&N2InformationTransferRspData> for N2InformationTransferRspData {
        fn from(value: &N2InformationTransferRspData) -> Self {
            value.clone()
        }
    }

    ///Represents the RAN related N2 information data part
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the RAN related N2 information data part",
    ///  "type": "object",
    ///  "required": [
    ///    "n2InfoContent"
    ///  ],
    ///  "properties": {
    ///    "n2InfoContent": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N2RanInformation {
        #[serde(rename = "n2InfoContent")]
        pub n2_info_content: N2InfoContent,
    }

    impl From<&N2RanInformation> for N2RanInformation {
        fn from(value: &N2RanInformation) -> Self {
            value.clone()
        }
    }

    ///Represents the session management SMF related N2 information data part
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the session management SMF related N2
    /// information data part",
    ///  "type": "object",
    ///  "required": [
    ///    "pduSessionId"
    ///  ],
    ///  "properties": {
    ///    "homePlmnSnssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "iwkSnssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "n2InfoContent": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    },
    ///    "pduSessionId": {
    ///      "$ref": "#/components/schemas/PduSessionId"
    ///    },
    ///    "sNssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "subjectToHo": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N2SmInformation {
        #[serde(
            rename = "homePlmnSnssai",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub home_plmn_snssai: Option<Snssai>,
        #[serde(rename = "iwkSnssai", default, skip_serializing_if = "Option::is_none")]
        pub iwk_snssai: Option<Snssai>,
        #[serde(
            rename = "n2InfoContent",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n2_info_content: Option<N2InfoContent>,
        #[serde(rename = "pduSessionId")]
        pub pdu_session_id: PduSessionId,
        #[serde(rename = "sNssai", default, skip_serializing_if = "Option::is_none")]
        pub s_nssai: Option<Snssai>,
        #[serde(
            rename = "subjectToHo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub subject_to_ho: Option<bool>,
    }

    impl From<&N2SmInformation> for N2SmInformation {
        fn from(value: &N2SmInformation) -> Self {
            value.clone()
        }
    }

    ///This represents the identifier of the N3IWF ID as specified in clause
    /// 9.3.1.57 of  3GPP TS 38.413 in hexadecimal representation. Each
    /// character in the string shall take a value  of "0" to "9", "a" to "f" or
    /// "A" to "F" and shall represent 4 bits. The most significant  character
    /// representing the 4 most significant bits of the N3IWF ID shall appear
    /// first in the  string, and the character representing the 4 least
    /// significant bit of the N3IWF ID shall  appear last in the string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This represents the identifier of the N3IWF ID as
    /// specified in clause 9.3.1.57 of  3GPP TS 38.413 in hexadecimal
    /// representation. Each character in the string shall take a value  of
    /// \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4
    /// bits. The most significant  character representing the 4 most
    /// significant bits of the N3IWF ID shall appear first in the  string, and
    /// the character representing the 4 least significant bit of the N3IWF ID
    /// shall  appear last in the string. \n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]+$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct N3IwfId(String);
    impl ::std::ops::Deref for N3IwfId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<N3IwfId> for String {
        fn from(value: N3IwfId) -> Self {
            value.0
        }
    }

    impl From<&N3IwfId> for N3IwfId {
        fn from(value: &N3IwfId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for N3IwfId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]+$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for N3IwfId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for N3IwfId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for N3IwfId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for N3IwfId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Contains the Non-3GPP access user location.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the Non-3GPP access user location.",
    ///  "type": "object",
    ///  "properties": {
    ///    "gci": {
    ///      "$ref": "#/components/schemas/Gci"
    ///    },
    ///    "gli": {
    ///      "$ref": "#/components/schemas/Bytes"
    ///    },
    ///    "hfcNodeId": {
    ///      "$ref": "#/components/schemas/HfcNodeId"
    ///    },
    ///    "n3IwfId": {
    ///      "description": "This IE shall contain the N3IWF identifier received
    /// over NGAP and shall be encoded as a  string of hexadecimal characters.
    /// Each character in the string shall take a value of \"0\"  to \"9\",
    /// \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most
    /// significant  character representing the 4 most significant bits of the
    /// N3IWF ID shall appear first in  the string, and the character
    /// representing the 4 least significant bit of the N3IWF ID  shall appear
    /// last in the string. \n",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]+$"
    ///    },
    ///    "n3gppTai": {
    ///      "$ref": "#/components/schemas/Tai"
    ///    },
    ///    "portNumber": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "protocol": {
    ///      "$ref": "#/components/schemas/TransportProtocol"
    ///    },
    ///    "tnapId": {
    ///      "$ref": "#/components/schemas/TnapId"
    ///    },
    ///    "twapId": {
    ///      "$ref": "#/components/schemas/TwapId"
    ///    },
    ///    "ueIpv4Addr": {
    ///      "$ref": "#/components/schemas/Ipv4Addr"
    ///    },
    ///    "ueIpv6Addr": {
    ///      "$ref": "#/components/schemas/Ipv6Addr"
    ///    },
    ///    "w5gbanLineType": {
    ///      "$ref": "#/components/schemas/LineType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct N3gaLocation {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub gci: Option<Gci>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub gli: Option<Bytes>,
        #[serde(rename = "hfcNodeId", default, skip_serializing_if = "Option::is_none")]
        pub hfc_node_id: Option<HfcNodeId>,
        ///This IE shall contain the N3IWF identifier received over NGAP and
        /// shall be encoded as a  string of hexadecimal characters. Each
        /// character in the string shall take a value of "0"  to "9", "a" to
        /// "f" or "A" to "F" and shall represent 4 bits. The most significant
        /// character representing the 4 most significant bits of the N3IWF ID
        /// shall appear first in  the string, and the character representing
        /// the 4 least significant bit of the N3IWF ID  shall appear last in
        /// the string.
        #[serde(rename = "n3IwfId", default, skip_serializing_if = "Option::is_none")]
        pub n3_iwf_id: Option<N3gaLocationN3IwfId>,
        #[serde(rename = "n3gppTai", default, skip_serializing_if = "Option::is_none")]
        pub n3gpp_tai: Option<Tai>,
        #[serde(
            rename = "portNumber",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub port_number: Option<Uinteger>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub protocol: Option<TransportProtocol>,
        #[serde(rename = "tnapId", default, skip_serializing_if = "Option::is_none")]
        pub tnap_id: Option<TnapId>,
        #[serde(rename = "twapId", default, skip_serializing_if = "Option::is_none")]
        pub twap_id: Option<TwapId>,
        #[serde(
            rename = "ueIpv4Addr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_ipv4_addr: Option<Ipv4Addr>,
        #[serde(
            rename = "ueIpv6Addr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_ipv6_addr: Option<Ipv6Addr>,
        #[serde(
            rename = "w5gbanLineType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub w5gban_line_type: Option<LineType>,
    }

    impl From<&N3gaLocation> for N3gaLocation {
        fn from(value: &N3gaLocation) -> Self {
            value.clone()
        }
    }

    ///This IE shall contain the N3IWF identifier received over NGAP and shall
    /// be encoded as a  string of hexadecimal characters. Each character in the
    /// string shall take a value of "0"  to "9", "a" to "f" or "A" to "F" and
    /// shall represent 4 bits. The most significant  character representing the
    /// 4 most significant bits of the N3IWF ID shall appear first in  the
    /// string, and the character representing the 4 least significant bit of
    /// the N3IWF ID  shall appear last in the string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This IE shall contain the N3IWF identifier received
    /// over NGAP and shall be encoded as a  string of hexadecimal characters.
    /// Each character in the string shall take a value of \"0\"  to \"9\",
    /// \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most
    /// significant  character representing the 4 most significant bits of the
    /// N3IWF ID shall appear first in  the string, and the character
    /// representing the 4 least significant bit of the N3IWF ID  shall appear
    /// last in the string. \n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]+$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct N3gaLocationN3IwfId(String);
    impl ::std::ops::Deref for N3gaLocationN3IwfId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<N3gaLocationN3IwfId> for String {
        fn from(value: N3gaLocationN3IwfId) -> Self {
            value.0
        }
    }

    impl From<&N3gaLocationN3IwfId> for N3gaLocationN3IwfId {
        fn from(value: &N3gaLocationN3IwfId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for N3gaLocationN3IwfId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]+$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for N3gaLocationN3IwfId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for N3gaLocationN3IwfId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for N3gaLocationN3IwfId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for N3gaLocationN3IwfId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///NasCount
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "$ref": "#/components/schemas/Uinteger"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NasCount(pub Uinteger);
    impl ::std::ops::Deref for NasCount {
        type Target = Uinteger;
        fn deref(&self) -> &Uinteger {
            &self.0
        }
    }

    impl From<NasCount> for Uinteger {
        fn from(value: NasCount) -> Self {
            value.0
        }
    }

    impl From<&NasCount> for NasCount {
        fn from(value: &NasCount) -> Self {
            value.clone()
        }
    }

    impl From<Uinteger> for NasCount {
        fn from(value: Uinteger) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for NasCount {
        type Err = <Uinteger as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for NasCount {
        type Error = <Uinteger as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for NasCount {
        type Error = <Uinteger as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for NasCount {
        type Error = <Uinteger as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for NasCount {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Indicates the NAS Security Mode
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the NAS Security Mode",
    ///  "type": "object",
    ///  "required": [
    ///    "cipheringAlgorithm",
    ///    "integrityAlgorithm"
    ///  ],
    ///  "properties": {
    ///    "cipheringAlgorithm": {
    ///      "$ref": "#/components/schemas/CipheringAlgorithm"
    ///    },
    ///    "integrityAlgorithm": {
    ///      "$ref": "#/components/schemas/IntegrityAlgorithm"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NasSecurityMode {
        #[serde(rename = "cipheringAlgorithm")]
        pub ciphering_algorithm: CipheringAlgorithm,
        #[serde(rename = "integrityAlgorithm")]
        pub integrity_algorithm: IntegrityAlgorithm,
    }

    impl From<&NasSecurityMode> for NasSecurityMode {
        fn from(value: &NasSecurityMode) -> Self {
            value.clone()
        }
    }

    ///Contains the NCGI (NR Cell Global Identity), as described in 3GPP 23.003
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the NCGI (NR Cell Global Identity), as
    /// described in 3GPP 23.003",
    ///  "type": "object",
    ///  "required": [
    ///    "nrCellId",
    ///    "plmnId"
    ///  ],
    ///  "properties": {
    ///    "nid": {
    ///      "$ref": "#/components/schemas/Nid"
    ///    },
    ///    "nrCellId": {
    ///      "$ref": "#/components/schemas/NrCellId"
    ///    },
    ///    "plmnId": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Ncgi {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub nid: Option<Nid>,
        #[serde(rename = "nrCellId")]
        pub nr_cell_id: NrCellId,
        #[serde(rename = "plmnId")]
        pub plmn_id: PlmnId,
    }

    impl From<&Ncgi> for Ncgi {
        fn from(value: &Ncgi) -> Self {
            value.clone()
        }
    }

    ///List of NR cell ids, with their pertaining TAIs
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of NR cell ids, with their pertaining TAIs",
    ///  "type": "object",
    ///  "required": [
    ///    "cellList",
    ///    "tai"
    ///  ],
    ///  "properties": {
    ///    "cellList": {
    ///      "description": "List of List of NR cell ids",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Ncgi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "tai": {
    ///      "$ref": "#/components/schemas/Tai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NcgiTai {
        ///List of List of NR cell ids
        #[serde(rename = "cellList")]
        pub cell_list: Vec<Ncgi>,
        pub tai: Tai,
    }

    impl From<&NcgiTai> for NcgiTai {
        fn from(value: &NcgiTai) -> Self {
            value.clone()
        }
    }

    ///Describes a network area information in which the NF service consumer
    /// requests the number of UEs.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes a network area information in which the NF
    /// service consumer requests the number of UEs.\n",
    ///  "type": "object",
    ///  "properties": {
    ///    "ecgis": {
    ///      "description": "Contains a list of E-UTRA cell identities.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Ecgi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "gRanNodeIds": {
    ///      "description": "Contains a list of NG RAN nodes.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GlobalRanNodeId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "ncgis": {
    ///      "description": "Contains a list of NR cell identities.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Ncgi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "tais": {
    ///      "description": "Contains a list of tracking area identities.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Tai"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NetworkAreaInfo {
        ///Contains a list of E-UTRA cell identities.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub ecgis: Vec<Ecgi>,
        ///Contains a list of NG RAN nodes.
        #[serde(rename = "gRanNodeIds", default, skip_serializing_if = "Vec::is_empty")]
        pub g_ran_node_ids: Vec<GlobalRanNodeId>,
        ///Contains a list of NR cell identities.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub ncgis: Vec<Ncgi>,
        ///Contains a list of tracking area identities.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub tais: Vec<Tai>,
    }

    impl From<&NetworkAreaInfo> for NetworkAreaInfo {
        fn from(value: &NetworkAreaInfo) -> Self {
            value.clone()
        }
    }

    ///Represents the network performance information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the network performance information.",
    ///  "type": "object",
    ///  "allOf": [
    ///    {
    ///      "required": [
    ///        "networkArea"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "nwPerfType"
    ///      ]
    ///    },
    ///    {
    ///      "oneOf": [
    ///        {
    ///          "required": [
    ///            "relativeRatio"
    ///          ]
    ///        },
    ///        {
    ///          "required": [
    ///            "absoluteNum"
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "absoluteNum": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "confidence": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "networkArea": {
    ///      "$ref": "#/components/schemas/NetworkAreaInfo"
    ///    },
    ///    "nwPerfType": {
    ///      "$ref": "#/components/schemas/NetworkPerfType"
    ///    },
    ///    "relativeRatio": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum NetworkPerfInfo {
        Variant0 {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            #[serde(rename = "networkArea")]
            network_area: NetworkAreaInfo,
            #[serde(rename = "nwPerfType")]
            nw_perf_type: NetworkPerfType,
            #[serde(rename = "relativeRatio")]
            relative_ratio: SamplingRatio,
        },
        Variant1 {
            #[serde(rename = "absoluteNum")]
            absolute_num: Uinteger,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            #[serde(rename = "networkArea")]
            network_area: NetworkAreaInfo,
            #[serde(rename = "nwPerfType")]
            nw_perf_type: NetworkPerfType,
        },
    }

    impl From<&NetworkPerfInfo> for NetworkPerfInfo {
        fn from(value: &NetworkPerfInfo) -> Self {
            value.clone()
        }
    }

    ///Represents a network performance requirement.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a network performance requirement.",
    ///  "type": "object",
    ///  "required": [
    ///    "nwPerfType"
    ///  ],
    ///  "properties": {
    ///    "absoluteNum": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "nwPerfType": {
    ///      "$ref": "#/components/schemas/NetworkPerfType"
    ///    },
    ///    "relativeRatio": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NetworkPerfRequirement {
        #[serde(
            rename = "absoluteNum",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub absolute_num: Option<Uinteger>,
        #[serde(rename = "nwPerfType")]
        pub nw_perf_type: NetworkPerfType,
        #[serde(
            rename = "relativeRatio",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub relative_ratio: Option<SamplingRatio>,
    }

    impl From<&NetworkPerfRequirement> for NetworkPerfRequirement {
        fn from(value: &NetworkPerfRequirement) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - GNB_ACTIVE_RATIO: Indicates that the network performance requirement
    ///   is gNodeB active (i.e. up and running) rate. Indicates the ratio of
    ///   gNB active (i.e. up and running) number to the total number of gNB
    /// - GNB_COMPUTING_USAGE: Indicates gNodeB computing resource usage.
    /// - GNB_MEMORY_USAGE: Indicates gNodeB memory usage.
    /// - GNB_DISK_USAGE: Indicates gNodeB disk usage.
    /// - NUM_OF_UE: Indicates number of UEs.
    /// - SESS_SUCC_RATIO: Indicates ratio of successful setup of PDU sessions
    ///   to total PDU session setup attempts.
    /// - HO_SUCC_RATIO: Indicates Ratio of successful handovers to the total
    ///   handover attempts.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- GNB_ACTIVE_RATIO: Indicates
    /// that the network performance requirement is gNodeB active (i.e. up and
    /// running) rate. Indicates the ratio of gNB active (i.e. up and running)
    /// number to the total number of gNB\n- GNB_COMPUTING_USAGE: Indicates
    /// gNodeB computing resource usage.\n- GNB_MEMORY_USAGE: Indicates gNodeB
    /// memory usage.\n- GNB_DISK_USAGE: Indicates gNodeB disk usage.\n-
    /// NUM_OF_UE: Indicates number of UEs.\n- SESS_SUCC_RATIO: Indicates ratio
    /// of successful setup of PDU sessions to total PDU session setup
    /// attempts.\n- HO_SUCC_RATIO: Indicates Ratio of successful handovers to
    /// the total handover attempts.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "GNB_ACTIVE_RATIO",
    ///    "GNB_COMPUTING_USAGE",
    ///    "GNB_MEMORY_USAGE",
    ///    "GNB_DISK_USAGE",
    ///    "NUM_OF_UE",
    ///    "SESS_SUCC_RATIO",
    ///    "HO_SUCC_RATIO"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum NetworkPerfType {
        #[serde(rename = "GNB_ACTIVE_RATIO")]
        GnbActiveRatio,
        #[serde(rename = "GNB_COMPUTING_USAGE")]
        GnbComputingUsage,
        #[serde(rename = "GNB_MEMORY_USAGE")]
        GnbMemoryUsage,
        #[serde(rename = "GNB_DISK_USAGE")]
        GnbDiskUsage,
        #[serde(rename = "NUM_OF_UE")]
        NumOfUe,
        #[serde(rename = "SESS_SUCC_RATIO")]
        SessSuccRatio,
        #[serde(rename = "HO_SUCC_RATIO")]
        HoSuccRatio,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&NetworkPerfType> for NetworkPerfType {
        fn from(value: &NetworkPerfType) -> Self {
            value.clone()
        }
    }

    impl ToString for NetworkPerfType {
        fn to_string(&self) -> String {
            match *self {
                Self::GnbActiveRatio => "GNB_ACTIVE_RATIO".to_string(),
                Self::GnbComputingUsage => "GNB_COMPUTING_USAGE".to_string(),
                Self::GnbMemoryUsage => "GNB_MEMORY_USAGE".to_string(),
                Self::GnbDiskUsage => "GNB_DISK_USAGE".to_string(),
                Self::NumOfUe => "NUM_OF_UE".to_string(),
                Self::SessSuccRatio => "SESS_SUCC_RATIO".to_string(),
                Self::HoSuccRatio => "HO_SUCC_RATIO".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for NetworkPerfType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "GNB_ACTIVE_RATIO" => Ok(Self::GnbActiveRatio),
                "GNB_COMPUTING_USAGE" => Ok(Self::GnbComputingUsage),
                "GNB_MEMORY_USAGE" => Ok(Self::GnbMemoryUsage),
                "GNB_DISK_USAGE" => Ok(Self::GnbDiskUsage),
                "NUM_OF_UE" => Ok(Self::NumOfUe),
                "SESS_SUCC_RATIO" => Ok(Self::SessSuccRatio),
                "HO_SUCC_RATIO" => Ok(Self::HoSuccRatio),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for NetworkPerfType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for NetworkPerfType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for NetworkPerfType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Identifier of a group of NFs.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identifier of a group of NFs.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct NfGroupId(pub String);
    impl ::std::ops::Deref for NfGroupId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<NfGroupId> for String {
        fn from(value: NfGroupId) -> Self {
            value.0
        }
    }

    impl From<&NfGroupId> for NfGroupId {
        fn from(value: &NfGroupId) -> Self {
            value.clone()
        }
    }

    impl From<String> for NfGroupId {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for NfGroupId {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for NfGroupId {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///String uniquely identifying a NF instance. The format of the NF Instance
    /// ID shall be a  Universally Unique Identifier (UUID) version 4, as
    /// described in IETF RFC 4122.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String uniquely identifying a NF instance. The format
    /// of the NF Instance ID shall be a  Universally Unique Identifier (UUID)
    /// version 4, as described in IETF RFC 4122. \n",
    ///  "type": "string",
    ///  "format": "uuid"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NfInstanceId(pub uuid::Uuid);
    impl ::std::ops::Deref for NfInstanceId {
        type Target = uuid::Uuid;
        fn deref(&self) -> &uuid::Uuid {
            &self.0
        }
    }

    impl From<NfInstanceId> for uuid::Uuid {
        fn from(value: NfInstanceId) -> Self {
            value.0
        }
    }

    impl From<&NfInstanceId> for NfInstanceId {
        fn from(value: &NfInstanceId) -> Self {
            value.clone()
        }
    }

    impl From<uuid::Uuid> for NfInstanceId {
        fn from(value: uuid::Uuid) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for NfInstanceId {
        type Err = <uuid::Uuid as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for NfInstanceId {
        type Error = <uuid::Uuid as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for NfInstanceId {
        type Error = <uuid::Uuid as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for NfInstanceId {
        type Error = <uuid::Uuid as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for NfInstanceId {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Represents load level information of a given NF instance.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents load level information of a given NF
    /// instance.",
    ///  "type": "object",
    ///  "allOf": [
    ///    {
    ///      "required": [
    ///        "nfType"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "nfInstanceId"
    ///      ]
    ///    },
    ///    {
    ///      "anyOf": [
    ///        {
    ///          "required": [
    ///            "nfStatus"
    ///          ]
    ///        },
    ///        {
    ///          "required": [
    ///            "nfCpuUsage"
    ///          ]
    ///        },
    ///        {
    ///          "required": [
    ///            "nfMemoryUsage"
    ///          ]
    ///        },
    ///        {
    ///          "required": [
    ///            "nfStorageUsage"
    ///          ]
    ///        },
    ///        {
    ///          "required": [
    ///            "nfLoadLevelAverage"
    ///          ]
    ///        },
    ///        {
    ///          "required": [
    ///            "nfLoadLevelPeak"
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "confidence": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "nfCpuUsage": {
    ///      "type": "integer"
    ///    },
    ///    "nfInstanceId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "nfLoadAvgInAoi": {
    ///      "type": "integer"
    ///    },
    ///    "nfLoadLevelAverage": {
    ///      "type": "integer"
    ///    },
    ///    "nfLoadLevelpeak": {
    ///      "type": "integer"
    ///    },
    ///    "nfMemoryUsage": {
    ///      "type": "integer"
    ///    },
    ///    "nfSetId": {
    ///      "$ref": "#/components/schemas/NfSetId"
    ///    },
    ///    "nfStatus": {
    ///      "$ref": "#/components/schemas/NfStatus"
    ///    },
    ///    "nfStorageUsage": {
    ///      "type": "integer"
    ///    },
    ///    "nfType": {
    ///      "$ref": "#/components/schemas/NFType"
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum NfLoadLevelInformation {
        Variant0 {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            #[serde(rename = "nfInstanceId")]
            nf_instance_id: NfInstanceId,
            #[serde(
                rename = "nfLoadAvgInAoi",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            nf_load_avg_in_aoi: Option<i64>,
            #[serde(
                rename = "nfLoadLevelpeak",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            nf_load_levelpeak: Option<i64>,
            #[serde(rename = "nfSetId", default, skip_serializing_if = "Option::is_none")]
            nf_set_id: Option<NfSetId>,
            #[serde(rename = "nfStatus")]
            nf_status: NfStatus,
            #[serde(rename = "nfType")]
            nf_type: NfType,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            snssai: Option<Snssai>,
        },
        Variant1 {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            #[serde(rename = "nfCpuUsage")]
            nf_cpu_usage: i64,
            #[serde(rename = "nfInstanceId")]
            nf_instance_id: NfInstanceId,
            #[serde(
                rename = "nfLoadAvgInAoi",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            nf_load_avg_in_aoi: Option<i64>,
            #[serde(
                rename = "nfLoadLevelpeak",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            nf_load_levelpeak: Option<i64>,
            #[serde(rename = "nfSetId", default, skip_serializing_if = "Option::is_none")]
            nf_set_id: Option<NfSetId>,
            #[serde(rename = "nfType")]
            nf_type: NfType,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            snssai: Option<Snssai>,
        },
        Variant2 {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            #[serde(rename = "nfInstanceId")]
            nf_instance_id: NfInstanceId,
            #[serde(
                rename = "nfLoadAvgInAoi",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            nf_load_avg_in_aoi: Option<i64>,
            #[serde(
                rename = "nfLoadLevelpeak",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            nf_load_levelpeak: Option<i64>,
            #[serde(rename = "nfMemoryUsage")]
            nf_memory_usage: i64,
            #[serde(rename = "nfSetId", default, skip_serializing_if = "Option::is_none")]
            nf_set_id: Option<NfSetId>,
            #[serde(rename = "nfType")]
            nf_type: NfType,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            snssai: Option<Snssai>,
        },
        Variant3 {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            #[serde(rename = "nfInstanceId")]
            nf_instance_id: NfInstanceId,
            #[serde(
                rename = "nfLoadAvgInAoi",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            nf_load_avg_in_aoi: Option<i64>,
            #[serde(
                rename = "nfLoadLevelpeak",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            nf_load_levelpeak: Option<i64>,
            #[serde(rename = "nfSetId", default, skip_serializing_if = "Option::is_none")]
            nf_set_id: Option<NfSetId>,
            #[serde(rename = "nfStorageUsage")]
            nf_storage_usage: i64,
            #[serde(rename = "nfType")]
            nf_type: NfType,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            snssai: Option<Snssai>,
        },
        Variant4 {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            #[serde(rename = "nfInstanceId")]
            nf_instance_id: NfInstanceId,
            #[serde(
                rename = "nfLoadAvgInAoi",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            nf_load_avg_in_aoi: Option<i64>,
            #[serde(rename = "nfLoadLevelAverage")]
            nf_load_level_average: i64,
            #[serde(
                rename = "nfLoadLevelpeak",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            nf_load_levelpeak: Option<i64>,
            #[serde(rename = "nfSetId", default, skip_serializing_if = "Option::is_none")]
            nf_set_id: Option<NfSetId>,
            #[serde(rename = "nfType")]
            nf_type: NfType,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            snssai: Option<Snssai>,
        },
        Variant5 {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            #[serde(rename = "nfInstanceId")]
            nf_instance_id: NfInstanceId,
            #[serde(
                rename = "nfLoadAvgInAoi",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            nf_load_avg_in_aoi: Option<i64>,
            #[serde(rename = "nfLoadLevelPeak")]
            nf_load_level_peak: ::serde_json::Value,
            #[serde(
                rename = "nfLoadLevelpeak",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            nf_load_levelpeak: Option<i64>,
            #[serde(rename = "nfSetId", default, skip_serializing_if = "Option::is_none")]
            nf_set_id: Option<NfSetId>,
            #[serde(rename = "nfType")]
            nf_type: NfType,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            snssai: Option<Snssai>,
        },
    }

    impl From<&NfLoadLevelInformation> for NfLoadLevelInformation {
        fn from(value: &NfLoadLevelInformation) -> Self {
            value.clone()
        }
    }

    ///NF Service Set Identifier (see clause 28.12 of 3GPP TS 23.003) formatted
    /// as the following  string "set<Set ID>.sn<Service Name>.nfi<NF Instance
    /// ID>.5gc.mnc<MNC>.mcc<MCC>", or
    /// "set<SetID>.sn<ServiceName>.nfi<NFInstanceID>.5gc.nid<NID>.mnc<MNC>.
    /// mcc<MCC>" with  <MCC> encoded as defined in clause 5.4.2 ("Mcc" data
    /// type definition)   <MNC> encoding the Mobile Network Code part of the
    /// PLMN, comprising 3 digits.  If there are only 2 significant digits
    /// in the MNC, one "0" digit shall be inserted  at the left side to
    /// fill the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$'
    /// <NID> encoded as defined in clause5.4.2 ("Nid" data type definition)
    /// <NFInstanceId> encoded as defined in clause 5.3.2  <ServiceName> encoded
    /// as defined in 3GPP TS 29.510  <Set ID> encoded as a string of characters
    /// consisting of alphabetic  characters (A-Z and a-z), digits (0-9)
    /// and/or the hyphen (-) and that shall end  with either an alphabetic
    /// character or a digit.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "NF Service Set Identifier (see clause 28.12 of 3GPP TS
    /// 23.003) formatted as the following  string \"set<Set ID>.sn<Service
    /// Name>.nfi<NF Instance ID>.5gc.mnc<MNC>.mcc<MCC>\", or
    /// \"set<SetID>.sn<ServiceName>.nfi<NFInstanceID>.5gc.nid<NID>.mnc<MNC>.
    /// mcc<MCC>\" with  <MCC> encoded as defined in clause 5.4.2 (\"Mcc\" data
    /// type definition)   <MNC> encoding the Mobile Network Code part of the
    /// PLMN, comprising 3 digits. \n  If there are only 2 significant digits in
    /// the MNC, one \"0\" digit shall be inserted \n  at the left side to fill
    /// the 3 digits coding of MNC.  Pattern: '^[0-9]{3}$'\n<NID> encoded as
    /// defined in clause5.4.2 (\"Nid\" data type definition)  <NFInstanceId>
    /// encoded as defined in clause 5.3.2  <ServiceName> encoded as defined in
    /// 3GPP TS 29.510  <Set ID> encoded as a string of characters consisting of
    /// alphabetic \n  characters (A-Z and a-z), digits (0-9) and/or the hyphen
    /// (-) and that shall end \n  with either an alphabetic character or a
    /// digit.\n",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct NfServiceSetId(pub String);
    impl ::std::ops::Deref for NfServiceSetId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<NfServiceSetId> for String {
        fn from(value: NfServiceSetId) -> Self {
            value.0
        }
    }

    impl From<&NfServiceSetId> for NfServiceSetId {
        fn from(value: &NfServiceSetId) -> Self {
            value.clone()
        }
    }

    impl From<String> for NfServiceSetId {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for NfServiceSetId {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for NfServiceSetId {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///NF Set Identifier (see clause 28.12 of 3GPP TS 23.003), formatted as the
    /// following string "set<Set ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>", or
    /// "set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>" with  <MCC>
    /// encoded as defined in clause 5.4.2 ("Mcc" data type definition)  <MNC>
    /// encoding the Mobile Network Code part of the PLMN, comprising 3 digits.
    ///  If there are only 2 significant digits in the MNC, one "0" digit shall
    /// be inserted  at the left side to fill the 3 digits coding of MNC.
    /// Pattern: '^[0-9]{3}$' <NFType> encoded as a value defined in Table
    /// 6.1.6.3.3-1 of 3GPP TS 29.510 but  with lower case characters <Set
    /// ID> encoded as a string of characters consisting of  alphabetic
    /// characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that
    ///  shall end with either an alphabetic character or a digit.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "NF Set Identifier (see clause 28.12 of 3GPP TS 23.003),
    /// formatted as the following string \"set<Set
    /// ID>.<nftype>set.5gc.mnc<MNC>.mcc<MCC>\", or
    /// \"set<SetID>.<NFType>set.5gc.nid<NID>.mnc<MNC>.mcc<MCC>\" with  <MCC>
    /// encoded as defined in clause 5.4.2 (\"Mcc\" data type definition)  <MNC>
    /// encoding the Mobile Network Code part of the PLMN, comprising 3 digits.
    /// \n  If there are only 2 significant digits in the MNC, one \"0\" digit
    /// shall be inserted \n  at the left side to fill the 3 digits coding of
    /// MNC.  Pattern: '^[0-9]{3}$'\n<NFType> encoded as a value defined in
    /// Table 6.1.6.3.3-1 of 3GPP TS 29.510 but \n  with lower case characters
    /// <Set ID> encoded as a string of characters consisting of \n  alphabetic
    /// characters (A-Z and a-z), digits (0-9) and/or the hyphen (-) and that \n
    /// shall end with either an alphabetic character or a digit. \n",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct NfSetId(pub String);
    impl ::std::ops::Deref for NfSetId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<NfSetId> for String {
        fn from(value: NfSetId) -> Self {
            value.0
        }
    }

    impl From<&NfSetId> for NfSetId {
        fn from(value: &NfSetId) -> Self {
            value.clone()
        }
    }

    impl From<String> for NfSetId {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for NfSetId {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for NfSetId {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Contains the percentage of time spent on various NF states.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the percentage of time spent on various NF
    /// states.",
    ///  "type": "object",
    ///  "anyOf": [
    ///    {
    ///      "required": [
    ///        "statusRegistered"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "statusUnregistered"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "statusUndiscoverable"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "statusRegistered": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    },
    ///    "statusUndiscoverable": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    },
    ///    "statusUnregistered": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum NfStatus {
        Variant0 {
            #[serde(rename = "statusRegistered")]
            status_registered: SamplingRatio,
        },
        Variant1 {
            #[serde(rename = "statusUnregistered")]
            status_unregistered: SamplingRatio,
        },
        Variant2 {
            #[serde(rename = "statusUndiscoverable")]
            status_undiscoverable: SamplingRatio,
        },
    }

    impl From<&NfStatus> for NfStatus {
        fn from(value: &NfStatus) -> Self {
            value.clone()
        }
    }

    ///NF types known to NRF
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "NF types known to NRF",
    ///  "type": "string",
    ///  "enum": [
    ///    "NRF",
    ///    "UDM",
    ///    "AMF",
    ///    "SMF",
    ///    "AUSF",
    ///    "NEF",
    ///    "PCF",
    ///    "SMSF",
    ///    "NSSF",
    ///    "UDR",
    ///    "LMF",
    ///    "GMLC",
    ///    "5G_EIR",
    ///    "SEPP",
    ///    "UPF",
    ///    "N3IWF",
    ///    "AF",
    ///    "UDSF",
    ///    "BSF",
    ///    "CHF",
    ///    "NWDAF",
    ///    "PCSCF",
    ///    "CBCF",
    ///    "HSS",
    ///    "UCMF",
    ///    "SOR_AF",
    ///    "SPAF",
    ///    "MME",
    ///    "SCSAS",
    ///    "SCEF",
    ///    "SCP",
    ///    "NSSAAF",
    ///    "ICSCF",
    ///    "SCSCF",
    ///    "DRA",
    ///    "IMS_AS",
    ///    "AANF",
    ///    "5G_DDNMF",
    ///    "NSACF",
    ///    "MFAF",
    ///    "EASDF",
    ///    "DCCF",
    ///    "MB_SMF",
    ///    "TSCTSF",
    ///    "ADRF",
    ///    "GBA_BSF",
    ///    "CEF",
    ///    "MB_UPF",
    ///    "NSWOF",
    ///    "PKMF",
    ///    "MNPF",
    ///    "SMS_GMSC",
    ///    "SMS_IWMSC",
    ///    "MBSF",
    ///    "MBSTF",
    ///    "PANF",
    ///    "IP_SM_GW",
    ///    "SMS_ROUTER"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum NfType {
        #[serde(rename = "NRF")]
        Nrf,
        #[serde(rename = "UDM")]
        Udm,
        #[serde(rename = "AMF")]
        Amf,
        #[serde(rename = "SMF")]
        Smf,
        #[serde(rename = "AUSF")]
        Ausf,
        #[serde(rename = "NEF")]
        Nef,
        #[serde(rename = "PCF")]
        Pcf,
        #[serde(rename = "SMSF")]
        Smsf,
        #[serde(rename = "NSSF")]
        Nssf,
        #[serde(rename = "UDR")]
        Udr,
        #[serde(rename = "LMF")]
        Lmf,
        #[serde(rename = "GMLC")]
        Gmlc,
        #[serde(rename = "5G_EIR")]
        FiveGEir,
        #[serde(rename = "SEPP")]
        Sepp,
        #[serde(rename = "UPF")]
        Upf,
        #[serde(rename = "N3IWF")]
        N3iwf,
        #[serde(rename = "AF")]
        Af,
        #[serde(rename = "UDSF")]
        Udsf,
        #[serde(rename = "BSF")]
        Bsf,
        #[serde(rename = "CHF")]
        Chf,
        #[serde(rename = "NWDAF")]
        Nwdaf,
        #[serde(rename = "PCSCF")]
        Pcscf,
        #[serde(rename = "CBCF")]
        Cbcf,
        #[serde(rename = "HSS")]
        Hss,
        #[serde(rename = "UCMF")]
        Ucmf,
        #[serde(rename = "SOR_AF")]
        SorAf,
        #[serde(rename = "SPAF")]
        Spaf,
        #[serde(rename = "MME")]
        Mme,
        #[serde(rename = "SCSAS")]
        Scsas,
        #[serde(rename = "SCEF")]
        Scef,
        #[serde(rename = "SCP")]
        Scp,
        #[serde(rename = "NSSAAF")]
        Nssaaf,
        #[serde(rename = "ICSCF")]
        Icscf,
        #[serde(rename = "SCSCF")]
        Scscf,
        #[serde(rename = "DRA")]
        Dra,
        #[serde(rename = "IMS_AS")]
        ImsAs,
        #[serde(rename = "AANF")]
        Aanf,
        #[serde(rename = "5G_DDNMF")]
        FiveGDdnmf,
        #[serde(rename = "NSACF")]
        Nsacf,
        #[serde(rename = "MFAF")]
        Mfaf,
        #[serde(rename = "EASDF")]
        Easdf,
        #[serde(rename = "DCCF")]
        Dccf,
        #[serde(rename = "MB_SMF")]
        MbSmf,
        #[serde(rename = "TSCTSF")]
        Tsctsf,
        #[serde(rename = "ADRF")]
        Adrf,
        #[serde(rename = "GBA_BSF")]
        GbaBsf,
        #[serde(rename = "CEF")]
        Cef,
        #[serde(rename = "MB_UPF")]
        MbUpf,
        #[serde(rename = "NSWOF")]
        Nswof,
        #[serde(rename = "PKMF")]
        Pkmf,
        #[serde(rename = "MNPF")]
        Mnpf,
        #[serde(rename = "SMS_GMSC")]
        SmsGmsc,
        #[serde(rename = "SMS_IWMSC")]
        SmsIwmsc,
        #[serde(rename = "MBSF")]
        Mbsf,
        #[serde(rename = "MBSTF")]
        Mbstf,
        #[serde(rename = "PANF")]
        Panf,
        #[serde(rename = "IP_SM_GW")]
        IpSmGw,
        #[serde(rename = "SMS_ROUTER")]
        SmsRouter,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&NfType> for NfType {
        fn from(value: &NfType) -> Self {
            value.clone()
        }
    }

    impl ToString for NfType {
        fn to_string(&self) -> String {
            match *self {
                Self::Nrf => "NRF".to_string(),
                Self::Udm => "UDM".to_string(),
                Self::Amf => "AMF".to_string(),
                Self::Smf => "SMF".to_string(),
                Self::Ausf => "AUSF".to_string(),
                Self::Nef => "NEF".to_string(),
                Self::Pcf => "PCF".to_string(),
                Self::Smsf => "SMSF".to_string(),
                Self::Nssf => "NSSF".to_string(),
                Self::Udr => "UDR".to_string(),
                Self::Lmf => "LMF".to_string(),
                Self::Gmlc => "GMLC".to_string(),
                Self::FiveGEir => "5G_EIR".to_string(),
                Self::Sepp => "SEPP".to_string(),
                Self::Upf => "UPF".to_string(),
                Self::N3iwf => "N3IWF".to_string(),
                Self::Af => "AF".to_string(),
                Self::Udsf => "UDSF".to_string(),
                Self::Bsf => "BSF".to_string(),
                Self::Chf => "CHF".to_string(),
                Self::Nwdaf => "NWDAF".to_string(),
                Self::Pcscf => "PCSCF".to_string(),
                Self::Cbcf => "CBCF".to_string(),
                Self::Hss => "HSS".to_string(),
                Self::Ucmf => "UCMF".to_string(),
                Self::SorAf => "SOR_AF".to_string(),
                Self::Spaf => "SPAF".to_string(),
                Self::Mme => "MME".to_string(),
                Self::Scsas => "SCSAS".to_string(),
                Self::Scef => "SCEF".to_string(),
                Self::Scp => "SCP".to_string(),
                Self::Nssaaf => "NSSAAF".to_string(),
                Self::Icscf => "ICSCF".to_string(),
                Self::Scscf => "SCSCF".to_string(),
                Self::Dra => "DRA".to_string(),
                Self::ImsAs => "IMS_AS".to_string(),
                Self::Aanf => "AANF".to_string(),
                Self::FiveGDdnmf => "5G_DDNMF".to_string(),
                Self::Nsacf => "NSACF".to_string(),
                Self::Mfaf => "MFAF".to_string(),
                Self::Easdf => "EASDF".to_string(),
                Self::Dccf => "DCCF".to_string(),
                Self::MbSmf => "MB_SMF".to_string(),
                Self::Tsctsf => "TSCTSF".to_string(),
                Self::Adrf => "ADRF".to_string(),
                Self::GbaBsf => "GBA_BSF".to_string(),
                Self::Cef => "CEF".to_string(),
                Self::MbUpf => "MB_UPF".to_string(),
                Self::Nswof => "NSWOF".to_string(),
                Self::Pkmf => "PKMF".to_string(),
                Self::Mnpf => "MNPF".to_string(),
                Self::SmsGmsc => "SMS_GMSC".to_string(),
                Self::SmsIwmsc => "SMS_IWMSC".to_string(),
                Self::Mbsf => "MBSF".to_string(),
                Self::Mbstf => "MBSTF".to_string(),
                Self::Panf => "PANF".to_string(),
                Self::IpSmGw => "IP_SM_GW".to_string(),
                Self::SmsRouter => "SMS_ROUTER".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for NfType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NRF" => Ok(Self::Nrf),
                "UDM" => Ok(Self::Udm),
                "AMF" => Ok(Self::Amf),
                "SMF" => Ok(Self::Smf),
                "AUSF" => Ok(Self::Ausf),
                "NEF" => Ok(Self::Nef),
                "PCF" => Ok(Self::Pcf),
                "SMSF" => Ok(Self::Smsf),
                "NSSF" => Ok(Self::Nssf),
                "UDR" => Ok(Self::Udr),
                "LMF" => Ok(Self::Lmf),
                "GMLC" => Ok(Self::Gmlc),
                "5G_EIR" => Ok(Self::FiveGEir),
                "SEPP" => Ok(Self::Sepp),
                "UPF" => Ok(Self::Upf),
                "N3IWF" => Ok(Self::N3iwf),
                "AF" => Ok(Self::Af),
                "UDSF" => Ok(Self::Udsf),
                "BSF" => Ok(Self::Bsf),
                "CHF" => Ok(Self::Chf),
                "NWDAF" => Ok(Self::Nwdaf),
                "PCSCF" => Ok(Self::Pcscf),
                "CBCF" => Ok(Self::Cbcf),
                "HSS" => Ok(Self::Hss),
                "UCMF" => Ok(Self::Ucmf),
                "SOR_AF" => Ok(Self::SorAf),
                "SPAF" => Ok(Self::Spaf),
                "MME" => Ok(Self::Mme),
                "SCSAS" => Ok(Self::Scsas),
                "SCEF" => Ok(Self::Scef),
                "SCP" => Ok(Self::Scp),
                "NSSAAF" => Ok(Self::Nssaaf),
                "ICSCF" => Ok(Self::Icscf),
                "SCSCF" => Ok(Self::Scscf),
                "DRA" => Ok(Self::Dra),
                "IMS_AS" => Ok(Self::ImsAs),
                "AANF" => Ok(Self::Aanf),
                "5G_DDNMF" => Ok(Self::FiveGDdnmf),
                "NSACF" => Ok(Self::Nsacf),
                "MFAF" => Ok(Self::Mfaf),
                "EASDF" => Ok(Self::Easdf),
                "DCCF" => Ok(Self::Dccf),
                "MB_SMF" => Ok(Self::MbSmf),
                "TSCTSF" => Ok(Self::Tsctsf),
                "ADRF" => Ok(Self::Adrf),
                "GBA_BSF" => Ok(Self::GbaBsf),
                "CEF" => Ok(Self::Cef),
                "MB_UPF" => Ok(Self::MbUpf),
                "NSWOF" => Ok(Self::Nswof),
                "PKMF" => Ok(Self::Pkmf),
                "MNPF" => Ok(Self::Mnpf),
                "SMS_GMSC" => Ok(Self::SmsGmsc),
                "SMS_IWMSC" => Ok(Self::SmsIwmsc),
                "MBSF" => Ok(Self::Mbsf),
                "MBSTF" => Ok(Self::Mbstf),
                "PANF" => Ok(Self::Panf),
                "IP_SM_GW" => Ok(Self::IpSmGw),
                "SMS_ROUTER" => Ok(Self::SmsRouter),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for NfType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for NfType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for NfType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents the NGAP cause.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the NGAP cause.",
    ///  "type": "object",
    ///  "required": [
    ///    "group",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "group": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "value": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NgApCause {
        pub group: Uinteger,
        pub value: Uinteger,
    }

    impl From<&NgApCause> for NgApCause {
        fn from(value: &NgApCause) -> Self {
            value.clone()
        }
    }

    ///Represents the ngKSI
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the ngKSI",
    ///  "type": "object",
    ///  "required": [
    ///    "ksi",
    ///    "tsc"
    ///  ],
    ///  "properties": {
    ///    "ksi": {
    ///      "type": "integer",
    ///      "maximum": 6.0,
    ///      "minimum": 0.0
    ///    },
    ///    "tsc": {
    ///      "$ref": "#/components/schemas/ScType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NgKsi {
        pub ksi: i64,
        pub tsc: ScType,
    }

    impl From<&NgKsi> for NgKsi {
        fn from(value: &NgKsi) -> Self {
            value.clone()
        }
    }

    ///Indicates a NG RAN as target of the handover
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates a NG RAN as target of the handover",
    ///  "type": "object",
    ///  "required": [
    ///    "ranNodeId",
    ///    "tai"
    ///  ],
    ///  "properties": {
    ///    "ranNodeId": {
    ///      "$ref": "#/components/schemas/GlobalRanNodeId"
    ///    },
    ///    "tai": {
    ///      "$ref": "#/components/schemas/Tai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NgRanTargetId {
        #[serde(rename = "ranNodeId")]
        pub ran_node_id: GlobalRanNodeId,
        pub tai: Tai,
    }

    impl From<&NgRanTargetId> for NgRanTargetId {
        fn from(value: &NgRanTargetId) -> Self {
            value.clone()
        }
    }

    ///Indicates the supported NGAP IE types
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the supported NGAP IE types",
    ///  "type": "string",
    ///  "enum": [
    ///    "PDU_RES_SETUP_REQ",
    ///    "PDU_RES_REL_CMD",
    ///    "PDU_RES_MOD_REQ",
    ///    "HANDOVER_CMD",
    ///    "HANDOVER_REQUIRED",
    ///    "HANDOVER_PREP_FAIL",
    ///    "SRC_TO_TAR_CONTAINER",
    ///    "TAR_TO_SRC_CONTAINER",
    ///    "TAR_TO_SRC_FAIL_CONTAINER",
    ///    "RAN_STATUS_TRANS_CONTAINER",
    ///    "SON_CONFIG_TRANSFER",
    ///    "NRPPA_PDU",
    ///    "UE_RADIO_CAPABILITY",
    ///    "RIM_INFO_TRANSFER",
    ///    "SECONDARY_RAT_USAGE",
    ///    "PC5_QOS_PARA",
    ///    "EARLY_STATUS_TRANS_CONTAINER",
    ///    "UE_RADIO_CAPABILITY_FOR_PAGING"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum NgapIeType {
        #[serde(rename = "PDU_RES_SETUP_REQ")]
        PduResSetupReq,
        #[serde(rename = "PDU_RES_REL_CMD")]
        PduResRelCmd,
        #[serde(rename = "PDU_RES_MOD_REQ")]
        PduResModReq,
        #[serde(rename = "HANDOVER_CMD")]
        HandoverCmd,
        #[serde(rename = "HANDOVER_REQUIRED")]
        HandoverRequired,
        #[serde(rename = "HANDOVER_PREP_FAIL")]
        HandoverPrepFail,
        #[serde(rename = "SRC_TO_TAR_CONTAINER")]
        SrcToTarContainer,
        #[serde(rename = "TAR_TO_SRC_CONTAINER")]
        TarToSrcContainer,
        #[serde(rename = "TAR_TO_SRC_FAIL_CONTAINER")]
        TarToSrcFailContainer,
        #[serde(rename = "RAN_STATUS_TRANS_CONTAINER")]
        RanStatusTransContainer,
        #[serde(rename = "SON_CONFIG_TRANSFER")]
        SonConfigTransfer,
        #[serde(rename = "NRPPA_PDU")]
        NrppaPdu,
        #[serde(rename = "UE_RADIO_CAPABILITY")]
        UeRadioCapability,
        #[serde(rename = "RIM_INFO_TRANSFER")]
        RimInfoTransfer,
        #[serde(rename = "SECONDARY_RAT_USAGE")]
        SecondaryRatUsage,
        #[serde(rename = "PC5_QOS_PARA")]
        Pc5QosPara,
        #[serde(rename = "EARLY_STATUS_TRANS_CONTAINER")]
        EarlyStatusTransContainer,
        #[serde(rename = "UE_RADIO_CAPABILITY_FOR_PAGING")]
        UeRadioCapabilityForPaging,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&NgapIeType> for NgapIeType {
        fn from(value: &NgapIeType) -> Self {
            value.clone()
        }
    }

    impl ToString for NgapIeType {
        fn to_string(&self) -> String {
            match *self {
                Self::PduResSetupReq => "PDU_RES_SETUP_REQ".to_string(),
                Self::PduResRelCmd => "PDU_RES_REL_CMD".to_string(),
                Self::PduResModReq => "PDU_RES_MOD_REQ".to_string(),
                Self::HandoverCmd => "HANDOVER_CMD".to_string(),
                Self::HandoverRequired => "HANDOVER_REQUIRED".to_string(),
                Self::HandoverPrepFail => "HANDOVER_PREP_FAIL".to_string(),
                Self::SrcToTarContainer => "SRC_TO_TAR_CONTAINER".to_string(),
                Self::TarToSrcContainer => "TAR_TO_SRC_CONTAINER".to_string(),
                Self::TarToSrcFailContainer => "TAR_TO_SRC_FAIL_CONTAINER".to_string(),
                Self::RanStatusTransContainer => "RAN_STATUS_TRANS_CONTAINER".to_string(),
                Self::SonConfigTransfer => "SON_CONFIG_TRANSFER".to_string(),
                Self::NrppaPdu => "NRPPA_PDU".to_string(),
                Self::UeRadioCapability => "UE_RADIO_CAPABILITY".to_string(),
                Self::RimInfoTransfer => "RIM_INFO_TRANSFER".to_string(),
                Self::SecondaryRatUsage => "SECONDARY_RAT_USAGE".to_string(),
                Self::Pc5QosPara => "PC5_QOS_PARA".to_string(),
                Self::EarlyStatusTransContainer => "EARLY_STATUS_TRANS_CONTAINER".to_string(),
                Self::UeRadioCapabilityForPaging => "UE_RADIO_CAPABILITY_FOR_PAGING".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for NgapIeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "PDU_RES_SETUP_REQ" => Ok(Self::PduResSetupReq),
                "PDU_RES_REL_CMD" => Ok(Self::PduResRelCmd),
                "PDU_RES_MOD_REQ" => Ok(Self::PduResModReq),
                "HANDOVER_CMD" => Ok(Self::HandoverCmd),
                "HANDOVER_REQUIRED" => Ok(Self::HandoverRequired),
                "HANDOVER_PREP_FAIL" => Ok(Self::HandoverPrepFail),
                "SRC_TO_TAR_CONTAINER" => Ok(Self::SrcToTarContainer),
                "TAR_TO_SRC_CONTAINER" => Ok(Self::TarToSrcContainer),
                "TAR_TO_SRC_FAIL_CONTAINER" => Ok(Self::TarToSrcFailContainer),
                "RAN_STATUS_TRANS_CONTAINER" => Ok(Self::RanStatusTransContainer),
                "SON_CONFIG_TRANSFER" => Ok(Self::SonConfigTransfer),
                "NRPPA_PDU" => Ok(Self::NrppaPdu),
                "UE_RADIO_CAPABILITY" => Ok(Self::UeRadioCapability),
                "RIM_INFO_TRANSFER" => Ok(Self::RimInfoTransfer),
                "SECONDARY_RAT_USAGE" => Ok(Self::SecondaryRatUsage),
                "PC5_QOS_PARA" => Ok(Self::Pc5QosPara),
                "EARLY_STATUS_TRANS_CONTAINER" => Ok(Self::EarlyStatusTransContainer),
                "UE_RADIO_CAPABILITY_FOR_PAGING" => Ok(Self::UeRadioCapabilityForPaging),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for NgapIeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for NgapIeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for NgapIeType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///This represents the identifier of the ng-eNB ID as specified in clause
    /// 9.3.1.8 of  3GPP TS 38.413. The value of the ng-eNB ID shall be encoded
    /// in hexadecimal representation.  Each character in the string shall take
    /// a value of "0" to "9", "a" to "f" or "A" to "F" and  shall represent 4
    /// bits. The padding 0 shall be added to make multiple nibbles, so the most
    /// significant character representing the padding 0 if required together
    /// with the 4 most  significant bits of the ng-eNB ID shall appear first in
    /// the string, and the character  representing the 4 least significant bit
    /// of the ng-eNB ID (to form a nibble) shall appear last  in the string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This represents the identifier of the ng-eNB ID as
    /// specified in clause 9.3.1.8 of  3GPP TS 38.413. The value of the ng-eNB
    /// ID shall be encoded in hexadecimal representation.  Each character in
    /// the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\"
    /// to \"F\" and  shall represent 4 bits. The padding 0 shall be added to
    /// make multiple nibbles, so the most  significant character representing
    /// the padding 0 if required together with the 4 most  significant bits of
    /// the ng-eNB ID shall appear first in the string, and the character
    /// representing the 4 least significant bit of the ng-eNB ID (to form a
    /// nibble) shall appear last  in the string. \n",
    ///  "examples": [
    ///    "SMacroNGeNB-34B89"
    ///  ],
    ///  "type": "string",
    ///  "pattern":
    /// "^(MacroNGeNB-[A-Fa-f0-9]{5}|LMacroNGeNB-[A-Fa-f0-9]{6}|SMacroNGeNB-[A-Fa-f0-9]{5})$"
    ///
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct NgeNbId(String);
    impl ::std::ops::Deref for NgeNbId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<NgeNbId> for String {
        fn from(value: NgeNbId) -> Self {
            value.0
        }
    }

    impl From<&NgeNbId> for NgeNbId {
        fn from(value: &NgeNbId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for NgeNbId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress :: Regex :: new ("^(MacroNGeNB-[A-Fa-f0-9]{5}|LMacroNGeNB-[A-Fa-f0-9]{6}|SMacroNGeNB-[A-Fa-f0-9]{5})$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(MacroNGeNB-[A-Fa-f0-9]{5}|LMacroNGeNB-[A-Fa-f0-9]{6}|SMacroNGeNB-[A-Fa-f0-9]{5})$\"" . into ()) ; }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for NgeNbId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for NgeNbId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for NgeNbId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for NgeNbId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///This represents the Network Identifier, which together with a PLMN ID is
    /// used to identify an SNPN (see 3GPP TS 23.003 and 3GPP TS 23.501 clause
    /// 5.30.2.1).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This represents the Network Identifier, which together
    /// with a PLMN ID is used to identify an SNPN (see 3GPP TS 23.003 and 3GPP
    /// TS 23.501 clause 5.30.2.1). \n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{11}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct Nid(String);
    impl ::std::ops::Deref for Nid {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Nid> for String {
        fn from(value: Nid) -> Self {
            value.0
        }
    }

    impl From<&Nid> for Nid {
        fn from(value: &Nid) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Nid {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{11}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{11}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Nid {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for Nid {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for Nid {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Nid {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Represents an Individual NWDAF Event Subscription resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents an Individual NWDAF Event Subscription
    /// resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "eventSubscriptions"
    ///  ],
    ///  "properties": {
    ///    "consNfInfo": {
    ///      "$ref": "#/components/schemas/ConsumerNfInformation"
    ///    },
    ///    "eventNotifications": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EventNotification"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "eventSubscriptions": {
    ///      "description": "Subscribed events",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EventSubscription"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "evtReq": {
    ///      "$ref": "#/components/schemas/ReportingInformation"
    ///    },
    ///    "failEventReports": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/FailureEventInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "notifCorrId": {
    ///      "description": "Notification correlation identifier.",
    ///      "type": "string"
    ///    },
    ///    "notificationURI": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "prevSub": {
    ///      "$ref": "#/components/schemas/PrevSubInfo"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NnwdafEventsSubscription {
        #[serde(
            rename = "consNfInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub cons_nf_info: Option<ConsumerNfInformation>,
        #[serde(
            rename = "eventNotifications",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub event_notifications: Vec<EventNotification>,
        ///Subscribed events
        #[serde(rename = "eventSubscriptions")]
        pub event_subscriptions: Vec<EventSubscription>,
        #[serde(rename = "evtReq", default, skip_serializing_if = "Option::is_none")]
        pub evt_req: Option<ReportingInformation>,
        #[serde(
            rename = "failEventReports",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub fail_event_reports: Vec<FailureEventInfo>,
        ///Notification correlation identifier.
        #[serde(
            rename = "notifCorrId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub notif_corr_id: Option<String>,
        #[serde(
            rename = "notificationURI",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub notification_uri: Option<Uri>,
        #[serde(rename = "prevSub", default, skip_serializing_if = "Option::is_none")]
        pub prev_sub: Option<PrevSubInfo>,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
    }

    impl From<&NnwdafEventsSubscription> for NnwdafEventsSubscription {
        fn from(value: &NnwdafEventsSubscription) -> Self {
            value.clone()
        }
    }

    ///Data within a create subscription request for non-UE specific N2
    /// information notification
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a create subscription request for non-UE
    /// specific N2 information notification",
    ///  "type": "object",
    ///  "required": [
    ///    "n2InformationClass",
    ///    "n2NotifyCallbackUri"
    ///  ],
    ///  "properties": {
    ///    "anTypeList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AccessType"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "globalRanNodeList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GlobalRanNodeId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "n2InformationClass": {
    ///      "$ref": "#/components/schemas/N2InformationClass"
    ///    },
    ///    "n2NotifyCallbackUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "nfId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NonUeN2InfoSubscriptionCreateData {
        #[serde(rename = "anTypeList", default, skip_serializing_if = "Vec::is_empty")]
        pub an_type_list: Vec<AccessType>,
        #[serde(
            rename = "globalRanNodeList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub global_ran_node_list: Vec<GlobalRanNodeId>,
        #[serde(rename = "n2InformationClass")]
        pub n2_information_class: N2InformationClass,
        #[serde(rename = "n2NotifyCallbackUri")]
        pub n2_notify_callback_uri: Uri,
        #[serde(rename = "nfId", default, skip_serializing_if = "Option::is_none")]
        pub nf_id: Option<NfInstanceId>,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
    }

    impl From<&NonUeN2InfoSubscriptionCreateData> for NonUeN2InfoSubscriptionCreateData {
        fn from(value: &NonUeN2InfoSubscriptionCreateData) -> Self {
            value.clone()
        }
    }

    ///Data for the created subscription for non-UE specific N2 information
    /// notification
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data for the created subscription for non-UE specific
    /// N2 information notification",
    ///  "type": "object",
    ///  "required": [
    ///    "n2NotifySubscriptionId"
    ///  ],
    ///  "properties": {
    ///    "n2InformationClass": {
    ///      "$ref": "#/components/schemas/N2InformationClass"
    ///    },
    ///    "n2NotifySubscriptionId": {
    ///      "type": "string"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NonUeN2InfoSubscriptionCreatedData {
        #[serde(
            rename = "n2InformationClass",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n2_information_class: Option<N2InformationClass>,
        #[serde(rename = "n2NotifySubscriptionId")]
        pub n2_notify_subscription_id: String,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
    }

    impl From<&NonUeN2InfoSubscriptionCreatedData> for NonUeN2InfoSubscriptionCreatedData {
        fn from(value: &NonUeN2InfoSubscriptionCreatedData) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - ACTIVATE: The event notification is activated.
    /// - DEACTIVATE: The event notification is deactivated and shall be muted.
    ///   The available event(s) shall be stored.
    /// - RETRIEVAL: The event notification shall be sent to the NF service
    ///   consumer(s),
    ///  after that, is muted again.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- ACTIVATE: The event
    /// notification is activated.\n- DEACTIVATE: The event notification is
    /// deactivated and shall be muted. The available\n   event(s) shall be
    /// stored.\n- RETRIEVAL: The event notification shall be sent to the NF
    /// service consumer(s),\n  after that, is muted again. \n",
    ///  "type": "string",
    ///  "enum": [
    ///    "ACTIVATE",
    ///    "DEACTIVATE",
    ///    "RETRIEVAL"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum NotificationFlag {
        #[serde(rename = "ACTIVATE")]
        Activate,
        #[serde(rename = "DEACTIVATE")]
        Deactivate,
        #[serde(rename = "RETRIEVAL")]
        Retrieval,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&NotificationFlag> for NotificationFlag {
        fn from(value: &NotificationFlag) -> Self {
            value.clone()
        }
    }

    impl ToString for NotificationFlag {
        fn to_string(&self) -> String {
            match *self {
                Self::Activate => "ACTIVATE".to_string(),
                Self::Deactivate => "DEACTIVATE".to_string(),
                Self::Retrieval => "RETRIEVAL".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for NotificationFlag {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ACTIVATE" => Ok(Self::Activate),
                "DEACTIVATE" => Ok(Self::Deactivate),
                "RETRIEVAL" => Ok(Self::Retrieval),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for NotificationFlag {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for NotificationFlag {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for NotificationFlag {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Possible values are:
    /// - PERIODIC: The subscribe of NWDAF Event is periodically. The periodic
    ///   of the notification is identified by repetitionPeriod defined in
    ///   clause 5.1.6.2.3.
    /// - THRESHOLD: The subscribe of NWDAF Event is upon threshold exceeded.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- PERIODIC: The subscribe of NWDAF Event is periodically. The periodic of the notification is identified by repetitionPeriod defined in clause 5.1.6.2.3.\n- THRESHOLD: The subscribe of NWDAF Event is upon threshold exceeded.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "PERIODIC",
    ///    "THRESHOLD"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum NotificationMethod {
        #[serde(rename = "PERIODIC")]
        Periodic,
        #[serde(rename = "THRESHOLD")]
        Threshold,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&NotificationMethod> for NotificationMethod {
        fn from(value: &NotificationMethod) -> Self {
            value.clone()
        }
    }

    impl ToString for NotificationMethod {
        fn to_string(&self) -> String {
            match *self {
                Self::Periodic => "PERIODIC".to_string(),
                Self::Threshold => "THRESHOLD".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for NotificationMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "PERIODIC" => Ok(Self::Periodic),
                "THRESHOLD" => Ok(Self::Threshold),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for NotificationMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for NotificationMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for NotificationMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Data within EventNotify notification
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within EventNotify notification",
    ///  "type": "object",
    ///  "required": [
    ///    "locationEvent"
    ///  ],
    ///  "properties": {
    ///    "achievedQos": {
    ///      "$ref": "#/components/schemas/MinorLocationQoS"
    ///    },
    ///    "ageOfLocationEstimate": {
    ///      "$ref": "#/components/schemas/AgeOfLocationEstimate"
    ///    },
    ///    "altitude": {
    ///      "$ref": "#/components/schemas/Altitude"
    ///    },
    ///    "barometricPressure": {
    ///      "$ref": "#/components/schemas/BarometricPressure"
    ///    },
    ///    "civicAddress": {
    ///      "$ref": "#/components/schemas/CivicAddress"
    ///    },
    ///    "ecgi": {
    ///      "$ref": "#/components/schemas/Ecgi"
    ///    },
    ///    "gnssPositioningDataList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GnssPositioningMethodAndUsage"
    ///      },
    ///      "maxItems": 9,
    ///      "minItems": 0
    ///    },
    ///    "gpsi": {
    ///      "$ref": "#/components/schemas/Gpsi"
    ///    },
    ///    "haGnssMetrics": {
    ///      "$ref": "#/components/schemas/HighAccuracyGnssMetrics"
    ///    },
    ///    "hgmlcCallBackURI": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "ldrReference": {
    ///      "$ref": "#/components/schemas/LdrReference"
    ///    },
    ///    "localLocationEstimate": {
    ///      "$ref": "#/components/schemas/LocalArea"
    ///    },
    ///    "locationEstimate": {
    ///      "$ref": "#/components/schemas/GeographicArea"
    ///    },
    ///    "locationEvent": {
    ///      "$ref": "#/components/schemas/LocationEvent"
    ///    },
    ///    "mscServerId": {
    ///      "$ref": "#/components/schemas/E164Number"
    ///    },
    ///    "ncgi": {
    ///      "$ref": "#/components/schemas/Ncgi"
    ///    },
    ///    "pei": {
    ///      "$ref": "#/components/schemas/Pei"
    ///    },
    ///    "positioningDataList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PositioningMethodAndUsage"
    ///      },
    ///      "maxItems": 9,
    ///      "minItems": 0
    ///    },
    ///    "servingLMFIdentification": {
    ///      "$ref": "#/components/schemas/LMFIdentification"
    ///    },
    ///    "servingNode": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "supi": {
    ///      "$ref": "#/components/schemas/Supi"
    ///    },
    ///    "targetMmeName": {
    ///      "$ref": "#/components/schemas/Fqdn"
    ///    },
    ///    "targetMmeRealm": {
    ///      "$ref": "#/components/schemas/Fqdn"
    ///    },
    ///    "terminationCause": {
    ///      "$ref": "#/components/schemas/TerminationCause"
    ///    },
    ///    "timestampOfLocationEstimate": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "utranSrvccInd": {
    ///      "type": "boolean"
    ///    },
    ///    "velocityEstimate": {
    ///      "$ref": "#/components/schemas/VelocityEstimate"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NotifiedPosInfo {
        #[serde(
            rename = "achievedQos",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub achieved_qos: Option<MinorLocationQoS>,
        #[serde(
            rename = "ageOfLocationEstimate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub age_of_location_estimate: Option<AgeOfLocationEstimate>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub altitude: Option<Altitude>,
        #[serde(
            rename = "barometricPressure",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub barometric_pressure: Option<BarometricPressure>,
        #[serde(
            rename = "civicAddress",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub civic_address: Option<CivicAddress>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ecgi: Option<Ecgi>,
        #[serde(
            rename = "gnssPositioningDataList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub gnss_positioning_data_list: Vec<GnssPositioningMethodAndUsage>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub gpsi: Option<Gpsi>,
        #[serde(
            rename = "haGnssMetrics",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ha_gnss_metrics: Option<HighAccuracyGnssMetrics>,
        #[serde(
            rename = "hgmlcCallBackURI",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub hgmlc_call_back_uri: Option<Uri>,
        #[serde(
            rename = "ldrReference",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ldr_reference: Option<LdrReference>,
        #[serde(
            rename = "localLocationEstimate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub local_location_estimate: Option<LocalArea>,
        #[serde(
            rename = "locationEstimate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub location_estimate: Option<GeographicArea>,
        #[serde(rename = "locationEvent")]
        pub location_event: LocationEvent,
        #[serde(
            rename = "mscServerId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub msc_server_id: Option<E164Number>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ncgi: Option<Ncgi>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pei: Option<Pei>,
        #[serde(
            rename = "positioningDataList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub positioning_data_list: Vec<PositioningMethodAndUsage>,
        #[serde(
            rename = "servingLMFIdentification",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub serving_lmf_identification: Option<LmfIdentification>,
        #[serde(
            rename = "servingNode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub serving_node: Option<NfInstanceId>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub supi: Option<Supi>,
        #[serde(
            rename = "targetMmeName",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_mme_name: Option<Fqdn>,
        #[serde(
            rename = "targetMmeRealm",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_mme_realm: Option<Fqdn>,
        #[serde(
            rename = "terminationCause",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub termination_cause: Option<TerminationCause>,
        #[serde(
            rename = "timestampOfLocationEstimate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub timestamp_of_location_estimate: Option<DateTime>,
        #[serde(
            rename = "utranSrvccInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub utran_srvcc_ind: Option<bool>,
        #[serde(
            rename = "velocityEstimate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub velocity_estimate: Option<VelocityEstimate>,
    }

    impl From<&NotifiedPosInfo> for NotifiedPosInfo {
        fn from(value: &NotifiedPosInfo) -> Self {
            value.clone()
        }
    }

    ///NPN Access Information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "NPN Access Information.",
    ///  "type": "object",
    ///  "properties": {
    ///    "cellCagInfo": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CagId"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NpnAccessInfo {
        #[serde(rename = "cellCagInfo", default, skip_serializing_if = "Vec::is_empty")]
        pub cell_cag_info: Vec<CagId>,
    }

    impl From<&NpnAccessInfo> for NpnAccessInfo {
        fn from(value: &NpnAccessInfo) -> Self {
            value.clone()
        }
    }

    ///36-bit string identifying an NR Cell Id as specified in clause 9.3.1.7
    /// of 3GPP TS 38.413,  in hexadecimal representation. Each character in the
    /// string shall take a value of "0" to "9",  "a" to "f" or "A" to "F" and
    /// shall represent 4 bits. The most significant character  representing the
    /// 4 most significant bits of the Cell Id shall appear first in the string,
    /// and  the character representing the 4 least significant bit of the Cell
    /// Id shall appear last in the  string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "36-bit string identifying an NR Cell Id as specified in clause 9.3.1.7 of 3GPP TS 38.413,  in hexadecimal representation. Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4 bits. The most significant character  representing the 4 most significant bits of the Cell Id shall appear first in the string, and  the character representing the 4 least significant bit of the Cell Id shall appear last in the  string. \n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{9}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct NrCellId(String);
    impl ::std::ops::Deref for NrCellId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<NrCellId> for String {
        fn from(value: NrCellId) -> Self {
            value.0
        }
    }

    impl From<&NrCellId> for NrCellId {
        fn from(value: &NrCellId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for NrCellId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{9}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{9}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for NrCellId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for NrCellId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for NrCellId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for NrCellId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Contains the NR user location.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the NR user location.",
    ///  "type": "object",
    ///  "required": [
    ///    "ncgi",
    ///    "tai"
    ///  ],
    ///  "properties": {
    ///    "ageOfLocationInformation": {
    ///      "description": "The value represents the elapsed time in minutes
    /// since the last network contact of the mobile station. Value \"0\"
    /// indicates that the location information was obtained after a successful
    /// paging procedure for Active Location Retrieval when the UE is in idle
    /// mode or after a successful  NG-RAN location reporting procedure with the
    /// eNB when the UE is in connected mode. Any other value than \"0\"
    /// indicates that the location information is the last known one. See 3GPP
    /// TS 29.002 clause 17.7.8.\n",
    ///      "type": "integer",
    ///      "maximum": 32767.0,
    ///      "minimum": 0.0
    ///    },
    ///    "geodeticInformation": {
    ///      "description": "Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763 (1999) [24] clause 3.88.2. Only the description of an ellipsoid point with uncertainty circle is allowed to be used.\n",
    ///      "type": "string",
    ///      "pattern": "^[0-9A-F]{20}$"
    ///    },
    ///    "geographicalInformation": {
    ///      "description": "Refer to geographical Information. See 3GPP TS
    /// 23.032 clause 7.3.2. Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.\n",
    ///      "type": "string",
    ///      "pattern": "^[0-9A-F]{16}$"
    ///    },
    ///    "globalGnbId": {
    ///      "$ref": "#/components/schemas/GlobalRanNodeId"
    ///    },
    ///    "ignoreNcgi": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "ncgi": {
    ///      "$ref": "#/components/schemas/Ncgi"
    ///    },
    ///    "tai": {
    ///      "$ref": "#/components/schemas/Tai"
    ///    },
    ///    "ueLocationTimestamp": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NrLocation {
        ///The value represents the elapsed time in minutes since the last
        /// network contact of the mobile station. Value "0" indicates that the
        /// location information was obtained after a successful paging
        /// procedure for Active Location Retrieval when the UE is in idle mode
        /// or after a successful  NG-RAN location reporting procedure with the
        /// eNB when the UE is in connected mode. Any other value than "0"
        /// indicates that the location information is the last known one. See
        /// 3GPP TS 29.002 clause 17.7.8.
        #[serde(
            rename = "ageOfLocationInformation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub age_of_location_information: Option<i64>,
        ///Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763
        /// (1999) [24] clause 3.88.2. Only the description of an ellipsoid
        /// point with uncertainty circle is allowed to be used.
        #[serde(
            rename = "geodeticInformation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub geodetic_information: Option<NrLocationGeodeticInformation>,
        ///Refer to geographical Information. See 3GPP TS 23.032 clause 7.3.2.
        /// Only the description of an ellipsoid point with uncertainty circle
        /// is allowed to be used.
        #[serde(
            rename = "geographicalInformation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub geographical_information: Option<NrLocationGeographicalInformation>,
        #[serde(
            rename = "globalGnbId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub global_gnb_id: Option<GlobalRanNodeId>,
        #[serde(rename = "ignoreNcgi", default)]
        pub ignore_ncgi: bool,
        pub ncgi: Ncgi,
        pub tai: Tai,
        #[serde(
            rename = "ueLocationTimestamp",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_location_timestamp: Option<DateTime>,
    }

    impl From<&NrLocation> for NrLocation {
        fn from(value: &NrLocation) -> Self {
            value.clone()
        }
    }

    ///Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763
    /// (1999) [24] clause 3.88.2. Only the description of an ellipsoid point
    /// with uncertainty circle is allowed to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refers to Calling Geodetic Location. See ITU-T Recommendation Q.763 (1999) [24] clause 3.88.2. Only the description of an ellipsoid point with uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{20}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct NrLocationGeodeticInformation(String);
    impl ::std::ops::Deref for NrLocationGeodeticInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<NrLocationGeodeticInformation> for String {
        fn from(value: NrLocationGeodeticInformation) -> Self {
            value.0
        }
    }

    impl From<&NrLocationGeodeticInformation> for NrLocationGeodeticInformation {
        fn from(value: &NrLocationGeodeticInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for NrLocationGeodeticInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{20}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for NrLocationGeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for NrLocationGeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for NrLocationGeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for NrLocationGeodeticInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Refer to geographical Information. See 3GPP TS 23.032 clause 7.3.2. Only
    /// the description of an ellipsoid point with uncertainty circle is allowed
    /// to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refer to geographical Information. See 3GPP TS 23.032
    /// clause 7.3.2. Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{16}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct NrLocationGeographicalInformation(String);
    impl ::std::ops::Deref for NrLocationGeographicalInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<NrLocationGeographicalInformation> for String {
        fn from(value: NrLocationGeographicalInformation) -> Self {
            value.0
        }
    }

    impl From<&NrLocationGeographicalInformation> for NrLocationGeographicalInformation {
        fn from(value: &NrLocationGeographicalInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for NrLocationGeographicalInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{16}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for NrLocationGeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for NrLocationGeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for NrLocationGeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for NrLocationGeographicalInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Contains NR V2X services authorized information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains NR V2X services authorized information.",
    ///  "type": "object",
    ///  "properties": {
    ///    "pedestrianUeAuth": {
    ///      "$ref": "#/components/schemas/UeAuth"
    ///    },
    ///    "vehicleUeAuth": {
    ///      "$ref": "#/components/schemas/UeAuth"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NrV2xAuth {
        #[serde(
            rename = "pedestrianUeAuth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pedestrian_ue_auth: Option<UeAuth>,
        #[serde(
            rename = "vehicleUeAuth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub vehicle_ue_auth: Option<UeAuth>,
    }

    impl From<&NrV2xAuth> for NrV2xAuth {
        fn from(value: &NrV2xAuth) -> Self {
            value.clone()
        }
    }

    ///Represents a NRPPa related N2 information data part
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a NRPPa related N2 information data part",
    ///  "type": "object",
    ///  "required": [
    ///    "nfId",
    ///    "nrppaPdu"
    ///  ],
    ///  "properties": {
    ///    "nfId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "nrppaPdu": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    },
    ///    "serviceInstanceId": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NrppaInformation {
        #[serde(rename = "nfId")]
        pub nf_id: NfInstanceId,
        #[serde(rename = "nrppaPdu")]
        pub nrppa_pdu: N2InfoContent,
        #[serde(
            rename = "serviceInstanceId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub service_instance_id: Option<String>,
    }

    impl From<&NrppaInformation> for NrppaInformation {
        fn from(value: &NrppaInformation) -> Self {
            value.clone()
        }
    }

    ///Contains the Identifier of the selected Network Slice instance
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the Identifier of the selected Network Slice
    /// instance",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct NsiId(pub String);
    impl ::std::ops::Deref for NsiId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<NsiId> for String {
        fn from(value: NsiId) -> Self {
            value.0
        }
    }

    impl From<&NsiId> for NsiId {
        fn from(value: &NsiId) -> Self {
            value.clone()
        }
    }

    impl From<String> for NsiId {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for NsiId {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for NsiId {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Represents the S-NSSAI and the optionally associated Network Slice
    /// Instance(s).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the S-NSSAI and the optionally associated
    /// Network Slice Instance(s).",
    ///  "type": "object",
    ///  "required": [
    ///    "snssai"
    ///  ],
    ///  "properties": {
    ///    "nsiIds": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NsiId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NsiIdInfo {
        #[serde(rename = "nsiIds", default, skip_serializing_if = "Vec::is_empty")]
        pub nsi_ids: Vec<NsiId>,
        pub snssai: Snssai,
    }

    impl From<&NsiIdInfo> for NsiIdInfo {
        fn from(value: &NsiIdInfo) -> Self {
            value.clone()
        }
    }

    ///Contains the API URIs of NRF services to be used to discover
    /// NFs/services, subscribe to NF status changes and/or request access
    /// tokens within the selected Network Slice instance and optional the
    /// Identifier of the selected Network Slice instance
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the API URIs of NRF services to be used to
    /// discover NFs/services, subscribe to NF status changes and/or request
    /// access tokens within the selected Network Slice instance and optional
    /// the Identifier of the selected Network Slice instance\n",
    ///  "type": "object",
    ///  "required": [
    ///    "nrfId"
    ///  ],
    ///  "properties": {
    ///    "nrfAccessTokenUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "nrfId": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "nrfNfMgtUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "nrfOauth2Required": {
    ///      "description": "Map indicating whether the NRF requires
    /// Oauth2-based authorization for accessing its services. The key of the
    /// map shall be the name of an NRF service, e.g. \"nnrf-nfm\" or
    /// \"nnrf-disc\"\n",
    ///      "type": "object",
    ///      "minProperties": 1,
    ///      "additionalProperties": {
    ///        "type": "boolean"
    ///      }
    ///    },
    ///    "nsiId": {
    ///      "$ref": "#/components/schemas/NsiId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NsiInformation {
        #[serde(
            rename = "nrfAccessTokenUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nrf_access_token_uri: Option<Uri>,
        #[serde(rename = "nrfId")]
        pub nrf_id: Uri,
        #[serde(
            rename = "nrfNfMgtUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nrf_nf_mgt_uri: Option<Uri>,
        ///Map indicating whether the NRF requires Oauth2-based authorization
        /// for accessing its services. The key of the map shall be the name of
        /// an NRF service, e.g. "nnrf-nfm" or "nnrf-disc"
        #[serde(
            rename = "nrfOauth2Required",
            default,
            skip_serializing_if = "::std::collections::HashMap::is_empty"
        )]
        pub nrf_oauth2_required: ::std::collections::HashMap<String, bool>,
        #[serde(rename = "nsiId", default, skip_serializing_if = "Option::is_none")]
        pub nsi_id: Option<NsiId>,
    }

    impl From<&NsiInformation> for NsiInformation {
        fn from(value: &NsiInformation) -> Self {
            value.clone()
        }
    }

    ///Represents the network slice and optionally the associated network slice
    /// instance and the load level information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the network slice and optionally the associated network slice instance and the load level information.\n",
    ///  "type": "object",
    ///  "required": [
    ///    "loadLevelInformation",
    ///    "snssai"
    ///  ],
    ///  "properties": {
    ///    "confidence": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "exceedLoadLevelThrInd": {
    ///      "type": "boolean"
    ///    },
    ///    "loadLevelInformation": {
    ///      "$ref": "#/components/schemas/LoadLevelInformation"
    ///    },
    ///    "networkArea": {
    ///      "$ref": "#/components/schemas/NetworkAreaInfo"
    ///    },
    ///    "nsiId": {
    ///      "$ref": "#/components/schemas/NsiId"
    ///    },
    ///    "numOfExceedLoadLevelThr": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "numOfPduSess": {
    ///      "$ref": "#/components/schemas/NumberAverage"
    ///    },
    ///    "numOfUes": {
    ///      "$ref": "#/components/schemas/NumberAverage"
    ///    },
    ///    "resUsage": {
    ///      "$ref": "#/components/schemas/ResourceUsage"
    ///    },
    ///    "resUsgThrCrossTimePeriod": {
    ///      "description": "Each element indicates the time elapsed between
    /// times each threshold is met or exceeded or crossed. The start time and
    /// end time are the exact time stamps of the resource usage threshold is
    /// reached or exceeded. May be present if the \"listOfAnaSubsets\"
    /// attribute is\n provided and the maximum number of instances shall not
    /// exceed the value provided in the\n \"numOfExceedLoadLevelThr\"
    /// attribute.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TimeWindow"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "timePeriod": {
    ///      "$ref": "#/components/schemas/TimeWindow"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NsiLoadLevelInfo {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub confidence: Option<Uinteger>,
        #[serde(
            rename = "exceedLoadLevelThrInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub exceed_load_level_thr_ind: Option<bool>,
        #[serde(rename = "loadLevelInformation")]
        pub load_level_information: LoadLevelInformation,
        #[serde(
            rename = "networkArea",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub network_area: Option<NetworkAreaInfo>,
        #[serde(rename = "nsiId", default, skip_serializing_if = "Option::is_none")]
        pub nsi_id: Option<NsiId>,
        #[serde(
            rename = "numOfExceedLoadLevelThr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub num_of_exceed_load_level_thr: Option<Uinteger>,
        #[serde(
            rename = "numOfPduSess",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub num_of_pdu_sess: Option<NumberAverage>,
        #[serde(rename = "numOfUes", default, skip_serializing_if = "Option::is_none")]
        pub num_of_ues: Option<NumberAverage>,
        #[serde(rename = "resUsage", default, skip_serializing_if = "Option::is_none")]
        pub res_usage: Option<ResourceUsage>,
        ///Each element indicates the time elapsed between times each threshold
        /// is met or exceeded or crossed. The start time and end time are the
        /// exact time stamps of the resource usage threshold is reached or
        /// exceeded. May be present if the "listOfAnaSubsets" attribute is
        /// provided and the maximum number of instances shall not exceed the
        /// value provided in the "numOfExceedLoadLevelThr" attribute.
        #[serde(
            rename = "resUsgThrCrossTimePeriod",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub res_usg_thr_cross_time_period: Vec<TimeWindow>,
        pub snssai: Snssai,
        #[serde(
            rename = "timePeriod",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub time_period: Option<TimeWindow>,
    }

    impl From<&NsiLoadLevelInfo> for NsiLoadLevelInfo {
        fn from(value: &NsiLoadLevelInfo) -> Self {
            value.clone()
        }
    }

    ///contains the Subscribed S-NSSAI subject to NSSAA procedure and the
    /// status.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "contains the Subscribed S-NSSAI subject to NSSAA
    /// procedure and the status.",
    ///  "type": "object",
    ///  "required": [
    ///    "snssai",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "status": {
    ///      "$ref": "#/components/schemas/AuthStatus"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NssaaStatus {
        pub snssai: Snssai,
        pub status: AuthStatus,
    }

    impl From<&NssaaStatus> for NssaaStatus {
        fn from(value: &NssaaStatus) -> Self {
            value.clone()
        }
    }

    ///Represents the mapping between a S-NSSAI in serving PLMN to a S-NSSAI in
    /// home PLMN
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the mapping between a S-NSSAI in serving
    /// PLMN to a S-NSSAI in home PLMN",
    ///  "type": "object",
    ///  "required": [
    ///    "hSnssai",
    ///    "mappedSnssai"
    ///  ],
    ///  "properties": {
    ///    "hSnssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "mappedSnssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NssaiMapping {
        #[serde(rename = "hSnssai")]
        pub h_snssai: Snssai,
        #[serde(rename = "mappedSnssai")]
        pub mapped_snssai: Snssai,
    }

    impl From<&NssaiMapping> for NssaiMapping {
        fn from(value: &NssaiMapping) -> Self {
            value.clone()
        }
    }

    ///Represents average and variance information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents average and variance information.",
    ///  "type": "object",
    ///  "required": [
    ///    "number",
    ///    "variance"
    ///  ],
    ///  "properties": {
    ///    "number": {
    ///      "$ref": "#/components/schemas/Float"
    ///    },
    ///    "skewness": {
    ///      "$ref": "#/components/schemas/Float"
    ///    },
    ///    "variance": {
    ///      "$ref": "#/components/schemas/Float"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NumberAverage {
        pub number: Float,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub skewness: Option<Float>,
        pub variance: Float,
    }

    impl From<&NumberAverage> for NumberAverage {
        fn from(value: &NumberAverage) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - SLICE_LOAD_LEVEL: Indicates that the event subscribed is load level
    ///   information of Network Slice
    /// - NETWORK_PERFORMANCE: Indicates that the event subscribed is network
    ///   performance information.
    /// - NF_LOAD: Indicates that the event subscribed is load level and status
    ///   of one or several Network Functions.
    /// - SERVICE_EXPERIENCE: Indicates that the event subscribed is service
    ///   experience.
    /// - UE_MOBILITY: Indicates that the event subscribed is UE mobility
    ///   information.
    /// - UE_COMMUNICATION: Indicates that the event subscribed is UE
    ///   communication information.
    /// - QOS_SUSTAINABILITY: Indicates that the event subscribed is QoS
    ///   sustainability.
    /// - ABNORMAL_BEHAVIOUR: Indicates that the event subscribed is abnormal
    ///   behaviour.
    /// - USER_DATA_CONGESTION: Indicates that the event subscribed is user data
    ///   congestion information.
    /// - NSI_LOAD_LEVEL: Indicates that the event subscribed is load level
    ///   information of Network Slice and the optionally associated Network
    ///   Slice Instance
    /// - DN_PERFORMANCE: Indicates that the event subscribed is DN performance
    ///   information.
    /// - DISPERSION: Indicates that the event subscribed is dispersion
    ///   information.
    /// - RED_TRANS_EXP: Indicates that the event subscribed is redundant
    ///   transmission experience.
    /// - WLAN_PERFORMANCE: Indicates that the event subscribed is WLAN
    ///   performance.
    /// - SM_CONGESTION: Indicates the Session Management Congestion Control
    ///   Experience information for specific DNN and/or S-NSSAI.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- SLICE_LOAD_LEVEL: Indicates
    /// that the event subscribed is load level information of Network Slice\n-
    /// NETWORK_PERFORMANCE: Indicates that the event subscribed is network
    /// performance information.\n- NF_LOAD: Indicates that the event subscribed
    /// is load level and status of one or several Network Functions.\n-
    /// SERVICE_EXPERIENCE: Indicates that the event subscribed is service
    /// experience.\n- UE_MOBILITY: Indicates that the event subscribed is UE
    /// mobility information.\n- UE_COMMUNICATION: Indicates that the event
    /// subscribed is UE communication information.\n- QOS_SUSTAINABILITY:
    /// Indicates that the event subscribed is QoS sustainability.\n-
    /// ABNORMAL_BEHAVIOUR: Indicates that the event subscribed is abnormal
    /// behaviour.\n- USER_DATA_CONGESTION: Indicates that the event subscribed
    /// is user data congestion information.\n- NSI_LOAD_LEVEL: Indicates that
    /// the event subscribed is load level information of Network Slice and the
    /// optionally associated Network Slice Instance\n- DN_PERFORMANCE:
    /// Indicates that the event subscribed is DN performance information.\n-
    /// DISPERSION: Indicates that the event subscribed is dispersion
    /// information.\n- RED_TRANS_EXP: Indicates that the event subscribed is
    /// redundant transmission experience.\n- WLAN_PERFORMANCE: Indicates that
    /// the event subscribed is WLAN performance.\n- SM_CONGESTION: Indicates
    /// the Session Management Congestion Control Experience information for
    /// specific DNN and/or S-NSSAI.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "SLICE_LOAD_LEVEL",
    ///    "NETWORK_PERFORMANCE",
    ///    "NF_LOAD",
    ///    "SERVICE_EXPERIENCE",
    ///    "UE_MOBILITY",
    ///    "UE_COMMUNICATION",
    ///    "QOS_SUSTAINABILITY",
    ///    "ABNORMAL_BEHAVIOUR",
    ///    "USER_DATA_CONGESTION",
    ///    "NSI_LOAD_LEVEL",
    ///    "DN_PERFORMANCE",
    ///    "DISPERSION",
    ///    "RED_TRANS_EXP",
    ///    "WLAN_PERFORMANCE",
    ///    "SM_CONGESTION"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum NwdafEvent {
        #[serde(rename = "SLICE_LOAD_LEVEL")]
        SliceLoadLevel,
        #[serde(rename = "NETWORK_PERFORMANCE")]
        NetworkPerformance,
        #[serde(rename = "NF_LOAD")]
        NfLoad,
        #[serde(rename = "SERVICE_EXPERIENCE")]
        ServiceExperience,
        #[serde(rename = "UE_MOBILITY")]
        UeMobility,
        #[serde(rename = "UE_COMMUNICATION")]
        UeCommunication,
        #[serde(rename = "QOS_SUSTAINABILITY")]
        QosSustainability,
        #[serde(rename = "ABNORMAL_BEHAVIOUR")]
        AbnormalBehaviour,
        #[serde(rename = "USER_DATA_CONGESTION")]
        UserDataCongestion,
        #[serde(rename = "NSI_LOAD_LEVEL")]
        NsiLoadLevel,
        #[serde(rename = "DN_PERFORMANCE")]
        DnPerformance,
        #[serde(rename = "DISPERSION")]
        Dispersion,
        #[serde(rename = "RED_TRANS_EXP")]
        RedTransExp,
        #[serde(rename = "WLAN_PERFORMANCE")]
        WlanPerformance,
        #[serde(rename = "SM_CONGESTION")]
        SmCongestion,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&NwdafEvent> for NwdafEvent {
        fn from(value: &NwdafEvent) -> Self {
            value.clone()
        }
    }

    impl ToString for NwdafEvent {
        fn to_string(&self) -> String {
            match *self {
                Self::SliceLoadLevel => "SLICE_LOAD_LEVEL".to_string(),
                Self::NetworkPerformance => "NETWORK_PERFORMANCE".to_string(),
                Self::NfLoad => "NF_LOAD".to_string(),
                Self::ServiceExperience => "SERVICE_EXPERIENCE".to_string(),
                Self::UeMobility => "UE_MOBILITY".to_string(),
                Self::UeCommunication => "UE_COMMUNICATION".to_string(),
                Self::QosSustainability => "QOS_SUSTAINABILITY".to_string(),
                Self::AbnormalBehaviour => "ABNORMAL_BEHAVIOUR".to_string(),
                Self::UserDataCongestion => "USER_DATA_CONGESTION".to_string(),
                Self::NsiLoadLevel => "NSI_LOAD_LEVEL".to_string(),
                Self::DnPerformance => "DN_PERFORMANCE".to_string(),
                Self::Dispersion => "DISPERSION".to_string(),
                Self::RedTransExp => "RED_TRANS_EXP".to_string(),
                Self::WlanPerformance => "WLAN_PERFORMANCE".to_string(),
                Self::SmCongestion => "SM_CONGESTION".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for NwdafEvent {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SLICE_LOAD_LEVEL" => Ok(Self::SliceLoadLevel),
                "NETWORK_PERFORMANCE" => Ok(Self::NetworkPerformance),
                "NF_LOAD" => Ok(Self::NfLoad),
                "SERVICE_EXPERIENCE" => Ok(Self::ServiceExperience),
                "UE_MOBILITY" => Ok(Self::UeMobility),
                "UE_COMMUNICATION" => Ok(Self::UeCommunication),
                "QOS_SUSTAINABILITY" => Ok(Self::QosSustainability),
                "ABNORMAL_BEHAVIOUR" => Ok(Self::AbnormalBehaviour),
                "USER_DATA_CONGESTION" => Ok(Self::UserDataCongestion),
                "NSI_LOAD_LEVEL" => Ok(Self::NsiLoadLevel),
                "DN_PERFORMANCE" => Ok(Self::DnPerformance),
                "DISPERSION" => Ok(Self::Dispersion),
                "RED_TRANS_EXP" => Ok(Self::RedTransExp),
                "WLAN_PERFORMANCE" => Ok(Self::WlanPerformance),
                "SM_CONGESTION" => Ok(Self::SmCongestion),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for NwdafEvent {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for NwdafEvent {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for NwdafEvent {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Possible values are:
    /// - UNAVAILABLE_DATA: Indicates the requested statistics information for
    ///   the event is rejected since necessary data to perform the service is
    ///   unavailable.
    /// - BOTH_STAT_PRED_NOT_ALLOWED: Indicates the requested analysis
    ///   information for the event is rejected since the start time is in the
    ///   past and the end time is in the future, which means the NF service
    ///   consumer requested both statistics and prediction for the analytics.
    /// - UNSATISFIED_REQUESTED_ANALYTICS_TIME: Indicates that the requested
    ///   event is rejected since the analytics information is not ready when
    ///   the time indicated by the "timeAnaNeeded" attribute (as provided
    ///   during the creation or modification of subscription) is reached.
    /// - OTHER: Indicates the requested analysis information for the event is
    ///   rejected due to other reasons.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- UNAVAILABLE_DATA: Indicates the
    /// requested statistics information for the event is rejected since
    /// necessary data to perform the service is unavailable.\n-
    /// BOTH_STAT_PRED_NOT_ALLOWED: Indicates the requested analysis information
    /// for the event is rejected since the start time is in the past and the
    /// end time is in the future, which means the NF service consumer requested
    /// both statistics and prediction for the analytics.\n-
    /// UNSATISFIED_REQUESTED_ANALYTICS_TIME: Indicates that the requested event
    /// is rejected since the analytics information is not ready when the time
    /// indicated by the \"timeAnaNeeded\" attribute (as provided during the
    /// creation or modification of subscription) is reached.\n- OTHER:
    /// Indicates the requested analysis information for the event is rejected
    /// due to other reasons.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "UNAVAILABLE_DATA",
    ///    "BOTH_STAT_PRED_NOT_ALLOWED",
    ///    "UNSATISFIED_REQUESTED_ANALYTICS_TIME",
    ///    "OTHER"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum NwdafFailureCode {
        #[serde(rename = "UNAVAILABLE_DATA")]
        UnavailableData,
        #[serde(rename = "BOTH_STAT_PRED_NOT_ALLOWED")]
        BothStatPredNotAllowed,
        #[serde(rename = "UNSATISFIED_REQUESTED_ANALYTICS_TIME")]
        UnsatisfiedRequestedAnalyticsTime,
        #[serde(rename = "OTHER")]
        Other,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&NwdafFailureCode> for NwdafFailureCode {
        fn from(value: &NwdafFailureCode) -> Self {
            value.clone()
        }
    }

    impl ToString for NwdafFailureCode {
        fn to_string(&self) -> String {
            match *self {
                Self::UnavailableData => "UNAVAILABLE_DATA".to_string(),
                Self::BothStatPredNotAllowed => "BOTH_STAT_PRED_NOT_ALLOWED".to_string(),
                Self::UnsatisfiedRequestedAnalyticsTime => {
                    "UNSATISFIED_REQUESTED_ANALYTICS_TIME".to_string()
                }
                Self::Other => "OTHER".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for NwdafFailureCode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "UNAVAILABLE_DATA" => Ok(Self::UnavailableData),
                "BOTH_STAT_PRED_NOT_ALLOWED" => Ok(Self::BothStatPredNotAllowed),
                "UNSATISFIED_REQUESTED_ANALYTICS_TIME" => {
                    Ok(Self::UnsatisfiedRequestedAnalyticsTime)
                }
                "OTHER" => Ok(Self::Other),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for NwdafFailureCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for NwdafFailureCode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for NwdafFailureCode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Individual NWDAF subscription identified by the subscription Id.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Individual NWDAF subscription identified by the
    /// subscription Id.",
    ///  "type": "object",
    ///  "required": [
    ///    "nwdafEventsSubscription",
    ///    "nwdafEvtSubsServiceUri"
    ///  ],
    ///  "properties": {
    ///    "nwdafEventsSubscription": {
    ///      "$ref": "#/components/schemas/NnwdafEventsSubscription"
    ///    },
    ///    "nwdafEvtSubsServiceUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct NwdafSubscription {
        #[serde(rename = "nwdafEventsSubscription")]
        pub nwdaf_events_subscription: NnwdafEventsSubscription,
        #[serde(rename = "nwdafEvtSubsServiceUri")]
        pub nwdaf_evt_subs_service_uri: Uri,
    }

    impl From<&NwdafSubscription> for NwdafSubscription {
        fn from(value: &NwdafSubscription) -> Self {
            value.clone()
        }
    }

    ///Represents the observed redundant transmission experience related
    /// information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the observed redundant transmission
    /// experience related information.",
    ///  "type": "object",
    ///  "properties": {
    ///    "avgPktDelayDl": {
    ///      "$ref": "#/components/schemas/PacketDelBudget"
    ///    },
    ///    "avgPktDelayUl": {
    ///      "$ref": "#/components/schemas/PacketDelBudget"
    ///    },
    ///    "avgPktDropRateDl": {
    ///      "$ref": "#/components/schemas/PacketLossRate"
    ///    },
    ///    "avgPktDropRateUl": {
    ///      "$ref": "#/components/schemas/PacketLossRate"
    ///    },
    ///    "varPktDelayDl": {
    ///      "$ref": "#/components/schemas/Float"
    ///    },
    ///    "varPktDelayUl": {
    ///      "$ref": "#/components/schemas/Float"
    ///    },
    ///    "varPktDropRateDl": {
    ///      "$ref": "#/components/schemas/Float"
    ///    },
    ///    "varPktDropRateUl": {
    ///      "$ref": "#/components/schemas/Float"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ObservedRedundantTransExp {
        #[serde(
            rename = "avgPktDelayDl",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub avg_pkt_delay_dl: Option<PacketDelBudget>,
        #[serde(
            rename = "avgPktDelayUl",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub avg_pkt_delay_ul: Option<PacketDelBudget>,
        #[serde(
            rename = "avgPktDropRateDl",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub avg_pkt_drop_rate_dl: Option<PacketLossRate>,
        #[serde(
            rename = "avgPktDropRateUl",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub avg_pkt_drop_rate_ul: Option<PacketLossRate>,
        #[serde(
            rename = "varPktDelayDl",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub var_pkt_delay_dl: Option<Float>,
        #[serde(
            rename = "varPktDelayUl",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub var_pkt_delay_ul: Option<Float>,
        #[serde(
            rename = "varPktDropRateDl",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub var_pkt_drop_rate_dl: Option<Float>,
        #[serde(
            rename = "varPktDropRateUl",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub var_pkt_drop_rate_ul: Option<Float>,
    }

    impl From<&ObservedRedundantTransExp> for ObservedRedundantTransExp {
        fn from(value: &ObservedRedundantTransExp) -> Self {
            value.clone()
        }
    }

    ///Specifies occurrence of event reporting.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Specifies occurrence of event reporting.",
    ///  "type": "string",
    ///  "enum": [
    ///    "ONE_TIME_EVENT",
    ///    "MULTIPLE_TIME_EVENT"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OccurrenceInfo {
        #[serde(rename = "ONE_TIME_EVENT")]
        OneTimeEvent,
        #[serde(rename = "MULTIPLE_TIME_EVENT")]
        MultipleTimeEvent,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&OccurrenceInfo> for OccurrenceInfo {
        fn from(value: &OccurrenceInfo) -> Self {
            value.clone()
        }
    }

    impl ToString for OccurrenceInfo {
        fn to_string(&self) -> String {
            match *self {
                Self::OneTimeEvent => "ONE_TIME_EVENT".to_string(),
                Self::MultipleTimeEvent => "MULTIPLE_TIME_EVENT".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for OccurrenceInfo {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ONE_TIME_EVENT" => Ok(Self::OneTimeEvent),
                "MULTIPLE_TIME_EVENT" => Ok(Self::MultipleTimeEvent),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for OccurrenceInfo {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for OccurrenceInfo {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for OccurrenceInfo {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents the OMC Identifier
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the OMC Identifier",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct OmcIdentifier(pub String);
    impl ::std::ops::Deref for OmcIdentifier {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<OmcIdentifier> for String {
        fn from(value: OmcIdentifier) -> Self {
            value.0
        }
    }

    impl From<&OmcIdentifier> for OmcIdentifier {
        fn from(value: &OmcIdentifier) -> Self {
            value.clone()
        }
    }

    impl From<String> for OmcIdentifier {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for OmcIdentifier {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for OmcIdentifier {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Indicates value of orientation angle.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates value of orientation angle.",
    ///  "type": "integer",
    ///  "maximum": 180.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Orientation(pub i64);
    impl ::std::ops::Deref for Orientation {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<Orientation> for i64 {
        fn from(value: Orientation) -> Self {
            value.0
        }
    }

    impl From<&Orientation> for Orientation {
        fn from(value: &Orientation) -> Self {
            value.clone()
        }
    }

    impl From<i64> for Orientation {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for Orientation {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for Orientation {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Orientation {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Orientation {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for Orientation {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Possible values are:
    /// - BINARY: Indicates that the analytics shall only be reported when the
    ///   requested level of accuracy is reached within a cycle of periodic
    ///   notification.
    /// - GRADIENT: Indicates that the analytics shall be reported according
    ///   with the periodicity irrespective of whether the requested level of
    ///   accuracy has been reached or not.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- BINARY: Indicates that the
    /// analytics shall only be reported when the requested level of accuracy is
    /// reached within a cycle of periodic notification.\n- GRADIENT: Indicates
    /// that the analytics shall be reported according with the periodicity
    /// irrespective of whether the requested level of accuracy has been reached
    /// or not.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "BINARY",
    ///    "GRADIENT"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum OutputStrategy {
        #[serde(rename = "BINARY")]
        Binary,
        #[serde(rename = "GRADIENT")]
        Gradient,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&OutputStrategy> for OutputStrategy {
        fn from(value: &OutputStrategy) -> Self {
            value.clone()
        }
    }

    impl ToString for OutputStrategy {
        fn to_string(&self) -> String {
            match *self {
                Self::Binary => "BINARY".to_string(),
                Self::Gradient => "GRADIENT".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for OutputStrategy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "BINARY" => Ok(Self::Binary),
                "GRADIENT" => Ok(Self::Gradient),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for OutputStrategy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for OutputStrategy {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for OutputStrategy {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Unsigned integer indicating Packet Delay Budget (see clauses 5.7.3.4 and
    /// 5.7.4 of 3GPP TS 23.501), expressed in milliseconds.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unsigned integer indicating Packet Delay Budget (see
    /// clauses 5.7.3.4 and 5.7.4 of 3GPP TS 23.501), expressed in
    /// milliseconds.\n",
    ///  "type": "integer",
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PacketDelBudget(pub std::num::NonZeroU64);
    impl ::std::ops::Deref for PacketDelBudget {
        type Target = std::num::NonZeroU64;
        fn deref(&self) -> &std::num::NonZeroU64 {
            &self.0
        }
    }

    impl From<PacketDelBudget> for std::num::NonZeroU64 {
        fn from(value: PacketDelBudget) -> Self {
            value.0
        }
    }

    impl From<&PacketDelBudget> for PacketDelBudget {
        fn from(value: &PacketDelBudget) -> Self {
            value.clone()
        }
    }

    impl From<std::num::NonZeroU64> for PacketDelBudget {
        fn from(value: std::num::NonZeroU64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for PacketDelBudget {
        type Err = <std::num::NonZeroU64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for PacketDelBudget {
        type Error = <std::num::NonZeroU64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PacketDelBudget {
        type Error = <std::num::NonZeroU64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PacketDelBudget {
        type Error = <std::num::NonZeroU64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for PacketDelBudget {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///String representing Packet Error Rate (see clause 5.7.3.5 and 5.7.4 of
    /// 3GPP TS 23.501, expressed as a "scalar x 10-k" where the scalar and the
    /// exponent k are each encoded as one decimal digit.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String representing Packet Error Rate (see clause
    /// 5.7.3.5 and 5.7.4 of 3GPP TS 23.501, expressed as a \"scalar x 10-k\"
    /// where the scalar and the exponent k are each encoded as one decimal
    /// digit.\n",
    ///  "type": "string",
    ///  "pattern": "^([0-9]E-[0-9])$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct PacketErrRate(String);
    impl ::std::ops::Deref for PacketErrRate {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<PacketErrRate> for String {
        fn from(value: PacketErrRate) -> Self {
            value.0
        }
    }

    impl From<&PacketErrRate> for PacketErrRate {
        fn from(value: &PacketErrRate) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for PacketErrRate {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^([0-9]E-[0-9])$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^([0-9]E-[0-9])$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for PacketErrRate {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for PacketErrRate {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for PacketErrRate {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for PacketErrRate {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Unsigned integer indicating Packet Loss Rate (see clauses 5.7.2.8 and
    /// 5.7.4 of 3GPP TS 23.501), expressed in tenth of percent.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unsigned integer indicating Packet Loss Rate (see
    /// clauses 5.7.2.8 and 5.7.4 of 3GPP TS 23.501), expressed in tenth of
    /// percent.\n",
    ///  "type": "integer",
    ///  "maximum": 1000.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PacketLossRate(pub i64);
    impl ::std::ops::Deref for PacketLossRate {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<PacketLossRate> for i64 {
        fn from(value: PacketLossRate) -> Self {
            value.0
        }
    }

    impl From<&PacketLossRate> for PacketLossRate {
        fn from(value: &PacketLossRate) -> Self {
            value.clone()
        }
    }

    impl From<i64> for PacketLossRate {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for PacketLossRate {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for PacketLossRate {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PacketLossRate {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PacketLossRate {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for PacketLossRate {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Possible values are:
    /// - "TAC": Type Allocation Code
    /// - "SUBPLMN": Subscriber PLMN ID
    /// - "GEOAREA": Geographical area, i.e. list(s) of TAI(s)
    /// - "SNSSAI": S-NSSAI
    /// - "DNN": DNN
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- \"TAC\": Type Allocation Code\n- \"SUBPLMN\": Subscriber PLMN ID\n- \"GEOAREA\": Geographical area, i.e. list(s) of TAI(s)\n- \"SNSSAI\": S-NSSAI\n- \"DNN\": DNN\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "TAC",
    ///    "SUBPLMN",
    ///    "GEOAREA",
    ///    "SNSSAI",
    ///    "DNN"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PartitioningCriteria {
        #[serde(rename = "TAC")]
        Tac,
        #[serde(rename = "SUBPLMN")]
        Subplmn,
        #[serde(rename = "GEOAREA")]
        Geoarea,
        #[serde(rename = "SNSSAI")]
        Snssai,
        #[serde(rename = "DNN")]
        Dnn,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&PartitioningCriteria> for PartitioningCriteria {
        fn from(value: &PartitioningCriteria) -> Self {
            value.clone()
        }
    }

    impl ToString for PartitioningCriteria {
        fn to_string(&self) -> String {
            match *self {
                Self::Tac => "TAC".to_string(),
                Self::Subplmn => "SUBPLMN".to_string(),
                Self::Geoarea => "GEOAREA".to_string(),
                Self::Snssai => "SNSSAI".to_string(),
                Self::Dnn => "DNN".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for PartitioningCriteria {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TAC" => Ok(Self::Tac),
                "SUBPLMN" => Ok(Self::Subplmn),
                "GEOAREA" => Ok(Self::Geoarea),
                "SNSSAI" => Ok(Self::Snssai),
                "DNN" => Ok(Self::Dnn),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PartitioningCriteria {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PartitioningCriteria {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PartitioningCriteria {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///it shall represent the PC5 Flow Bit Rates
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "it shall represent the PC5 Flow Bit Rates",
    ///  "type": "object",
    ///  "properties": {
    ///    "guaFbr": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "maxFbr": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Pc5FlowBitRates {
        #[serde(rename = "guaFbr", default, skip_serializing_if = "Option::is_none")]
        pub gua_fbr: Option<BitRate>,
        #[serde(rename = "maxFbr", default, skip_serializing_if = "Option::is_none")]
        pub max_fbr: Option<BitRate>,
    }

    impl From<&Pc5FlowBitRates> for Pc5FlowBitRates {
        fn from(value: &Pc5FlowBitRates) -> Self {
            value.clone()
        }
    }

    ///Contains policy data on the PC5 QoS parameters.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains policy data on the PC5 QoS parameters.",
    ///  "type": "object",
    ///  "required": [
    ///    "pc5QosFlowList"
    ///  ],
    ///  "properties": {
    ///    "pc5LinkAmbr": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "pc5QosFlowList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Pc5QosFlowItem"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Pc5QoSPara {
        #[serde(
            rename = "pc5LinkAmbr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pc5_link_ambr: Option<BitRate>,
        #[serde(rename = "pc5QosFlowList")]
        pub pc5_qos_flow_list: Vec<Pc5QosFlowItem>,
    }

    impl From<&Pc5QoSPara> for Pc5QoSPara {
        fn from(value: &Pc5QoSPara) -> Self {
            value.clone()
        }
    }

    ///Contains a PC5 QOS flow.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains a PC5 QOS flow.",
    ///  "type": "object",
    ///  "required": [
    ///    "pqi"
    ///  ],
    ///  "properties": {
    ///    "pc5FlowBitRates": {
    ///      "$ref": "#/components/schemas/Pc5FlowBitRates"
    ///    },
    ///    "pqi": {
    ///      "$ref": "#/components/schemas/5Qi"
    ///    },
    ///    "range": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Pc5QosFlowItem {
        #[serde(
            rename = "pc5FlowBitRates",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pc5_flow_bit_rates: Option<Pc5FlowBitRates>,
        pub pqi: _5qi,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub range: Option<Uinteger>,
    }

    impl From<&Pc5QosFlowItem> for Pc5QosFlowItem {
        fn from(value: &Pc5QosFlowItem) -> Self {
            value.clone()
        }
    }

    ///Contains the PCF for the UE information necessary for the PCF for the
    /// PDU session to send  SM Policy Association Establishment and Termination
    /// events.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the PCF for the UE information necessary for
    /// the PCF for the PDU session to send  SM Policy Association Establishment
    /// and Termination events.\n",
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "required": [
    ///    "callbackUri"
    ///  ],
    ///  "properties": {
    ///    "bindingInfo": {
    ///      "type": "string"
    ///    },
    ///    "callbackUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PcfUeCallbackInfo(pub Option<PcfUeCallbackInfoInner>);
    impl ::std::ops::Deref for PcfUeCallbackInfo {
        type Target = Option<PcfUeCallbackInfoInner>;
        fn deref(&self) -> &Option<PcfUeCallbackInfoInner> {
            &self.0
        }
    }

    impl From<PcfUeCallbackInfo> for Option<PcfUeCallbackInfoInner> {
        fn from(value: PcfUeCallbackInfo) -> Self {
            value.0
        }
    }

    impl From<&PcfUeCallbackInfo> for PcfUeCallbackInfo {
        fn from(value: &PcfUeCallbackInfo) -> Self {
            value.clone()
        }
    }

    impl From<Option<PcfUeCallbackInfoInner>> for PcfUeCallbackInfo {
        fn from(value: Option<PcfUeCallbackInfoInner>) -> Self {
            Self(value)
        }
    }

    ///Contains the PCF for the UE information necessary for the PCF for the
    /// PDU session to send  SM Policy Association Establishment and Termination
    /// events.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the PCF for the UE information necessary for
    /// the PCF for the PDU session to send  SM Policy Association Establishment
    /// and Termination events.\n",
    ///  "type": "object",
    ///  "required": [
    ///    "callbackUri"
    ///  ],
    ///  "properties": {
    ///    "bindingInfo": {
    ///      "type": "string"
    ///    },
    ///    "callbackUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PcfUeCallbackInfoInner {
        #[serde(
            rename = "bindingInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub binding_info: Option<String>,
        #[serde(rename = "callbackUri")]
        pub callback_uri: Uri,
    }

    impl From<&PcfUeCallbackInfoInner> for PcfUeCallbackInfoInner {
        fn from(value: &PcfUeCallbackInfoInner) -> Self {
            value.clone()
        }
    }

    ///Represents a PDU Session Context in UE Context
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a PDU Session Context in UE Context",
    ///  "type": "object",
    ///  "required": [
    ///    "accessType",
    ///    "dnn",
    ///    "pduSessionId",
    ///    "sNssai",
    ///    "smContextRef"
    ///  ],
    ///  "properties": {
    ///    "accessType": {
    ///      "$ref": "#/components/schemas/AccessType"
    ///    },
    ///    "additionalAccessType": {
    ///      "$ref": "#/components/schemas/AccessType"
    ///    },
    ///    "additionalSnssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "allocatedEbiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EbiArpMapping"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "anchorSmfOauth2Required": {
    ///      "type": "boolean"
    ///    },
    ///    "anchorSmfSupportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    },
    ///    "cnAssistedRanPara": {
    ///      "$ref": "#/components/schemas/CnAssistedRanPara"
    ///    },
    ///    "dnn": {
    ///      "$ref": "#/components/schemas/Dnn"
    ///    },
    ///    "hsmfId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "hsmfServiceSetId": {
    ///      "$ref": "#/components/schemas/NfServiceSetId"
    ///    },
    ///    "hsmfSetId": {
    ///      "$ref": "#/components/schemas/NfSetId"
    ///    },
    ///    "interPlmnApiRoot": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "ismfBinding": {
    ///      "$ref": "#/components/schemas/SbiBindingLevel"
    ///    },
    ///    "ismfBindingInfo": {
    ///      "type": "string"
    ///    },
    ///    "ismfId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "ismfServiceSetId": {
    ///      "$ref": "#/components/schemas/NfServiceSetId"
    ///    },
    ///    "ismfSetId": {
    ///      "$ref": "#/components/schemas/NfSetId"
    ///    },
    ///    "maPduSession": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "nrfAccessTokenUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "nrfDiscoveryUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "nrfManagementUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "nsInstance": {
    ///      "$ref": "#/components/schemas/NsiId"
    ///    },
    ///    "pduSessionId": {
    ///      "$ref": "#/components/schemas/PduSessionId"
    ///    },
    ///    "pgwFqdn": {
    ///      "$ref": "#/components/schemas/Fqdn"
    ///    },
    ///    "pgwIpAddr": {
    ///      "$ref": "#/components/schemas/IpAddress"
    ///    },
    ///    "plmnId": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    },
    ///    "sNssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "selectedDnn": {
    ///      "$ref": "#/components/schemas/Dnn"
    ///    },
    ///    "smContextRef": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "smfBinding": {
    ///      "$ref": "#/components/schemas/SbiBindingLevel"
    ///    },
    ///    "smfBindingInfo": {
    ///      "type": "string"
    ///    },
    ///    "smfServiceInstanceId": {
    ///      "type": "string"
    ///    },
    ///    "vsmfBinding": {
    ///      "$ref": "#/components/schemas/SbiBindingLevel"
    ///    },
    ///    "vsmfBindingInfo": {
    ///      "type": "string"
    ///    },
    ///    "vsmfId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "vsmfServiceSetId": {
    ///      "$ref": "#/components/schemas/NfServiceSetId"
    ///    },
    ///    "vsmfSetId": {
    ///      "$ref": "#/components/schemas/NfSetId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PduSessionContext {
        #[serde(rename = "accessType")]
        pub access_type: AccessType,
        #[serde(
            rename = "additionalAccessType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub additional_access_type: Option<AccessType>,
        #[serde(
            rename = "additionalSnssai",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub additional_snssai: Option<Snssai>,
        #[serde(
            rename = "allocatedEbiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub allocated_ebi_list: Vec<EbiArpMapping>,
        #[serde(
            rename = "anchorSmfOauth2Required",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub anchor_smf_oauth2_required: Option<bool>,
        #[serde(
            rename = "anchorSmfSupportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub anchor_smf_supported_features: Option<SupportedFeatures>,
        #[serde(
            rename = "cnAssistedRanPara",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub cn_assisted_ran_para: Option<CnAssistedRanPara>,
        pub dnn: Dnn,
        #[serde(rename = "hsmfId", default, skip_serializing_if = "Option::is_none")]
        pub hsmf_id: Option<NfInstanceId>,
        #[serde(
            rename = "hsmfServiceSetId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub hsmf_service_set_id: Option<NfServiceSetId>,
        #[serde(rename = "hsmfSetId", default, skip_serializing_if = "Option::is_none")]
        pub hsmf_set_id: Option<NfSetId>,
        #[serde(
            rename = "interPlmnApiRoot",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub inter_plmn_api_root: Option<Uri>,
        #[serde(
            rename = "ismfBinding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ismf_binding: Option<SbiBindingLevel>,
        #[serde(
            rename = "ismfBindingInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ismf_binding_info: Option<String>,
        #[serde(rename = "ismfId", default, skip_serializing_if = "Option::is_none")]
        pub ismf_id: Option<NfInstanceId>,
        #[serde(
            rename = "ismfServiceSetId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ismf_service_set_id: Option<NfServiceSetId>,
        #[serde(rename = "ismfSetId", default, skip_serializing_if = "Option::is_none")]
        pub ismf_set_id: Option<NfSetId>,
        #[serde(rename = "maPduSession", default)]
        pub ma_pdu_session: bool,
        #[serde(
            rename = "nrfAccessTokenUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nrf_access_token_uri: Option<Uri>,
        #[serde(
            rename = "nrfDiscoveryUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nrf_discovery_uri: Option<Uri>,
        #[serde(
            rename = "nrfManagementUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nrf_management_uri: Option<Uri>,
        #[serde(
            rename = "nsInstance",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ns_instance: Option<NsiId>,
        #[serde(rename = "pduSessionId")]
        pub pdu_session_id: PduSessionId,
        #[serde(rename = "pgwFqdn", default, skip_serializing_if = "Option::is_none")]
        pub pgw_fqdn: Option<Fqdn>,
        #[serde(rename = "pgwIpAddr", default, skip_serializing_if = "Option::is_none")]
        pub pgw_ip_addr: Option<IpAddress>,
        #[serde(rename = "plmnId", default, skip_serializing_if = "Option::is_none")]
        pub plmn_id: Option<PlmnId>,
        #[serde(rename = "sNssai")]
        pub s_nssai: Snssai,
        #[serde(
            rename = "selectedDnn",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub selected_dnn: Option<Dnn>,
        #[serde(rename = "smContextRef")]
        pub sm_context_ref: Uri,
        #[serde(
            rename = "smfBinding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub smf_binding: Option<SbiBindingLevel>,
        #[serde(
            rename = "smfBindingInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub smf_binding_info: Option<String>,
        #[serde(
            rename = "smfServiceInstanceId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub smf_service_instance_id: Option<String>,
        #[serde(
            rename = "vsmfBinding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub vsmf_binding: Option<SbiBindingLevel>,
        #[serde(
            rename = "vsmfBindingInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub vsmf_binding_info: Option<String>,
        #[serde(rename = "vsmfId", default, skip_serializing_if = "Option::is_none")]
        pub vsmf_id: Option<NfInstanceId>,
        #[serde(
            rename = "vsmfServiceSetId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub vsmf_service_set_id: Option<NfServiceSetId>,
        #[serde(rename = "vsmfSetId", default, skip_serializing_if = "Option::is_none")]
        pub vsmf_set_id: Option<NfSetId>,
    }

    impl From<&PduSessionContext> for PduSessionContext {
        fn from(value: &PduSessionContext) -> Self {
            value.clone()
        }
    }

    ///Unsigned integer identifying a PDU session, within the range 0 to 255,
    /// as specified in  clause 11.2.3.1b, bits 1 to 8, of 3GPP TS 24.007. If
    /// the PDU Session ID is allocated by the  Core Network for UEs not
    /// supporting N1 mode, reserved range 64 to 95 is used. PDU Session ID
    /// within the reserved range is only visible in the Core Network.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unsigned integer identifying a PDU session, within the range 0 to 255, as specified in  clause 11.2.3.1b, bits 1 to 8, of 3GPP TS 24.007. If the PDU Session ID is allocated by the  Core Network for UEs not supporting N1 mode, reserved range 64 to 95 is used. PDU Session ID  within the reserved range is only visible in the Core Network. \n",
    ///  "type": "integer",
    ///  "maximum": 255.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PduSessionId(pub u8);
    impl ::std::ops::Deref for PduSessionId {
        type Target = u8;
        fn deref(&self) -> &u8 {
            &self.0
        }
    }

    impl From<PduSessionId> for u8 {
        fn from(value: PduSessionId) -> Self {
            value.0
        }
    }

    impl From<&PduSessionId> for PduSessionId {
        fn from(value: &PduSessionId) -> Self {
            value.clone()
        }
    }

    impl From<u8> for PduSessionId {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for PduSessionId {
        type Err = <u8 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for PduSessionId {
        type Error = <u8 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PduSessionId {
        type Error = <u8 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PduSessionId {
        type Error = <u8 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for PduSessionId {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///indicates the DNN and S-NSSAI combination of a PDU session.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "indicates the DNN and S-NSSAI combination of a PDU
    /// session.",
    ///  "type": "object",
    ///  "required": [
    ///    "dnn",
    ///    "snssai"
    ///  ],
    ///  "properties": {
    ///    "dnn": {
    ///      "$ref": "#/components/schemas/Dnn"
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PduSessionInfo {
        pub dnn: Dnn,
        pub snssai: Snssai,
    }

    impl From<&PduSessionInfo> for PduSessionInfo {
        fn from(value: &PduSessionInfo) -> Self {
            value.clone()
        }
    }

    ///String representing a Permanent Equipment Identifier that may contain -
    /// an IMEI or IMEISV, as  specified in clause 6.2 of 3GPP TS 23.003; a MAC
    /// address for a 5G-RG or FN-RG via  wireline  access, with an indication
    /// that this address cannot be trusted for regulatory purpose if this
    /// address cannot be used as an Equipment Identifier of the FN-RG, as
    /// specified in clause 4.7.7  of 3GPP TS23.316. Examples are
    /// imei-012345678901234 or imeisv-0123456789012345.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String representing a Permanent Equipment Identifier
    /// that may contain - an IMEI or IMEISV, as  specified in clause 6.2 of
    /// 3GPP TS 23.003; a MAC address for a 5G-RG or FN-RG via  wireline
    /// access, with an indication that this address cannot be trusted for
    /// regulatory purpose if this  address cannot be used as an Equipment
    /// Identifier of the FN-RG, as specified in clause 4.7.7  of 3GPP TS23.316.
    /// Examples are imei-012345678901234 or imeisv-0123456789012345. \n",
    ///  "type": "string",
    ///  "pattern":
    /// "^(imei-[0-9]{15}|imeisv-[0-9]{16}|mac((-[0-9a-fA-F]{2}){6})(-untrusted)?
    /// |eui((-[0-9a-fA-F]{2}){8})|.+)$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct Pei(String);
    impl ::std::ops::Deref for Pei {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Pei> for String {
        fn from(value: Pei) -> Self {
            value.0
        }
    }

    impl From<&Pei> for Pei {
        fn from(value: &Pei) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Pei {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress :: Regex :: new ("^(imei-[0-9]{15}|imeisv-[0-9]{16}|mac((-[0-9a-fA-F]{2}){6})(-untrusted)?|eui((-[0-9a-fA-F]{2}){8})|.+)$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(imei-[0-9]{15}|imeisv-[0-9]{16}|mac((-[0-9a-fA-F]{2}){6})(-untrusted)?|eui((-[0-9a-fA-F]{2}){8})|.+)$\"" . into ()) ; }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Pei {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for Pei {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for Pei {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Pei {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Represents DN performance data.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents DN performance data.",
    ///  "type": "object",
    ///  "properties": {
    ///    "avePacketDelay": {
    ///      "$ref": "#/components/schemas/PacketDelBudget"
    ///    },
    ///    "avgPacketLossRate": {
    ///      "$ref": "#/components/schemas/PacketLossRate"
    ///    },
    ///    "avgTrafficRate": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "maxPacketDelay": {
    ///      "$ref": "#/components/schemas/PacketDelBudget"
    ///    },
    ///    "maxTrafficRate": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PerfData {
        #[serde(
            rename = "avePacketDelay",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ave_packet_delay: Option<PacketDelBudget>,
        #[serde(
            rename = "avgPacketLossRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub avg_packet_loss_rate: Option<PacketLossRate>,
        #[serde(
            rename = "avgTrafficRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub avg_traffic_rate: Option<BitRate>,
        #[serde(
            rename = "maxPacketDelay",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_packet_delay: Option<PacketDelBudget>,
        #[serde(
            rename = "maxTrafficRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_traffic_rate: Option<BitRate>,
    }

    impl From<&PerfData> for PerfData {
        fn from(value: &PerfData) -> Self {
            value.clone()
        }
    }

    ///Indicates the Periodic Communication Indicator
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the Periodic Communication Indicator",
    ///  "type": "string",
    ///  "enum": [
    ///    "PIORIODICALLY",
    ///    "ON_DEMAND"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PeriodicCommunicationIndicator {
        #[serde(rename = "PIORIODICALLY")]
        Pioriodically,
        #[serde(rename = "ON_DEMAND")]
        OnDemand,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&PeriodicCommunicationIndicator> for PeriodicCommunicationIndicator {
        fn from(value: &PeriodicCommunicationIndicator) -> Self {
            value.clone()
        }
    }

    impl ToString for PeriodicCommunicationIndicator {
        fn to_string(&self) -> String {
            match *self {
                Self::Pioriodically => "PIORIODICALLY".to_string(),
                Self::OnDemand => "ON_DEMAND".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for PeriodicCommunicationIndicator {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "PIORIODICALLY" => Ok(Self::Pioriodically),
                "ON_DEMAND" => Ok(Self::OnDemand),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PeriodicCommunicationIndicator {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PeriodicCommunicationIndicator {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PeriodicCommunicationIndicator {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates the information of periodic event reporting.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the information of periodic event
    /// reporting.",
    ///  "type": "object",
    ///  "required": [
    ///    "reportingAmount",
    ///    "reportingInterval"
    ///  ],
    ///  "properties": {
    ///    "reportingAmount": {
    ///      "$ref": "#/components/schemas/ReportingAmount"
    ///    },
    ///    "reportingInfiniteInd": {
    ///      "type": "boolean",
    ///      "enum": [
    ///        true
    ///      ]
    ///    },
    ///    "reportingInterval": {
    ///      "$ref": "#/components/schemas/ReportingInterval"
    ///    },
    ///    "reportingIntervalMs": {
    ///      "$ref": "#/components/schemas/ReportingIntervalMs"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PeriodicEventInfo {
        #[serde(rename = "reportingAmount")]
        pub reporting_amount: ReportingAmount,
        #[serde(
            rename = "reportingInfiniteInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub reporting_infinite_ind: Option<bool>,
        #[serde(rename = "reportingInterval")]
        pub reporting_interval: ReportingInterval,
        #[serde(
            rename = "reportingIntervalMs",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub reporting_interval_ms: Option<ReportingIntervalMs>,
    }

    impl From<&PeriodicEventInfo> for PeriodicEventInfo {
        fn from(value: &PeriodicEventInfo) -> Self {
            value.clone()
        }
    }

    ///When PlmnId needs to be converted to string (e.g. when used in maps as
    /// key), the string  shall be composed of three digits "mcc" followed by
    /// "-" and two or three digits "mnc".
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "When PlmnId needs to be converted to string (e.g. when
    /// used in maps as key), the string  shall be composed of three digits
    /// \"mcc\" followed by \"-\" and two or three digits \"mnc\".\n",
    ///  "type": "object",
    ///  "required": [
    ///    "mcc",
    ///    "mnc"
    ///  ],
    ///  "properties": {
    ///    "mcc": {
    ///      "$ref": "#/components/schemas/Mcc"
    ///    },
    ///    "mnc": {
    ///      "$ref": "#/components/schemas/Mnc"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PlmnId {
        pub mcc: Mcc,
        pub mnc: Mnc,
    }

    impl From<&PlmnId> for PlmnId {
        fn from(value: &PlmnId) -> Self {
            value.clone()
        }
    }

    ///Contains the serving core network operator PLMN ID and, for an SNPN, the
    /// NID that together with the PLMN ID identifies the SNPN.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the serving core network operator PLMN ID and,
    /// for an SNPN, the NID that together with the PLMN ID identifies the
    /// SNPN.\n",
    ///  "type": "object",
    ///  "required": [
    ///    "mcc",
    ///    "mnc"
    ///  ],
    ///  "properties": {
    ///    "mcc": {
    ///      "$ref": "#/components/schemas/Mcc"
    ///    },
    ///    "mnc": {
    ///      "$ref": "#/components/schemas/Mnc"
    ///    },
    ///    "nid": {
    ///      "$ref": "#/components/schemas/Nid"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PlmnIdNid {
        pub mcc: Mcc,
        pub mnc: Mnc,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub nid: Option<Nid>,
    }

    impl From<&PlmnIdNid> for PlmnIdNid {
        fn from(value: &PlmnIdNid) -> Self {
            value.clone()
        }
    }

    ///Ellipsoid Point.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Ellipsoid Point.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GADShape"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "point"
    ///      ],
    ///      "properties": {
    ///        "point": {
    ///          "$ref": "#/components/schemas/GeographicalCoordinates"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Point {
        pub point: GeographicalCoordinates,
        pub shape: SupportedGadShapes,
    }

    impl From<&Point> for Point {
        fn from(value: &Point) -> Self {
            value.clone()
        }
    }

    ///Ellipsoid point with altitude.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Ellipsoid point with altitude.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GADShape"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "altitude",
    ///        "point"
    ///      ],
    ///      "properties": {
    ///        "altitude": {
    ///          "$ref": "#/components/schemas/Altitude"
    ///        },
    ///        "point": {
    ///          "$ref": "#/components/schemas/GeographicalCoordinates"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PointAltitude {
        pub altitude: Altitude,
        pub point: GeographicalCoordinates,
        pub shape: SupportedGadShapes,
    }

    impl From<&PointAltitude> for PointAltitude {
        fn from(value: &PointAltitude) -> Self {
            value.clone()
        }
    }

    ///Ellipsoid point with altitude and uncertainty ellipsoid.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Ellipsoid point with altitude and uncertainty
    /// ellipsoid.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GADShape"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "altitude",
    ///        "confidence",
    ///        "point",
    ///        "uncertaintyAltitude",
    ///        "uncertaintyEllipse"
    ///      ],
    ///      "properties": {
    ///        "altitude": {
    ///          "$ref": "#/components/schemas/Altitude"
    ///        },
    ///        "confidence": {
    ///          "$ref": "#/components/schemas/Confidence"
    ///        },
    ///        "point": {
    ///          "$ref": "#/components/schemas/GeographicalCoordinates"
    ///        },
    ///        "uncertaintyAltitude": {
    ///          "$ref": "#/components/schemas/Uncertainty"
    ///        },
    ///        "uncertaintyEllipse": {
    ///          "$ref": "#/components/schemas/UncertaintyEllipse"
    ///        },
    ///        "vConfidence": {
    ///          "$ref": "#/components/schemas/Confidence"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PointAltitudeUncertainty {
        pub altitude: Altitude,
        pub confidence: Confidence,
        pub point: GeographicalCoordinates,
        pub shape: SupportedGadShapes,
        #[serde(rename = "uncertaintyAltitude")]
        pub uncertainty_altitude: Uncertainty,
        #[serde(rename = "uncertaintyEllipse")]
        pub uncertainty_ellipse: UncertaintyEllipse,
        #[serde(
            rename = "vConfidence",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub v_confidence: Option<Confidence>,
    }

    impl From<&PointAltitudeUncertainty> for PointAltitudeUncertainty {
        fn from(value: &PointAltitudeUncertainty) -> Self {
            value.clone()
        }
    }

    ///List of points.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of points.",
    ///  "type": "array",
    ///  "items": {
    ///    "$ref": "#/components/schemas/GeographicalCoordinates"
    ///  },
    ///  "maxItems": 15,
    ///  "minItems": 3
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PointList(pub Vec<GeographicalCoordinates>);
    impl ::std::ops::Deref for PointList {
        type Target = Vec<GeographicalCoordinates>;
        fn deref(&self) -> &Vec<GeographicalCoordinates> {
            &self.0
        }
    }

    impl From<PointList> for Vec<GeographicalCoordinates> {
        fn from(value: PointList) -> Self {
            value.0
        }
    }

    impl From<&PointList> for PointList {
        fn from(value: &PointList) -> Self {
            value.clone()
        }
    }

    impl From<Vec<GeographicalCoordinates>> for PointList {
        fn from(value: Vec<GeographicalCoordinates>) -> Self {
            Self(value)
        }
    }

    ///Ellipsoid point with uncertainty circle.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Ellipsoid point with uncertainty circle.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GADShape"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "point",
    ///        "uncertainty"
    ///      ],
    ///      "properties": {
    ///        "point": {
    ///          "$ref": "#/components/schemas/GeographicalCoordinates"
    ///        },
    ///        "uncertainty": {
    ///          "$ref": "#/components/schemas/Uncertainty"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PointUncertaintyCircle {
        pub point: GeographicalCoordinates,
        pub shape: SupportedGadShapes,
        pub uncertainty: Uncertainty,
    }

    impl From<&PointUncertaintyCircle> for PointUncertaintyCircle {
        fn from(value: &PointUncertaintyCircle) -> Self {
            value.clone()
        }
    }

    ///Ellipsoid point with uncertainty ellipse.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Ellipsoid point with uncertainty ellipse.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GADShape"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "confidence",
    ///        "point",
    ///        "uncertaintyEllipse"
    ///      ],
    ///      "properties": {
    ///        "confidence": {
    ///          "$ref": "#/components/schemas/Confidence"
    ///        },
    ///        "point": {
    ///          "$ref": "#/components/schemas/GeographicalCoordinates"
    ///        },
    ///        "uncertaintyEllipse": {
    ///          "$ref": "#/components/schemas/UncertaintyEllipse"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PointUncertaintyEllipse {
        pub confidence: Confidence,
        pub point: GeographicalCoordinates,
        pub shape: SupportedGadShapes,
        #[serde(rename = "uncertaintyEllipse")]
        pub uncertainty_ellipse: UncertaintyEllipse,
    }

    impl From<&PointUncertaintyEllipse> for PointUncertaintyEllipse {
        fn from(value: &PointUncertaintyEllipse) -> Self {
            value.clone()
        }
    }

    ///Policy Request Triggers
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Policy Request Triggers",
    ///  "type": "string",
    ///  "enum": [
    ///    "LOCATION_CHANGE",
    ///    "PRA_CHANGE",
    ///    "ALLOWED_NSSAI_CHANGE",
    ///    "NWDAF_DATA_CHANGE",
    ///    "PLMN_CHANGE",
    ///    "CON_STATE_CHANGE",
    ///    "SMF_SELECT_CHANGE",
    ///    "ACCESS_TYPE_CHANGE"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PolicyReqTrigger {
        #[serde(rename = "LOCATION_CHANGE")]
        LocationChange,
        #[serde(rename = "PRA_CHANGE")]
        PraChange,
        #[serde(rename = "ALLOWED_NSSAI_CHANGE")]
        AllowedNssaiChange,
        #[serde(rename = "NWDAF_DATA_CHANGE")]
        NwdafDataChange,
        #[serde(rename = "PLMN_CHANGE")]
        PlmnChange,
        #[serde(rename = "CON_STATE_CHANGE")]
        ConStateChange,
        #[serde(rename = "SMF_SELECT_CHANGE")]
        SmfSelectChange,
        #[serde(rename = "ACCESS_TYPE_CHANGE")]
        AccessTypeChange,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&PolicyReqTrigger> for PolicyReqTrigger {
        fn from(value: &PolicyReqTrigger) -> Self {
            value.clone()
        }
    }

    impl ToString for PolicyReqTrigger {
        fn to_string(&self) -> String {
            match *self {
                Self::LocationChange => "LOCATION_CHANGE".to_string(),
                Self::PraChange => "PRA_CHANGE".to_string(),
                Self::AllowedNssaiChange => "ALLOWED_NSSAI_CHANGE".to_string(),
                Self::NwdafDataChange => "NWDAF_DATA_CHANGE".to_string(),
                Self::PlmnChange => "PLMN_CHANGE".to_string(),
                Self::ConStateChange => "CON_STATE_CHANGE".to_string(),
                Self::SmfSelectChange => "SMF_SELECT_CHANGE".to_string(),
                Self::AccessTypeChange => "ACCESS_TYPE_CHANGE".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for PolicyReqTrigger {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "LOCATION_CHANGE" => Ok(Self::LocationChange),
                "PRA_CHANGE" => Ok(Self::PraChange),
                "ALLOWED_NSSAI_CHANGE" => Ok(Self::AllowedNssaiChange),
                "NWDAF_DATA_CHANGE" => Ok(Self::NwdafDataChange),
                "PLMN_CHANGE" => Ok(Self::PlmnChange),
                "CON_STATE_CHANGE" => Ok(Self::ConStateChange),
                "SMF_SELECT_CHANGE" => Ok(Self::SmfSelectChange),
                "ACCESS_TYPE_CHANGE" => Ok(Self::AccessTypeChange),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PolicyReqTrigger {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PolicyReqTrigger {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PolicyReqTrigger {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Polygon.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Polygon.",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/GADShape"
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "pointList"
    ///      ],
    ///      "properties": {
    ///        "pointList": {
    ///          "$ref": "#/components/schemas/PointList"
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Polygon {
        #[serde(rename = "pointList")]
        pub point_list: PointList,
        pub shape: SupportedGadShapes,
    }

    impl From<&Polygon> for Polygon {
        fn from(value: &Polygon) -> Self {
            value.clone()
        }
    }

    ///Indicates supported positioning methods.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates supported positioning methods.",
    ///  "type": "string",
    ///  "enum": [
    ///    "CELLID",
    ///    "ECID",
    ///    "OTDOA",
    ///    "BAROMETRIC_PRESSURE",
    ///    "WLAN",
    ///    "BLUETOOTH",
    ///    "MBS",
    ///    "MOTION_SENSOR",
    ///    "DL_TDOA",
    ///    "DL_AOD",
    ///    "MULTI-RTT",
    ///    "NR_ECID",
    ///    "UL_TDOA",
    ///    "UL_AOA",
    ///    "NETWORK_SPECIFIC"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PositioningMethod {
        #[serde(rename = "CELLID")]
        Cellid,
        #[serde(rename = "ECID")]
        Ecid,
        #[serde(rename = "OTDOA")]
        Otdoa,
        #[serde(rename = "BAROMETRIC_PRESSURE")]
        BarometricPressure,
        #[serde(rename = "WLAN")]
        Wlan,
        #[serde(rename = "BLUETOOTH")]
        Bluetooth,
        #[serde(rename = "MBS")]
        Mbs,
        #[serde(rename = "MOTION_SENSOR")]
        MotionSensor,
        #[serde(rename = "DL_TDOA")]
        DlTdoa,
        #[serde(rename = "DL_AOD")]
        DlAod,
        #[serde(rename = "MULTI-RTT")]
        MultiRtt,
        #[serde(rename = "NR_ECID")]
        NrEcid,
        #[serde(rename = "UL_TDOA")]
        UlTdoa,
        #[serde(rename = "UL_AOA")]
        UlAoa,
        #[serde(rename = "NETWORK_SPECIFIC")]
        NetworkSpecific,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&PositioningMethod> for PositioningMethod {
        fn from(value: &PositioningMethod) -> Self {
            value.clone()
        }
    }

    impl ToString for PositioningMethod {
        fn to_string(&self) -> String {
            match *self {
                Self::Cellid => "CELLID".to_string(),
                Self::Ecid => "ECID".to_string(),
                Self::Otdoa => "OTDOA".to_string(),
                Self::BarometricPressure => "BAROMETRIC_PRESSURE".to_string(),
                Self::Wlan => "WLAN".to_string(),
                Self::Bluetooth => "BLUETOOTH".to_string(),
                Self::Mbs => "MBS".to_string(),
                Self::MotionSensor => "MOTION_SENSOR".to_string(),
                Self::DlTdoa => "DL_TDOA".to_string(),
                Self::DlAod => "DL_AOD".to_string(),
                Self::MultiRtt => "MULTI-RTT".to_string(),
                Self::NrEcid => "NR_ECID".to_string(),
                Self::UlTdoa => "UL_TDOA".to_string(),
                Self::UlAoa => "UL_AOA".to_string(),
                Self::NetworkSpecific => "NETWORK_SPECIFIC".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for PositioningMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "CELLID" => Ok(Self::Cellid),
                "ECID" => Ok(Self::Ecid),
                "OTDOA" => Ok(Self::Otdoa),
                "BAROMETRIC_PRESSURE" => Ok(Self::BarometricPressure),
                "WLAN" => Ok(Self::Wlan),
                "BLUETOOTH" => Ok(Self::Bluetooth),
                "MBS" => Ok(Self::Mbs),
                "MOTION_SENSOR" => Ok(Self::MotionSensor),
                "DL_TDOA" => Ok(Self::DlTdoa),
                "DL_AOD" => Ok(Self::DlAod),
                "MULTI-RTT" => Ok(Self::MultiRtt),
                "NR_ECID" => Ok(Self::NrEcid),
                "UL_TDOA" => Ok(Self::UlTdoa),
                "UL_AOA" => Ok(Self::UlAoa),
                "NETWORK_SPECIFIC" => Ok(Self::NetworkSpecific),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PositioningMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PositioningMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PositioningMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates the usage of a positioning method.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the usage of a positioning method.",
    ///  "type": "object",
    ///  "required": [
    ///    "method",
    ///    "mode",
    ///    "usage"
    ///  ],
    ///  "properties": {
    ///    "method": {
    ///      "$ref": "#/components/schemas/PositioningMethod"
    ///    },
    ///    "methodCode": {
    ///      "type": "integer",
    ///      "maximum": 31.0,
    ///      "minimum": 16.0
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/PositioningMode"
    ///    },
    ///    "usage": {
    ///      "$ref": "#/components/schemas/Usage"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PositioningMethodAndUsage {
        pub method: PositioningMethod,
        #[serde(
            rename = "methodCode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub method_code: Option<i64>,
        pub mode: PositioningMode,
        pub usage: Usage,
    }

    impl From<&PositioningMethodAndUsage> for PositioningMethodAndUsage {
        fn from(value: &PositioningMethodAndUsage) -> Self {
            value.clone()
        }
    }

    ///The enumeration LoggingDurationMdt defines Logging Duration for MDT in
    /// the trace. See 3GPP TS 32.422 for further description of the values. It
    /// shall comply with the provisions defined in table 5.6.3.13-1.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration LoggingDurationMdt defines Logging
    /// Duration for MDT in the trace. See 3GPP TS 32.422 for further
    /// description of the values. It shall comply with the provisions defined
    /// in table 5.6.3.13-1.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "GNSS",
    ///    "E_CELL_ID"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PositioningMethodMdt {
        #[serde(rename = "GNSS")]
        Gnss,
        #[serde(rename = "E_CELL_ID")]
        ECellId,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&PositioningMethodMdt> for PositioningMethodMdt {
        fn from(value: &PositioningMethodMdt) -> Self {
            value.clone()
        }
    }

    impl ToString for PositioningMethodMdt {
        fn to_string(&self) -> String {
            match *self {
                Self::Gnss => "GNSS".to_string(),
                Self::ECellId => "E_CELL_ID".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for PositioningMethodMdt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "GNSS" => Ok(Self::Gnss),
                "E_CELL_ID" => Ok(Self::ECellId),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PositioningMethodMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PositioningMethodMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PositioningMethodMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates supported modes used for positioning method.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates supported modes used for positioning
    /// method.",
    ///  "type": "string",
    ///  "enum": [
    ///    "UE_BASED",
    ///    "UE_ASSISTED",
    ///    "CONVENTIONAL"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PositioningMode {
        #[serde(rename = "UE_BASED")]
        UeBased,
        #[serde(rename = "UE_ASSISTED")]
        UeAssisted,
        #[serde(rename = "CONVENTIONAL")]
        Conventional,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&PositioningMode> for PositioningMode {
        fn from(value: &PositioningMode) -> Self {
            value.clone()
        }
    }

    impl ToString for PositioningMode {
        fn to_string(&self) -> String {
            match *self {
                Self::UeBased => "UE_BASED".to_string(),
                Self::UeAssisted => "UE_ASSISTED".to_string(),
                Self::Conventional => "CONVENTIONAL".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for PositioningMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "UE_BASED" => Ok(Self::UeBased),
                "UE_ASSISTED" => Ok(Self::UeAssisted),
                "CONVENTIONAL" => Ok(Self::Conventional),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PositioningMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PositioningMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PositioningMode {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Paging Policy Indicator
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Paging Policy Indicator",
    ///  "type": "integer",
    ///  "maximum": 7.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Ppi(pub i64);
    impl ::std::ops::Deref for Ppi {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<Ppi> for i64 {
        fn from(value: Ppi) -> Self {
            value.0
        }
    }

    impl From<&Ppi> for Ppi {
        fn from(value: &Ppi) -> Self {
            value.clone()
        }
    }

    impl From<i64> for Ppi {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for Ppi {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for Ppi {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Ppi {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Ppi {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for Ppi {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///The enumeration PreemptionCapability indicates the pre-emption
    /// capability of a request on other QoS flows. See clause 5.7.2.2 of 3GPP
    /// TS 23.501. It shall comply with the provisions defined in table
    /// 5.5.3.1-1.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration PreemptionCapability indicates the
    /// pre-emption capability of a request on other QoS flows. See clause
    /// 5.7.2.2 of 3GPP TS 23.501. It shall comply with the provisions defined
    /// in table 5.5.3.1-1.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "NOT_PREEMPT",
    ///    "MAY_PREEMPT"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PreemptionCapability {
        #[serde(rename = "NOT_PREEMPT")]
        NotPreempt,
        #[serde(rename = "MAY_PREEMPT")]
        MayPreempt,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&PreemptionCapability> for PreemptionCapability {
        fn from(value: &PreemptionCapability) -> Self {
            value.clone()
        }
    }

    impl ToString for PreemptionCapability {
        fn to_string(&self) -> String {
            match *self {
                Self::NotPreempt => "NOT_PREEMPT".to_string(),
                Self::MayPreempt => "MAY_PREEMPT".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for PreemptionCapability {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NOT_PREEMPT" => Ok(Self::NotPreempt),
                "MAY_PREEMPT" => Ok(Self::MayPreempt),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PreemptionCapability {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PreemptionCapability {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PreemptionCapability {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The enumeration PreemptionVulnerability indicates the pre-emption
    /// vulnerability of the QoS flow to pre-emption from other QoS flows. See
    /// clause 5.7.2.2 of 3GPP TS 23.501. It shall comply with the provisions
    /// defined in table 5.5.3.2-1
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration PreemptionVulnerability indicates the
    /// pre-emption vulnerability of the QoS flow to pre-emption from other QoS
    /// flows. See clause 5.7.2.2 of 3GPP TS 23.501. It shall comply with the
    /// provisions defined in table 5.5.3.2-1\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "NOT_PREEMPTABLE",
    ///    "PREEMPTABLE"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PreemptionVulnerability {
        #[serde(rename = "NOT_PREEMPTABLE")]
        NotPreemptable,
        #[serde(rename = "PREEMPTABLE")]
        Preemptable,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&PreemptionVulnerability> for PreemptionVulnerability {
        fn from(value: &PreemptionVulnerability) -> Self {
            value.clone()
        }
    }

    impl ToString for PreemptionVulnerability {
        fn to_string(&self) -> String {
            match *self {
                Self::NotPreemptable => "NOT_PREEMPTABLE".to_string(),
                Self::Preemptable => "PREEMPTABLE".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for PreemptionVulnerability {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NOT_PREEMPTABLE" => Ok(Self::NotPreemptable),
                "PREEMPTABLE" => Ok(Self::Preemptable),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PreemptionVulnerability {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PreemptionVulnerability {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PreemptionVulnerability {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///If the additionalPraId IE is present, this IE shall state the presence
    /// information of the UE for the individual PRA identified by the
    /// additionalPraId IE;  If the additionalPraId IE is not present, this IE
    /// shall state the presence information of the UE for the PRA identified by
    /// the praId IE.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "If the additionalPraId IE is present, this IE shall
    /// state the presence information of the UE for the individual PRA
    /// identified by the additionalPraId IE;  If the additionalPraId IE is not
    /// present, this IE shall state the presence information of the UE for the
    /// PRA identified by the praId IE.\n",
    ///  "type": "object",
    ///  "properties": {
    ///    "additionalPraId": {
    ///      "description": "This IE may be present if the praId IE is present
    /// and if it contains a PRA identifier referring to a set of Core Network
    /// predefined Presence Reporting Areas. When present, this IE shall contain
    /// a PRA Identifier of an individual PRA within the Set of Core Network
    /// predefined Presence Reporting Areas indicated by the praId IE. \n",
    ///      "type": "string"
    ///    },
    ///    "ecgiList": {
    ///      "description": "Represents the list of EUTRAN cell Ids that
    /// constitutes the area. This IE shall be present if the Area of Interest
    /// subscribed is a list of EUTRAN cell Ids. \n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Ecgi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "globalRanNodeIdList": {
    ///      "description": "Represents the list of NG RAN node identifiers that
    /// constitutes the area. This IE shall be present if the Area of Interest
    /// subscribed is a list of NG RAN node identifiers. \n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GlobalRanNodeId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "globaleNbIdList": {
    ///      "description": "Represents the list of eNodeB identifiers that
    /// constitutes the area. This IE shall be  present if the Area of Interest
    /// subscribed is a list of eNodeB identifiers.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GlobalRanNodeId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "ncgiList": {
    ///      "description": "Represents the list of NR cell Ids that constitutes
    /// the area. This IE shall be present if the Area of Interest subscribed is
    /// a list of NR cell Ids. \n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Ncgi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "praId": {
    ///      "description": "Represents an identifier of the Presence Reporting
    /// Area (see clause 28.10 of 3GPP  TS 23.003.  This IE shall be present  if
    /// the Area of Interest subscribed or reported is a Presence Reporting Area
    /// or a Set of Core Network predefined Presence Reporting Areas. When
    /// present, it shall be encoded as a string representing an integer in the
    /// following ranges: 0 to 8 388 607 for UE-dedicated PRA 8 388 608 to 16
    /// 777 215 for Core Network predefined PRA Examples: PRA ID 123 is encoded
    /// as \"123\" PRA ID 11 238 660 is encoded as \"11238660\"\n",
    ///      "type": "string"
    ///    },
    ///    "presenceState": {
    ///      "$ref": "#/components/schemas/PresenceState"
    ///    },
    ///    "trackingAreaList": {
    ///      "description": "Represents the list of tracking areas that
    /// constitutes the area. This IE shall be present if the subscription or
    /// the event report is for tracking UE presence in the tracking areas. For
    /// non 3GPP access the TAI shall be the N3GPP TAI. \n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Tai"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PresenceInfo {
        ///This IE may be present if the praId IE is present and if it contains
        /// a PRA identifier referring to a set of Core Network predefined
        /// Presence Reporting Areas. When present, this IE shall contain a PRA
        /// Identifier of an individual PRA within the Set of Core Network
        /// predefined Presence Reporting Areas indicated by the praId IE.
        #[serde(
            rename = "additionalPraId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub additional_pra_id: Option<String>,
        ///Represents the list of EUTRAN cell Ids that constitutes the area.
        /// This IE shall be present if the Area of Interest subscribed is a
        /// list of EUTRAN cell Ids.
        #[serde(rename = "ecgiList", default, skip_serializing_if = "Vec::is_empty")]
        pub ecgi_list: Vec<Ecgi>,
        ///Represents the list of NG RAN node identifiers that constitutes the
        /// area. This IE shall be present if the Area of Interest subscribed is
        /// a list of NG RAN node identifiers.
        #[serde(
            rename = "globalRanNodeIdList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub global_ran_node_id_list: Vec<GlobalRanNodeId>,
        ///Represents the list of eNodeB identifiers that constitutes the area.
        /// This IE shall be  present if the Area of Interest subscribed is a
        /// list of eNodeB identifiers.
        #[serde(
            rename = "globaleNbIdList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub globale_nb_id_list: Vec<GlobalRanNodeId>,
        ///Represents the list of NR cell Ids that constitutes the area. This
        /// IE shall be present if the Area of Interest subscribed is a list of
        /// NR cell Ids.
        #[serde(rename = "ncgiList", default, skip_serializing_if = "Vec::is_empty")]
        pub ncgi_list: Vec<Ncgi>,
        ///Represents an identifier of the Presence Reporting Area (see clause
        /// 28.10 of 3GPP  TS 23.003.  This IE shall be present  if the Area of
        /// Interest subscribed or reported is a Presence Reporting Area or a
        /// Set of Core Network predefined Presence Reporting Areas. When
        /// present, it shall be encoded as a string representing an integer in
        /// the following ranges: 0 to 8 388 607 for UE-dedicated PRA 8 388 608
        /// to 16 777 215 for Core Network predefined PRA Examples: PRA ID 123
        /// is encoded as "123" PRA ID 11 238 660 is encoded as "11238660"
        #[serde(rename = "praId", default, skip_serializing_if = "Option::is_none")]
        pub pra_id: Option<String>,
        #[serde(
            rename = "presenceState",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub presence_state: Option<PresenceState>,
        ///Represents the list of tracking areas that constitutes the area.
        /// This IE shall be present if the subscription or  the event report is
        /// for tracking UE presence in the tracking areas. For non 3GPP access
        /// the TAI shall be the N3GPP TAI.
        #[serde(
            rename = "trackingAreaList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub tracking_area_list: Vec<Tai>,
    }

    impl From<&PresenceInfo> for PresenceInfo {
        fn from(value: &PresenceInfo) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    ///-IN_AREA: Indicates that the UE is inside or enters the presence
    /// reporting area. -OUT_OF_AREA: Indicates that the UE is outside or
    /// leaves the presence reporting area -UNKNOW: Indicates it is unknown
    /// whether the UE is in the presence reporting area or not -INACTIVE:
    /// Indicates that the presence reporting area is inactive in the serving
    /// node.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n-IN_AREA: Indicates that the UE
    /// is inside or enters the presence reporting area.\n-OUT_OF_AREA:
    /// Indicates that the UE is outside or leaves the presence reporting
    /// area\n-UNKNOW: Indicates it is unknown whether the UE is in the presence
    /// reporting area or not\n-INACTIVE: Indicates that the presence reporting
    /// area is inactive in the serving node. \n",
    ///  "type": "string",
    ///  "enum": [
    ///    "IN_AREA",
    ///    "OUT_OF_AREA",
    ///    "UNKNOWN",
    ///    "INACTIVE"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum PresenceState {
        #[serde(rename = "IN_AREA")]
        InArea,
        #[serde(rename = "OUT_OF_AREA")]
        OutOfArea,
        #[serde(rename = "UNKNOWN")]
        Unknown,
        #[serde(rename = "INACTIVE")]
        Inactive,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&PresenceState> for PresenceState {
        fn from(value: &PresenceState) -> Self {
            value.clone()
        }
    }

    impl ToString for PresenceState {
        fn to_string(&self) -> String {
            match *self {
                Self::InArea => "IN_AREA".to_string(),
                Self::OutOfArea => "OUT_OF_AREA".to_string(),
                Self::Unknown => "UNKNOWN".to_string(),
                Self::Inactive => "INACTIVE".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for PresenceState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "IN_AREA" => Ok(Self::InArea),
                "OUT_OF_AREA" => Ok(Self::OutOfArea),
                "UNKNOWN" => Ok(Self::Unknown),
                "INACTIVE" => Ok(Self::Inactive),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PresenceState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PresenceState {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PresenceState {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Information of the previous subscription.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Information of the previous subscription.",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "required": [
    ///        "producerId"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "producerSetId"
    ///      ]
    ///    }
    ///  ],
    ///  "required": [
    ///    "subscriptionId"
    ///  ],
    ///  "properties": {
    ///    "nfAnaEvents": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NwdafEvent"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "producerId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "producerSetId": {
    ///      "$ref": "#/components/schemas/NfSetId"
    ///    },
    ///    "subscriptionId": {
    ///      "description": "The identifier of a subscription.",
    ///      "type": "string"
    ///    },
    ///    "ueAnaEvents": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UeAnalyticsContextDescriptor"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum PrevSubInfo {
        Variant0 {
            #[serde(rename = "nfAnaEvents", default, skip_serializing_if = "Vec::is_empty")]
            nf_ana_events: Vec<NwdafEvent>,
            #[serde(rename = "producerId")]
            producer_id: NfInstanceId,
            ///The identifier of a subscription.
            #[serde(rename = "subscriptionId")]
            subscription_id: String,
            #[serde(rename = "ueAnaEvents", default, skip_serializing_if = "Vec::is_empty")]
            ue_ana_events: Vec<UeAnalyticsContextDescriptor>,
        },
        Variant1 {
            #[serde(rename = "nfAnaEvents", default, skip_serializing_if = "Vec::is_empty")]
            nf_ana_events: Vec<NwdafEvent>,
            #[serde(rename = "producerSetId")]
            producer_set_id: NfSetId,
            ///The identifier of a subscription.
            #[serde(rename = "subscriptionId")]
            subscription_id: String,
            #[serde(rename = "ueAnaEvents", default, skip_serializing_if = "Vec::is_empty")]
            ue_ana_events: Vec<UeAnalyticsContextDescriptor>,
        },
    }

    impl From<&PrevSubInfo> for PrevSubInfo {
        fn from(value: &PrevSubInfo) -> Self {
            value.clone()
        }
    }

    ///Represents 5G ProSe related N2 information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents 5G ProSe related N2 information.",
    ///  "type": "object",
    ///  "properties": {
    ///    "n2Pc5ProSePol": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProSeInformation {
        #[serde(
            rename = "n2Pc5ProSePol",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n2_pc5_pro_se_pol: Option<N2InfoContent>,
    }

    impl From<&ProSeInformation> for ProSeInformation {
        fn from(value: &ProSeInformation) -> Self {
            value.clone()
        }
    }

    ///Provides additional information in an error response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Provides additional information in an error response.",
    ///  "type": "object",
    ///  "properties": {
    ///    "accessTokenError": {
    ///      "$ref": "#/components/schemas/AccessTokenErr"
    ///    },
    ///    "accessTokenRequest": {
    ///      "$ref": "#/components/schemas/AccessTokenReq"
    ///    },
    ///    "cause": {
    ///      "description": "A machine-readable application error cause specific
    /// to this occurrence of the problem.  This IE should be present and
    /// provide application-related error information, if available.\n",
    ///      "type": "string"
    ///    },
    ///    "detail": {
    ///      "description": "A human-readable explanation specific to this
    /// occurrence of the problem.",
    ///      "type": "string"
    ///    },
    ///    "instance": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "invalidParams": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/InvalidParam"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "nrfId": {
    ///      "$ref": "#/components/schemas/Fqdn"
    ///    },
    ///    "status": {
    ///      "type": "integer"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    },
    ///    "title": {
    ///      "type": "string"
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProblemDetails {
        #[serde(
            rename = "accessTokenError",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub access_token_error: Option<AccessTokenErr>,
        #[serde(
            rename = "accessTokenRequest",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub access_token_request: Option<AccessTokenReq>,
        ///A machine-readable application error cause specific to this
        /// occurrence of the problem.  This IE should be present and provide
        /// application-related error information, if available.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cause: Option<String>,
        ///A human-readable explanation specific to this occurrence of the
        /// problem.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub detail: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub instance: Option<Uri>,
        #[serde(
            rename = "invalidParams",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub invalid_params: Vec<InvalidParam>,
        #[serde(rename = "nrfId", default, skip_serializing_if = "Option::is_none")]
        pub nrf_id: Option<Fqdn>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub status: Option<i64>,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub title: Option<String>,
        #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<Uri>,
    }

    impl From<&ProblemDetails> for ProblemDetails {
        fn from(value: &ProblemDetails) -> Self {
            value.clone()
        }
    }

    ///Enable UE Reachability Error Detail
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Enable UE Reachability Error Detail",
    ///  "allOf": [
    ///    {
    ///      "$ref": "#/components/schemas/ProblemDetails"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/AdditionInfoEnableUeReachability"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProblemDetailsEnableUeReachability {
        #[serde(
            rename = "accessTokenError",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub access_token_error: Option<AccessTokenErr>,
        #[serde(
            rename = "accessTokenRequest",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub access_token_request: Option<AccessTokenReq>,
        ///A machine-readable application error cause specific to this
        /// occurrence of the problem.  This IE should be present and provide
        /// application-related error information, if available.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cause: Option<String>,
        ///A human-readable explanation specific to this occurrence of the
        /// problem.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub detail: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub instance: Option<Uri>,
        #[serde(
            rename = "invalidParams",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub invalid_params: Vec<InvalidParam>,
        #[serde(
            rename = "maxWaitingTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_waiting_time: Option<DurationSec>,
        #[serde(rename = "nrfId", default, skip_serializing_if = "Option::is_none")]
        pub nrf_id: Option<Fqdn>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub status: Option<i64>,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub title: Option<String>,
        #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
        pub type_: Option<Uri>,
    }

    impl From<&ProblemDetailsEnableUeReachability> for ProblemDetailsEnableUeReachability {
        fn from(value: &ProblemDetailsEnableUeReachability) -> Self {
            value.clone()
        }
    }

    ///Represents the ProSe services related parameters.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the ProSe services related parameters.",
    ///  "type": "object",
    ///  "properties": {
    ///    "directComm": {
    ///      "$ref": "#/components/schemas/UeAuth"
    ///    },
    ///    "directDiscovery": {
    ///      "$ref": "#/components/schemas/UeAuth"
    ///    },
    ///    "l2Relay": {
    ///      "$ref": "#/components/schemas/UeAuth"
    ///    },
    ///    "l2Remote": {
    ///      "$ref": "#/components/schemas/UeAuth"
    ///    },
    ///    "l3Relay": {
    ///      "$ref": "#/components/schemas/UeAuth"
    ///    },
    ///    "nrUePc5Ambr": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "pc5QoSPara": {
    ///      "$ref": "#/components/schemas/Pc5QoSPara"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProseContext {
        #[serde(
            rename = "directComm",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub direct_comm: Option<UeAuth>,
        #[serde(
            rename = "directDiscovery",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub direct_discovery: Option<UeAuth>,
        #[serde(rename = "l2Relay", default, skip_serializing_if = "Option::is_none")]
        pub l2_relay: Option<UeAuth>,
        #[serde(rename = "l2Remote", default, skip_serializing_if = "Option::is_none")]
        pub l2_remote: Option<UeAuth>,
        #[serde(rename = "l3Relay", default, skip_serializing_if = "Option::is_none")]
        pub l3_relay: Option<UeAuth>,
        #[serde(
            rename = "nrUePc5Ambr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nr_ue_pc5_ambr: Option<BitRate>,
        #[serde(
            rename = "pc5QoSPara",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pc5_qo_s_para: Option<Pc5QoSPara>,
    }

    impl From<&ProseContext> for ProseContext {
        fn from(value: &ProseContext) -> Self {
            value.clone()
        }
    }

    ///Data within Provide Location Information Response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within Provide Location Information Response",
    ///  "type": "object",
    ///  "properties": {
    ///    "additionalLocation": {
    ///      "$ref": "#/components/schemas/UserLocation"
    ///    },
    ///    "currentLoc": {
    ///      "type": "boolean"
    ///    },
    ///    "geoInfo": {
    ///      "$ref": "#/components/schemas/GeographicArea"
    ///    },
    ///    "location": {
    ///      "$ref": "#/components/schemas/UserLocation"
    ///    },
    ///    "locationAge": {
    ///      "$ref": "#/components/schemas/AgeOfLocationEstimate"
    ///    },
    ///    "oldGuami": {
    ///      "$ref": "#/components/schemas/Guami"
    ///    },
    ///    "ratType": {
    ///      "$ref": "#/components/schemas/RatType"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    },
    ///    "timezone": {
    ///      "$ref": "#/components/schemas/TimeZone"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProvideLocInfo {
        #[serde(
            rename = "additionalLocation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub additional_location: Option<UserLocation>,
        #[serde(
            rename = "currentLoc",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub current_loc: Option<bool>,
        #[serde(rename = "geoInfo", default, skip_serializing_if = "Option::is_none")]
        pub geo_info: Option<GeographicArea>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub location: Option<UserLocation>,
        #[serde(
            rename = "locationAge",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub location_age: Option<AgeOfLocationEstimate>,
        #[serde(rename = "oldGuami", default, skip_serializing_if = "Option::is_none")]
        pub old_guami: Option<Guami>,
        #[serde(rename = "ratType", default, skip_serializing_if = "Option::is_none")]
        pub rat_type: Option<RatType>,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub timezone: Option<TimeZone>,
    }

    impl From<&ProvideLocInfo> for ProvideLocInfo {
        fn from(value: &ProvideLocInfo) -> Self {
            value.clone()
        }
    }

    ///Data within Provide Positioning Information Response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within Provide Positioning Information Response",
    ///  "type": "object",
    ///  "properties": {
    ///    "acceptedPeriodicEventInfo": {
    ///      "$ref": "#/components/schemas/PeriodicEventInfo"
    ///    },
    ///    "accuracyFulfilmentIndicator": {
    ///      "$ref": "#/components/schemas/AccuracyFulfilmentIndicator"
    ///    },
    ///    "achievedQos": {
    ///      "$ref": "#/components/schemas/MinorLocationQoS"
    ///    },
    ///    "ageOfLocationEstimate": {
    ///      "$ref": "#/components/schemas/AgeOfLocationEstimate"
    ///    },
    ///    "altitude": {
    ///      "$ref": "#/components/schemas/Altitude"
    ///    },
    ///    "barometricPressure": {
    ///      "$ref": "#/components/schemas/BarometricPressure"
    ///    },
    ///    "civicAddress": {
    ///      "$ref": "#/components/schemas/CivicAddress"
    ///    },
    ///    "ecgi": {
    ///      "$ref": "#/components/schemas/Ecgi"
    ///    },
    ///    "gnssPositioningDataList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GnssPositioningMethodAndUsage"
    ///      },
    ///      "maxItems": 9,
    ///      "minItems": 0
    ///    },
    ///    "haGnssMetrics": {
    ///      "$ref": "#/components/schemas/HighAccuracyGnssMetrics"
    ///    },
    ///    "localLocationEstimate": {
    ///      "$ref": "#/components/schemas/LocalArea"
    ///    },
    ///    "locationEstimate": {
    ///      "$ref": "#/components/schemas/GeographicArea"
    ///    },
    ///    "locationPrivacyVerResult": {
    ///      "$ref": "#/components/schemas/LocationPrivacyVerResult"
    ///    },
    ///    "ncgi": {
    ///      "$ref": "#/components/schemas/Ncgi"
    ///    },
    ///    "positioningDataList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PositioningMethodAndUsage"
    ///      },
    ///      "maxItems": 9,
    ///      "minItems": 0
    ///    },
    ///    "servingLMFIdentification": {
    ///      "$ref": "#/components/schemas/LMFIdentification"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    },
    ///    "targetMmeName": {
    ///      "$ref": "#/components/schemas/Fqdn"
    ///    },
    ///    "targetMmeRealm": {
    ///      "$ref": "#/components/schemas/Fqdn"
    ///    },
    ///    "targetServingNode": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "timestampOfLocationEstimate": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "utranSrvccInd": {
    ///      "type": "boolean"
    ///    },
    ///    "velocityEstimate": {
    ///      "$ref": "#/components/schemas/VelocityEstimate"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ProvidePosInfo {
        #[serde(
            rename = "acceptedPeriodicEventInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub accepted_periodic_event_info: Option<PeriodicEventInfo>,
        #[serde(
            rename = "accuracyFulfilmentIndicator",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub accuracy_fulfilment_indicator: Option<AccuracyFulfilmentIndicator>,
        #[serde(
            rename = "achievedQos",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub achieved_qos: Option<MinorLocationQoS>,
        #[serde(
            rename = "ageOfLocationEstimate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub age_of_location_estimate: Option<AgeOfLocationEstimate>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub altitude: Option<Altitude>,
        #[serde(
            rename = "barometricPressure",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub barometric_pressure: Option<BarometricPressure>,
        #[serde(
            rename = "civicAddress",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub civic_address: Option<CivicAddress>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ecgi: Option<Ecgi>,
        #[serde(
            rename = "gnssPositioningDataList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub gnss_positioning_data_list: Vec<GnssPositioningMethodAndUsage>,
        #[serde(
            rename = "haGnssMetrics",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ha_gnss_metrics: Option<HighAccuracyGnssMetrics>,
        #[serde(
            rename = "localLocationEstimate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub local_location_estimate: Option<LocalArea>,
        #[serde(
            rename = "locationEstimate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub location_estimate: Option<GeographicArea>,
        #[serde(
            rename = "locationPrivacyVerResult",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub location_privacy_ver_result: Option<LocationPrivacyVerResult>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ncgi: Option<Ncgi>,
        #[serde(
            rename = "positioningDataList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub positioning_data_list: Vec<PositioningMethodAndUsage>,
        #[serde(
            rename = "servingLMFIdentification",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub serving_lmf_identification: Option<LmfIdentification>,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
        #[serde(
            rename = "targetMmeName",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_mme_name: Option<Fqdn>,
        #[serde(
            rename = "targetMmeRealm",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_mme_realm: Option<Fqdn>,
        #[serde(
            rename = "targetServingNode",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_serving_node: Option<NfInstanceId>,
        #[serde(
            rename = "timestampOfLocationEstimate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub timestamp_of_location_estimate: Option<DateTime>,
        #[serde(
            rename = "utranSrvccInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub utran_srvcc_ind: Option<bool>,
        #[serde(
            rename = "velocityEstimate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub velocity_estimate: Option<VelocityEstimate>,
    }

    impl From<&ProvidePosInfo> for ProvidePosInfo {
        fn from(value: &ProvidePosInfo) -> Self {
            value.clone()
        }
    }

    ///Data related to PWS error included in a N2 Information Transfer failure
    /// response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data related to PWS error included in a N2 Information
    /// Transfer failure response",
    ///  "type": "object",
    ///  "required": [
    ///    "namfCause"
    ///  ],
    ///  "properties": {
    ///    "namfCause": {
    ///      "type": "integer"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PwsErrorData {
        #[serde(rename = "namfCause")]
        pub namf_cause: i64,
    }

    impl From<&PwsErrorData> for PwsErrorData {
        fn from(value: &PwsErrorData) -> Self {
            value.clone()
        }
    }

    ///Represents a PWS related information data part
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a PWS related information data part",
    ///  "type": "object",
    ///  "required": [
    ///    "messageIdentifier",
    ///    "pwsContainer",
    ///    "serialNumber"
    ///  ],
    ///  "properties": {
    ///    "bcEmptyAreaList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GlobalRanNodeId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "messageIdentifier": {
    ///      "$ref": "#/components/schemas/Uint16"
    ///    },
    ///    "nfId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "omcId": {
    ///      "$ref": "#/components/schemas/OmcIdentifier"
    ///    },
    ///    "pwsContainer": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    },
    ///    "sendRanResponse": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "serialNumber": {
    ///      "$ref": "#/components/schemas/Uint16"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PwsInformation {
        #[serde(
            rename = "bcEmptyAreaList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub bc_empty_area_list: Vec<GlobalRanNodeId>,
        #[serde(rename = "messageIdentifier")]
        pub message_identifier: Uint16,
        #[serde(rename = "nfId", default, skip_serializing_if = "Option::is_none")]
        pub nf_id: Option<NfInstanceId>,
        #[serde(rename = "omcId", default, skip_serializing_if = "Option::is_none")]
        pub omc_id: Option<OmcIdentifier>,
        #[serde(rename = "pwsContainer")]
        pub pws_container: N2InfoContent,
        #[serde(rename = "sendRanResponse", default)]
        pub send_ran_response: bool,
        #[serde(rename = "serialNumber")]
        pub serial_number: Uint16,
    }

    impl From<&PwsInformation> for PwsInformation {
        fn from(value: &PwsInformation) -> Self {
            value.clone()
        }
    }

    ///Data related PWS included in a N2 Information Transfer response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data related PWS included in a N2 Information Transfer
    /// response",
    ///  "type": "object",
    ///  "required": [
    ///    "messageIdentifier",
    ///    "ngapMessageType",
    ///    "serialNumber"
    ///  ],
    ///  "properties": {
    ///    "messageIdentifier": {
    ///      "type": "integer"
    ///    },
    ///    "ngapMessageType": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "serialNumber": {
    ///      "$ref": "#/components/schemas/Uint16"
    ///    },
    ///    "unknownTaiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Tai"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct PwsResponseData {
        #[serde(rename = "messageIdentifier")]
        pub message_identifier: i64,
        #[serde(rename = "ngapMessageType")]
        pub ngap_message_type: Uinteger,
        #[serde(rename = "serialNumber")]
        pub serial_number: Uint16,
        #[serde(
            rename = "unknownTaiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub unknown_tai_list: Vec<Tai>,
    }

    impl From<&PwsResponseData> for PwsResponseData {
        fn from(value: &PwsResponseData) -> Self {
            value.clone()
        }
    }

    ///Represents the QoS requirements.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the QoS requirements.",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "required": [
    ///        "5qi"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "resType"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "5qi": {
    ///      "$ref": "#/components/schemas/5Qi"
    ///    },
    ///    "gfbrDl": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "gfbrUl": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "pdb": {
    ///      "$ref": "#/components/schemas/PacketDelBudget"
    ///    },
    ///    "per": {
    ///      "$ref": "#/components/schemas/PacketErrRate"
    ///    },
    ///    "resType": {
    ///      "$ref": "#/components/schemas/QosResourceType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum QosRequirement {
        Variant0 {
            #[serde(rename = "5qi")]
            five_qi: _5qi,
            #[serde(rename = "gfbrDl", default, skip_serializing_if = "Option::is_none")]
            gfbr_dl: Option<BitRate>,
            #[serde(rename = "gfbrUl", default, skip_serializing_if = "Option::is_none")]
            gfbr_ul: Option<BitRate>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pdb: Option<PacketDelBudget>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            per: Option<PacketErrRate>,
        },
        Variant1 {
            #[serde(rename = "gfbrDl", default, skip_serializing_if = "Option::is_none")]
            gfbr_dl: Option<BitRate>,
            #[serde(rename = "gfbrUl", default, skip_serializing_if = "Option::is_none")]
            gfbr_ul: Option<BitRate>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pdb: Option<PacketDelBudget>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            per: Option<PacketErrRate>,
            #[serde(rename = "resType")]
            res_type: QosResourceType,
        },
    }

    impl From<&QosRequirement> for QosRequirement {
        fn from(value: &QosRequirement) -> Self {
            value.clone()
        }
    }

    ///The enumeration QosResourceType indicates whether a QoS Flow is non-GBR,
    /// delay critical GBR, or non-delay critical GBR (see clauses 5.7.3.4 and
    /// 5.7.3.5 of 3GPP TS 23.501). It shall comply with the provisions defined
    /// in table 5.5.3.6-1.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration QosResourceType indicates whether a QoS
    /// Flow is non-GBR, delay critical GBR, or non-delay critical GBR (see
    /// clauses 5.7.3.4 and 5.7.3.5 of 3GPP TS 23.501). It shall comply with the
    /// provisions defined in table 5.5.3.6-1. \n",
    ///  "type": "string",
    ///  "enum": [
    ///    "NON_GBR",
    ///    "NON_CRITICAL_GBR",
    ///    "CRITICAL_GBR"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum QosResourceType {
        #[serde(rename = "NON_GBR")]
        NonGbr,
        #[serde(rename = "NON_CRITICAL_GBR")]
        NonCriticalGbr,
        #[serde(rename = "CRITICAL_GBR")]
        CriticalGbr,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&QosResourceType> for QosResourceType {
        fn from(value: &QosResourceType) -> Self {
            value.clone()
        }
    }

    impl ToString for QosResourceType {
        fn to_string(&self) -> String {
            match *self {
                Self::NonGbr => "NON_GBR".to_string(),
                Self::NonCriticalGbr => "NON_CRITICAL_GBR".to_string(),
                Self::CriticalGbr => "CRITICAL_GBR".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for QosResourceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NON_GBR" => Ok(Self::NonGbr),
                "NON_CRITICAL_GBR" => Ok(Self::NonCriticalGbr),
                "CRITICAL_GBR" => Ok(Self::CriticalGbr),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for QosResourceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for QosResourceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for QosResourceType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents the QoS Sustainability information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the QoS Sustainability information.",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "required": [
    ///        "qosFlowRetThd"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "ranUeThrouThd"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "areaInfo": {
    ///      "$ref": "#/components/schemas/NetworkAreaInfo"
    ///    },
    ///    "confidence": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "endTs": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "qosFlowRetThd": {
    ///      "$ref": "#/components/schemas/RetainabilityThreshold"
    ///    },
    ///    "ranUeThrouThd": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "startTs": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum QosSustainabilityInfo {
        Variant0 {
            #[serde(rename = "areaInfo", default, skip_serializing_if = "Option::is_none")]
            area_info: Option<NetworkAreaInfo>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            #[serde(rename = "endTs", default, skip_serializing_if = "Option::is_none")]
            end_ts: Option<DateTime>,
            #[serde(rename = "qosFlowRetThd")]
            qos_flow_ret_thd: RetainabilityThreshold,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            snssai: Option<Snssai>,
            #[serde(rename = "startTs", default, skip_serializing_if = "Option::is_none")]
            start_ts: Option<DateTime>,
        },
        Variant1 {
            #[serde(rename = "areaInfo", default, skip_serializing_if = "Option::is_none")]
            area_info: Option<NetworkAreaInfo>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            #[serde(rename = "endTs", default, skip_serializing_if = "Option::is_none")]
            end_ts: Option<DateTime>,
            #[serde(rename = "ranUeThrouThd")]
            ran_ue_throu_thd: BitRate,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            snssai: Option<Snssai>,
            #[serde(rename = "startTs", default, skip_serializing_if = "Option::is_none")]
            start_ts: Option<DateTime>,
        },
    }

    impl From<&QosSustainabilityInfo> for QosSustainabilityInfo {
        fn from(value: &QosSustainabilityInfo) -> Self {
            value.clone()
        }
    }

    ///Indicates the usage ranking criterion between the high, medium and low
    /// usage UE.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the usage ranking criterion between the high,
    /// medium and low usage UE.",
    ///  "type": "object",
    ///  "required": [
    ///    "highBase",
    ///    "lowBase"
    ///  ],
    ///  "properties": {
    ///    "highBase": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    },
    ///    "lowBase": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RankingCriterion {
        #[serde(rename = "highBase")]
        pub high_base: SamplingRatio,
        #[serde(rename = "lowBase")]
        pub low_base: SamplingRatio,
    }

    impl From<&RankingCriterion> for RankingCriterion {
        fn from(value: &RankingCriterion) -> Self {
            value.clone()
        }
    }

    ///Represents the RAT type and/or Frequency information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the RAT type and/or Frequency information.",
    ///  "type": "object",
    ///  "properties": {
    ///    "allFreq": {
    ///      "description": "Set to \"true\" to indicate to handle all the
    /// frequencies the NWDAF received, otherwise set to \"false\" or omit. The
    /// \"allFreq\" attribute and the \"freq\" attribute are mutually
    /// exclusive.\n",
    ///      "type": "boolean"
    ///    },
    ///    "allRat": {
    ///      "description": "Set to \"true\" to indicate to handle all the RAT
    /// Types the NWDAF received, otherwise set to \"false\" or omit. The
    /// \"allRat\" attribute and the \"ratType\" attribute are mutually
    /// exclusive.\n",
    ///      "type": "boolean"
    ///    },
    ///    "freq": {
    ///      "$ref": "#/components/schemas/ArfcnValueNR"
    ///    },
    ///    "matchingDir": {
    ///      "$ref": "#/components/schemas/MatchingDirection"
    ///    },
    ///    "ratType": {
    ///      "$ref": "#/components/schemas/RatType"
    ///    },
    ///    "svcExpThreshold": {
    ///      "$ref": "#/components/schemas/ThresholdLevel"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RatFreqInformation {
        ///Set to "true" to indicate to handle all the frequencies the NWDAF
        /// received, otherwise set to "false" or omit. The "allFreq" attribute
        /// and the "freq" attribute are mutually exclusive.
        #[serde(rename = "allFreq", default, skip_serializing_if = "Option::is_none")]
        pub all_freq: Option<bool>,
        ///Set to "true" to indicate to handle all the RAT Types the NWDAF
        /// received, otherwise set to "false" or omit. The "allRat" attribute
        /// and the "ratType" attribute are mutually exclusive.
        #[serde(rename = "allRat", default, skip_serializing_if = "Option::is_none")]
        pub all_rat: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub freq: Option<ArfcnValueNr>,
        #[serde(
            rename = "matchingDir",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub matching_dir: Option<MatchingDirection>,
        #[serde(rename = "ratType", default, skip_serializing_if = "Option::is_none")]
        pub rat_type: Option<RatType>,
        #[serde(
            rename = "svcExpThreshold",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub svc_exp_threshold: Option<ThresholdLevel>,
    }

    impl From<&RatFreqInformation> for RatFreqInformation {
        fn from(value: &RatFreqInformation) -> Self {
            value.clone()
        }
    }

    ///Indicates the RAT type for the transfer of N2 information
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the RAT type for the transfer of N2
    /// information",
    ///  "type": "string",
    ///  "enum": [
    ///    "E-UTRA",
    ///    "NR"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RatSelector {
        #[serde(rename = "E-UTRA")]
        EUtra,
        #[serde(rename = "NR")]
        Nr,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&RatSelector> for RatSelector {
        fn from(value: &RatSelector) -> Self {
            value.clone()
        }
    }

    impl ToString for RatSelector {
        fn to_string(&self) -> String {
            match *self {
                Self::EUtra => "E-UTRA".to_string(),
                Self::Nr => "NR".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for RatSelector {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "E-UTRA" => Ok(Self::EUtra),
                "NR" => Ok(Self::Nr),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for RatSelector {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for RatSelector {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for RatSelector {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates the radio access used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the radio access used.",
    ///  "type": "string",
    ///  "enum": [
    ///    "NR",
    ///    "EUTRA",
    ///    "WLAN",
    ///    "VIRTUAL",
    ///    "NBIOT",
    ///    "WIRELINE",
    ///    "WIRELINE_CABLE",
    ///    "WIRELINE_BBF",
    ///    "LTE-M",
    ///    "NR_U",
    ///    "EUTRA_U",
    ///    "TRUSTED_N3GA",
    ///    "TRUSTED_WLAN",
    ///    "UTRA",
    ///    "GERA",
    ///    "NR_LEO",
    ///    "NR_MEO",
    ///    "NR_GEO",
    ///    "NR_OTHER_SAT",
    ///    "NR_REDCAP",
    ///    "WB_E_UTRAN_LEO",
    ///    "WB_E_UTRAN_MEO",
    ///    "WB_E_UTRAN_GEO",
    ///    "WB_E_UTRAN_OTHERSAT",
    ///    "NB_IOT_LEO",
    ///    "NB_IOT_MEO",
    ///    "NB_IOT_GEO",
    ///    "NB_IOT_OTHERSAT",
    ///    "LTE_M_LEO",
    ///    "LTE_M_MEO",
    ///    "LTE_M_GEO",
    ///    "LTE_M_OTHERSAT"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RatType {
        #[serde(rename = "NR")]
        Nr,
        #[serde(rename = "EUTRA")]
        Eutra,
        #[serde(rename = "WLAN")]
        Wlan,
        #[serde(rename = "VIRTUAL")]
        Virtual,
        #[serde(rename = "NBIOT")]
        Nbiot,
        #[serde(rename = "WIRELINE")]
        Wireline,
        #[serde(rename = "WIRELINE_CABLE")]
        WirelineCable,
        #[serde(rename = "WIRELINE_BBF")]
        WirelineBbf,
        #[serde(rename = "LTE-M")]
        LteM,
        #[serde(rename = "NR_U")]
        NrU,
        #[serde(rename = "EUTRA_U")]
        EutraU,
        #[serde(rename = "TRUSTED_N3GA")]
        TrustedN3ga,
        #[serde(rename = "TRUSTED_WLAN")]
        TrustedWlan,
        #[serde(rename = "UTRA")]
        Utra,
        #[serde(rename = "GERA")]
        Gera,
        #[serde(rename = "NR_LEO")]
        NrLeo,
        #[serde(rename = "NR_MEO")]
        NrMeo,
        #[serde(rename = "NR_GEO")]
        NrGeo,
        #[serde(rename = "NR_OTHER_SAT")]
        NrOtherSat,
        #[serde(rename = "NR_REDCAP")]
        NrRedcap,
        #[serde(rename = "WB_E_UTRAN_LEO")]
        WbEUtranLeo,
        #[serde(rename = "WB_E_UTRAN_MEO")]
        WbEUtranMeo,
        #[serde(rename = "WB_E_UTRAN_GEO")]
        WbEUtranGeo,
        #[serde(rename = "WB_E_UTRAN_OTHERSAT")]
        WbEUtranOthersat,
        #[serde(rename = "NB_IOT_LEO")]
        NbIotLeo,
        #[serde(rename = "NB_IOT_MEO")]
        NbIotMeo,
        #[serde(rename = "NB_IOT_GEO")]
        NbIotGeo,
        #[serde(rename = "NB_IOT_OTHERSAT")]
        NbIotOthersat,
        #[serde(rename = "LTE_M_LEO")]
        LteMLeo,
        #[serde(rename = "LTE_M_MEO")]
        LteMMeo,
        #[serde(rename = "LTE_M_GEO")]
        LteMGeo,
        #[serde(rename = "LTE_M_OTHERSAT")]
        LteMOthersat,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&RatType> for RatType {
        fn from(value: &RatType) -> Self {
            value.clone()
        }
    }

    impl ToString for RatType {
        fn to_string(&self) -> String {
            match *self {
                Self::Nr => "NR".to_string(),
                Self::Eutra => "EUTRA".to_string(),
                Self::Wlan => "WLAN".to_string(),
                Self::Virtual => "VIRTUAL".to_string(),
                Self::Nbiot => "NBIOT".to_string(),
                Self::Wireline => "WIRELINE".to_string(),
                Self::WirelineCable => "WIRELINE_CABLE".to_string(),
                Self::WirelineBbf => "WIRELINE_BBF".to_string(),
                Self::LteM => "LTE-M".to_string(),
                Self::NrU => "NR_U".to_string(),
                Self::EutraU => "EUTRA_U".to_string(),
                Self::TrustedN3ga => "TRUSTED_N3GA".to_string(),
                Self::TrustedWlan => "TRUSTED_WLAN".to_string(),
                Self::Utra => "UTRA".to_string(),
                Self::Gera => "GERA".to_string(),
                Self::NrLeo => "NR_LEO".to_string(),
                Self::NrMeo => "NR_MEO".to_string(),
                Self::NrGeo => "NR_GEO".to_string(),
                Self::NrOtherSat => "NR_OTHER_SAT".to_string(),
                Self::NrRedcap => "NR_REDCAP".to_string(),
                Self::WbEUtranLeo => "WB_E_UTRAN_LEO".to_string(),
                Self::WbEUtranMeo => "WB_E_UTRAN_MEO".to_string(),
                Self::WbEUtranGeo => "WB_E_UTRAN_GEO".to_string(),
                Self::WbEUtranOthersat => "WB_E_UTRAN_OTHERSAT".to_string(),
                Self::NbIotLeo => "NB_IOT_LEO".to_string(),
                Self::NbIotMeo => "NB_IOT_MEO".to_string(),
                Self::NbIotGeo => "NB_IOT_GEO".to_string(),
                Self::NbIotOthersat => "NB_IOT_OTHERSAT".to_string(),
                Self::LteMLeo => "LTE_M_LEO".to_string(),
                Self::LteMMeo => "LTE_M_MEO".to_string(),
                Self::LteMGeo => "LTE_M_GEO".to_string(),
                Self::LteMOthersat => "LTE_M_OTHERSAT".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for RatType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NR" => Ok(Self::Nr),
                "EUTRA" => Ok(Self::Eutra),
                "WLAN" => Ok(Self::Wlan),
                "VIRTUAL" => Ok(Self::Virtual),
                "NBIOT" => Ok(Self::Nbiot),
                "WIRELINE" => Ok(Self::Wireline),
                "WIRELINE_CABLE" => Ok(Self::WirelineCable),
                "WIRELINE_BBF" => Ok(Self::WirelineBbf),
                "LTE-M" => Ok(Self::LteM),
                "NR_U" => Ok(Self::NrU),
                "EUTRA_U" => Ok(Self::EutraU),
                "TRUSTED_N3GA" => Ok(Self::TrustedN3ga),
                "TRUSTED_WLAN" => Ok(Self::TrustedWlan),
                "UTRA" => Ok(Self::Utra),
                "GERA" => Ok(Self::Gera),
                "NR_LEO" => Ok(Self::NrLeo),
                "NR_MEO" => Ok(Self::NrMeo),
                "NR_GEO" => Ok(Self::NrGeo),
                "NR_OTHER_SAT" => Ok(Self::NrOtherSat),
                "NR_REDCAP" => Ok(Self::NrRedcap),
                "WB_E_UTRAN_LEO" => Ok(Self::WbEUtranLeo),
                "WB_E_UTRAN_MEO" => Ok(Self::WbEUtranMeo),
                "WB_E_UTRAN_GEO" => Ok(Self::WbEUtranGeo),
                "WB_E_UTRAN_OTHERSAT" => Ok(Self::WbEUtranOthersat),
                "NB_IOT_LEO" => Ok(Self::NbIotLeo),
                "NB_IOT_MEO" => Ok(Self::NbIotMeo),
                "NB_IOT_GEO" => Ok(Self::NbIotGeo),
                "NB_IOT_OTHERSAT" => Ok(Self::NbIotOthersat),
                "LTE_M_LEO" => Ok(Self::LteMLeo),
                "LTE_M_MEO" => Ok(Self::LteMMeo),
                "LTE_M_GEO" => Ok(Self::LteMGeo),
                "LTE_M_OTHERSAT" => Ok(Self::LteMOthersat),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for RatType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for RatType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for RatType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Event filter for REACHABILITY_REPORT event type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Event filter for REACHABILITY_REPORT event type",
    ///  "type": "string",
    ///  "enum": [
    ///    "UE_REACHABILITY_STATUS_CHANGE",
    ///    "UE_REACHABLE_DL_TRAFFIC"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ReachabilityFilter {
        #[serde(rename = "UE_REACHABILITY_STATUS_CHANGE")]
        UeReachabilityStatusChange,
        #[serde(rename = "UE_REACHABLE_DL_TRAFFIC")]
        UeReachableDlTraffic,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&ReachabilityFilter> for ReachabilityFilter {
        fn from(value: &ReachabilityFilter) -> Self {
            value.clone()
        }
    }

    impl ToString for ReachabilityFilter {
        fn to_string(&self) -> String {
            match *self {
                Self::UeReachabilityStatusChange => "UE_REACHABILITY_STATUS_CHANGE".to_string(),
                Self::UeReachableDlTraffic => "UE_REACHABLE_DL_TRAFFIC".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for ReachabilityFilter {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "UE_REACHABILITY_STATUS_CHANGE" => Ok(Self::UeReachabilityStatusChange),
                "UE_REACHABLE_DL_TRAFFIC" => Ok(Self::UeReachableDlTraffic),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ReachabilityFilter {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ReachabilityFilter {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ReachabilityFilter {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Data within the UE Reachability Info Notify
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within the UE Reachability Info Notify",
    ///  "type": "object",
    ///  "properties": {
    ///    "reachableUeList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ReachableUeInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "unreachableUeList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReachabilityNotificationData {
        #[serde(
            rename = "reachableUeList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub reachable_ue_list: Vec<ReachableUeInfo>,
        #[serde(
            rename = "unreachableUeList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub unreachable_ue_list: Vec<Supi>,
    }

    impl From<&ReachabilityNotificationData> for ReachabilityNotificationData {
        fn from(value: &ReachabilityNotificationData) -> Self {
            value.clone()
        }
    }

    ///Contains the reachable UE Information
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the reachable UE Information",
    ///  "type": "object",
    ///  "required": [
    ///    "ueList"
    ///  ],
    ///  "properties": {
    ///    "ueList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "userLocation": {
    ///      "$ref": "#/components/schemas/UserLocation"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReachableUeInfo {
        #[serde(rename = "ueList")]
        pub ue_list: Vec<Supi>,
        #[serde(
            rename = "userLocation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub user_location: Option<UserLocation>,
    }

    impl From<&ReachableUeInfo> for ReachableUeInfo {
        fn from(value: &ReachableUeInfo) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - TIME_SLOT_START: Indicates the order of time slot start.
    /// - RED_TRANS_EXP: Indicates the order of Redundant Transmission
    ///   Experience.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- TIME_SLOT_START: Indicates the
    /// order of time slot start.\n- RED_TRANS_EXP: Indicates the order of
    /// Redundant Transmission Experience.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "TIME_SLOT_START",
    ///    "RED_TRANS_EXP"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RedTransExpOrderingCriterion {
        #[serde(rename = "TIME_SLOT_START")]
        TimeSlotStart,
        #[serde(rename = "RED_TRANS_EXP")]
        RedTransExp,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&RedTransExpOrderingCriterion> for RedTransExpOrderingCriterion {
        fn from(value: &RedTransExpOrderingCriterion) -> Self {
            value.clone()
        }
    }

    impl ToString for RedTransExpOrderingCriterion {
        fn to_string(&self) -> String {
            match *self {
                Self::TimeSlotStart => "TIME_SLOT_START".to_string(),
                Self::RedTransExp => "RED_TRANS_EXP".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for RedTransExpOrderingCriterion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TIME_SLOT_START" => Ok(Self::TimeSlotStart),
                "RED_TRANS_EXP" => Ok(Self::RedTransExp),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for RedTransExpOrderingCriterion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for RedTransExpOrderingCriterion {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for RedTransExpOrderingCriterion {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The response shall include a Location header field containing a
    /// different URI  (pointing to a different URI of an other service
    /// instance), or the same URI if a request  is redirected to the same
    /// target resource via a different SCP.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The response shall include a Location header field
    /// containing a different URI  (pointing to a different URI of an other
    /// service instance), or the same URI if a request  is redirected to the
    /// same target resource via a different SCP.\n",
    ///  "type": "object",
    ///  "properties": {
    ///    "cause": {
    ///      "type": "string"
    ///    },
    ///    "targetScp": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "targetSepp": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RedirectResponse {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub cause: Option<String>,
        #[serde(rename = "targetScp", default, skip_serializing_if = "Option::is_none")]
        pub target_scp: Option<Uri>,
        #[serde(
            rename = "targetSepp",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_sepp: Option<Uri>,
    }

    impl From<&RedirectResponse> for RedirectResponse {
        fn from(value: &RedirectResponse) -> Self {
            value.clone()
        }
    }

    ///The redundant transmission experience related information. When
    /// subscribed event is "RED_TRANS_EXP", the "redTransInfos" attribute shall
    /// be included.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The redundant transmission experience related
    /// information. When subscribed event is \"RED_TRANS_EXP\", the
    /// \"redTransInfos\" attribute shall be included.\n",
    ///  "type": "object",
    ///  "required": [
    ///    "redTransExps"
    ///  ],
    ///  "properties": {
    ///    "dnn": {
    ///      "$ref": "#/components/schemas/Dnn"
    ///    },
    ///    "redTransExps": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RedundantTransmissionExpPerTS"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "spatialValidCon": {
    ///      "$ref": "#/components/schemas/NetworkAreaInfo"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RedundantTransmissionExpInfo {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dnn: Option<Dnn>,
        #[serde(rename = "redTransExps")]
        pub red_trans_exps: Vec<RedundantTransmissionExpPerTs>,
        #[serde(
            rename = "spatialValidCon",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub spatial_valid_con: Option<NetworkAreaInfo>,
    }

    impl From<&RedundantTransmissionExpInfo> for RedundantTransmissionExpInfo {
        fn from(value: &RedundantTransmissionExpInfo) -> Self {
            value.clone()
        }
    }

    ///The redundant transmission experience per Time Slot.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The redundant transmission experience per Time Slot.",
    ///  "type": "object",
    ///  "required": [
    ///    "obsvRedTransExp",
    ///    "tsDuration",
    ///    "tsStart"
    ///  ],
    ///  "properties": {
    ///    "confidence": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "obsvRedTransExp": {
    ///      "$ref": "#/components/schemas/ObservedRedundantTransExp"
    ///    },
    ///    "redTransStatus": {
    ///      "description": "Redundant Transmission Status. Set to \"true\" if
    /// redundant transmission was activated, otherwise set to \"false\".
    /// Default value is \"false\" if omitted.\n",
    ///      "type": "boolean"
    ///    },
    ///    "tsDuration": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "tsStart": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "ueRatio": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RedundantTransmissionExpPerTs {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub confidence: Option<Uinteger>,
        #[serde(rename = "obsvRedTransExp")]
        pub obsv_red_trans_exp: ObservedRedundantTransExp,
        ///Redundant Transmission Status. Set to "true" if redundant
        /// transmission was activated, otherwise set to "false". Default value
        /// is "false" if omitted.
        #[serde(
            rename = "redTransStatus",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub red_trans_status: Option<bool>,
        #[serde(rename = "tsDuration")]
        pub ts_duration: DurationSec,
        #[serde(rename = "tsStart")]
        pub ts_start: DateTime,
        #[serde(rename = "ueRatio", default, skip_serializing_if = "Option::is_none")]
        pub ue_ratio: Option<SamplingRatio>,
    }

    impl From<&RedundantTransmissionExpPerTs> for RedundantTransmissionExpPerTs {
        fn from(value: &RedundantTransmissionExpPerTs) -> Self {
            value.clone()
        }
    }

    ///Represents other redundant transmission experience analytics
    /// requirements.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents other redundant transmission experience
    /// analytics requirements.",
    ///  "type": "object",
    ///  "properties": {
    ///    "order": {
    ///      "$ref": "#/components/schemas/MatchingDirection"
    ///    },
    ///    "redTOrderCriter": {
    ///      "$ref": "#/components/schemas/RedTransExpOrderingCriterion"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RedundantTransmissionExpReq {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub order: Option<MatchingDirection>,
        #[serde(
            rename = "redTOrderCriter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub red_t_order_criter: Option<RedTransExpOrderingCriterion>,
    }

    impl From<&RedundantTransmissionExpReq> for RedundantTransmissionExpReq {
        fn from(value: &RedundantTransmissionExpReq) -> Self {
            value.clone()
        }
    }

    ///This parameter provides information about the referenced binary body
    /// data.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This parameter provides information about the
    /// referenced binary body data.",
    ///  "type": "object",
    ///  "required": [
    ///    "contentId"
    ///  ],
    ///  "properties": {
    ///    "contentId": {
    ///      "description": "This IE shall contain the value of the Content-ID
    /// header of the referenced binary body part.\n",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RefToBinaryData {
        ///This IE shall contain the value of the Content-ID header of the
        /// referenced binary body part.
        #[serde(rename = "contentId")]
        pub content_id: String,
    }

    impl From<&RefToBinaryData> for RefToBinaryData {
        fn from(value: &RefToBinaryData) -> Self {
            value.clone()
        }
    }

    ///ReferenceId
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "integer"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReferenceId(pub i64);
    impl ::std::ops::Deref for ReferenceId {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<ReferenceId> for i64 {
        fn from(value: ReferenceId) -> Self {
            value.0
        }
    }

    impl From<&ReferenceId> for ReferenceId {
        fn from(value: &ReferenceId) -> Self {
            value.clone()
        }
    }

    impl From<i64> for ReferenceId {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for ReferenceId {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for ReferenceId {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ReferenceId {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ReferenceId {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for ReferenceId {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Registration Context Container used to send the UE context information,
    /// N1 message from UE, AN address etc during Registration with AMF
    /// re-allocation procedure
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Registration Context Container used to send the UE
    /// context information, N1 message from UE, AN address etc during
    /// Registration with AMF re-allocation procedure",
    ///  "type": "object",
    ///  "required": [
    ///    "anN2ApId",
    ///    "anType",
    ///    "initialAmfName",
    ///    "ranNodeId",
    ///    "ueContext",
    ///    "userLocation"
    ///  ],
    ///  "properties": {
    ///    "allowedNssai": {
    ///      "$ref": "#/components/schemas/AllowedNssai"
    ///    },
    ///    "anN2ApId": {
    ///      "type": "integer"
    ///    },
    ///    "anN2IPv4Addr": {
    ///      "$ref": "#/components/schemas/Ipv4Addr"
    ///    },
    ///    "anN2IPv6Addr": {
    ///      "$ref": "#/components/schemas/Ipv6Addr"
    ///    },
    ///    "anType": {
    ///      "$ref": "#/components/schemas/AccessType"
    ///    },
    ///    "authenticatedInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "ceModeBInd": {
    ///      "$ref": "#/components/schemas/CeModeBInd"
    ///    },
    ///    "configuredNssai": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ConfiguredSnssai"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "iabNodeInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "initialAmfN2ApId": {
    ///      "type": "integer"
    ///    },
    ///    "initialAmfName": {
    ///      "$ref": "#/components/schemas/Fqdn"
    ///    },
    ///    "localTimeZone": {
    ///      "$ref": "#/components/schemas/TimeZone"
    ///    },
    ///    "lteMInd": {
    ///      "$ref": "#/components/schemas/LteMInd"
    ///    },
    ///    "npnAccessInfo": {
    ///      "$ref": "#/components/schemas/NpnAccessInfo"
    ///    },
    ///    "ranNodeId": {
    ///      "$ref": "#/components/schemas/GlobalRanNodeId"
    ///    },
    ///    "rejectedNssaiInPlmn": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Snssai"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "rejectedNssaiInTa": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Snssai"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "rrcEstCause": {
    ///      "type": "string",
    ///      "pattern": "^[0-9a-fA-F]+$"
    ///    },
    ///    "selectedPlmnId": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    },
    ///    "ueContext": {
    ///      "$ref": "#/components/schemas/UeContext"
    ///    },
    ///    "ueContextRequest": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "userLocation": {
    ///      "$ref": "#/components/schemas/UserLocation"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RegistrationContextContainer {
        #[serde(
            rename = "allowedNssai",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub allowed_nssai: Option<AllowedNssai>,
        #[serde(rename = "anN2ApId")]
        pub an_n2_ap_id: i64,
        #[serde(
            rename = "anN2IPv4Addr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub an_n2i_pv4_addr: Option<Ipv4Addr>,
        #[serde(
            rename = "anN2IPv6Addr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub an_n2i_pv6_addr: Option<Ipv6Addr>,
        #[serde(rename = "anType")]
        pub an_type: AccessType,
        #[serde(rename = "authenticatedInd", default)]
        pub authenticated_ind: bool,
        #[serde(
            rename = "ceModeBInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ce_mode_b_ind: Option<CeModeBInd>,
        #[serde(
            rename = "configuredNssai",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub configured_nssai: Vec<ConfiguredSnssai>,
        #[serde(rename = "iabNodeInd", default)]
        pub iab_node_ind: bool,
        #[serde(
            rename = "initialAmfN2ApId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub initial_amf_n2_ap_id: Option<i64>,
        #[serde(rename = "initialAmfName")]
        pub initial_amf_name: Fqdn,
        #[serde(
            rename = "localTimeZone",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub local_time_zone: Option<TimeZone>,
        #[serde(rename = "lteMInd", default, skip_serializing_if = "Option::is_none")]
        pub lte_m_ind: Option<LteMInd>,
        #[serde(
            rename = "npnAccessInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub npn_access_info: Option<NpnAccessInfo>,
        #[serde(rename = "ranNodeId")]
        pub ran_node_id: GlobalRanNodeId,
        #[serde(
            rename = "rejectedNssaiInPlmn",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub rejected_nssai_in_plmn: Vec<Snssai>,
        #[serde(
            rename = "rejectedNssaiInTa",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub rejected_nssai_in_ta: Vec<Snssai>,
        #[serde(
            rename = "rrcEstCause",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub rrc_est_cause: Option<RegistrationContextContainerRrcEstCause>,
        #[serde(
            rename = "selectedPlmnId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub selected_plmn_id: Option<PlmnId>,
        #[serde(rename = "ueContext")]
        pub ue_context: UeContext,
        #[serde(rename = "ueContextRequest", default)]
        pub ue_context_request: bool,
        #[serde(rename = "userLocation")]
        pub user_location: UserLocation,
    }

    impl From<&RegistrationContextContainer> for RegistrationContextContainer {
        fn from(value: &RegistrationContextContainer) -> Self {
            value.clone()
        }
    }

    ///RegistrationContextContainerRrcEstCause
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[0-9a-fA-F]+$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct RegistrationContextContainerRrcEstCause(String);
    impl ::std::ops::Deref for RegistrationContextContainerRrcEstCause {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<RegistrationContextContainerRrcEstCause> for String {
        fn from(value: RegistrationContextContainerRrcEstCause) -> Self {
            value.0
        }
    }

    impl From<&RegistrationContextContainerRrcEstCause> for RegistrationContextContainerRrcEstCause {
        fn from(value: &RegistrationContextContainerRrcEstCause) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for RegistrationContextContainerRrcEstCause {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9a-fA-F]+$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9a-fA-F]+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for RegistrationContextContainerRrcEstCause {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for RegistrationContextContainerRrcEstCause {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for RegistrationContextContainerRrcEstCause {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for RegistrationContextContainerRrcEstCause {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Relative Cartesian Location
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Relative Cartesian Location",
    ///  "type": "object",
    ///  "required": [
    ///    "x",
    ///    "y"
    ///  ],
    ///  "properties": {
    ///    "x": {
    ///      "$ref": "#/components/schemas/Float"
    ///    },
    ///    "y": {
    ///      "$ref": "#/components/schemas/Float"
    ///    },
    ///    "z": {
    ///      "$ref": "#/components/schemas/Float"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RelativeCartesianLocation {
        pub x: Float,
        pub y: Float,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub z: Option<Float>,
    }

    impl From<&RelativeCartesianLocation> for RelativeCartesianLocation {
        fn from(value: &RelativeCartesianLocation) -> Self {
            value.clone()
        }
    }

    ///The cause for triggering the release.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The cause for triggering the release.",
    ///  "type": "string",
    ///  "enum": [
    ///    "SNPN_SNPN_MOBILITY",
    ///    "NO_HR_AGREEMENT",
    ///    "UNSPECIFIED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ReleaseCause {
        #[serde(rename = "SNPN_SNPN_MOBILITY")]
        SnpnSnpnMobility,
        #[serde(rename = "NO_HR_AGREEMENT")]
        NoHrAgreement,
        #[serde(rename = "UNSPECIFIED")]
        Unspecified,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&ReleaseCause> for ReleaseCause {
        fn from(value: &ReleaseCause) -> Self {
            value.clone()
        }
    }

    impl ToString for ReleaseCause {
        fn to_string(&self) -> String {
            match *self {
                Self::SnpnSnpnMobility => "SNPN_SNPN_MOBILITY".to_string(),
                Self::NoHrAgreement => "NO_HR_AGREEMENT".to_string(),
                Self::Unspecified => "UNSPECIFIED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for ReleaseCause {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SNPN_SNPN_MOBILITY" => Ok(Self::SnpnSnpnMobility),
                "NO_HR_AGREEMENT" => Ok(Self::NoHrAgreement),
                "UNSPECIFIED" => Ok(Self::Unspecified),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ReleaseCause {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ReleaseCause {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ReleaseCause {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///PDU session Id(s) and the cause for triggering the release.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "PDU session Id(s) and the cause for triggering the
    /// release.",
    ///  "type": "object",
    ///  "required": [
    ///    "releaseCause",
    ///    "releaseSessionList"
    ///  ],
    ///  "properties": {
    ///    "releaseCause": {
    ///      "$ref": "#/components/schemas/ReleaseCause"
    ///    },
    ///    "releaseSessionList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PduSessionId"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReleaseSessionInfo {
        #[serde(rename = "releaseCause")]
        pub release_cause: ReleaseCause,
        #[serde(rename = "releaseSessionList")]
        pub release_session_list: Vec<PduSessionId>,
    }

    impl From<&ReleaseSessionInfo> for ReleaseSessionInfo {
        fn from(value: &ReleaseSessionInfo) -> Self {
            value.clone()
        }
    }

    ///The enumeration ReportAmountMdt defines Report Amount for MDT in the
    /// trace. See 3GPP TS 32.422 for further description of the values. It
    /// shall comply with the provisions defined in table 5.6.3.10-1.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration ReportAmountMdt defines Report Amount
    /// for MDT in the trace. See 3GPP TS 32.422 for further description of the
    /// values. It shall comply with the provisions defined in table
    /// 5.6.3.10-1.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    1,
    ///    2,
    ///    4,
    ///    8,
    ///    16,
    ///    32,
    ///    64,
    ///    "infinity"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ReportAmountMdt {
        #[serde(rename = "1")]
        NUM1,
        #[serde(rename = "2")]
        NUM2,
        #[serde(rename = "4")]
        NUM4,
        #[serde(rename = "8")]
        NUM8,
        #[serde(rename = "16")]
        NUM16,
        #[serde(rename = "32")]
        NUM32,
        #[serde(rename = "64")]
        NUM64,
        #[serde(rename = "infinity")]
        Infinity,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&ReportAmountMdt> for ReportAmountMdt {
        fn from(value: &ReportAmountMdt) -> Self {
            value.clone()
        }
    }

    impl ToString for ReportAmountMdt {
        fn to_string(&self) -> String {
            match *self {
                Self::NUM1 => "1".to_string(),
                Self::NUM2 => "2".to_string(),
                Self::NUM4 => "4".to_string(),
                Self::NUM8 => "8".to_string(),
                Self::NUM16 => "16".to_string(),
                Self::NUM32 => "32".to_string(),
                Self::NUM64 => "64".to_string(),
                Self::Infinity => "infinity".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for ReportAmountMdt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "1" => Ok(Self::NUM1),
                "2" => Ok(Self::NUM2),
                "4" => Ok(Self::NUM4),
                "8" => Ok(Self::NUM8),
                "16" => Ok(Self::NUM16),
                "32" => Ok(Self::NUM32),
                "64" => Ok(Self::NUM64),
                "infinity" => Ok(Self::Infinity),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ReportAmountMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ReportAmountMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ReportAmountMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The enumeration ReportIntervalMdt defines Report Interval for MDT in the
    /// trace. See 3GPP TS 32.422 for further description of the values. It
    /// shall comply with the provisions defined in table 5.6.3.9-1.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration ReportIntervalMdt defines Report
    /// Interval for MDT in the trace. See 3GPP TS 32.422 for further
    /// description of the values. It shall comply with the provisions defined
    /// in table 5.6.3.9-1.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    120,
    ///    240,
    ///    480,
    ///    640,
    ///    1024,
    ///    2048,
    ///    5120,
    ///    10240,
    ///    60000,
    ///    360000,
    ///    720000,
    ///    1800000,
    ///    3600000
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ReportIntervalMdt {
        #[serde(rename = "120")]
        NUM120,
        #[serde(rename = "240")]
        NUM240,
        #[serde(rename = "480")]
        NUM480,
        #[serde(rename = "640")]
        NUM640,
        #[serde(rename = "1024")]
        NUM1024,
        #[serde(rename = "2048")]
        NUM2048,
        #[serde(rename = "5120")]
        NUM5120,
        #[serde(rename = "10240")]
        NUM10240,
        #[serde(rename = "60000")]
        NUM60000,
        #[serde(rename = "360000")]
        NUM360000,
        #[serde(rename = "720000")]
        NUM720000,
        #[serde(rename = "1800000")]
        NUM1800000,
        #[serde(rename = "3600000")]
        NUM3600000,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&ReportIntervalMdt> for ReportIntervalMdt {
        fn from(value: &ReportIntervalMdt) -> Self {
            value.clone()
        }
    }

    impl ToString for ReportIntervalMdt {
        fn to_string(&self) -> String {
            match *self {
                Self::NUM120 => "120".to_string(),
                Self::NUM240 => "240".to_string(),
                Self::NUM480 => "480".to_string(),
                Self::NUM640 => "640".to_string(),
                Self::NUM1024 => "1024".to_string(),
                Self::NUM2048 => "2048".to_string(),
                Self::NUM5120 => "5120".to_string(),
                Self::NUM10240 => "10240".to_string(),
                Self::NUM60000 => "60000".to_string(),
                Self::NUM360000 => "360000".to_string(),
                Self::NUM720000 => "720000".to_string(),
                Self::NUM1800000 => "1800000".to_string(),
                Self::NUM3600000 => "3600000".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for ReportIntervalMdt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "120" => Ok(Self::NUM120),
                "240" => Ok(Self::NUM240),
                "480" => Ok(Self::NUM480),
                "640" => Ok(Self::NUM640),
                "1024" => Ok(Self::NUM1024),
                "2048" => Ok(Self::NUM2048),
                "5120" => Ok(Self::NUM5120),
                "10240" => Ok(Self::NUM10240),
                "60000" => Ok(Self::NUM60000),
                "360000" => Ok(Self::NUM360000),
                "720000" => Ok(Self::NUM720000),
                "1800000" => Ok(Self::NUM1800000),
                "3600000" => Ok(Self::NUM3600000),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ReportIntervalMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ReportIntervalMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ReportIntervalMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The enumeration ReportIntervalNrMdt defines Report Interval in NR for
    /// MDT in the trace. See 3GPP TS 32.422 for further description of the
    /// values. It shall comply with the provisions defined in table 5.6.3.17-1.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration ReportIntervalNrMdt defines Report
    /// Interval in NR for MDT in the trace. See 3GPP TS 32.422 for further
    /// description of the values. It shall comply with the provisions defined
    /// in table 5.6.3.17-1.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    120,
    ///    240,
    ///    480,
    ///    640,
    ///    1024,
    ///    2048,
    ///    5120,
    ///    10240,
    ///    20480,
    ///    40960,
    ///    60000,
    ///    360000,
    ///    720000,
    ///    1800000,
    ///    3600000
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ReportIntervalNrMdt {
        #[serde(rename = "120")]
        NUM120,
        #[serde(rename = "240")]
        NUM240,
        #[serde(rename = "480")]
        NUM480,
        #[serde(rename = "640")]
        NUM640,
        #[serde(rename = "1024")]
        NUM1024,
        #[serde(rename = "2048")]
        NUM2048,
        #[serde(rename = "5120")]
        NUM5120,
        #[serde(rename = "10240")]
        NUM10240,
        #[serde(rename = "20480")]
        NUM20480,
        #[serde(rename = "40960")]
        NUM40960,
        #[serde(rename = "60000")]
        NUM60000,
        #[serde(rename = "360000")]
        NUM360000,
        #[serde(rename = "720000")]
        NUM720000,
        #[serde(rename = "1800000")]
        NUM1800000,
        #[serde(rename = "3600000")]
        NUM3600000,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&ReportIntervalNrMdt> for ReportIntervalNrMdt {
        fn from(value: &ReportIntervalNrMdt) -> Self {
            value.clone()
        }
    }

    impl ToString for ReportIntervalNrMdt {
        fn to_string(&self) -> String {
            match *self {
                Self::NUM120 => "120".to_string(),
                Self::NUM240 => "240".to_string(),
                Self::NUM480 => "480".to_string(),
                Self::NUM640 => "640".to_string(),
                Self::NUM1024 => "1024".to_string(),
                Self::NUM2048 => "2048".to_string(),
                Self::NUM5120 => "5120".to_string(),
                Self::NUM10240 => "10240".to_string(),
                Self::NUM20480 => "20480".to_string(),
                Self::NUM40960 => "40960".to_string(),
                Self::NUM60000 => "60000".to_string(),
                Self::NUM360000 => "360000".to_string(),
                Self::NUM720000 => "720000".to_string(),
                Self::NUM1800000 => "1800000".to_string(),
                Self::NUM3600000 => "3600000".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for ReportIntervalNrMdt {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "120" => Ok(Self::NUM120),
                "240" => Ok(Self::NUM240),
                "480" => Ok(Self::NUM480),
                "640" => Ok(Self::NUM640),
                "1024" => Ok(Self::NUM1024),
                "2048" => Ok(Self::NUM2048),
                "5120" => Ok(Self::NUM5120),
                "10240" => Ok(Self::NUM10240),
                "20480" => Ok(Self::NUM20480),
                "40960" => Ok(Self::NUM40960),
                "60000" => Ok(Self::NUM60000),
                "360000" => Ok(Self::NUM360000),
                "720000" => Ok(Self::NUM720000),
                "1800000" => Ok(Self::NUM1800000),
                "3600000" => Ok(Self::NUM3600000),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ReportIntervalNrMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ReportIntervalNrMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ReportIntervalNrMdt {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Number of required periodic event reports.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Number of required periodic event reports.",
    ///  "type": "integer",
    ///  "maximum": 8639999.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReportingAmount(pub i64);
    impl ::std::ops::Deref for ReportingAmount {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<ReportingAmount> for i64 {
        fn from(value: ReportingAmount) -> Self {
            value.0
        }
    }

    impl From<&ReportingAmount> for ReportingAmount {
        fn from(value: &ReportingAmount) -> Self {
            value.clone()
        }
    }

    impl From<i64> for ReportingAmount {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for ReportingAmount {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for ReportingAmount {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ReportingAmount {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ReportingAmount {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for ReportingAmount {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Indicates an area for event reporting.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates an area for event reporting.",
    ///  "type": "object",
    ///  "required": [
    ///    "areaType"
    ///  ],
    ///  "properties": {
    ///    "areaType": {
    ///      "$ref": "#/components/schemas/ReportingAreaType"
    ///    },
    ///    "ecgi": {
    ///      "$ref": "#/components/schemas/Ecgi"
    ///    },
    ///    "ncgi": {
    ///      "$ref": "#/components/schemas/Ncgi"
    ///    },
    ///    "tai": {
    ///      "$ref": "#/components/schemas/Tai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReportingArea {
        #[serde(rename = "areaType")]
        pub area_type: ReportingAreaType,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ecgi: Option<Ecgi>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ncgi: Option<Ncgi>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub tai: Option<Tai>,
    }

    impl From<&ReportingArea> for ReportingArea {
        fn from(value: &ReportingArea) -> Self {
            value.clone()
        }
    }

    ///Indicates type of event reporting area.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates type of event reporting area.",
    ///  "type": "string",
    ///  "enum": [
    ///    "EPS_TRACKING_AREA_IDENTITY",
    ///    "E-UTRAN_CELL_GLOBAL_IDENTIFICATION",
    ///    "5GS_TRACKING_AREA_IDENTITY",
    ///    "NR_CELL_GLOBAL_IDENTITY"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ReportingAreaType {
        #[serde(rename = "EPS_TRACKING_AREA_IDENTITY")]
        EpsTrackingAreaIdentity,
        #[serde(rename = "E-UTRAN_CELL_GLOBAL_IDENTIFICATION")]
        EUtranCellGlobalIdentification,
        #[serde(rename = "5GS_TRACKING_AREA_IDENTITY")]
        FiveGsTrackingAreaIdentity,
        #[serde(rename = "NR_CELL_GLOBAL_IDENTITY")]
        NrCellGlobalIdentity,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&ReportingAreaType> for ReportingAreaType {
        fn from(value: &ReportingAreaType) -> Self {
            value.clone()
        }
    }

    impl ToString for ReportingAreaType {
        fn to_string(&self) -> String {
            match *self {
                Self::EpsTrackingAreaIdentity => "EPS_TRACKING_AREA_IDENTITY".to_string(),
                Self::EUtranCellGlobalIdentification => {
                    "E-UTRAN_CELL_GLOBAL_IDENTIFICATION".to_string()
                }
                Self::FiveGsTrackingAreaIdentity => "5GS_TRACKING_AREA_IDENTITY".to_string(),
                Self::NrCellGlobalIdentity => "NR_CELL_GLOBAL_IDENTITY".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for ReportingAreaType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "EPS_TRACKING_AREA_IDENTITY" => Ok(Self::EpsTrackingAreaIdentity),
                "E-UTRAN_CELL_GLOBAL_IDENTIFICATION" => Ok(Self::EUtranCellGlobalIdentification),
                "5GS_TRACKING_AREA_IDENTITY" => Ok(Self::FiveGsTrackingAreaIdentity),
                "NR_CELL_GLOBAL_IDENTITY" => Ok(Self::NrCellGlobalIdentity),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ReportingAreaType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ReportingAreaType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ReportingAreaType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Maximum duration of event reporting.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Maximum duration of event reporting.",
    ///  "type": "integer",
    ///  "maximum": 8640000.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReportingDuration(pub i64);
    impl ::std::ops::Deref for ReportingDuration {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<ReportingDuration> for i64 {
        fn from(value: ReportingDuration) -> Self {
            value.0
        }
    }

    impl From<&ReportingDuration> for ReportingDuration {
        fn from(value: &ReportingDuration) -> Self {
            value.clone()
        }
    }

    impl From<i64> for ReportingDuration {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for ReportingDuration {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for ReportingDuration {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ReportingDuration {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ReportingDuration {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for ReportingDuration {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Represents the type of reporting that the subscription requires.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the type of reporting that the subscription
    /// requires.",
    ///  "type": "object",
    ///  "properties": {
    ///    "grpRepTime": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "immRep": {
    ///      "type": "boolean"
    ///    },
    ///    "maxReportNbr": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "monDur": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "notifFlag": {
    ///      "$ref": "#/components/schemas/NotificationFlag"
    ///    },
    ///    "notifMethod": {
    ///      "$ref": "#/components/schemas/schemas-NotificationMethod"
    ///    },
    ///    "partitionCriteria": {
    ///      "description": "Criteria for partitioning the UEs before applying
    /// the sampling ratio.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PartitioningCriteria"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "repPeriod": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "sampRatio": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReportingInformation {
        #[serde(
            rename = "grpRepTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub grp_rep_time: Option<DurationSec>,
        #[serde(rename = "immRep", default, skip_serializing_if = "Option::is_none")]
        pub imm_rep: Option<bool>,
        #[serde(
            rename = "maxReportNbr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_report_nbr: Option<Uinteger>,
        #[serde(rename = "monDur", default, skip_serializing_if = "Option::is_none")]
        pub mon_dur: Option<DateTime>,
        #[serde(rename = "notifFlag", default, skip_serializing_if = "Option::is_none")]
        pub notif_flag: Option<NotificationFlag>,
        #[serde(
            rename = "notifMethod",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub notif_method: Option<SchemasNotificationMethod>,
        ///Criteria for partitioning the UEs before applying the sampling
        /// ratio.
        #[serde(
            rename = "partitionCriteria",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub partition_criteria: Vec<PartitioningCriteria>,
        #[serde(rename = "repPeriod", default, skip_serializing_if = "Option::is_none")]
        pub rep_period: Option<DurationSec>,
        #[serde(rename = "sampRatio", default, skip_serializing_if = "Option::is_none")]
        pub samp_ratio: Option<SamplingRatio>,
    }

    impl From<&ReportingInformation> for ReportingInformation {
        fn from(value: &ReportingInformation) -> Self {
            value.clone()
        }
    }

    ///Event reporting periodic interval in seconds.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Event reporting periodic interval in seconds.",
    ///  "type": "integer",
    ///  "maximum": 8639999.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReportingInterval(pub i64);
    impl ::std::ops::Deref for ReportingInterval {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<ReportingInterval> for i64 {
        fn from(value: ReportingInterval) -> Self {
            value.0
        }
    }

    impl From<&ReportingInterval> for ReportingInterval {
        fn from(value: &ReportingInterval) -> Self {
            value.clone()
        }
    }

    impl From<i64> for ReportingInterval {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for ReportingInterval {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for ReportingInterval {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ReportingInterval {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ReportingInterval {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for ReportingInterval {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Event reporting periodic interval in milliseconds.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Event reporting periodic interval in milliseconds.",
    ///  "type": "integer",
    ///  "maximum": 999.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ReportingIntervalMs(pub i64);
    impl ::std::ops::Deref for ReportingIntervalMs {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<ReportingIntervalMs> for i64 {
        fn from(value: ReportingIntervalMs) -> Self {
            value.0
        }
    }

    impl From<&ReportingIntervalMs> for ReportingIntervalMs {
        fn from(value: &ReportingIntervalMs) -> Self {
            value.clone()
        }
    }

    impl From<i64> for ReportingIntervalMs {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for ReportingIntervalMs {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for ReportingIntervalMs {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ReportingIntervalMs {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ReportingIntervalMs {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for ReportingIntervalMs {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///The enumeration ReportingTrigger defines Reporting Triggers for MDT in
    /// the trace. See 3GPP TS 32.42] for further  description of the values. It
    /// shall comply with the provisions defined in table 5.6.3.8-1.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration ReportingTrigger defines Reporting
    /// Triggers for MDT in the trace. See 3GPP TS 32.42] for further
    /// description of the values. It shall comply with the provisions defined
    /// in table 5.6.3.8-1.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "PERIODICAL",
    ///    "EVENT_A2",
    ///    "EVENT_A2_PERIODIC",
    ///    "ALL_RRM_EVENT_TRIGGERS"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ReportingTrigger {
        #[serde(rename = "PERIODICAL")]
        Periodical,
        #[serde(rename = "EVENT_A2")]
        EventA2,
        #[serde(rename = "EVENT_A2_PERIODIC")]
        EventA2Periodic,
        #[serde(rename = "ALL_RRM_EVENT_TRIGGERS")]
        AllRrmEventTriggers,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&ReportingTrigger> for ReportingTrigger {
        fn from(value: &ReportingTrigger) -> Self {
            value.clone()
        }
    }

    impl ToString for ReportingTrigger {
        fn to_string(&self) -> String {
            match *self {
                Self::Periodical => "PERIODICAL".to_string(),
                Self::EventA2 => "EVENT_A2".to_string(),
                Self::EventA2Periodic => "EVENT_A2_PERIODIC".to_string(),
                Self::AllRrmEventTriggers => "ALL_RRM_EVENT_TRIGGERS".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for ReportingTrigger {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "PERIODICAL" => Ok(Self::Periodical),
                "EVENT_A2" => Ok(Self::EventA2),
                "EVENT_A2_PERIODIC" => Ok(Self::EventA2Periodic),
                "ALL_RRM_EVENT_TRIGGERS" => Ok(Self::AllRrmEventTriggers),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ReportingTrigger {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ReportingTrigger {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ReportingTrigger {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Data within Provide Location Information Request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within Provide Location Information Request",
    ///  "type": "object",
    ///  "properties": {
    ///    "req5gsLoc": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "reqCurrentLoc": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "reqRatType": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "reqTimeZone": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RequestLocInfo {
        #[serde(rename = "req5gsLoc", default)]
        pub req5gs_loc: bool,
        #[serde(rename = "reqCurrentLoc", default)]
        pub req_current_loc: bool,
        #[serde(rename = "reqRatType", default)]
        pub req_rat_type: bool,
        #[serde(rename = "reqTimeZone", default)]
        pub req_time_zone: bool,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
    }

    impl From<&RequestLocInfo> for RequestLocInfo {
        fn from(value: &RequestLocInfo) -> Self {
            value.clone()
        }
    }

    ///Data within Provide Positioning Information Request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within Provide Positioning Information Request",
    ///  "type": "object",
    ///  "required": [
    ///    "lcsClientType",
    ///    "lcsLocation"
    ///  ],
    ///  "properties": {
    ///    "additionalLcsSuppGADShapes": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SupportedGADShapes"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "afID": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "areaEventInfo": {
    ///      "$ref": "#/components/schemas/AreaEventInfo"
    ///    },
    ///    "codeWord": {
    ///      "$ref": "#/components/schemas/CodeWord"
    ///    },
    ///    "externalClientIdentification": {
    ///      "$ref": "#/components/schemas/ExternalClientIdentification"
    ///    },
    ///    "gpsi": {
    ///      "$ref": "#/components/schemas/Gpsi"
    ///    },
    ///    "hgmlcCallBackURI": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "integrityRequirements": {
    ///      "$ref": "#/components/schemas/IntegrityRequirements"
    ///    },
    ///    "lcsClientType": {
    ///      "$ref": "#/components/schemas/ExternalClientType"
    ///    },
    ///    "lcsLocation": {
    ///      "$ref": "#/components/schemas/LocationType"
    ///    },
    ///    "lcsQoS": {
    ///      "$ref": "#/components/schemas/LocationQoS"
    ///    },
    ///    "lcsServiceType": {
    ///      "$ref": "#/components/schemas/LcsServiceType"
    ///    },
    ///    "lcsSupportedGADShapes": {
    ///      "$ref": "#/components/schemas/SupportedGADShapes"
    ///    },
    ///    "ldrReference": {
    ///      "$ref": "#/components/schemas/LdrReference"
    ///    },
    ///    "ldrType": {
    ///      "$ref": "#/components/schemas/LdrType"
    ///    },
    ///    "locationNotificationUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "motionEventInfo": {
    ///      "$ref": "#/components/schemas/MotionEventInfo"
    ///    },
    ///    "oldGuami": {
    ///      "$ref": "#/components/schemas/Guami"
    ///    },
    ///    "pei": {
    ///      "$ref": "#/components/schemas/Pei"
    ///    },
    ///    "periodicEventInfo": {
    ///      "$ref": "#/components/schemas/PeriodicEventInfo"
    ///    },
    ///    "priority": {
    ///      "$ref": "#/components/schemas/LcsPriority"
    ///    },
    ///    "reliableLocReq": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "scheduledLocTime": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "supi": {
    ///      "$ref": "#/components/schemas/Supi"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    },
    ///    "uePrivacyRequirements": {
    ///      "$ref": "#/components/schemas/UePrivacyRequirements"
    ///    },
    ///    "velocityRequested": {
    ///      "$ref": "#/components/schemas/VelocityRequested"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RequestPosInfo {
        #[serde(
            rename = "additionalLcsSuppGADShapes",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub additional_lcs_supp_gad_shapes: Vec<SupportedGadShapes>,
        #[serde(rename = "afID", default, skip_serializing_if = "Option::is_none")]
        pub af_id: Option<NfInstanceId>,
        #[serde(
            rename = "areaEventInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub area_event_info: Option<AreaEventInfo>,
        #[serde(rename = "codeWord", default, skip_serializing_if = "Option::is_none")]
        pub code_word: Option<CodeWord>,
        #[serde(
            rename = "externalClientIdentification",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub external_client_identification: Option<ExternalClientIdentification>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub gpsi: Option<Gpsi>,
        #[serde(
            rename = "hgmlcCallBackURI",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub hgmlc_call_back_uri: Option<Uri>,
        #[serde(
            rename = "integrityRequirements",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub integrity_requirements: Option<IntegrityRequirements>,
        #[serde(rename = "lcsClientType")]
        pub lcs_client_type: ExternalClientType,
        #[serde(rename = "lcsLocation")]
        pub lcs_location: LocationType,
        #[serde(rename = "lcsQoS", default, skip_serializing_if = "Option::is_none")]
        pub lcs_qo_s: Option<LocationQoS>,
        #[serde(
            rename = "lcsServiceType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub lcs_service_type: Option<LcsServiceType>,
        #[serde(
            rename = "lcsSupportedGADShapes",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub lcs_supported_gad_shapes: Option<SupportedGadShapes>,
        #[serde(
            rename = "ldrReference",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ldr_reference: Option<LdrReference>,
        #[serde(rename = "ldrType", default, skip_serializing_if = "Option::is_none")]
        pub ldr_type: Option<LdrType>,
        #[serde(
            rename = "locationNotificationUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub location_notification_uri: Option<Uri>,
        #[serde(
            rename = "motionEventInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub motion_event_info: Option<MotionEventInfo>,
        #[serde(rename = "oldGuami", default, skip_serializing_if = "Option::is_none")]
        pub old_guami: Option<Guami>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pei: Option<Pei>,
        #[serde(
            rename = "periodicEventInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub periodic_event_info: Option<PeriodicEventInfo>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub priority: Option<LcsPriority>,
        #[serde(rename = "reliableLocReq", default)]
        pub reliable_loc_req: bool,
        #[serde(
            rename = "scheduledLocTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub scheduled_loc_time: Option<DateTime>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub supi: Option<Supi>,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
        #[serde(
            rename = "uePrivacyRequirements",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_privacy_requirements: Option<UePrivacyRequirements>,
        #[serde(
            rename = "velocityRequested",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub velocity_requested: Option<VelocityRequested>,
    }

    impl From<&RequestPosInfo> for RequestPosInfo {
        fn from(value: &RequestPosInfo) -> Self {
            value.clone()
        }
    }

    ///The current usage of the virtual resources assigned to the NF instances
    /// belonging to a particular network slice instance.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The current usage of the virtual resources assigned to the NF instances belonging to a particular network slice instance.\n",
    ///  "type": "object",
    ///  "properties": {
    ///    "cpuUsage": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "memoryUsage": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "storageUsage": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ResourceUsage {
        #[serde(rename = "cpuUsage", default, skip_serializing_if = "Option::is_none")]
        pub cpu_usage: Option<Uinteger>,
        #[serde(
            rename = "memoryUsage",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub memory_usage: Option<Uinteger>,
        #[serde(
            rename = "storageUsage",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub storage_usage: Option<Uinteger>,
    }

    impl From<&ResourceUsage> for ResourceUsage {
        fn from(value: &ResourceUsage) -> Self {
            value.clone()
        }
    }

    ///Indicates acceptable delay of location request.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates acceptable delay of location request.",
    ///  "type": "string",
    ///  "enum": [
    ///    "LOW_DELAY",
    ///    "DELAY_TOLERANT",
    ///    "NO_DELAY"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ResponseTime {
        #[serde(rename = "LOW_DELAY")]
        LowDelay,
        #[serde(rename = "DELAY_TOLERANT")]
        DelayTolerant,
        #[serde(rename = "NO_DELAY")]
        NoDelay,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&ResponseTime> for ResponseTime {
        fn from(value: &ResponseTime) -> Self {
            value.clone()
        }
    }

    impl ToString for ResponseTime {
        fn to_string(&self) -> String {
            match *self {
                Self::LowDelay => "LOW_DELAY".to_string(),
                Self::DelayTolerant => "DELAY_TOLERANT".to_string(),
                Self::NoDelay => "NO_DELAY".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for ResponseTime {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "LOW_DELAY" => Ok(Self::LowDelay),
                "DELAY_TOLERANT" => Ok(Self::DelayTolerant),
                "NO_DELAY" => Ok(Self::NoDelay),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ResponseTime {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ResponseTime {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ResponseTime {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///It contains the restriction type ALLOWED_AREAS or NOT_ALLOWED_AREAS.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "It contains the restriction type ALLOWED_AREAS or
    /// NOT_ALLOWED_AREAS.",
    ///  "type": "string",
    ///  "enum": [
    ///    "ALLOWED_AREAS",
    ///    "NOT_ALLOWED_AREAS"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RestrictionType {
        #[serde(rename = "ALLOWED_AREAS")]
        AllowedAreas,
        #[serde(rename = "NOT_ALLOWED_AREAS")]
        NotAllowedAreas,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&RestrictionType> for RestrictionType {
        fn from(value: &RestrictionType) -> Self {
            value.clone()
        }
    }

    impl ToString for RestrictionType {
        fn to_string(&self) -> String {
            match *self {
                Self::AllowedAreas => "ALLOWED_AREAS".to_string(),
                Self::NotAllowedAreas => "NOT_ALLOWED_AREAS".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for RestrictionType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "ALLOWED_AREAS" => Ok(Self::AllowedAreas),
                "NOT_ALLOWED_AREAS" => Ok(Self::NotAllowedAreas),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for RestrictionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for RestrictionType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for RestrictionType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents a QoS flow retainability threshold.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a QoS flow retainability threshold.",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "allOf": [
    ///        {
    ///          "required": [
    ///            "relFlowNum"
    ///          ]
    ///        },
    ///        {
    ///          "required": [
    ///            "relTimeUnit"
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "relFlowRatio"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "relFlowNum": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "relFlowRatio": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    },
    ///    "relTimeUnit": {
    ///      "$ref": "#/components/schemas/TimeUnit"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum RetainabilityThreshold {
        Variant0 {
            #[serde(rename = "relFlowNum")]
            rel_flow_num: Uinteger,
            #[serde(rename = "relTimeUnit")]
            rel_time_unit: TimeUnit,
        },
        Variant1 {
            #[serde(rename = "relFlowRatio")]
            rel_flow_ratio: SamplingRatio,
        },
    }

    impl From<&RetainabilityThreshold> for RetainabilityThreshold {
        fn from(value: &RetainabilityThreshold) -> Self {
            value.clone()
        }
    }

    ///Unsigned integer representing the "Subscriber Profile ID for
    /// RAT/Frequency Priority"  as specified in 3GPP TS 36.413.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unsigned integer representing the \"Subscriber Profile
    /// ID for RAT/Frequency Priority\"  as specified in 3GPP TS 36.413.\n",
    ///  "type": "integer",
    ///  "maximum": 256.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RfspIndex(pub i64);
    impl ::std::ops::Deref for RfspIndex {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<RfspIndex> for i64 {
        fn from(value: RfspIndex) -> Self {
            value.0
        }
    }

    impl From<&RfspIndex> for RfspIndex {
        fn from(value: &RfspIndex) -> Self {
            value.clone()
        }
    }

    impl From<i64> for RfspIndex {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for RfspIndex {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for RfspIndex {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for RfspIndex {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for RfspIndex {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for RfspIndex {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Represents the registration state of a UE for an access type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the registration state of a UE for an access
    /// type",
    ///  "type": "object",
    ///  "required": [
    ///    "accessType",
    ///    "rmState"
    ///  ],
    ///  "properties": {
    ///    "accessType": {
    ///      "$ref": "#/components/schemas/AccessType"
    ///    },
    ///    "rmState": {
    ///      "$ref": "#/components/schemas/RmState"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RmInfo {
        #[serde(rename = "accessType")]
        pub access_type: AccessType,
        #[serde(rename = "rmState")]
        pub rm_state: RmState,
    }

    impl From<&RmInfo> for RmInfo {
        fn from(value: &RmInfo) -> Self {
            value.clone()
        }
    }

    ///Describes the registration management state of a UE
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the registration management state of a UE",
    ///  "type": "string",
    ///  "enum": [
    ///    "REGISTERED",
    ///    "DEREGISTERED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum RmState {
        #[serde(rename = "REGISTERED")]
        Registered,
        #[serde(rename = "DEREGISTERED")]
        Deregistered,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&RmState> for RmState {
        fn from(value: &RmState) -> Self {
            value.clone()
        }
    }

    impl ToString for RmState {
        fn to_string(&self) -> String {
            match *self {
                Self::Registered => "REGISTERED".to_string(),
                Self::Deregistered => "DEREGISTERED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for RmState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "REGISTERED" => Ok(Self::Registered),
                "DEREGISTERED" => Ok(Self::Deregistered),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for RmState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for RmState {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for RmState {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Contains a Routing Area Identification as defined in 3GPP TS 23.003,
    /// clause 4.2.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains a Routing Area Identification as defined in
    /// 3GPP TS 23.003, clause 4.2.",
    ///  "type": "object",
    ///  "required": [
    ///    "lac",
    ///    "plmnId",
    ///    "rac"
    ///  ],
    ///  "properties": {
    ///    "lac": {
    ///      "description": "Location Area Code",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]{4}$"
    ///    },
    ///    "plmnId": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    },
    ///    "rac": {
    ///      "description": "Routing Area Code",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]{2}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct RoutingAreaId {
        ///Location Area Code
        pub lac: RoutingAreaIdLac,
        #[serde(rename = "plmnId")]
        pub plmn_id: PlmnId,
        ///Routing Area Code
        pub rac: RoutingAreaIdRac,
    }

    impl From<&RoutingAreaId> for RoutingAreaId {
        fn from(value: &RoutingAreaId) -> Self {
            value.clone()
        }
    }

    ///Location Area Code
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Location Area Code",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{4}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct RoutingAreaIdLac(String);
    impl ::std::ops::Deref for RoutingAreaIdLac {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<RoutingAreaIdLac> for String {
        fn from(value: RoutingAreaIdLac) -> Self {
            value.0
        }
    }

    impl From<&RoutingAreaIdLac> for RoutingAreaIdLac {
        fn from(value: &RoutingAreaIdLac) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for RoutingAreaIdLac {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{4}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{4}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for RoutingAreaIdLac {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for RoutingAreaIdLac {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for RoutingAreaIdLac {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for RoutingAreaIdLac {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Routing Area Code
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Routing Area Code",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{2}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct RoutingAreaIdRac(String);
    impl ::std::ops::Deref for RoutingAreaIdRac {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<RoutingAreaIdRac> for String {
        fn from(value: RoutingAreaIdRac) -> Self {
            value.0
        }
    }

    impl From<&RoutingAreaIdRac> for RoutingAreaIdRac {
        fn from(value: &RoutingAreaIdRac) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for RoutingAreaIdRac {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{2}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{2}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for RoutingAreaIdRac {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for RoutingAreaIdRac {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for RoutingAreaIdRac {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for RoutingAreaIdRac {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///S1UeNetworkCapability
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "$ref": "#/components/schemas/Bytes"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct S1UeNetworkCapability(pub Bytes);
    impl ::std::ops::Deref for S1UeNetworkCapability {
        type Target = Bytes;
        fn deref(&self) -> &Bytes {
            &self.0
        }
    }

    impl From<S1UeNetworkCapability> for Bytes {
        fn from(value: S1UeNetworkCapability) -> Self {
            value.0
        }
    }

    impl From<&S1UeNetworkCapability> for S1UeNetworkCapability {
        fn from(value: &S1UeNetworkCapability) -> Self {
            value.clone()
        }
    }

    impl From<Bytes> for S1UeNetworkCapability {
        fn from(value: Bytes) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for S1UeNetworkCapability {
        type Err = <Bytes as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for S1UeNetworkCapability {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for S1UeNetworkCapability {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for S1UeNetworkCapability {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for S1UeNetworkCapability {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Maximum time interval between consecutive evaluations by a UE of a
    /// trigger event.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Maximum time interval between consecutive evaluations
    /// by a UE of a trigger event.",
    ///  "type": "integer",
    ///  "maximum": 3600.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SamplingInterval(pub i64);
    impl ::std::ops::Deref for SamplingInterval {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<SamplingInterval> for i64 {
        fn from(value: SamplingInterval) -> Self {
            value.0
        }
    }

    impl From<&SamplingInterval> for SamplingInterval {
        fn from(value: &SamplingInterval) -> Self {
            value.clone()
        }
    }

    impl From<i64> for SamplingInterval {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for SamplingInterval {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for SamplingInterval {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SamplingInterval {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SamplingInterval {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for SamplingInterval {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Unsigned integer indicating Sampling Ratio (see clauses 4.15.1 of 3GPP
    /// TS 23.502), expressed in percent.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unsigned integer indicating Sampling Ratio (see clauses
    /// 4.15.1 of 3GPP TS 23.502), expressed in percent. \n",
    ///  "type": "integer",
    ///  "maximum": 100.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SamplingRatio(pub i64);
    impl ::std::ops::Deref for SamplingRatio {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<SamplingRatio> for i64 {
        fn from(value: SamplingRatio) -> Self {
            value.0
        }
    }

    impl From<&SamplingRatio> for SamplingRatio {
        fn from(value: &SamplingRatio) -> Self {
            value.clone()
        }
    }

    impl From<i64> for SamplingRatio {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for SamplingRatio {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for SamplingRatio {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SamplingRatio {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SamplingRatio {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for SamplingRatio {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///SBI Binding Level
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "SBI Binding Level",
    ///  "type": "string",
    ///  "enum": [
    ///    "NF_INSTANCE_BINDING",
    ///    "NF_SET_BINDING",
    ///    "NF_SERVICE_SET_BINDING",
    ///    "NF_SERVICE_INSTANCE_BINDING"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SbiBindingLevel {
        #[serde(rename = "NF_INSTANCE_BINDING")]
        NfInstanceBinding,
        #[serde(rename = "NF_SET_BINDING")]
        NfSetBinding,
        #[serde(rename = "NF_SERVICE_SET_BINDING")]
        NfServiceSetBinding,
        #[serde(rename = "NF_SERVICE_INSTANCE_BINDING")]
        NfServiceInstanceBinding,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&SbiBindingLevel> for SbiBindingLevel {
        fn from(value: &SbiBindingLevel) -> Self {
            value.clone()
        }
    }

    impl ToString for SbiBindingLevel {
        fn to_string(&self) -> String {
            match *self {
                Self::NfInstanceBinding => "NF_INSTANCE_BINDING".to_string(),
                Self::NfSetBinding => "NF_SET_BINDING".to_string(),
                Self::NfServiceSetBinding => "NF_SERVICE_SET_BINDING".to_string(),
                Self::NfServiceInstanceBinding => "NF_SERVICE_INSTANCE_BINDING".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for SbiBindingLevel {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NF_INSTANCE_BINDING" => Ok(Self::NfInstanceBinding),
                "NF_SET_BINDING" => Ok(Self::NfSetBinding),
                "NF_SERVICE_SET_BINDING" => Ok(Self::NfServiceSetBinding),
                "NF_SERVICE_INSTANCE_BINDING" => Ok(Self::NfServiceInstanceBinding),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for SbiBindingLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SbiBindingLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SbiBindingLevel {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates the security context type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the security context type",
    ///  "type": "string",
    ///  "enum": [
    ///    "NATIVE",
    ///    "MAPPED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ScType {
        #[serde(rename = "NATIVE")]
        Native,
        #[serde(rename = "MAPPED")]
        Mapped,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&ScType> for ScType {
        fn from(value: &ScType) -> Self {
            value.clone()
        }
    }

    impl ToString for ScType {
        fn to_string(&self) -> String {
            match *self {
                Self::Native => "NATIVE".to_string(),
                Self::Mapped => "MAPPED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for ScType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "NATIVE" => Ok(Self::Native),
                "MAPPED" => Ok(Self::Mapped),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ScType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ScType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ScType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Identifies time and day of the week when the UE is available for
    /// communication.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identifies time and day of the week when the UE is
    /// available for communication.",
    ///  "type": "object",
    ///  "properties": {
    ///    "daysOfWeek": {
    ///      "description": "Identifies the day(s) of the week. If absent, it
    /// indicates every day of the week.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DayOfWeek"
    ///      },
    ///      "maxItems": 6,
    ///      "minItems": 1
    ///    },
    ///    "timeOfDayEnd": {
    ///      "$ref": "#/components/schemas/TimeOfDay"
    ///    },
    ///    "timeOfDayStart": {
    ///      "$ref": "#/components/schemas/TimeOfDay"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ScheduledCommunicationTime {
        ///Identifies the day(s) of the week. If absent, it indicates every day
        /// of the week.
        #[serde(rename = "daysOfWeek", default, skip_serializing_if = "Vec::is_empty")]
        pub days_of_week: Vec<DayOfWeek>,
        #[serde(
            rename = "timeOfDayEnd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub time_of_day_end: Option<TimeOfDay>,
        #[serde(
            rename = "timeOfDayStart",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub time_of_day_start: Option<TimeOfDay>,
    }

    impl From<&ScheduledCommunicationTime> for ScheduledCommunicationTime {
        fn from(value: &ScheduledCommunicationTime) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    ///-DOWNLINK_ONLY: Downlink only
    ///-UPLINK_ONLY: Uplink only
    ///-BIDIRECTIONA: Bi-directional
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n-DOWNLINK_ONLY: Downlink
    /// only\n-UPLINK_ONLY: Uplink only\n-BIDIRECTIONA: Bi-directional\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "DOWNLINK_ONLY",
    ///    "UPLINK_ONLY",
    ///    "BIDIRECTIONAL"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ScheduledCommunicationType {
        #[serde(rename = "DOWNLINK_ONLY")]
        DownlinkOnly,
        #[serde(rename = "UPLINK_ONLY")]
        UplinkOnly,
        #[serde(rename = "BIDIRECTIONAL")]
        Bidirectional,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&ScheduledCommunicationType> for ScheduledCommunicationType {
        fn from(value: &ScheduledCommunicationType) -> Self {
            value.clone()
        }
    }

    impl ToString for ScheduledCommunicationType {
        fn to_string(&self) -> String {
            match *self {
                Self::DownlinkOnly => "DOWNLINK_ONLY".to_string(),
                Self::UplinkOnly => "UPLINK_ONLY".to_string(),
                Self::Bidirectional => "BIDIRECTIONAL".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for ScheduledCommunicationType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DOWNLINK_ONLY" => Ok(Self::DownlinkOnly),
                "UPLINK_ONLY" => Ok(Self::UplinkOnly),
                "BIDIRECTIONAL" => Ok(Self::Bidirectional),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ScheduledCommunicationType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ScheduledCommunicationType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ScheduledCommunicationType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///SchemasAccuracy
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates value of accuracy.",
    ///  "type": "number",
    ///  "format": "float",
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SchemasAccuracy(pub f32);
    impl ::std::ops::Deref for SchemasAccuracy {
        type Target = f32;
        fn deref(&self) -> &f32 {
            &self.0
        }
    }

    impl From<SchemasAccuracy> for f32 {
        fn from(value: SchemasAccuracy) -> Self {
            value.0
        }
    }

    impl From<&SchemasAccuracy> for SchemasAccuracy {
        fn from(value: &SchemasAccuracy) -> Self {
            value.clone()
        }
    }

    impl From<f32> for SchemasAccuracy {
        fn from(value: f32) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for SchemasAccuracy {
        type Err = <f32 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for SchemasAccuracy {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SchemasAccuracy {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SchemasAccuracy {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for SchemasAccuracy {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Describes an event to be subscribed
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes an event to be subscribed",
    ///  "type": "object",
    ///  "required": [
    ///    "type"
    ///  ],
    ///  "properties": {
    ///    "areaList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/schemas-AmfEventArea"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "dispersionArea": {
    ///      "$ref": "#/components/schemas/schemas-DispersionArea"
    ///    },
    ///    "idleStatusInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "immediateFlag": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "locationFilterList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LocationFilter"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "maxReports": {
    ///      "type": "integer"
    ///    },
    ///    "maxResponseTime": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "minInterval": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "nextPeriodicReportTime": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "nextReport": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "presenceInfoList": {
    ///      "description": "A map(list of key-value pairs) where praId serves
    /// as key.",
    ///      "type": "object",
    ///      "minProperties": 1,
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/PresenceInfo"
    ///      }
    ///    },
    ///    "reachabilityFilter": {
    ///      "$ref": "#/components/schemas/ReachabilityFilter"
    ///    },
    ///    "refId": {
    ///      "$ref": "#/components/schemas/ReferenceId"
    ///    },
    ///    "reportUeReachable": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "snssaiFilter": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ExtSnssai"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "targetArea": {
    ///      "$ref": "#/components/schemas/schemas-TargetArea"
    ///    },
    ///    "trafficDescriptorList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/schemas-TrafficDescriptor"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "type": {
    ///      "$ref": "#/components/schemas/AmfEventType"
    ///    },
    ///    "udmDetectInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "ueInAreaFilter": {
    ///      "$ref": "#/components/schemas/UeInAreaFilter"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SchemasAmfEvent {
        #[serde(rename = "areaList", default, skip_serializing_if = "Vec::is_empty")]
        pub area_list: Vec<SchemasAmfEventArea>,
        #[serde(
            rename = "dispersionArea",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub dispersion_area: Option<SchemasDispersionArea>,
        #[serde(rename = "idleStatusInd", default)]
        pub idle_status_ind: bool,
        #[serde(rename = "immediateFlag", default)]
        pub immediate_flag: bool,
        #[serde(
            rename = "locationFilterList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub location_filter_list: Vec<LocationFilter>,
        #[serde(
            rename = "maxReports",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_reports: Option<i64>,
        #[serde(
            rename = "maxResponseTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_response_time: Option<DurationSec>,
        #[serde(
            rename = "minInterval",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub min_interval: Option<DurationSec>,
        #[serde(
            rename = "nextPeriodicReportTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub next_periodic_report_time: Option<DateTime>,
        #[serde(
            rename = "nextReport",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub next_report: Option<DateTime>,
        ///A map(list of key-value pairs) where praId serves as key.
        #[serde(
            rename = "presenceInfoList",
            default,
            skip_serializing_if = "::std::collections::HashMap::is_empty"
        )]
        pub presence_info_list: ::std::collections::HashMap<String, PresenceInfo>,
        #[serde(
            rename = "reachabilityFilter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub reachability_filter: Option<ReachabilityFilter>,
        #[serde(rename = "refId", default, skip_serializing_if = "Option::is_none")]
        pub ref_id: Option<ReferenceId>,
        #[serde(rename = "reportUeReachable", default)]
        pub report_ue_reachable: bool,
        #[serde(
            rename = "snssaiFilter",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub snssai_filter: Vec<ExtSnssai>,
        #[serde(
            rename = "targetArea",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_area: Option<SchemasTargetArea>,
        #[serde(
            rename = "trafficDescriptorList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub traffic_descriptor_list: Vec<SchemasTrafficDescriptor>,
        #[serde(rename = "type")]
        pub type_: AmfEventType,
        #[serde(rename = "udmDetectInd", default)]
        pub udm_detect_ind: bool,
        #[serde(
            rename = "ueInAreaFilter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_in_area_filter: Option<UeInAreaFilter>,
    }

    impl From<&SchemasAmfEvent> for SchemasAmfEvent {
        fn from(value: &SchemasAmfEvent) -> Self {
            value.clone()
        }
    }

    ///Represents an area to be monitored by an AMF event
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents an area to be monitored by an AMF event",
    ///  "type": "object",
    ///  "properties": {
    ///    "ladnInfo": {
    ///      "$ref": "#/components/schemas/schemas-LadnInfo"
    ///    },
    ///    "nsiId": {
    ///      "$ref": "#/components/schemas/NsiId"
    ///    },
    ///    "presenceInfo": {
    ///      "$ref": "#/components/schemas/PresenceInfo"
    ///    },
    ///    "sNssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SchemasAmfEventArea {
        #[serde(rename = "ladnInfo", default, skip_serializing_if = "Option::is_none")]
        pub ladn_info: Option<SchemasLadnInfo>,
        #[serde(rename = "nsiId", default, skip_serializing_if = "Option::is_none")]
        pub nsi_id: Option<NsiId>,
        #[serde(
            rename = "presenceInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub presence_info: Option<PresenceInfo>,
        #[serde(rename = "sNssai", default, skip_serializing_if = "Option::is_none")]
        pub s_nssai: Option<Snssai>,
    }

    impl From<&SchemasAmfEventArea> for SchemasAmfEventArea {
        fn from(value: &SchemasAmfEventArea) -> Self {
            value.clone()
        }
    }

    ///Describes how the reports shall be generated by a subscribed event
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes how the reports shall be generated by a
    /// subscribed event",
    ///  "type": "object",
    ///  "required": [
    ///    "trigger"
    ///  ],
    ///  "properties": {
    ///    "expiry": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "maxReports": {
    ///      "type": "integer"
    ///    },
    ///    "notifFlag": {
    ///      "$ref": "#/components/schemas/NotificationFlag"
    ///    },
    ///    "partitioningCriteria": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PartitioningCriteria"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "repPeriod": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "sampRatio": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    },
    ///    "trigger": {
    ///      "$ref": "#/components/schemas/AmfEventTrigger"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SchemasAmfEventMode {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub expiry: Option<DateTime>,
        #[serde(
            rename = "maxReports",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_reports: Option<i64>,
        #[serde(rename = "notifFlag", default, skip_serializing_if = "Option::is_none")]
        pub notif_flag: Option<NotificationFlag>,
        #[serde(
            rename = "partitioningCriteria",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub partitioning_criteria: Vec<PartitioningCriteria>,
        #[serde(rename = "repPeriod", default, skip_serializing_if = "Option::is_none")]
        pub rep_period: Option<DurationSec>,
        #[serde(rename = "sampRatio", default, skip_serializing_if = "Option::is_none")]
        pub samp_ratio: Option<SamplingRatio>,
        pub trigger: AmfEventTrigger,
    }

    impl From<&SchemasAmfEventMode> for SchemasAmfEventMode {
        fn from(value: &SchemasAmfEventMode) -> Self {
            value.clone()
        }
    }

    ///Represents an individual event subscription resource on AMF
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents an individual event subscription resource on
    /// AMF",
    ///  "type": "object",
    ///  "required": [
    ///    "eventList",
    ///    "eventNotifyUri",
    ///    "nfId",
    ///    "notifyCorrelationId"
    ///  ],
    ///  "properties": {
    ///    "anyUE": {
    ///      "type": "boolean"
    ///    },
    ///    "eventList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/schemas-AmfEvent"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "eventNotifyUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "excludeGpsiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Gpsi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "excludeSupiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "gpsi": {
    ///      "$ref": "#/components/schemas/Gpsi"
    ///    },
    ///    "groupId": {
    ///      "$ref": "#/components/schemas/GroupId"
    ///    },
    ///    "includeGpsiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Gpsi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "includeSupiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "nfId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "notifyCorrelationId": {
    ///      "type": "string"
    ///    },
    ///    "options": {
    ///      "$ref": "#/components/schemas/schemas-AmfEventMode"
    ///    },
    ///    "pei": {
    ///      "$ref": "#/components/schemas/Pei"
    ///    },
    ///    "sourceNfType": {
    ///      "$ref": "#/components/schemas/NFType"
    ///    },
    ///    "subsChangeNotifyCorrelationId": {
    ///      "type": "string"
    ///    },
    ///    "subsChangeNotifyUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "supi": {
    ///      "$ref": "#/components/schemas/Supi"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SchemasAmfEventSubscription {
        #[serde(rename = "anyUE", default, skip_serializing_if = "Option::is_none")]
        pub any_ue: Option<bool>,
        #[serde(rename = "eventList")]
        pub event_list: Vec<SchemasAmfEvent>,
        #[serde(rename = "eventNotifyUri")]
        pub event_notify_uri: Uri,
        #[serde(
            rename = "excludeGpsiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub exclude_gpsi_list: Vec<Gpsi>,
        #[serde(
            rename = "excludeSupiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub exclude_supi_list: Vec<Supi>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub gpsi: Option<Gpsi>,
        #[serde(rename = "groupId", default, skip_serializing_if = "Option::is_none")]
        pub group_id: Option<GroupId>,
        #[serde(
            rename = "includeGpsiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub include_gpsi_list: Vec<Gpsi>,
        #[serde(
            rename = "includeSupiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub include_supi_list: Vec<Supi>,
        #[serde(rename = "nfId")]
        pub nf_id: NfInstanceId,
        #[serde(rename = "notifyCorrelationId")]
        pub notify_correlation_id: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub options: Option<SchemasAmfEventMode>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pei: Option<Pei>,
        #[serde(
            rename = "sourceNfType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub source_nf_type: Option<NfType>,
        #[serde(
            rename = "subsChangeNotifyCorrelationId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub subs_change_notify_correlation_id: Option<String>,
        #[serde(
            rename = "subsChangeNotifyUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub subs_change_notify_uri: Option<Uri>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub supi: Option<Supi>,
    }

    impl From<&SchemasAmfEventSubscription> for SchemasAmfEventSubscription {
        fn from(value: &SchemasAmfEventSubscription) -> Self {
            value.clone()
        }
    }

    ///string with format "date-time" as defined in OpenAPI.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "string with format \"date-time\" as defined in
    /// OpenAPI.",
    ///  "type": "string",
    ///  "format": "date-time"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SchemasDateTime(pub chrono::DateTime<chrono::offset::Utc>);
    impl ::std::ops::Deref for SchemasDateTime {
        type Target = chrono::DateTime<chrono::offset::Utc>;
        fn deref(&self) -> &chrono::DateTime<chrono::offset::Utc> {
            &self.0
        }
    }

    impl From<SchemasDateTime> for chrono::DateTime<chrono::offset::Utc> {
        fn from(value: SchemasDateTime) -> Self {
            value.0
        }
    }

    impl From<&SchemasDateTime> for SchemasDateTime {
        fn from(value: &SchemasDateTime) -> Self {
            value.clone()
        }
    }

    impl From<chrono::DateTime<chrono::offset::Utc>> for SchemasDateTime {
        fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for SchemasDateTime {
        type Err = <chrono::DateTime<chrono::offset::Utc> as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for SchemasDateTime {
        type Error = <chrono::DateTime<chrono::offset::Utc> as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SchemasDateTime {
        type Error = <chrono::DateTime<chrono::offset::Utc> as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SchemasDateTime {
        type Error = <chrono::DateTime<chrono::offset::Utc> as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for SchemasDateTime {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///integer between and including 1 and 7 denoting a weekday. 1 shall
    /// indicate Monday, and the subsequent weekdays shall be indicated with the
    /// next higher numbers. 7 shall indicate Sunday.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "integer between and including 1 and 7 denoting a
    /// weekday. 1 shall indicate Monday, and the subsequent weekdays shall be
    /// indicated with the next higher numbers. 7 shall indicate Sunday.",
    ///  "type": "integer",
    ///  "maximum": 7.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SchemasDayOfWeek(pub i64);
    impl ::std::ops::Deref for SchemasDayOfWeek {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<SchemasDayOfWeek> for i64 {
        fn from(value: SchemasDayOfWeek) -> Self {
            value.0
        }
    }

    impl From<&SchemasDayOfWeek> for SchemasDayOfWeek {
        fn from(value: &SchemasDayOfWeek) -> Self {
            value.clone()
        }
    }

    impl From<i64> for SchemasDayOfWeek {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for SchemasDayOfWeek {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for SchemasDayOfWeek {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SchemasDayOfWeek {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SchemasDayOfWeek {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for SchemasDayOfWeek {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Dispersion Area
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Dispersion Area",
    ///  "type": "object",
    ///  "properties": {
    ///    "ecgiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Ecgi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "n3gaInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "ncgiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Ncgi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "taiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Tai"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SchemasDispersionArea {
        #[serde(rename = "ecgiList", default, skip_serializing_if = "Vec::is_empty")]
        pub ecgi_list: Vec<Ecgi>,
        #[serde(rename = "n3gaInd", default)]
        pub n3ga_ind: bool,
        #[serde(rename = "ncgiList", default, skip_serializing_if = "Vec::is_empty")]
        pub ncgi_list: Vec<Ncgi>,
        #[serde(rename = "taiList", default, skip_serializing_if = "Vec::is_empty")]
        pub tai_list: Vec<Tai>,
    }

    impl From<&SchemasDispersionArea> for SchemasDispersionArea {
        fn from(value: &SchemasDispersionArea) -> Self {
            value.clone()
        }
    }

    ///LADN Information
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "LADN Information",
    ///  "type": "object",
    ///  "required": [
    ///    "ladn"
    ///  ],
    ///  "properties": {
    ///    "ladn": {
    ///      "type": "string"
    ///    },
    ///    "presence": {
    ///      "$ref": "#/components/schemas/PresenceState"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SchemasLadnInfo {
        pub ladn: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub presence: Option<PresenceState>,
    }

    impl From<&SchemasLadnInfo> for SchemasLadnInfo {
        fn from(value: &SchemasLadnInfo) -> Self {
            value.clone()
        }
    }

    ///Describes a network area information in which the NF service consumer
    /// requests the number of UEs.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes a network area information in which the NF
    /// service consumer requests the number of UEs.",
    ///  "type": "object",
    ///  "properties": {
    ///    "ecgis": {
    ///      "description": "Contains a list of E-UTRA cell identities.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Ecgi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "gRanNodeIds": {
    ///      "description": "Contains a list of NG RAN nodes.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GlobalRanNodeId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "ncgis": {
    ///      "description": "Contains a list of NR cell identities.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Ncgi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "tais": {
    ///      "description": "Contains a list of tracking area identities.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Tai"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SchemasNetworkAreaInfo {
        ///Contains a list of E-UTRA cell identities.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub ecgis: Vec<Ecgi>,
        ///Contains a list of NG RAN nodes.
        #[serde(rename = "gRanNodeIds", default, skip_serializing_if = "Vec::is_empty")]
        pub g_ran_node_ids: Vec<GlobalRanNodeId>,
        ///Contains a list of NR cell identities.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub ncgis: Vec<Ncgi>,
        ///Contains a list of tracking area identities.
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub tais: Vec<Tai>,
    }

    impl From<&SchemasNetworkAreaInfo> for SchemasNetworkAreaInfo {
        fn from(value: &SchemasNetworkAreaInfo) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - PERIODIC
    /// - ONE_TIME
    /// - ON_EVENT_DETECTION
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- PERIODIC\n- ONE_TIME\n-
    /// ON_EVENT_DETECTION\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "PERIODIC",
    ///    "ONE_TIME",
    ///    "ON_EVENT_DETECTION"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SchemasNotificationMethod {
        #[serde(rename = "PERIODIC")]
        Periodic,
        #[serde(rename = "ONE_TIME")]
        OneTime,
        #[serde(rename = "ON_EVENT_DETECTION")]
        OnEventDetection,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&SchemasNotificationMethod> for SchemasNotificationMethod {
        fn from(value: &SchemasNotificationMethod) -> Self {
            value.clone()
        }
    }

    impl ToString for SchemasNotificationMethod {
        fn to_string(&self) -> String {
            match *self {
                Self::Periodic => "PERIODIC".to_string(),
                Self::OneTime => "ONE_TIME".to_string(),
                Self::OnEventDetection => "ON_EVENT_DETECTION".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for SchemasNotificationMethod {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "PERIODIC" => Ok(Self::Periodic),
                "ONE_TIME" => Ok(Self::OneTime),
                "ON_EVENT_DETECTION" => Ok(Self::OnEventDetection),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for SchemasNotificationMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SchemasNotificationMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SchemasNotificationMethod {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents an offered scheduled communication time.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents an offered scheduled communication time.",
    ///  "type": "object",
    ///  "properties": {
    ///    "daysOfWeek": {
    ///      "description": "Identifies the day(s) of the week. If absent, it
    /// indicates every day of the week.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/schemas-DayOfWeek"
    ///      },
    ///      "maxItems": 6,
    ///      "minItems": 1
    ///    },
    ///    "timeOfDayEnd": {
    ///      "$ref": "#/components/schemas/schemas-TimeOfDay"
    ///    },
    ///    "timeOfDayStart": {
    ///      "$ref": "#/components/schemas/schemas-TimeOfDay"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SchemasScheduledCommunicationTime {
        ///Identifies the day(s) of the week. If absent, it indicates every day
        /// of the week.
        #[serde(rename = "daysOfWeek", default, skip_serializing_if = "Vec::is_empty")]
        pub days_of_week: Vec<SchemasDayOfWeek>,
        #[serde(
            rename = "timeOfDayEnd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub time_of_day_end: Option<SchemasTimeOfDay>,
        #[serde(
            rename = "timeOfDayStart",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub time_of_day_start: Option<SchemasTimeOfDay>,
    }

    impl From<&SchemasScheduledCommunicationTime> for SchemasScheduledCommunicationTime {
        fn from(value: &SchemasScheduledCommunicationTime) -> Self {
            value.clone()
        }
    }

    ///TA list or TAI range list or any TA
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "TA list or TAI range list or any TA",
    ///  "type": "object",
    ///  "properties": {
    ///    "anyTa": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "taList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Tai"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "taiRangeList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TaiRange"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SchemasTargetArea {
        #[serde(rename = "anyTa", default)]
        pub any_ta: bool,
        #[serde(rename = "taList", default, skip_serializing_if = "Vec::is_empty")]
        pub ta_list: Vec<Tai>,
        #[serde(
            rename = "taiRangeList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub tai_range_list: Vec<TaiRange>,
    }

    impl From<&SchemasTargetArea> for SchemasTargetArea {
        fn from(value: &SchemasTargetArea) -> Self {
            value.clone()
        }
    }

    ///String with format partial-time or full-time as defined in clause 5.6 of
    /// IETF RFC 3339. Examples, 20:15:00, 20:15:00-08:00 (for 8 hours behind
    /// UTC).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String with format partial-time or full-time as defined
    /// in clause 5.6 of IETF RFC 3339. Examples, 20:15:00, 20:15:00-08:00 (for
    /// 8 hours behind UTC).",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct SchemasTimeOfDay(pub String);
    impl ::std::ops::Deref for SchemasTimeOfDay {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<SchemasTimeOfDay> for String {
        fn from(value: SchemasTimeOfDay) -> Self {
            value.0
        }
    }

    impl From<&SchemasTimeOfDay> for SchemasTimeOfDay {
        fn from(value: &SchemasTimeOfDay) -> Self {
            value.clone()
        }
    }

    impl From<String> for SchemasTimeOfDay {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for SchemasTimeOfDay {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for SchemasTimeOfDay {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Represents the Traffic Descriptor
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the Traffic Descriptor",
    ///  "type": "object",
    ///  "properties": {
    ///    "dddTrafficDescriptorList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DddTrafficDescriptor"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "dnn": {
    ///      "$ref": "#/components/schemas/Dnn"
    ///    },
    ///    "sNssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SchemasTrafficDescriptor {
        #[serde(
            rename = "dddTrafficDescriptorList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub ddd_traffic_descriptor_list: Vec<DddTrafficDescriptor>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dnn: Option<Dnn>,
        #[serde(rename = "sNssai", default, skip_serializing_if = "Option::is_none")]
        pub s_nssai: Option<Snssai>,
    }

    impl From<&SchemasTrafficDescriptor> for SchemasTrafficDescriptor {
        fn from(value: &SchemasTrafficDescriptor) -> Self {
            value.clone()
        }
    }

    ///A range of SDs (Slice Differentiators)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A range of SDs (Slice Differentiators)",
    ///  "type": "object",
    ///  "properties": {
    ///    "end": {
    ///      "description": "Last value identifying the end of an SD range. This
    /// string shall be formatted as specified for the sd attribute of the
    /// Snssai data type in clause 5.4.4.2.\n",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]{6}$"
    ///    },
    ///    "start": {
    ///      "description": "First value identifying the start of an SD range.
    /// This string shall be formatted as specified for the sd attribute of the
    /// Snssai data type in clause 5.4.4.2.\n",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]{6}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SdRange {
        ///Last value identifying the end of an SD range. This string shall be
        /// formatted as specified for the sd attribute of the Snssai data type
        /// in clause 5.4.4.2.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub end: Option<SdRangeEnd>,
        ///First value identifying the start of an SD range. This string shall
        /// be formatted as specified for the sd attribute of the Snssai data
        /// type in clause 5.4.4.2.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start: Option<SdRangeStart>,
    }

    impl From<&SdRange> for SdRange {
        fn from(value: &SdRange) -> Self {
            value.clone()
        }
    }

    ///Last value identifying the end of an SD range. This string shall be
    /// formatted as specified for the sd attribute of the Snssai data type in
    /// clause 5.4.4.2.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Last value identifying the end of an SD range. This
    /// string shall be formatted as specified for the sd attribute of the
    /// Snssai data type in clause 5.4.4.2.\n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{6}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct SdRangeEnd(String);
    impl ::std::ops::Deref for SdRangeEnd {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<SdRangeEnd> for String {
        fn from(value: SdRangeEnd) -> Self {
            value.0
        }
    }

    impl From<&SdRangeEnd> for SdRangeEnd {
        fn from(value: &SdRangeEnd) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for SdRangeEnd {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{6}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{6}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for SdRangeEnd {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for SdRangeEnd {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for SdRangeEnd {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for SdRangeEnd {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///First value identifying the start of an SD range. This string shall be
    /// formatted as specified for the sd attribute of the Snssai data type in
    /// clause 5.4.4.2.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "First value identifying the start of an SD range. This
    /// string shall be formatted as specified for the sd attribute of the
    /// Snssai data type in clause 5.4.4.2.\n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{6}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct SdRangeStart(String);
    impl ::std::ops::Deref for SdRangeStart {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<SdRangeStart> for String {
        fn from(value: SdRangeStart) -> Self {
            value.0
        }
    }

    impl From<&SdRangeStart> for SdRangeStart {
        fn from(value: &SdRangeStart) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for SdRangeStart {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{6}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{6}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for SdRangeStart {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for SdRangeStart {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for SdRangeStart {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for SdRangeStart {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Represents SEAF data derived from data received from AUSF
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents SEAF data derived from data received from
    /// AUSF",
    ///  "type": "object",
    ///  "required": [
    ///    "keyAmf",
    ///    "ngKsi"
    ///  ],
    ///  "properties": {
    ///    "keyAmf": {
    ///      "$ref": "#/components/schemas/KeyAmf"
    ///    },
    ///    "keyAmfChangeInd": {
    ///      "type": "boolean"
    ///    },
    ///    "keyAmfHDerivationInd": {
    ///      "type": "boolean"
    ///    },
    ///    "ncc": {
    ///      "type": "integer",
    ///      "maximum": 7.0,
    ///      "minimum": 0.0
    ///    },
    ///    "ngKsi": {
    ///      "$ref": "#/components/schemas/NgKsi"
    ///    },
    ///    "nh": {
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]+$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SeafData {
        #[serde(rename = "keyAmf")]
        pub key_amf: KeyAmf,
        #[serde(
            rename = "keyAmfChangeInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub key_amf_change_ind: Option<bool>,
        #[serde(
            rename = "keyAmfHDerivationInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub key_amf_h_derivation_ind: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ncc: Option<i64>,
        #[serde(rename = "ngKsi")]
        pub ng_ksi: NgKsi,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub nh: Option<SeafDataNh>,
    }

    impl From<&SeafData> for SeafData {
        fn from(value: &SeafData) -> Self {
            value.clone()
        }
    }

    ///SeafDataNh
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]+$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct SeafDataNh(String);
    impl ::std::ops::Deref for SeafDataNh {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<SeafDataNh> for String {
        fn from(value: SeafDataNh) -> Self {
            value.0
        }
    }

    impl From<&SeafDataNh> for SeafDataNh {
        fn from(value: &SeafDataNh) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for SeafDataNh {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]+$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for SeafDataNh {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for SeafDataNh {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for SeafDataNh {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for SeafDataNh {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The enumeration SensorMeasurement defines sensor measurement type for
    /// MDT in the trace. See 3GPP TS 32.422 for further description of the
    /// values. It shall comply with the provisions defined in table 5.6.3.7-1.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration SensorMeasurement defines sensor
    /// measurement type for MDT in the trace. See 3GPP TS 32.422 for further
    /// description of the values. It shall comply with the provisions defined
    /// in table 5.6.3.7-1.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "BAROMETRIC_PRESSURE",
    ///    "UE_SPEED",
    ///    "UE_ORIENTATION"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SensorMeasurement {
        #[serde(rename = "BAROMETRIC_PRESSURE")]
        BarometricPressure,
        #[serde(rename = "UE_SPEED")]
        UeSpeed,
        #[serde(rename = "UE_ORIENTATION")]
        UeOrientation,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&SensorMeasurement> for SensorMeasurement {
        fn from(value: &SensorMeasurement) -> Self {
            value.clone()
        }
    }

    impl ToString for SensorMeasurement {
        fn to_string(&self) -> String {
            match *self {
                Self::BarometricPressure => "BAROMETRIC_PRESSURE".to_string(),
                Self::UeSpeed => "UE_SPEED".to_string(),
                Self::UeOrientation => "UE_ORIENTATION".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for SensorMeasurement {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "BAROMETRIC_PRESSURE" => Ok(Self::BarometricPressure),
                "UE_SPEED" => Ok(Self::UeSpeed),
                "UE_ORIENTATION" => Ok(Self::UeOrientation),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for SensorMeasurement {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SensorMeasurement {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SensorMeasurement {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Contains a Service Area Identifier as defined in 3GPP TS 23.003, clause
    /// 12.5.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains a Service Area Identifier as defined in 3GPP
    /// TS 23.003, clause 12.5.",
    ///  "type": "object",
    ///  "required": [
    ///    "lac",
    ///    "plmnId",
    ///    "sac"
    ///  ],
    ///  "properties": {
    ///    "lac": {
    ///      "description": "Location Area Code.",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]{4}$"
    ///    },
    ///    "plmnId": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    },
    ///    "sac": {
    ///      "description": "Service Area Code.",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]{4}$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ServiceAreaId {
        ///Location Area Code.
        pub lac: ServiceAreaIdLac,
        #[serde(rename = "plmnId")]
        pub plmn_id: PlmnId,
        ///Service Area Code.
        pub sac: ServiceAreaIdSac,
    }

    impl From<&ServiceAreaId> for ServiceAreaId {
        fn from(value: &ServiceAreaId) -> Self {
            value.clone()
        }
    }

    ///Location Area Code.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Location Area Code.",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{4}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ServiceAreaIdLac(String);
    impl ::std::ops::Deref for ServiceAreaIdLac {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ServiceAreaIdLac> for String {
        fn from(value: ServiceAreaIdLac) -> Self {
            value.0
        }
    }

    impl From<&ServiceAreaIdLac> for ServiceAreaIdLac {
        fn from(value: &ServiceAreaIdLac) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ServiceAreaIdLac {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{4}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{4}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ServiceAreaIdLac {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ServiceAreaIdLac {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ServiceAreaIdLac {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ServiceAreaIdLac {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Service Area Code.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Service Area Code.",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{4}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct ServiceAreaIdSac(String);
    impl ::std::ops::Deref for ServiceAreaIdSac {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<ServiceAreaIdSac> for String {
        fn from(value: ServiceAreaIdSac) -> Self {
            value.0
        }
    }

    impl From<&ServiceAreaIdSac> for ServiceAreaIdSac {
        fn from(value: &ServiceAreaIdSac) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for ServiceAreaIdSac {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{4}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{4}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for ServiceAreaIdSac {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ServiceAreaIdSac {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ServiceAreaIdSac {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for ServiceAreaIdSac {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Provides information about allowed or not allowed areas.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Provides information about allowed or not allowed
    /// areas.",
    ///  "type": "object",
    ///  "allOf": [
    ///    {
    ///      "oneOf": [
    ///        {
    ///          "not": {
    ///            "required": [
    ///              "restrictionType"
    ///            ]
    ///          }
    ///        },
    ///        {
    ///          "required": [
    ///            "areas"
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "anyOf": [
    ///        {
    ///          "not": {
    ///            "required": [
    ///              "restrictionType"
    ///            ],
    ///            "properties": {
    ///              "restrictionType": {
    ///                "type": "string",
    ///                "enum": [
    ///                  "NOT_ALLOWED_AREAS"
    ///                ]
    ///              }
    ///            }
    ///          }
    ///        },
    ///        {
    ///          "not": {
    ///            "required": [
    ///              "maxNumOfTAs"
    ///            ]
    ///          }
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "anyOf": [
    ///        {
    ///          "not": {
    ///            "required": [
    ///              "restrictionType"
    ///            ],
    ///            "properties": {
    ///              "restrictionType": {
    ///                "type": "string",
    ///                "enum": [
    ///                  "ALLOWED_AREAS"
    ///                ]
    ///              }
    ///            }
    ///          }
    ///        },
    ///        {
    ///          "not": {
    ///            "required": [
    ///              "maxNumOfTAsForNotAllowedAreas"
    ///            ]
    ///          }
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "areas": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Area"
    ///      }
    ///    },
    ///    "maxNumOfTAs": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "maxNumOfTAsForNotAllowedAreas": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "restrictionType": {
    ///      "$ref": "#/components/schemas/RestrictionType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum ServiceAreaRestriction {
        Variant0(ServiceAreaRestrictionVariant0),
        Variant1(ServiceAreaRestrictionVariant1),
    }

    impl From<&ServiceAreaRestriction> for ServiceAreaRestriction {
        fn from(value: &ServiceAreaRestriction) -> Self {
            value.clone()
        }
    }

    impl From<ServiceAreaRestrictionVariant0> for ServiceAreaRestriction {
        fn from(value: ServiceAreaRestrictionVariant0) -> Self {
            Self::Variant0(value)
        }
    }

    impl From<ServiceAreaRestrictionVariant1> for ServiceAreaRestriction {
        fn from(value: ServiceAreaRestrictionVariant1) -> Self {
            Self::Variant1(value)
        }
    }

    ///ServiceAreaRestrictionVariant0
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "anyOf": [
    ///        {
    ///          "allOf": [
    ///            {},
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "oneOf": [
    ///                    {
    ///                      "allOf": [
    ///                        {},
    ///                        {
    ///                          "allOf": [
    ///                            {
    ///                              "type": "object",
    ///                              "properties": {
    ///                                "areas": {
    ///                                  "type": "array",
    ///                                  "items": {
    ///                                    "$ref": "#/components/schemas/Area"
    ///                                  }
    ///                                },
    ///                                "maxNumOfTAs": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "maxNumOfTAsForNotAllowedAreas": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "restrictionType": {
    ///                                  "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                }
    ///                              }
    ///                            },
    ///                            {
    ///                              "not": {
    ///                                "required": [
    ///                                  "restrictionType"
    ///                                ]
    ///                              }
    ///                            },
    ///                            {
    ///                              "not": {
    ///                                "required": [
    ///                                  "areas"
    ///                                ]
    ///                              }
    ///                            }
    ///                          ]
    ///                        },
    ///                        {
    ///                          "not": {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "required": [
    ///                                  "areas"
    ///                                ]
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "restrictionType"
    ///                                    ]
    ///                                  }
    ///                                }
    ///                              }
    ///                            ]
    ///                          }
    ///                        }
    ///                      ]
    ///                    },
    ///                    {
    ///                      "allOf": [
    ///                        {},
    ///                        {
    ///                          "allOf": [
    ///                            {
    ///                              "type": "object",
    ///                              "properties": {
    ///                                "areas": {
    ///                                  "type": "array",
    ///                                  "items": {
    ///                                    "$ref": "#/components/schemas/Area"
    ///                                  }
    ///                                },
    ///                                "maxNumOfTAs": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "maxNumOfTAsForNotAllowedAreas": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "restrictionType": {
    ///                                  "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                }
    ///                              }
    ///                            },
    ///                            {
    ///                              "required": [
    ///                                "areas"
    ///                              ]
    ///                            },
    ///                            {
    ///                              "not": {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "restrictionType"
    ///                                  ]
    ///                                }
    ///                              }
    ///                            }
    ///                          ]
    ///                        },
    ///                        {
    ///                          "not": {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "restrictionType"
    ///                                  ]
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "areas"
    ///                                  ]
    ///                                }
    ///                              }
    ///                            ]
    ///                          }
    ///                        }
    ///                      ]
    ///                    }
    ///                  ]
    ///                },
    ///                {
    ///                  "not": {
    ///                    "required": [
    ///                      "restrictionType"
    ///                    ],
    ///                    "properties": {
    ///                      "restrictionType": {
    ///                        "type": "string",
    ///                        "enum": [
    ///                          "NOT_ALLOWED_AREAS"
    ///                        ]
    ///                      }
    ///                    }
    ///                  }
    ///                },
    ///                {
    ///                  "not": {
    ///                    "not": {
    ///                      "required": [
    ///                        "maxNumOfTAs"
    ///                      ]
    ///                    }
    ///                  }
    ///                }
    ///              ]
    ///            },
    ///            {
    ///              "not": {
    ///                "allOf": [
    ///                  {
    ///                    "oneOf": [
    ///                      {
    ///                        "allOf": [
    ///                          {},
    ///                          {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "restrictionType"
    ///                                  ]
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "areas"
    ///                                  ]
    ///                                }
    ///                              }
    ///                            ]
    ///                          },
    ///                          {
    ///                            "not": {
    ///                              "allOf": [
    ///                                {
    ///                                  "type": "object",
    ///                                  "properties": {
    ///                                    "areas": {
    ///                                      "type": "array",
    ///                                      "items": {
    ///                                        "$ref":
    /// "#/components/schemas/Area"
    ///                                      }
    ///                                    },
    ///                                    "maxNumOfTAs": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "maxNumOfTAsForNotAllowedAreas": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "restrictionType": {
    ///                                      "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                    }
    ///                                  }
    ///                                },
    ///                                {
    ///                                  "required": [
    ///                                    "areas"
    ///                                  ]
    ///                                },
    ///                                {
    ///                                  "not": {
    ///                                    "not": {
    ///                                      "required": [
    ///                                        "restrictionType"
    ///                                      ]
    ///                                    }
    ///                                  }
    ///                                }
    ///                              ]
    ///                            }
    ///                          }
    ///                        ]
    ///                      },
    ///                      {
    ///                        "allOf": [
    ///                          {},
    ///                          {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "required": [
    ///                                  "areas"
    ///                                ]
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "restrictionType"
    ///                                    ]
    ///                                  }
    ///                                }
    ///                              }
    ///                            ]
    ///                          },
    ///                          {
    ///                            "not": {
    ///                              "allOf": [
    ///                                {
    ///                                  "type": "object",
    ///                                  "properties": {
    ///                                    "areas": {
    ///                                      "type": "array",
    ///                                      "items": {
    ///                                        "$ref":
    /// "#/components/schemas/Area"
    ///                                      }
    ///                                    },
    ///                                    "maxNumOfTAs": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "maxNumOfTAsForNotAllowedAreas": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "restrictionType": {
    ///                                      "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                    }
    ///                                  }
    ///                                },
    ///                                {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "restrictionType"
    ///                                    ]
    ///                                  }
    ///                                },
    ///                                {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "areas"
    ///                                    ]
    ///                                  }
    ///                                }
    ///                              ]
    ///                            }
    ///                          }
    ///                        ]
    ///                      }
    ///                    ]
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "required": [
    ///                        "maxNumOfTAs"
    ///                      ]
    ///                    }
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "not": {
    ///                        "required": [
    ///                          "restrictionType"
    ///                        ],
    ///                        "properties": {
    ///                          "restrictionType": {
    ///                            "type": "string",
    ///                            "enum": [
    ///                              "NOT_ALLOWED_AREAS"
    ///                            ]
    ///                          }
    ///                        }
    ///                      }
    ///                    }
    ///                  }
    ///                ]
    ///              }
    ///            }
    ///          ]
    ///        },
    ///        {
    ///          "allOf": [
    ///            {},
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "oneOf": [
    ///                    {
    ///                      "allOf": [
    ///                        {},
    ///                        {
    ///                          "allOf": [
    ///                            {
    ///                              "type": "object",
    ///                              "properties": {
    ///                                "areas": {
    ///                                  "type": "array",
    ///                                  "items": {
    ///                                    "$ref": "#/components/schemas/Area"
    ///                                  }
    ///                                },
    ///                                "maxNumOfTAs": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "maxNumOfTAsForNotAllowedAreas": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "restrictionType": {
    ///                                  "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                }
    ///                              }
    ///                            },
    ///                            {
    ///                              "not": {
    ///                                "required": [
    ///                                  "restrictionType"
    ///                                ]
    ///                              }
    ///                            },
    ///                            {
    ///                              "not": {
    ///                                "required": [
    ///                                  "areas"
    ///                                ]
    ///                              }
    ///                            }
    ///                          ]
    ///                        },
    ///                        {
    ///                          "not": {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "required": [
    ///                                  "areas"
    ///                                ]
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "restrictionType"
    ///                                    ]
    ///                                  }
    ///                                }
    ///                              }
    ///                            ]
    ///                          }
    ///                        }
    ///                      ]
    ///                    },
    ///                    {
    ///                      "allOf": [
    ///                        {},
    ///                        {
    ///                          "allOf": [
    ///                            {
    ///                              "type": "object",
    ///                              "properties": {
    ///                                "areas": {
    ///                                  "type": "array",
    ///                                  "items": {
    ///                                    "$ref": "#/components/schemas/Area"
    ///                                  }
    ///                                },
    ///                                "maxNumOfTAs": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "maxNumOfTAsForNotAllowedAreas": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "restrictionType": {
    ///                                  "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                }
    ///                              }
    ///                            },
    ///                            {
    ///                              "required": [
    ///                                "areas"
    ///                              ]
    ///                            },
    ///                            {
    ///                              "not": {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "restrictionType"
    ///                                  ]
    ///                                }
    ///                              }
    ///                            }
    ///                          ]
    ///                        },
    ///                        {
    ///                          "not": {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "restrictionType"
    ///                                  ]
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "areas"
    ///                                  ]
    ///                                }
    ///                              }
    ///                            ]
    ///                          }
    ///                        }
    ///                      ]
    ///                    }
    ///                  ]
    ///                },
    ///                {
    ///                  "not": {
    ///                    "required": [
    ///                      "maxNumOfTAs"
    ///                    ]
    ///                  }
    ///                },
    ///                {
    ///                  "not": {
    ///                    "not": {
    ///                      "required": [
    ///                        "restrictionType"
    ///                      ],
    ///                      "properties": {
    ///                        "restrictionType": {
    ///                          "type": "string",
    ///                          "enum": [
    ///                            "NOT_ALLOWED_AREAS"
    ///                          ]
    ///                        }
    ///                      }
    ///                    }
    ///                  }
    ///                }
    ///              ]
    ///            },
    ///            {
    ///              "not": {
    ///                "allOf": [
    ///                  {
    ///                    "oneOf": [
    ///                      {
    ///                        "allOf": [
    ///                          {},
    ///                          {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "restrictionType"
    ///                                  ]
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "areas"
    ///                                  ]
    ///                                }
    ///                              }
    ///                            ]
    ///                          },
    ///                          {
    ///                            "not": {
    ///                              "allOf": [
    ///                                {
    ///                                  "type": "object",
    ///                                  "properties": {
    ///                                    "areas": {
    ///                                      "type": "array",
    ///                                      "items": {
    ///                                        "$ref":
    /// "#/components/schemas/Area"
    ///                                      }
    ///                                    },
    ///                                    "maxNumOfTAs": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "maxNumOfTAsForNotAllowedAreas": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "restrictionType": {
    ///                                      "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                    }
    ///                                  }
    ///                                },
    ///                                {
    ///                                  "required": [
    ///                                    "areas"
    ///                                  ]
    ///                                },
    ///                                {
    ///                                  "not": {
    ///                                    "not": {
    ///                                      "required": [
    ///                                        "restrictionType"
    ///                                      ]
    ///                                    }
    ///                                  }
    ///                                }
    ///                              ]
    ///                            }
    ///                          }
    ///                        ]
    ///                      },
    ///                      {
    ///                        "allOf": [
    ///                          {},
    ///                          {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "required": [
    ///                                  "areas"
    ///                                ]
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "restrictionType"
    ///                                    ]
    ///                                  }
    ///                                }
    ///                              }
    ///                            ]
    ///                          },
    ///                          {
    ///                            "not": {
    ///                              "allOf": [
    ///                                {
    ///                                  "type": "object",
    ///                                  "properties": {
    ///                                    "areas": {
    ///                                      "type": "array",
    ///                                      "items": {
    ///                                        "$ref":
    /// "#/components/schemas/Area"
    ///                                      }
    ///                                    },
    ///                                    "maxNumOfTAs": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "maxNumOfTAsForNotAllowedAreas": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "restrictionType": {
    ///                                      "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                    }
    ///                                  }
    ///                                },
    ///                                {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "restrictionType"
    ///                                    ]
    ///                                  }
    ///                                },
    ///                                {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "areas"
    ///                                    ]
    ///                                  }
    ///                                }
    ///                              ]
    ///                            }
    ///                          }
    ///                        ]
    ///                      }
    ///                    ]
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "required": [
    ///                        "restrictionType"
    ///                      ],
    ///                      "properties": {
    ///                        "restrictionType": {
    ///                          "type": "string",
    ///                          "enum": [
    ///                            "NOT_ALLOWED_AREAS"
    ///                          ]
    ///                        }
    ///                      }
    ///                    }
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "not": {
    ///                        "required": [
    ///                          "maxNumOfTAs"
    ///                        ]
    ///                      }
    ///                    }
    ///                  }
    ///                ]
    ///              }
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "not": {
    ///        "required": [
    ///          "restrictionType"
    ///        ],
    ///        "properties": {
    ///          "restrictionType": {
    ///            "type": "string",
    ///            "enum": [
    ///              "ALLOWED_AREAS"
    ///            ]
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "not": {
    ///        "not": {
    ///          "required": [
    ///            "maxNumOfTAsForNotAllowedAreas"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(deny_unknown_fields)]
    pub enum ServiceAreaRestrictionVariant0 {}
    impl From<&ServiceAreaRestrictionVariant0> for ServiceAreaRestrictionVariant0 {
        fn from(value: &ServiceAreaRestrictionVariant0) -> Self {
            value.clone()
        }
    }

    ///ServiceAreaRestrictionVariant1
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "allOf": [
    ///    {
    ///      "anyOf": [
    ///        {
    ///          "allOf": [
    ///            {},
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "oneOf": [
    ///                    {
    ///                      "allOf": [
    ///                        {},
    ///                        {
    ///                          "allOf": [
    ///                            {
    ///                              "type": "object",
    ///                              "properties": {
    ///                                "areas": {
    ///                                  "type": "array",
    ///                                  "items": {
    ///                                    "$ref": "#/components/schemas/Area"
    ///                                  }
    ///                                },
    ///                                "maxNumOfTAs": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "maxNumOfTAsForNotAllowedAreas": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "restrictionType": {
    ///                                  "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                }
    ///                              }
    ///                            },
    ///                            {
    ///                              "not": {
    ///                                "required": [
    ///                                  "restrictionType"
    ///                                ]
    ///                              }
    ///                            },
    ///                            {
    ///                              "not": {
    ///                                "required": [
    ///                                  "areas"
    ///                                ]
    ///                              }
    ///                            }
    ///                          ]
    ///                        },
    ///                        {
    ///                          "not": {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "required": [
    ///                                  "areas"
    ///                                ]
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "restrictionType"
    ///                                    ]
    ///                                  }
    ///                                }
    ///                              }
    ///                            ]
    ///                          }
    ///                        }
    ///                      ]
    ///                    },
    ///                    {
    ///                      "allOf": [
    ///                        {},
    ///                        {
    ///                          "allOf": [
    ///                            {
    ///                              "type": "object",
    ///                              "properties": {
    ///                                "areas": {
    ///                                  "type": "array",
    ///                                  "items": {
    ///                                    "$ref": "#/components/schemas/Area"
    ///                                  }
    ///                                },
    ///                                "maxNumOfTAs": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "maxNumOfTAsForNotAllowedAreas": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "restrictionType": {
    ///                                  "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                }
    ///                              }
    ///                            },
    ///                            {
    ///                              "required": [
    ///                                "areas"
    ///                              ]
    ///                            },
    ///                            {
    ///                              "not": {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "restrictionType"
    ///                                  ]
    ///                                }
    ///                              }
    ///                            }
    ///                          ]
    ///                        },
    ///                        {
    ///                          "not": {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "restrictionType"
    ///                                  ]
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "areas"
    ///                                  ]
    ///                                }
    ///                              }
    ///                            ]
    ///                          }
    ///                        }
    ///                      ]
    ///                    }
    ///                  ]
    ///                },
    ///                {
    ///                  "not": {
    ///                    "required": [
    ///                      "restrictionType"
    ///                    ],
    ///                    "properties": {
    ///                      "restrictionType": {
    ///                        "type": "string",
    ///                        "enum": [
    ///                          "NOT_ALLOWED_AREAS"
    ///                        ]
    ///                      }
    ///                    }
    ///                  }
    ///                },
    ///                {
    ///                  "not": {
    ///                    "not": {
    ///                      "required": [
    ///                        "maxNumOfTAs"
    ///                      ]
    ///                    }
    ///                  }
    ///                }
    ///              ]
    ///            },
    ///            {
    ///              "not": {
    ///                "allOf": [
    ///                  {
    ///                    "oneOf": [
    ///                      {
    ///                        "allOf": [
    ///                          {},
    ///                          {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "restrictionType"
    ///                                  ]
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "areas"
    ///                                  ]
    ///                                }
    ///                              }
    ///                            ]
    ///                          },
    ///                          {
    ///                            "not": {
    ///                              "allOf": [
    ///                                {
    ///                                  "type": "object",
    ///                                  "properties": {
    ///                                    "areas": {
    ///                                      "type": "array",
    ///                                      "items": {
    ///                                        "$ref":
    /// "#/components/schemas/Area"
    ///                                      }
    ///                                    },
    ///                                    "maxNumOfTAs": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "maxNumOfTAsForNotAllowedAreas": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "restrictionType": {
    ///                                      "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                    }
    ///                                  }
    ///                                },
    ///                                {
    ///                                  "required": [
    ///                                    "areas"
    ///                                  ]
    ///                                },
    ///                                {
    ///                                  "not": {
    ///                                    "not": {
    ///                                      "required": [
    ///                                        "restrictionType"
    ///                                      ]
    ///                                    }
    ///                                  }
    ///                                }
    ///                              ]
    ///                            }
    ///                          }
    ///                        ]
    ///                      },
    ///                      {
    ///                        "allOf": [
    ///                          {},
    ///                          {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "required": [
    ///                                  "areas"
    ///                                ]
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "restrictionType"
    ///                                    ]
    ///                                  }
    ///                                }
    ///                              }
    ///                            ]
    ///                          },
    ///                          {
    ///                            "not": {
    ///                              "allOf": [
    ///                                {
    ///                                  "type": "object",
    ///                                  "properties": {
    ///                                    "areas": {
    ///                                      "type": "array",
    ///                                      "items": {
    ///                                        "$ref":
    /// "#/components/schemas/Area"
    ///                                      }
    ///                                    },
    ///                                    "maxNumOfTAs": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "maxNumOfTAsForNotAllowedAreas": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "restrictionType": {
    ///                                      "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                    }
    ///                                  }
    ///                                },
    ///                                {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "restrictionType"
    ///                                    ]
    ///                                  }
    ///                                },
    ///                                {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "areas"
    ///                                    ]
    ///                                  }
    ///                                }
    ///                              ]
    ///                            }
    ///                          }
    ///                        ]
    ///                      }
    ///                    ]
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "required": [
    ///                        "maxNumOfTAs"
    ///                      ]
    ///                    }
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "not": {
    ///                        "required": [
    ///                          "restrictionType"
    ///                        ],
    ///                        "properties": {
    ///                          "restrictionType": {
    ///                            "type": "string",
    ///                            "enum": [
    ///                              "NOT_ALLOWED_AREAS"
    ///                            ]
    ///                          }
    ///                        }
    ///                      }
    ///                    }
    ///                  }
    ///                ]
    ///              }
    ///            }
    ///          ]
    ///        },
    ///        {
    ///          "allOf": [
    ///            {},
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "oneOf": [
    ///                    {
    ///                      "allOf": [
    ///                        {},
    ///                        {
    ///                          "allOf": [
    ///                            {
    ///                              "type": "object",
    ///                              "properties": {
    ///                                "areas": {
    ///                                  "type": "array",
    ///                                  "items": {
    ///                                    "$ref": "#/components/schemas/Area"
    ///                                  }
    ///                                },
    ///                                "maxNumOfTAs": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "maxNumOfTAsForNotAllowedAreas": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "restrictionType": {
    ///                                  "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                }
    ///                              }
    ///                            },
    ///                            {
    ///                              "not": {
    ///                                "required": [
    ///                                  "restrictionType"
    ///                                ]
    ///                              }
    ///                            },
    ///                            {
    ///                              "not": {
    ///                                "required": [
    ///                                  "areas"
    ///                                ]
    ///                              }
    ///                            }
    ///                          ]
    ///                        },
    ///                        {
    ///                          "not": {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "required": [
    ///                                  "areas"
    ///                                ]
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "restrictionType"
    ///                                    ]
    ///                                  }
    ///                                }
    ///                              }
    ///                            ]
    ///                          }
    ///                        }
    ///                      ]
    ///                    },
    ///                    {
    ///                      "allOf": [
    ///                        {},
    ///                        {
    ///                          "allOf": [
    ///                            {
    ///                              "type": "object",
    ///                              "properties": {
    ///                                "areas": {
    ///                                  "type": "array",
    ///                                  "items": {
    ///                                    "$ref": "#/components/schemas/Area"
    ///                                  }
    ///                                },
    ///                                "maxNumOfTAs": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "maxNumOfTAsForNotAllowedAreas": {
    ///                                  "$ref": "#/components/schemas/Uinteger"
    ///                                },
    ///                                "restrictionType": {
    ///                                  "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                }
    ///                              }
    ///                            },
    ///                            {
    ///                              "required": [
    ///                                "areas"
    ///                              ]
    ///                            },
    ///                            {
    ///                              "not": {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "restrictionType"
    ///                                  ]
    ///                                }
    ///                              }
    ///                            }
    ///                          ]
    ///                        },
    ///                        {
    ///                          "not": {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "restrictionType"
    ///                                  ]
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "areas"
    ///                                  ]
    ///                                }
    ///                              }
    ///                            ]
    ///                          }
    ///                        }
    ///                      ]
    ///                    }
    ///                  ]
    ///                },
    ///                {
    ///                  "not": {
    ///                    "required": [
    ///                      "maxNumOfTAs"
    ///                    ]
    ///                  }
    ///                },
    ///                {
    ///                  "not": {
    ///                    "not": {
    ///                      "required": [
    ///                        "restrictionType"
    ///                      ],
    ///                      "properties": {
    ///                        "restrictionType": {
    ///                          "type": "string",
    ///                          "enum": [
    ///                            "NOT_ALLOWED_AREAS"
    ///                          ]
    ///                        }
    ///                      }
    ///                    }
    ///                  }
    ///                }
    ///              ]
    ///            },
    ///            {
    ///              "not": {
    ///                "allOf": [
    ///                  {
    ///                    "oneOf": [
    ///                      {
    ///                        "allOf": [
    ///                          {},
    ///                          {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "restrictionType"
    ///                                  ]
    ///                                }
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "required": [
    ///                                    "areas"
    ///                                  ]
    ///                                }
    ///                              }
    ///                            ]
    ///                          },
    ///                          {
    ///                            "not": {
    ///                              "allOf": [
    ///                                {
    ///                                  "type": "object",
    ///                                  "properties": {
    ///                                    "areas": {
    ///                                      "type": "array",
    ///                                      "items": {
    ///                                        "$ref":
    /// "#/components/schemas/Area"
    ///                                      }
    ///                                    },
    ///                                    "maxNumOfTAs": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "maxNumOfTAsForNotAllowedAreas": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "restrictionType": {
    ///                                      "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                    }
    ///                                  }
    ///                                },
    ///                                {
    ///                                  "required": [
    ///                                    "areas"
    ///                                  ]
    ///                                },
    ///                                {
    ///                                  "not": {
    ///                                    "not": {
    ///                                      "required": [
    ///                                        "restrictionType"
    ///                                      ]
    ///                                    }
    ///                                  }
    ///                                }
    ///                              ]
    ///                            }
    ///                          }
    ///                        ]
    ///                      },
    ///                      {
    ///                        "allOf": [
    ///                          {},
    ///                          {
    ///                            "allOf": [
    ///                              {
    ///                                "type": "object",
    ///                                "properties": {
    ///                                  "areas": {
    ///                                    "type": "array",
    ///                                    "items": {
    ///                                      "$ref": "#/components/schemas/Area"
    ///                                    }
    ///                                  },
    ///                                  "maxNumOfTAs": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "maxNumOfTAsForNotAllowedAreas": {
    ///                                    "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                  },
    ///                                  "restrictionType": {
    ///                                    "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                  }
    ///                                }
    ///                              },
    ///                              {
    ///                                "required": [
    ///                                  "areas"
    ///                                ]
    ///                              },
    ///                              {
    ///                                "not": {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "restrictionType"
    ///                                    ]
    ///                                  }
    ///                                }
    ///                              }
    ///                            ]
    ///                          },
    ///                          {
    ///                            "not": {
    ///                              "allOf": [
    ///                                {
    ///                                  "type": "object",
    ///                                  "properties": {
    ///                                    "areas": {
    ///                                      "type": "array",
    ///                                      "items": {
    ///                                        "$ref":
    /// "#/components/schemas/Area"
    ///                                      }
    ///                                    },
    ///                                    "maxNumOfTAs": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "maxNumOfTAsForNotAllowedAreas": {
    ///                                      "$ref":
    /// "#/components/schemas/Uinteger"
    ///                                    },
    ///                                    "restrictionType": {
    ///                                      "$ref":
    /// "#/components/schemas/RestrictionType"
    ///                                    }
    ///                                  }
    ///                                },
    ///                                {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "restrictionType"
    ///                                    ]
    ///                                  }
    ///                                },
    ///                                {
    ///                                  "not": {
    ///                                    "required": [
    ///                                      "areas"
    ///                                    ]
    ///                                  }
    ///                                }
    ///                              ]
    ///                            }
    ///                          }
    ///                        ]
    ///                      }
    ///                    ]
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "required": [
    ///                        "restrictionType"
    ///                      ],
    ///                      "properties": {
    ///                        "restrictionType": {
    ///                          "type": "string",
    ///                          "enum": [
    ///                            "NOT_ALLOWED_AREAS"
    ///                          ]
    ///                        }
    ///                      }
    ///                    }
    ///                  },
    ///                  {
    ///                    "not": {
    ///                      "not": {
    ///                        "required": [
    ///                          "maxNumOfTAs"
    ///                        ]
    ///                      }
    ///                    }
    ///                  }
    ///                ]
    ///              }
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "not": {
    ///        "required": [
    ///          "maxNumOfTAsForNotAllowedAreas"
    ///        ]
    ///      }
    ///    },
    ///    {
    ///      "not": {
    ///        "not": {
    ///          "required": [
    ///            "restrictionType"
    ///          ],
    ///          "properties": {
    ///            "restrictionType": {
    ///              "type": "string",
    ///              "enum": [
    ///                "ALLOWED_AREAS"
    ///              ]
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    #[serde(deny_unknown_fields)]
    pub enum ServiceAreaRestrictionVariant1 {}
    impl From<&ServiceAreaRestrictionVariant1> for ServiceAreaRestrictionVariant1 {
        fn from(value: &ServiceAreaRestrictionVariant1) -> Self {
            value.clone()
        }
    }

    ///Represents service experience information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents service experience information.",
    ///  "type": "object",
    ///  "required": [
    ///    "svcExprc"
    ///  ],
    ///  "properties": {
    ///    "appId": {
    ///      "$ref": "#/components/schemas/ApplicationId"
    ///    },
    ///    "appServerInst": {
    ///      "$ref": "#/components/schemas/AddrFqdn"
    ///    },
    ///    "confidence": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "dnai": {
    ///      "$ref": "#/components/schemas/Dnai"
    ///    },
    ///    "dnn": {
    ///      "$ref": "#/components/schemas/Dnn"
    ///    },
    ///    "networkArea": {
    ///      "$ref": "#/components/schemas/NetworkAreaInfo"
    ///    },
    ///    "nsiId": {
    ///      "$ref": "#/components/schemas/NsiId"
    ///    },
    ///    "ratFreq": {
    ///      "$ref": "#/components/schemas/RatFreqInformation"
    ///    },
    ///    "ratio": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "srvExpcType": {
    ///      "$ref": "#/components/schemas/ServiceExperienceType"
    ///    },
    ///    "supis": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "svcExprc": {
    ///      "$ref": "#/components/schemas/SvcExperience"
    ///    },
    ///    "svcExprcVariance": {
    ///      "$ref": "#/components/schemas/Float"
    ///    },
    ///    "ueLocs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LocationInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "upfInfo": {
    ///      "$ref": "#/components/schemas/UpfInformation"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ServiceExperienceInfo {
        #[serde(rename = "appId", default, skip_serializing_if = "Option::is_none")]
        pub app_id: Option<ApplicationId>,
        #[serde(
            rename = "appServerInst",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub app_server_inst: Option<AddrFqdn>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub confidence: Option<Uinteger>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dnai: Option<Dnai>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dnn: Option<Dnn>,
        #[serde(
            rename = "networkArea",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub network_area: Option<NetworkAreaInfo>,
        #[serde(rename = "nsiId", default, skip_serializing_if = "Option::is_none")]
        pub nsi_id: Option<NsiId>,
        #[serde(rename = "ratFreq", default, skip_serializing_if = "Option::is_none")]
        pub rat_freq: Option<RatFreqInformation>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ratio: Option<SamplingRatio>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub snssai: Option<Snssai>,
        #[serde(
            rename = "srvExpcType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub srv_expc_type: Option<ServiceExperienceType>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub supis: Vec<Supi>,
        #[serde(rename = "svcExprc")]
        pub svc_exprc: SvcExperience,
        #[serde(
            rename = "svcExprcVariance",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub svc_exprc_variance: Option<Float>,
        #[serde(rename = "ueLocs", default, skip_serializing_if = "Vec::is_empty")]
        pub ue_locs: Vec<LocationInfo>,
        #[serde(rename = "upfInfo", default, skip_serializing_if = "Option::is_none")]
        pub upf_info: Option<UpfInformation>,
    }

    impl From<&ServiceExperienceInfo> for ServiceExperienceInfo {
        fn from(value: &ServiceExperienceInfo) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - VOICE: Indicates that the service experience analytics is for voice
    ///   service.
    /// - VIDEO: Indicates that the service experience analytics is for video
    ///   service.
    /// - OTHER: Indicates that the service experience analytics is for other
    ///   service.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- VOICE: Indicates that the
    /// service experience analytics is for voice service.\n- VIDEO: Indicates
    /// that the service experience analytics is for video service.\n- OTHER:
    /// Indicates that the service experience analytics is for other
    /// service.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "VOICE",
    ///    "VIDEO",
    ///    "OTHER"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum ServiceExperienceType {
        #[serde(rename = "VOICE")]
        Voice,
        #[serde(rename = "VIDEO")]
        Video,
        #[serde(rename = "OTHER")]
        Other,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&ServiceExperienceType> for ServiceExperienceType {
        fn from(value: &ServiceExperienceType) -> Self {
            value.clone()
        }
    }

    impl ToString for ServiceExperienceType {
        fn to_string(&self) -> String {
            match *self {
                Self::Voice => "VOICE".to_string(),
                Self::Video => "VIDEO".to_string(),
                Self::Other => "OTHER".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for ServiceExperienceType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "VOICE" => Ok(Self::Voice),
                "VIDEO" => Ok(Self::Video),
                "OTHER" => Ok(Self::Other),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ServiceExperienceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ServiceExperienceType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ServiceExperienceType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents the N4 Session inactivity timer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the N4 Session inactivity timer.",
    ///  "type": "object",
    ///  "required": [
    ///    "n4SessId",
    ///    "sessInactiveTimer"
    ///  ],
    ///  "properties": {
    ///    "n4SessId": {
    ///      "$ref": "#/components/schemas/PduSessionId"
    ///    },
    ///    "sessInactiveTimer": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SessInactTimerForUeComm {
        #[serde(rename = "n4SessId")]
        pub n4_sess_id: PduSessionId,
        #[serde(rename = "sessInactiveTimer")]
        pub sess_inactive_timer: DurationSec,
    }

    impl From<&SessInactTimerForUeComm> for SessInactTimerForUeComm {
        fn from(value: &SessInactTimerForUeComm) -> Self {
            value.clone()
        }
    }

    ///Contains load level information applicable for one or several slices.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains load level information applicable for one or
    /// several slices.",
    ///  "type": "object",
    ///  "required": [
    ///    "loadLevelInformation",
    ///    "snssais"
    ///  ],
    ///  "properties": {
    ///    "loadLevelInformation": {
    ///      "$ref": "#/components/schemas/LoadLevelInformation"
    ///    },
    ///    "snssais": {
    ///      "description": "Identification(s) of network slice to which the
    /// subscription applies.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Snssai"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SliceLoadLevelInformation {
        #[serde(rename = "loadLevelInformation")]
        pub load_level_information: LoadLevelInformation,
        ///Identification(s) of network slice to which the subscription
        /// applies.
        pub snssais: Vec<Snssai>,
    }

    impl From<&SliceLoadLevelInformation> for SliceLoadLevelInformation {
        fn from(value: &SliceLoadLevelInformation) -> Self {
            value.clone()
        }
    }

    ///MBR related to slice
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "MBR related to slice",
    ///  "type": "object",
    ///  "required": [
    ///    "downlink",
    ///    "uplink"
    ///  ],
    ///  "properties": {
    ///    "downlink": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "uplink": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SliceMbr {
        pub downlink: BitRate,
        pub uplink: BitRate,
    }

    impl From<&SliceMbr> for SliceMbr {
        fn from(value: &SliceMbr) -> Self {
            value.clone()
        }
    }

    ///It indicates theSmall Data Rate Control Status
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "It indicates theSmall Data Rate Control Status",
    ///  "type": "object",
    ///  "properties": {
    ///    "remainExReportsDl": {
    ///      "description": "When present, it shall indicate number of
    /// additional exception reports the AF is allowed to send downlink  in the
    /// given time unit for the given PDU session (see clause 5.31.14.3 in 3GPP
    /// TS 23.501\n",
    ///      "type": "integer",
    ///      "minimum": 0.0
    ///    },
    ///    "remainExReportsUl": {
    ///      "description": "When present, it shall indicate number of
    /// additional exception reports the UE is allowed to send uplink in the
    /// given time  unit for  the given PDU session (see clause 5.31.14.3 of
    /// 3GPP TS 23.501.\n",
    ///      "type": "integer",
    ///      "minimum": 0.0
    ///    },
    ///    "remainPacketsDl": {
    ///      "description": "When present it shall contain the number of packets
    /// the AF is allowed to send downlink in the given time unit for the given
    /// PDU session (see clause 5.31.14.3 of 3GPP TS 23.501.\n",
    ///      "type": "integer",
    ///      "minimum": 0.0
    ///    },
    ///    "remainPacketsUl": {
    ///      "description": "When present, it shall contain the number of
    /// packets the UE is allowed to send uplink in the given time unit for the
    /// given PDU session (see clause 5.31.14.3 of 3GPP TS 23.501.\n",
    ///      "type": "integer",
    ///      "minimum": 0.0
    ///    },
    ///    "validityTime": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SmallDataRateStatus {
        ///When present, it shall indicate number of additional exception
        /// reports the AF is allowed to send downlink  in the given time unit
        /// for the given PDU session (see clause 5.31.14.3 in 3GPP TS 23.501
        #[serde(
            rename = "remainExReportsDl",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub remain_ex_reports_dl: Option<u64>,
        ///When present, it shall indicate number of additional exception
        /// reports the UE is allowed to send uplink in the given time  unit for
        /// the given PDU session (see clause 5.31.14.3 of 3GPP TS 23.501.
        #[serde(
            rename = "remainExReportsUl",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub remain_ex_reports_ul: Option<u64>,
        ///When present it shall contain the number of packets the AF is
        /// allowed to send downlink in the given time unit for the given PDU
        /// session (see clause 5.31.14.3 of 3GPP TS 23.501.
        #[serde(
            rename = "remainPacketsDl",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub remain_packets_dl: Option<u64>,
        ///When present, it shall contain the number of packets the UE is
        /// allowed to send uplink in the given time unit for the given PDU
        /// session (see clause 5.31.14.3 of 3GPP TS 23.501.
        #[serde(
            rename = "remainPacketsUl",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub remain_packets_ul: Option<u64>,
        #[serde(
            rename = "validityTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub validity_time: Option<DateTime>,
    }

    impl From<&SmallDataRateStatus> for SmallDataRateStatus {
        fn from(value: &SmallDataRateStatus) -> Self {
            value.clone()
        }
    }

    ///Represents the small data rate status
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the small data rate status",
    ///  "type": "object",
    ///  "required": [
    ///    "Dnn",
    ///    "SmallDataRateStatus",
    ///    "Snssai"
    ///  ],
    ///  "properties": {
    ///    "Dnn": {
    ///      "$ref": "#/components/schemas/Dnn"
    ///    },
    ///    "SmallDataRateStatus": {
    ///      "$ref": "#/components/schemas/SmallDataRateStatus"
    ///    },
    ///    "Snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SmallDataRateStatusInfo {
        #[serde(rename = "Dnn")]
        pub dnn: Dnn,
        #[serde(rename = "SmallDataRateStatus")]
        pub small_data_rate_status: SmallDataRateStatus,
        #[serde(rename = "Snssai")]
        pub snssai: Snssai,
    }

    impl From<&SmallDataRateStatusInfo> for SmallDataRateStatusInfo {
        fn from(value: &SmallDataRateStatusInfo) -> Self {
            value.clone()
        }
    }

    ///Represents the Session Management congestion control experience
    /// information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the Session Management congestion control
    /// experience information.",
    ///  "type": "object",
    ///  "required": [
    ///    "smcceUeList"
    ///  ],
    ///  "properties": {
    ///    "dnn": {
    ///      "$ref": "#/components/schemas/Dnn"
    ///    },
    ///    "smcceUeList": {
    ///      "$ref": "#/components/schemas/SmcceUeList"
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SmcceInfo {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dnn: Option<Dnn>,
        #[serde(rename = "smcceUeList")]
        pub smcce_ue_list: SmcceUeList,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub snssai: Option<Snssai>,
    }

    impl From<&SmcceInfo> for SmcceInfo {
        fn from(value: &SmcceInfo) -> Self {
            value.clone()
        }
    }

    ///Represents the List of UEs classified based on experience level of
    /// Session Management  congestion control.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the List of UEs classified based on
    /// experience level of Session Management  congestion control.\n",
    ///  "type": "object",
    ///  "anyOf": [
    ///    {
    ///      "required": [
    ///        "highLevel"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "mediumLevel"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "lowLevel"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "highLevel": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "lowLevel": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "mediumLevel": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum SmcceUeList {
        Variant0 {
            #[serde(rename = "highLevel")]
            high_level: Vec<Supi>,
        },
        Variant1 {
            #[serde(rename = "mediumLevel")]
            medium_level: Vec<Supi>,
        },
        Variant2 {
            #[serde(rename = "lowLevel")]
            low_level: Vec<Supi>,
        },
    }

    impl From<&SmcceUeList> for SmcceUeList {
        fn from(value: &SmcceUeList) -> Self {
            value.clone()
        }
    }

    ///Indicates the I-SMF or V-SMF change or removal
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the I-SMF or V-SMF change or removal",
    ///  "type": "string",
    ///  "enum": [
    ///    "CHANGED",
    ///    "REMOVED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SmfChangeIndication {
        #[serde(rename = "CHANGED")]
        Changed,
        #[serde(rename = "REMOVED")]
        Removed,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&SmfChangeIndication> for SmfChangeIndication {
        fn from(value: &SmfChangeIndication) -> Self {
            value.clone()
        }
    }

    impl ToString for SmfChangeIndication {
        fn to_string(&self) -> String {
            match *self {
                Self::Changed => "CHANGED".to_string(),
                Self::Removed => "REMOVED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for SmfChangeIndication {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "CHANGED" => Ok(Self::Changed),
                "REMOVED" => Ok(Self::Removed),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for SmfChangeIndication {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SmfChangeIndication {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SmfChangeIndication {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///SMF change information for PDU session(s)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "SMF change information for PDU session(s)",
    ///  "type": "object",
    ///  "required": [
    ///    "pduSessionIdList",
    ///    "smfChangeInd"
    ///  ],
    ///  "properties": {
    ///    "pduSessionIdList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PduSessionId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "smfChangeInd": {
    ///      "$ref": "#/components/schemas/SmfChangeIndication"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SmfChangeInfo {
        #[serde(rename = "pduSessionIdList")]
        pub pdu_session_id_list: Vec<PduSessionId>,
        #[serde(rename = "smfChangeInd")]
        pub smf_change_ind: SmfChangeIndication,
    }

    impl From<&SmfChangeInfo> for SmfChangeInfo {
        fn from(value: &SmfChangeInfo) -> Self {
            value.clone()
        }
    }

    ///Represents the SMF Selection information that may be replaced by the
    /// PCF.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the SMF Selection information that may be
    /// replaced by the PCF.",
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "properties": {
    ///    "candidates": {
    ///      "description": "Contains the list of DNNs per S-NSSAI that are
    /// candidates for replacement. The snssai attribute within the
    /// CandidateForReplacement data type is the key of the map.\n",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "minProperties": 1,
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/CandidateForReplacement"
    ///      }
    ///    },
    ///    "dnn": {
    ///      "$ref": "#/components/schemas/Dnn"
    ///    },
    ///    "mappingSnssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "unsuppDnn": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SmfSelectionData(pub Option<SmfSelectionDataInner>);
    impl ::std::ops::Deref for SmfSelectionData {
        type Target = Option<SmfSelectionDataInner>;
        fn deref(&self) -> &Option<SmfSelectionDataInner> {
            &self.0
        }
    }

    impl From<SmfSelectionData> for Option<SmfSelectionDataInner> {
        fn from(value: SmfSelectionData) -> Self {
            value.0
        }
    }

    impl From<&SmfSelectionData> for SmfSelectionData {
        fn from(value: &SmfSelectionData) -> Self {
            value.clone()
        }
    }

    impl From<Option<SmfSelectionDataInner>> for SmfSelectionData {
        fn from(value: Option<SmfSelectionDataInner>) -> Self {
            Self(value)
        }
    }

    ///Represents the SMF Selection information that may be replaced by the
    /// PCF.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the SMF Selection information that may be
    /// replaced by the PCF.",
    ///  "type": "object",
    ///  "properties": {
    ///    "candidates": {
    ///      "description": "Contains the list of DNNs per S-NSSAI that are
    /// candidates for replacement. The snssai attribute within the
    /// CandidateForReplacement data type is the key of the map.\n",
    ///      "type": [
    ///        "object",
    ///        "null"
    ///      ],
    ///      "minProperties": 1,
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/CandidateForReplacement"
    ///      }
    ///    },
    ///    "dnn": {
    ///      "$ref": "#/components/schemas/Dnn"
    ///    },
    ///    "mappingSnssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "unsuppDnn": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SmfSelectionDataInner {
        ///Contains the list of DNNs per S-NSSAI that are candidates for
        /// replacement. The snssai attribute within the CandidateForReplacement
        /// data type is the key of the map.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub candidates: Option<::std::collections::HashMap<String, CandidateForReplacement>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dnn: Option<Dnn>,
        #[serde(
            rename = "mappingSnssai",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub mapping_snssai: Option<Snssai>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub snssai: Option<Snssai>,
        #[serde(rename = "unsuppDnn", default, skip_serializing_if = "Option::is_none")]
        pub unsupp_dnn: Option<bool>,
    }

    impl From<&SmfSelectionDataInner> for SmfSelectionDataInner {
        fn from(value: &SmfSelectionDataInner) -> Self {
            value.clone()
        }
    }

    ///Indicates the supported SMS delivery of a UE
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the supported SMS delivery of a UE",
    ///  "type": "string",
    ///  "enum": [
    ///    "3GPP",
    ///    "NON_3GPP",
    ///    "BOTH",
    ///    "NONE"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SmsSupport {
        #[serde(rename = "3GPP")]
        ThreeGpp,
        #[serde(rename = "NON_3GPP")]
        Non3gpp,
        #[serde(rename = "BOTH")]
        Both,
        #[serde(rename = "NONE")]
        None,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&SmsSupport> for SmsSupport {
        fn from(value: &SmsSupport) -> Self {
            value.clone()
        }
    }

    impl ToString for SmsSupport {
        fn to_string(&self) -> String {
            match *self {
                Self::ThreeGpp => "3GPP".to_string(),
                Self::Non3gpp => "NON_3GPP".to_string(),
                Self::Both => "BOTH".to_string(),
                Self::None => "NONE".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for SmsSupport {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "3GPP" => Ok(Self::ThreeGpp),
                "NON_3GPP" => Ok(Self::Non3gpp),
                "BOTH" => Ok(Self::Both),
                "NONE" => Ok(Self::None),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for SmsSupport {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SmsSupport {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SmsSupport {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///When Snssai needs to be converted to string (e.g. when used in maps as
    /// key), the string shall be composed of one to three digits "sst"
    /// optionally followed by "-" and 6 hexadecimal digits "sd".
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "When Snssai needs to be converted to string (e.g. when
    /// used in maps as key), the string shall be composed of one to three
    /// digits \"sst\" optionally followed by \"-\" and 6 hexadecimal digits
    /// \"sd\".\n",
    ///  "type": "object",
    ///  "required": [
    ///    "sst"
    ///  ],
    ///  "properties": {
    ///    "sd": {
    ///      "description": "3-octet string, representing the Slice
    /// Differentiator, in hexadecimal representation. Each character in the
    /// string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to
    /// \"F\" and shall represent 4 bits. The most significant character
    /// representing the 4 most significant bits of the SD shall appear first in
    /// the string, and the character representing the 4 least significant bit
    /// of the SD shall appear last in the string. This is an optional parameter
    /// that complements the Slice/Service type(s) to allow to  differentiate
    /// amongst multiple Network Slices of the same Slice/Service type. This IE
    /// shall be absent if no SD value is associated with the SST.\n",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]{6}$"
    ///    },
    ///    "sst": {
    ///      "description": "Unsigned integer, within the range 0 to 255,
    /// representing the Slice/Service Type.  It indicates the expected Network
    /// Slice behaviour in terms of features and services. Values 0 to 127
    /// correspond to the standardized SST range. Values 128 to 255 correspond
    /// to the Operator-specific range. See clause 28.4.2 of 3GPP TS 23.003.
    /// Standardized values are defined in clause 5.15.2.2 of 3GPP TS 23.501.
    /// \n",
    ///      "type": "integer",
    ///      "maximum": 255.0,
    ///      "minimum": 0.0
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Snssai {
        ///3-octet string, representing the Slice Differentiator, in
        /// hexadecimal representation. Each character in the string shall take
        /// a value of "0" to "9", "a" to "f" or "A" to "F" and shall represent
        /// 4 bits. The most significant character representing the 4 most
        /// significant bits of the SD shall appear first in the string, and the
        /// character representing the 4 least significant bit of the SD shall
        /// appear last in the string. This is an optional parameter that
        /// complements the Slice/Service type(s) to allow to  differentiate
        /// amongst multiple Network Slices of the same Slice/Service type. This
        /// IE shall be absent if no SD value is associated with the SST.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sd: Option<SnssaiSd>,
        ///Unsigned integer, within the range 0 to 255, representing the
        /// Slice/Service Type.  It indicates the expected Network Slice
        /// behaviour in terms of features and services. Values 0 to 127
        /// correspond to the standardized SST range. Values 128 to 255
        /// correspond  to the Operator-specific range. See clause 28.4.2 of
        /// 3GPP TS 23.003. Standardized values are defined in clause 5.15.2.2
        /// of 3GPP TS 23.501.
        pub sst: u8,
    }

    impl From<&Snssai> for Snssai {
        fn from(value: &Snssai) -> Self {
            value.clone()
        }
    }

    ///Extensions to the Snssai data type, sdRanges and wildcardSd shall not be
    /// present simultaneously
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Extensions to the Snssai data type, sdRanges and
    /// wildcardSd shall not be present simultaneously\n",
    ///  "type": "object",
    ///  "not": {
    ///    "required": [
    ///      "sdRanges",
    ///      "wildcardSd"
    ///    ]
    ///  },
    ///  "properties": {
    ///    "sdRanges": {
    ///      "description": "When present, it shall contain the range(s) of
    /// Slice Differentiator values supported for the Slice/Service Type value
    /// indicated in the sst attribute of the Snssai data type\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SdRange"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "wildcardSd": {
    ///      "description": "When present, it shall be set to true, to indicate
    /// that all SD values are supported for the Slice/Service Type value
    /// indicated in the sst attribute of the Snssai data type.\n",
    ///      "type": "boolean",
    ///      "enum": [
    ///        true
    ///      ]
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SnssaiExtension {}
    impl From<&SnssaiExtension> for SnssaiExtension {
        fn from(value: &SnssaiExtension) -> Self {
            value.clone()
        }
    }

    ///3-octet string, representing the Slice Differentiator, in hexadecimal
    /// representation. Each character in the string shall take a value of "0"
    /// to "9", "a" to "f" or "A" to "F" and shall represent 4 bits. The most
    /// significant character representing the 4 most significant bits of the SD
    /// shall appear first in the string, and the character representing the 4
    /// least significant bit of the SD shall appear last in the string. This is
    /// an optional parameter that complements the Slice/Service type(s) to
    /// allow to  differentiate amongst multiple Network Slices of the same
    /// Slice/Service type. This IE shall be absent if no SD value is associated
    /// with the SST.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "3-octet string, representing the Slice Differentiator,
    /// in hexadecimal representation. Each character in the string shall take a
    /// value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall
    /// represent 4 bits. The most significant character representing the 4 most
    /// significant bits of the SD shall appear first in the string, and the
    /// character representing the 4 least significant bit of the SD shall
    /// appear last in the string. This is an optional parameter that
    /// complements the Slice/Service type(s) to allow to  differentiate amongst
    /// multiple Network Slices of the same Slice/Service type. This IE shall be
    /// absent if no SD value is associated with the SST.\n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{6}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct SnssaiSd(String);
    impl ::std::ops::Deref for SnssaiSd {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<SnssaiSd> for String {
        fn from(value: SnssaiSd) -> Self {
            value.0
        }
    }

    impl From<&SnssaiSd> for SnssaiSd {
        fn from(value: &SnssaiSd) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for SnssaiSd {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{6}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{6}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for SnssaiSd {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for SnssaiSd {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for SnssaiSd {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for SnssaiSd {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///List of restricted or unrestricted S-NSSAIs per TAI(s)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of restricted or unrestricted S-NSSAIs per
    /// TAI(s)",
    ///  "type": "object",
    ///  "required": [
    ///    "reportingArea"
    ///  ],
    ///  "properties": {
    ///    "accessTypeList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AccessType"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "reportingArea": {
    ///      "$ref": "#/components/schemas/TargetArea"
    ///    },
    ///    "supportedSnssaiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SupportedSnssai"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SnssaiTaiMapping {
        #[serde(
            rename = "accessTypeList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub access_type_list: Vec<AccessType>,
        #[serde(rename = "reportingArea")]
        pub reporting_area: TargetArea,
        #[serde(
            rename = "supportedSnssaiList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub supported_snssai_list: Vec<SupportedSnssai>,
    }

    impl From<&SnssaiTaiMapping> for SnssaiTaiMapping {
        fn from(value: &SnssaiTaiMapping) -> Self {
            value.clone()
        }
    }

    ///SpeedUncertainty
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates value of speed uncertainty.",
    ///  "type": "number",
    ///  "format": "float",
    ///  "maximum": 255.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SpeedUncertainty(pub f32);
    impl ::std::ops::Deref for SpeedUncertainty {
        type Target = f32;
        fn deref(&self) -> &f32 {
            &self.0
        }
    }

    impl From<SpeedUncertainty> for f32 {
        fn from(value: SpeedUncertainty) -> Self {
            value.0
        }
    }

    impl From<&SpeedUncertainty> for SpeedUncertainty {
        fn from(value: &SpeedUncertainty) -> Self {
            value.clone()
        }
    }

    impl From<f32> for SpeedUncertainty {
        fn from(value: f32) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for SpeedUncertainty {
        type Err = <f32 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for SpeedUncertainty {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SpeedUncertainty {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SpeedUncertainty {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for SpeedUncertainty {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Possible values are:
    /// - STATIONARY: Identifies the UE is stationary
    /// - MOBILE: Identifies the UE is mobile
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- STATIONARY: Identifies the UE
    /// is stationary\n- MOBILE: Identifies the UE is mobile\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "STATIONARY",
    ///    "MOBILE"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum StationaryIndication {
        #[serde(rename = "STATIONARY")]
        Stationary,
        #[serde(rename = "MOBILE")]
        Mobile,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&StationaryIndication> for StationaryIndication {
        fn from(value: &StationaryIndication) -> Self {
            value.clone()
        }
    }

    impl ToString for StationaryIndication {
        fn to_string(&self) -> String {
            match *self {
                Self::Stationary => "STATIONARY".to_string(),
                Self::Mobile => "MOBILE".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for StationaryIndication {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "STATIONARY" => Ok(Self::Stationary),
                "MOBILE" => Ok(Self::Mobile),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for StationaryIndication {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for StationaryIndication {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for StationaryIndication {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Enumeration for AMF status
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Enumeration for AMF status",
    ///  "type": "string",
    ///  "enum": [
    ///    "AMF_UNAVAILABLE",
    ///    "AMF_AVAILABLE"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum StatusChange {
        #[serde(rename = "AMF_UNAVAILABLE")]
        AmfUnavailable,
        #[serde(rename = "AMF_AVAILABLE")]
        AmfAvailable,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&StatusChange> for StatusChange {
        fn from(value: &StatusChange) -> Self {
            value.clone()
        }
    }

    impl ToString for StatusChange {
        fn to_string(&self) -> String {
            match *self {
                Self::AmfUnavailable => "AMF_UNAVAILABLE".to_string(),
                Self::AmfAvailable => "AMF_AVAILABLE".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for StatusChange {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AMF_UNAVAILABLE" => Ok(Self::AmfUnavailable),
                "AMF_AVAILABLE" => Ok(Self::AmfAvailable),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for StatusChange {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for StatusChange {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for StatusChange {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///String representing the STN-SR as defined in clause 18.6 of 3GPP TS
    /// 23.003.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String representing the STN-SR as defined in clause
    /// 18.6 of 3GPP TS 23.003.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct StnSr(pub String);
    impl ::std::ops::Deref for StnSr {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<StnSr> for String {
        fn from(value: StnSr) -> Self {
            value.0
        }
    }

    impl From<&StnSr> for StnSr {
        fn from(value: &StnSr) -> Self {
            value.clone()
        }
    }

    impl From<String> for StnSr {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for StnSr {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for StnSr {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Data within an AMF Status Change Subscription request and response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within an AMF Status Change Subscription request
    /// and response",
    ///  "type": "object",
    ///  "required": [
    ///    "amfStatusUri"
    ///  ],
    ///  "properties": {
    ///    "amfStatusUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "guamiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Guami"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SubscriptionData {
        #[serde(rename = "amfStatusUri")]
        pub amf_status_uri: Uri,
        #[serde(rename = "guamiList", default, skip_serializing_if = "Vec::is_empty")]
        pub guami_list: Vec<Guami>,
    }

    impl From<&SubscriptionData> for SubscriptionData {
        fn from(value: &SubscriptionData) -> Self {
            value.clone()
        }
    }

    ///String identifying a Supi that shall contain either an IMSI, a network
    /// specific identifier, a Global Cable Identifier (GCI) or a Global
    /// Line Identifier (GLI) as specified in clause 2.2A of 3GPP TS 23.003.
    /// It shall be formatted as follows
    /// - for an IMSI "imsi-<imsi>", where <imsi> shall be formatted according
    ///   to clause 2.2 of 3GPP TS 23.003 that describes an IMSI.
    /// - for a network specific identifier "nai-<nai>, where <nai> shall be
    ///   formatted according to clause 28.7.2 of 3GPP TS 23.003 that describes
    ///   an NAI.
    /// - for a GCI "gci-<gci>", where <gci> shall be formatted according to
    ///   clause 28.15.2 of 3GPP TS 23.003.
    /// - for a GLI "gli-<gli>", where <gli> shall be formatted according to
    ///   clause 28.16.2 of 3GPP TS 23.003.To enable that the value is used as
    ///   part of an URI, the string shall only contain characters allowed
    ///   according to the "lower-with-hyphen" naming convention defined in 3GPP
    ///   TS 29.501.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String identifying a Supi that shall contain either an
    /// IMSI, a network specific identifier,\na Global Cable Identifier (GCI) or
    /// a Global Line Identifier (GLI) as specified in clause \n2.2A of 3GPP TS
    /// 23.003. It shall be formatted as follows\n - for an IMSI
    /// \"imsi-<imsi>\", where <imsi> shall be formatted according to clause
    /// 2.2\n   of 3GPP TS 23.003 that describes an IMSI.\n - for a network
    /// specific identifier \"nai-<nai>, where <nai> shall be formatted\n
    /// according to clause 28.7.2 of 3GPP TS 23.003 that describes an NAI.\n -
    /// for a GCI \"gci-<gci>\", where <gci> shall be formatted according to
    /// clause 28.15.2\n   of 3GPP TS 23.003.\n - for a GLI \"gli-<gli>\", where
    /// <gli> shall be formatted according to clause 28.16.2 of\n   3GPP TS
    /// 23.003.To enable that the value is used as part of an URI, the string
    /// shall\n   only contain characters allowed according to the
    /// \"lower-with-hyphen\" naming convention\n   defined in 3GPP TS
    /// 29.501.\n",
    ///  "type": "string",
    ///  "pattern": "^(imsi-[0-9]{5,15}|nai-.+|gci-.+|gli-.+|.+)$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct Supi(String);
    impl ::std::ops::Deref for Supi {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Supi> for String {
        fn from(value: Supi) -> Self {
            value.0
        }
    }

    impl From<&Supi> for Supi {
        fn from(value: &Supi) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Supi {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^(imsi-[0-9]{5,15}|nai-.+|gci-.+|gli-.+|.+)$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err(
                    "doesn't match pattern \"^(imsi-[0-9]{5,15}|nai-.+|gci-.+|gli-.+|.+)$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Supi {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for Supi {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for Supi {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Supi {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///SupportedCodec
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "$ref": "#/components/schemas/Bytes"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SupportedCodec(pub Bytes);
    impl ::std::ops::Deref for SupportedCodec {
        type Target = Bytes;
        fn deref(&self) -> &Bytes {
            &self.0
        }
    }

    impl From<SupportedCodec> for Bytes {
        fn from(value: SupportedCodec) -> Self {
            value.0
        }
    }

    impl From<&SupportedCodec> for SupportedCodec {
        fn from(value: &SupportedCodec) -> Self {
            value.clone()
        }
    }

    impl From<Bytes> for SupportedCodec {
        fn from(value: Bytes) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for SupportedCodec {
        type Err = <Bytes as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for SupportedCodec {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SupportedCodec {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SupportedCodec {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for SupportedCodec {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///A string used to indicate the features supported by an API that is used
    /// as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a
    /// bitmask indicating supported features in  hexadecimal representation
    /// Each character in the string shall take a value of "0" to "9",  "a" to
    /// "f" or "A" to "F" and shall represent the support of 4 features as
    /// described in  table5.2.2-3. The most significant character representing
    /// the highest-numbered features shall  appear first in the string, and the
    /// character representing features 1 to 4 shall appear last  in the string.
    /// The list of features and their numbering (starting with 1) are defined
    /// separately for each API. If the string contains a lower number of
    /// characters than there are  defined features for an API, all features
    /// that would be represented by characters that are not  present in the
    /// string are not supported.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "A string used to indicate the features supported by an API that is used as defined in clause  6.6 in 3GPP TS 29.500. The string shall contain a bitmask indicating supported features in  hexadecimal representation Each character in the string shall take a value of \"0\" to \"9\",  \"a\" to \"f\" or \"A\" to \"F\" and shall represent the support of 4 features as described in  table5.2.2-3. The most significant character representing the highest-numbered features shall  appear first in the string, and the character representing features 1 to 4 shall appear last  in the string. The list of features and their numbering (starting with 1) are defined  separately for each API. If the string contains a lower number of characters than there are  defined features for an API, all features that would be represented by characters that are not  present in the string are not supported.\n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]*$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct SupportedFeatures(String);
    impl ::std::ops::Deref for SupportedFeatures {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<SupportedFeatures> for String {
        fn from(value: SupportedFeatures) -> Self {
            value.0
        }
    }

    impl From<&SupportedFeatures> for SupportedFeatures {
        fn from(value: &SupportedFeatures) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for SupportedFeatures {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]*$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]*$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for SupportedFeatures {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for SupportedFeatures {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for SupportedFeatures {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for SupportedFeatures {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Indicates supported GAD shapes.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates supported GAD shapes.",
    ///  "type": "string",
    ///  "enum": [
    ///    "POINT",
    ///    "POINT_UNCERTAINTY_CIRCLE",
    ///    "POINT_UNCERTAINTY_ELLIPSE",
    ///    "POLYGON",
    ///    "POINT_ALTITUDE",
    ///    "POINT_ALTITUDE_UNCERTAINTY",
    ///    "ELLIPSOID_ARC",
    ///    "LOCAL_2D_POINT_UNCERTAINTY_ELLIPSE",
    ///    "LOCAL_3D_POINT_UNCERTAINTY_ELLIPSOID"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum SupportedGadShapes {
        #[serde(rename = "POINT")]
        Point,
        #[serde(rename = "POINT_UNCERTAINTY_CIRCLE")]
        PointUncertaintyCircle,
        #[serde(rename = "POINT_UNCERTAINTY_ELLIPSE")]
        PointUncertaintyEllipse,
        #[serde(rename = "POLYGON")]
        Polygon,
        #[serde(rename = "POINT_ALTITUDE")]
        PointAltitude,
        #[serde(rename = "POINT_ALTITUDE_UNCERTAINTY")]
        PointAltitudeUncertainty,
        #[serde(rename = "ELLIPSOID_ARC")]
        EllipsoidArc,
        #[serde(rename = "LOCAL_2D_POINT_UNCERTAINTY_ELLIPSE")]
        Local2dPointUncertaintyEllipse,
        #[serde(rename = "LOCAL_3D_POINT_UNCERTAINTY_ELLIPSOID")]
        Local3dPointUncertaintyEllipsoid,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&SupportedGadShapes> for SupportedGadShapes {
        fn from(value: &SupportedGadShapes) -> Self {
            value.clone()
        }
    }

    impl ToString for SupportedGadShapes {
        fn to_string(&self) -> String {
            match *self {
                Self::Point => "POINT".to_string(),
                Self::PointUncertaintyCircle => "POINT_UNCERTAINTY_CIRCLE".to_string(),
                Self::PointUncertaintyEllipse => "POINT_UNCERTAINTY_ELLIPSE".to_string(),
                Self::Polygon => "POLYGON".to_string(),
                Self::PointAltitude => "POINT_ALTITUDE".to_string(),
                Self::PointAltitudeUncertainty => "POINT_ALTITUDE_UNCERTAINTY".to_string(),
                Self::EllipsoidArc => "ELLIPSOID_ARC".to_string(),
                Self::Local2dPointUncertaintyEllipse => {
                    "LOCAL_2D_POINT_UNCERTAINTY_ELLIPSE".to_string()
                }
                Self::Local3dPointUncertaintyEllipsoid => {
                    "LOCAL_3D_POINT_UNCERTAINTY_ELLIPSOID".to_string()
                }
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for SupportedGadShapes {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "POINT" => Ok(Self::Point),
                "POINT_UNCERTAINTY_CIRCLE" => Ok(Self::PointUncertaintyCircle),
                "POINT_UNCERTAINTY_ELLIPSE" => Ok(Self::PointUncertaintyEllipse),
                "POLYGON" => Ok(Self::Polygon),
                "POINT_ALTITUDE" => Ok(Self::PointAltitude),
                "POINT_ALTITUDE_UNCERTAINTY" => Ok(Self::PointAltitudeUncertainty),
                "ELLIPSOID_ARC" => Ok(Self::EllipsoidArc),
                "LOCAL_2D_POINT_UNCERTAINTY_ELLIPSE" => Ok(Self::Local2dPointUncertaintyEllipse),
                "LOCAL_3D_POINT_UNCERTAINTY_ELLIPSOID" => {
                    Ok(Self::Local3dPointUncertaintyEllipsoid)
                }
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for SupportedGadShapes {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SupportedGadShapes {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SupportedGadShapes {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Supported S-NSSAIs
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Supported S-NSSAIs",
    ///  "type": "object",
    ///  "required": [
    ///    "sNssai"
    ///  ],
    ///  "properties": {
    ///    "restrictionInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "sNssai": {
    ///      "$ref": "#/components/schemas/ExtSnssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SupportedSnssai {
        #[serde(rename = "restrictionInd", default)]
        pub restriction_ind: bool,
        #[serde(rename = "sNssai")]
        pub s_nssai: ExtSnssai,
    }

    impl From<&SupportedSnssai> for SupportedSnssai {
        fn from(value: &SupportedSnssai) -> Self {
            value.clone()
        }
    }

    ///Contains a mean opinion score with the customized range.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains a mean opinion score with the customized
    /// range.",
    ///  "type": "object",
    ///  "properties": {
    ///    "lowerRange": {
    ///      "$ref": "#/components/schemas/Float"
    ///    },
    ///    "mos": {
    ///      "$ref": "#/components/schemas/Float"
    ///    },
    ///    "upperRange": {
    ///      "$ref": "#/components/schemas/Float"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct SvcExperience {
        #[serde(
            rename = "lowerRange",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub lower_range: Option<Float>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub mos: Option<Float>,
        #[serde(
            rename = "upperRange",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub upper_range: Option<Float>,
    }

    impl From<&SvcExperience> for SvcExperience {
        fn from(value: &SvcExperience) -> Self {
            value.clone()
        }
    }

    ///2 or 3-octet string identifying a tracking area code as specified in
    /// clause 9.3.3.10  of 3GPP TS 38.413, in hexadecimal representation. Each
    /// character in the string shall  take a value of "0" to "9", "a" to "f" or
    /// "A" to "F" and shall represent 4 bits. The most significant character
    /// representing the 4 most significant bits of the TAC shall  appear first
    /// in the string, and the character representing the 4 least significant
    /// bit  of the TAC shall appear last in the string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "2 or 3-octet string identifying a tracking area code as
    /// specified in clause 9.3.3.10  of 3GPP TS 38.413, in hexadecimal
    /// representation. Each character in the string shall  take a value of
    /// \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4
    /// bits. The most significant character representing the 4 most significant
    /// bits of the TAC shall  appear first in the string, and the character
    /// representing the 4 least significant bit  of the TAC shall appear last
    /// in the string. \n",
    ///  "type": "string",
    ///  "pattern": "(^[A-Fa-f0-9]{4}$)|(^[A-Fa-f0-9]{6}$)"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct Tac(String);
    impl ::std::ops::Deref for Tac {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Tac> for String {
        fn from(value: Tac) -> Self {
            value.0
        }
    }

    impl From<&Tac> for Tac {
        fn from(value: &Tac) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Tac {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("(^[A-Fa-f0-9]{4}$)|(^[A-Fa-f0-9]{6}$)")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err(
                    "doesn't match pattern \"(^[A-Fa-f0-9]{4}$)|(^[A-Fa-f0-9]{6}$)\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Tac {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for Tac {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for Tac {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Tac {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///contains tracking area information (tracking area codes).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "contains tracking area information (tracking area
    /// codes).",
    ///  "type": "object",
    ///  "required": [
    ///    "tacList"
    ///  ],
    ///  "properties": {
    ///    "tacList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Tac"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TacInfo {
        #[serde(rename = "tacList")]
        pub tac_list: Vec<Tac>,
    }

    impl From<&TacInfo> for TacInfo {
        fn from(value: &TacInfo) -> Self {
            value.clone()
        }
    }

    ///Range of TACs (Tracking Area Codes)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Range of TACs (Tracking Area Codes)",
    ///  "type": "object",
    ///  "properties": {
    ///    "end": {
    ///      "type": "string",
    ///      "pattern": "^([A-Fa-f0-9]{4}|[A-Fa-f0-9]{6})$"
    ///    },
    ///    "pattern": {
    ///      "type": "string"
    ///    },
    ///    "start": {
    ///      "type": "string",
    ///      "pattern": "^([A-Fa-f0-9]{4}|[A-Fa-f0-9]{6})$"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TacRange {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub end: Option<TacRangeEnd>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pattern: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub start: Option<TacRangeStart>,
    }

    impl From<&TacRange> for TacRange {
        fn from(value: &TacRange) -> Self {
            value.clone()
        }
    }

    ///TacRangeEnd
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^([A-Fa-f0-9]{4}|[A-Fa-f0-9]{6})$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct TacRangeEnd(String);
    impl ::std::ops::Deref for TacRangeEnd {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<TacRangeEnd> for String {
        fn from(value: TacRangeEnd) -> Self {
            value.0
        }
    }

    impl From<&TacRangeEnd> for TacRangeEnd {
        fn from(value: &TacRangeEnd) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for TacRangeEnd {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^([A-Fa-f0-9]{4}|[A-Fa-f0-9]{6})$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^([A-Fa-f0-9]{4}|[A-Fa-f0-9]{6})$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for TacRangeEnd {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for TacRangeEnd {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for TacRangeEnd {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for TacRangeEnd {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///TacRangeStart
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "string",
    ///  "pattern": "^([A-Fa-f0-9]{4}|[A-Fa-f0-9]{6})$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct TacRangeStart(String);
    impl ::std::ops::Deref for TacRangeStart {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<TacRangeStart> for String {
        fn from(value: TacRangeStart) -> Self {
            value.0
        }
    }

    impl From<&TacRangeStart> for TacRangeStart {
        fn from(value: &TacRangeStart) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for TacRangeStart {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^([A-Fa-f0-9]{4}|[A-Fa-f0-9]{6})$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^([A-Fa-f0-9]{4}|[A-Fa-f0-9]{6})$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for TacRangeStart {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for TacRangeStart {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for TacRangeStart {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for TacRangeStart {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Contains the tracking area identity as described in 3GPP 23.003
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the tracking area identity as described in
    /// 3GPP 23.003",
    ///  "type": "object",
    ///  "required": [
    ///    "plmnId",
    ///    "tac"
    ///  ],
    ///  "properties": {
    ///    "nid": {
    ///      "$ref": "#/components/schemas/Nid"
    ///    },
    ///    "plmnId": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    },
    ///    "tac": {
    ///      "$ref": "#/components/schemas/Tac"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Tai {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub nid: Option<Nid>,
        #[serde(rename = "plmnId")]
        pub plmn_id: PlmnId,
        pub tac: Tac,
    }

    impl From<&Tai> for Tai {
        fn from(value: &Tai) -> Self {
            value.clone()
        }
    }

    ///Range of TAIs (Tracking Area Identities)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Range of TAIs (Tracking Area Identities)",
    ///  "type": "object",
    ///  "required": [
    ///    "plmnId",
    ///    "tacRangeList"
    ///  ],
    ///  "properties": {
    ///    "nid": {
    ///      "$ref": "#/components/schemas/Nid"
    ///    },
    ///    "plmnId": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    },
    ///    "tacRangeList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TacRange"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TaiRange {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub nid: Option<Nid>,
        #[serde(rename = "plmnId")]
        pub plmn_id: PlmnId,
        #[serde(rename = "tacRangeList")]
        pub tac_range_list: Vec<TacRange>,
    }

    impl From<&TaiRange> for TaiRange {
        fn from(value: &TaiRange) -> Self {
            value.clone()
        }
    }

    ///TA list or TAI range list or any TA
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "TA list or TAI range list or any TA",
    ///  "type": "object",
    ///  "properties": {
    ///    "anyTa": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "taList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Tai"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "taiRangeList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TaiRange"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TargetArea {
        #[serde(rename = "anyTa", default)]
        pub any_ta: bool,
        #[serde(rename = "taList", default, skip_serializing_if = "Vec::is_empty")]
        pub ta_list: Vec<Tai>,
        #[serde(
            rename = "taiRangeList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub tai_range_list: Vec<TaiRange>,
    }

    impl From<&TargetArea> for TargetArea {
        fn from(value: &TargetArea) -> Self {
            value.clone()
        }
    }

    ///Contains the target integrity risk
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the target integrity risk",
    ///  "type": "integer",
    ///  "maximum": 90.0,
    ///  "minimum": 10.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TargetIntegrityRisk(pub i64);
    impl ::std::ops::Deref for TargetIntegrityRisk {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<TargetIntegrityRisk> for i64 {
        fn from(value: TargetIntegrityRisk) -> Self {
            value.0
        }
    }

    impl From<&TargetIntegrityRisk> for TargetIntegrityRisk {
        fn from(value: &TargetIntegrityRisk) -> Self {
            value.clone()
        }
    }

    impl From<i64> for TargetIntegrityRisk {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for TargetIntegrityRisk {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for TargetIntegrityRisk {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TargetIntegrityRisk {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TargetIntegrityRisk {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for TargetIntegrityRisk {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Identifies the target UE information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identifies the target UE information.",
    ///  "type": "object",
    ///  "properties": {
    ///    "anyUe": {
    ///      "type": "boolean"
    ///    },
    ///    "gpsis": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Gpsi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "intGroupIds": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GroupId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "supis": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TargetUeInformation {
        #[serde(rename = "anyUe", default, skip_serializing_if = "Option::is_none")]
        pub any_ue: Option<bool>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub gpsis: Vec<Gpsi>,
        #[serde(rename = "intGroupIds", default, skip_serializing_if = "Vec::is_empty")]
        pub int_group_ids: Vec<GroupId>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub supis: Vec<Supi>,
    }

    impl From<&TargetUeInformation> for TargetUeInformation {
        fn from(value: &TargetUeInformation) -> Self {
            value.clone()
        }
    }

    ///Specifies causes of event reporting termination.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Specifies causes of event reporting termination.",
    ///  "type": "string",
    ///  "enum": [
    ///    "TERMINATION_BY_UE",
    ///    "TERMINATION_BY_NETWORK",
    ///    "NORMAL_TERMINATION"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TerminationCause {
        #[serde(rename = "TERMINATION_BY_UE")]
        TerminationByUe,
        #[serde(rename = "TERMINATION_BY_NETWORK")]
        TerminationByNetwork,
        #[serde(rename = "NORMAL_TERMINATION")]
        NormalTermination,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&TerminationCause> for TerminationCause {
        fn from(value: &TerminationCause) -> Self {
            value.clone()
        }
    }

    impl ToString for TerminationCause {
        fn to_string(&self) -> String {
            match *self {
                Self::TerminationByUe => "TERMINATION_BY_UE".to_string(),
                Self::TerminationByNetwork => "TERMINATION_BY_NETWORK".to_string(),
                Self::NormalTermination => "NORMAL_TERMINATION".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for TerminationCause {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TERMINATION_BY_UE" => Ok(Self::TerminationByUe),
                "TERMINATION_BY_NETWORK" => Ok(Self::TerminationByNetwork),
                "NORMAL_TERMINATION" => Ok(Self::NormalTermination),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for TerminationCause {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TerminationCause {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TerminationCause {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents a threshold level.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a threshold level.",
    ///  "type": "object",
    ///  "properties": {
    ///    "avgPacketDelay": {
    ///      "$ref": "#/components/schemas/PacketDelBudget"
    ///    },
    ///    "avgPacketLossRate": {
    ///      "$ref": "#/components/schemas/PacketLossRate"
    ///    },
    ///    "avgTrafficRate": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "congLevel": {
    ///      "type": "integer"
    ///    },
    ///    "maxPacketDelay": {
    ///      "$ref": "#/components/schemas/PacketDelBudget"
    ///    },
    ///    "maxTrafficRate": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "nfCpuUsage": {
    ///      "type": "integer"
    ///    },
    ///    "nfLoadLevel": {
    ///      "type": "integer"
    ///    },
    ///    "nfMemoryUsage": {
    ///      "type": "integer"
    ///    },
    ///    "nfStorageUsage": {
    ///      "type": "integer"
    ///    },
    ///    "svcExpLevel": {
    ///      "$ref": "#/components/schemas/Float"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct ThresholdLevel {
        #[serde(
            rename = "avgPacketDelay",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub avg_packet_delay: Option<PacketDelBudget>,
        #[serde(
            rename = "avgPacketLossRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub avg_packet_loss_rate: Option<PacketLossRate>,
        #[serde(
            rename = "avgTrafficRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub avg_traffic_rate: Option<BitRate>,
        #[serde(rename = "congLevel", default, skip_serializing_if = "Option::is_none")]
        pub cong_level: Option<i64>,
        #[serde(
            rename = "maxPacketDelay",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_packet_delay: Option<PacketDelBudget>,
        #[serde(
            rename = "maxTrafficRate",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub max_traffic_rate: Option<BitRate>,
        #[serde(
            rename = "nfCpuUsage",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nf_cpu_usage: Option<i64>,
        #[serde(
            rename = "nfLoadLevel",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nf_load_level: Option<i64>,
        #[serde(
            rename = "nfMemoryUsage",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nf_memory_usage: Option<i64>,
        #[serde(
            rename = "nfStorageUsage",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nf_storage_usage: Option<i64>,
        #[serde(
            rename = "svcExpLevel",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub svc_exp_level: Option<Float>,
    }

    impl From<&ThresholdLevel> for ThresholdLevel {
        fn from(value: &ThresholdLevel) -> Self {
            value.clone()
        }
    }

    ///String with format partial-time or full-time as defined in clause 5.6 of
    /// IETF RFC 3339. Examples, 20:15:00, 20:15:00-08:00 (for 8 hours behind
    /// UTC).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String with format partial-time or full-time as defined
    /// in clause 5.6 of IETF RFC 3339. Examples, 20:15:00, 20:15:00-08:00 (for
    /// 8 hours behind UTC). \n",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct TimeOfDay(pub String);
    impl ::std::ops::Deref for TimeOfDay {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<TimeOfDay> for String {
        fn from(value: TimeOfDay) -> Self {
            value.0
        }
    }

    impl From<&TimeOfDay> for TimeOfDay {
        fn from(value: &TimeOfDay) -> Self {
            value.clone()
        }
    }

    impl From<String> for TimeOfDay {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for TimeOfDay {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for TimeOfDay {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Contains the time-to-alert
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the time-to-alert",
    ///  "type": "integer",
    ///  "maximum": 300.0,
    ///  "minimum": 1.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TimeToAlert(pub i64);
    impl ::std::ops::Deref for TimeToAlert {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<TimeToAlert> for i64 {
        fn from(value: TimeToAlert) -> Self {
            value.0
        }
    }

    impl From<&TimeToAlert> for TimeToAlert {
        fn from(value: &TimeToAlert) -> Self {
            value.clone()
        }
    }

    impl From<i64> for TimeToAlert {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for TimeToAlert {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for TimeToAlert {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TimeToAlert {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TimeToAlert {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for TimeToAlert {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Possible values are:
    /// - MINUTE: Time unit is per minute.
    /// - HOUR: Time unit is per hour.
    /// - DAY: Time unit is per day.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- MINUTE: Time unit is per
    /// minute.\n- HOUR: Time unit is per hour.\n- DAY: Time unit is per
    /// day.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "MINUTE",
    ///    "HOUR",
    ///    "DAY"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TimeUnit {
        #[serde(rename = "MINUTE")]
        Minute,
        #[serde(rename = "HOUR")]
        Hour,
        #[serde(rename = "DAY")]
        Day,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&TimeUnit> for TimeUnit {
        fn from(value: &TimeUnit) -> Self {
            value.clone()
        }
    }

    impl ToString for TimeUnit {
        fn to_string(&self) -> String {
            match *self {
                Self::Minute => "MINUTE".to_string(),
                Self::Hour => "HOUR".to_string(),
                Self::Day => "DAY".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for TimeUnit {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "MINUTE" => Ok(Self::Minute),
                "HOUR" => Ok(Self::Hour),
                "DAY" => Ok(Self::Day),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for TimeUnit {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TimeUnit {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TimeUnit {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents a time window identified by a start time and a stop time.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents a time window identified by a start time and
    /// a stop time.",
    ///  "type": "object",
    ///  "required": [
    ///    "startTime",
    ///    "stopTime"
    ///  ],
    ///  "properties": {
    ///    "startTime": {
    ///      "$ref": "#/components/schemas/schemas-DateTime"
    ///    },
    ///    "stopTime": {
    ///      "$ref": "#/components/schemas/schemas-DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TimeWindow {
        #[serde(rename = "startTime")]
        pub start_time: SchemasDateTime,
        #[serde(rename = "stopTime")]
        pub stop_time: SchemasDateTime,
    }

    impl From<&TimeWindow> for TimeWindow {
        fn from(value: &TimeWindow) -> Self {
            value.clone()
        }
    }

    ///String with format "time-numoffset" optionally appended by
    /// "daylightSavingTime", where
    /// - "time-numoffset" shall represent the time zone adjusted for daylight
    ///   saving time and be encoded as time-numoffset as defined in clause5.6
    ///   of IETF RFC 3339;
    /// - "daylightSavingTime" shall represent the adjustment that has been made
    ///   and shall be encoded as "+1" or "+2" for a +1 or +2 hours adjustment.
    ///
    ///The example is for 8 hours behind UTC, +1 hour adjustment for Daylight
    /// Saving Time.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String with format \"time-numoffset\" optionally
    /// appended by \"daylightSavingTime\", where \n- \"time-numoffset\" shall
    /// represent the time zone adjusted for daylight saving time and be\n
    /// encoded as time-numoffset as defined in clause5.6 of IETF RFC 3339; \n-
    /// \"daylightSavingTime\" shall represent the adjustment that has been made
    /// and shall be\n   encoded as \"+1\" or \"+2\" for a +1 or +2 hours
    /// adjustment. \n\nThe example is for 8 hours behind UTC, +1 hour
    /// adjustment for Daylight Saving Time.\n",
    ///  "examples": [
    ///    "-08:00+1"
    ///  ],
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct TimeZone(pub String);
    impl ::std::ops::Deref for TimeZone {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<TimeZone> for String {
        fn from(value: TimeZone) -> Self {
            value.0
        }
    }

    impl From<&TimeZone> for TimeZone {
        fn from(value: &TimeZone) -> Self {
            value.clone()
        }
    }

    impl From<String> for TimeZone {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for TimeZone {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for TimeZone {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Temporary Mobile Group Identity
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Temporary Mobile Group Identity",
    ///  "type": "object",
    ///  "required": [
    ///    "mbsServiceId",
    ///    "plmnId"
    ///  ],
    ///  "properties": {
    ///    "mbsServiceId": {
    ///      "description": "MBS Service ID",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]{6}$"
    ///    },
    ///    "plmnId": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Tmgi {
        ///MBS Service ID
        #[serde(rename = "mbsServiceId")]
        pub mbs_service_id: TmgiMbsServiceId,
        #[serde(rename = "plmnId")]
        pub plmn_id: PlmnId,
    }

    impl From<&Tmgi> for Tmgi {
        fn from(value: &Tmgi) -> Self {
            value.clone()
        }
    }

    ///MBS Service ID
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "MBS Service ID",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]{6}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct TmgiMbsServiceId(String);
    impl ::std::ops::Deref for TmgiMbsServiceId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<TmgiMbsServiceId> for String {
        fn from(value: TmgiMbsServiceId) -> Self {
            value.0
        }
    }

    impl From<&TmgiMbsServiceId> for TmgiMbsServiceId {
        fn from(value: &TmgiMbsServiceId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for TmgiMbsServiceId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]{6}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]{6}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for TmgiMbsServiceId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for TmgiMbsServiceId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for TmgiMbsServiceId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for TmgiMbsServiceId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Contain the TNAP Identifier see clause5.6.2 of 3GPP TS 23.501.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contain the TNAP Identifier see clause5.6.2 of 3GPP TS
    /// 23.501.",
    ///  "type": "object",
    ///  "properties": {
    ///    "bssId": {
    ///      "description": "When present, it shall contain the BSSID of the
    /// access point to which the UE is attached, that is received over NGAP,
    /// see IEEE Std 802.11-2012. \n",
    ///      "type": "string"
    ///    },
    ///    "civicAddress": {
    ///      "$ref": "#/components/schemas/Bytes"
    ///    },
    ///    "ssId": {
    ///      "description": "This IE shall be present if the UE is accessing the
    /// 5GC via a trusted WLAN access network.When present, it shall contain the
    /// SSID of the access point to which the UE is attached, that is received
    /// over NGAP,  see IEEE Std 802.11-2012. \n",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TnapId {
        ///When present, it shall contain the BSSID of the access point to
        /// which the UE is attached, that is received over NGAP, see IEEE Std
        /// 802.11-2012.
        #[serde(rename = "bssId", default, skip_serializing_if = "Option::is_none")]
        pub bss_id: Option<String>,
        #[serde(
            rename = "civicAddress",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub civic_address: Option<Bytes>,
        ///This IE shall be present if the UE is accessing the 5GC via a
        /// trusted WLAN access network.When present, it shall contain the SSID
        /// of the access point to which the UE is attached, that is received
        /// over NGAP,  see IEEE Std 802.11-2012.
        #[serde(rename = "ssId", default, skip_serializing_if = "Option::is_none")]
        pub ss_id: Option<String>,
    }

    impl From<&TnapId> for TnapId {
        fn from(value: &TnapId) -> Self {
            value.clone()
        }
    }

    ///This represents the identifier of the TNGF ID as specified in clause
    /// 9.3.1.161 of  3GPP TS 38.413  in hexadecimal representation. Each
    /// character in the string shall take a value of "0" to "9", "a"  to "f" or
    /// "A" to "F" and shall represent 4 bits. The most significant character
    /// representing the  4 most significant bits of the TNGF ID shall appear
    /// first in the string, and the character  representing the 4 least
    /// significant bit of the TNGF ID shall appear last in the string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This represents the identifier of the TNGF ID as
    /// specified in clause 9.3.1.161 of  3GPP TS 38.413  in hexadecimal
    /// representation. Each character in the string shall take a value of \"0\"
    /// to \"9\", \"a\"  to \"f\" or \"A\" to \"F\" and shall represent 4 bits.
    /// The most significant character representing the  4 most significant bits
    /// of the TNGF ID shall appear first in the string, and the character
    /// representing the 4 least significant bit of the TNGF ID shall appear
    /// last in the string. \n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]+$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct TngfId(String);
    impl ::std::ops::Deref for TngfId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<TngfId> for String {
        fn from(value: TngfId) -> Self {
            value.0
        }
    }

    impl From<&TngfId> for TngfId {
        fn from(value: &TngfId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for TngfId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]+$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for TngfId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for TngfId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for TngfId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for TngfId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Top application that contributes the most to the traffic.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Top application that contributes the most to the
    /// traffic.",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "required": [
    ///        "appId"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "ipTrafficFilter"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "appId": {
    ///      "$ref": "#/components/schemas/ApplicationId"
    ///    },
    ///    "ipTrafficFilter": {
    ///      "$ref": "#/components/schemas/FlowInfo"
    ///    },
    ///    "ratio": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum TopApplication {
        Variant0 {
            #[serde(rename = "appId")]
            app_id: ApplicationId,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            ratio: Option<SamplingRatio>,
        },
        Variant1 {
            #[serde(rename = "ipTrafficFilter")]
            ip_traffic_filter: FlowInfo,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            ratio: Option<SamplingRatio>,
        },
    }

    impl From<&TopApplication> for TopApplication {
        fn from(value: &TopApplication) -> Self {
            value.clone()
        }
    }

    ///contains Trace control and configuration parameters.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "contains Trace control and configuration parameters.",
    ///  "type": [
    ///    "object",
    ///    "null"
    ///  ],
    ///  "required": [
    ///    "eventList",
    ///    "neTypeList",
    ///    "traceDepth",
    ///    "traceRef"
    ///  ],
    ///  "properties": {
    ///    "collectionEntityIpv4Addr": {
    ///      "$ref": "#/components/schemas/Ipv4Addr"
    ///    },
    ///    "collectionEntityIpv6Addr": {
    ///      "$ref": "#/components/schemas/Ipv6Addr"
    ///    },
    ///    "eventList": {
    ///      "description": "Triggering events (see 3GPP TS 32.422).It shall be
    /// encoded as an octet string in hexadecimal representation. Each character
    /// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
    /// \"A\" to \"F\" and shall represent 4 bits. The most significant
    /// character representing the 4 most significant bits shall appear first in
    /// the string, and the character representing the 4 least significant bit
    /// shall appear last in the string. Octets shall be coded according to 3GPP
    /// TS 32.422.\n",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]+$"
    ///    },
    ///    "interfaceList": {
    ///      "description": "List of Interfaces (see 3GPP TS 32.422).It shall be
    /// encoded as an octet string in hexadecimal representation. Each character
    /// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
    /// \"A\" to \"F\" and shall represent 4 bits. The most significant
    /// character representing the 4 most significant bits shall appear first in
    /// the string, and the character representing the  4 least significant bit
    /// shall appear last in the string. Octets shall be coded according to 3GPP
    /// TS 32.422. If this attribute is not present, all the interfaces
    /// applicable to the list of NE types indicated in the neTypeList attribute
    /// should be traced.\n",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]+$"
    ///    },
    ///    "neTypeList": {
    ///      "description": "List of NE Types (see 3GPP TS 32.422).It shall be
    /// encoded as an octet string in hexadecimal representation. Each character
    /// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
    /// \"A\" to \"F\" and shall represent 4 bits. The most significant
    /// character representing the 4 most significant bits shall Appear first in
    /// the string, and the character representing the 4 least significant bit
    /// shall appear last in the string.Octets shall be coded according to 3GPP
    /// TS 32.422.\n",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]+$"
    ///    },
    ///    "traceDepth": {
    ///      "$ref": "#/components/schemas/TraceDepth"
    ///    },
    ///    "traceRef": {
    ///      "description": "Trace Reference (see 3GPP TS 32.422).It shall be
    /// encoded as the concatenation of MCC, MNC and Trace ID as follows:
    /// <MCC><MNC>-<Trace ID> The Trace ID shall be encoded as a 3 octet string
    /// in hexadecimal representation. Each character in the Trace ID string
    /// shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\"
    /// and shall represent 4 bits. The most significant character representing
    /// the 4 most significant bits of the Trace ID shall appear first  in the
    /// string, and the character representing the 4 least significant bit of
    /// the Trace ID shall appear last in the string.\n",
    ///      "type": "string",
    ///      "pattern": "^[0-9]{3}[0-9]{2,3}-[A-Fa-f0-9]{6}$"
    ///    },
    ///    "traceReportingConsumerUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TraceData(pub Option<TraceDataInner>);
    impl ::std::ops::Deref for TraceData {
        type Target = Option<TraceDataInner>;
        fn deref(&self) -> &Option<TraceDataInner> {
            &self.0
        }
    }

    impl From<TraceData> for Option<TraceDataInner> {
        fn from(value: TraceData) -> Self {
            value.0
        }
    }

    impl From<&TraceData> for TraceData {
        fn from(value: &TraceData) -> Self {
            value.clone()
        }
    }

    impl From<Option<TraceDataInner>> for TraceData {
        fn from(value: Option<TraceDataInner>) -> Self {
            Self(value)
        }
    }

    ///contains Trace control and configuration parameters.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "contains Trace control and configuration parameters.",
    ///  "type": "object",
    ///  "required": [
    ///    "eventList",
    ///    "neTypeList",
    ///    "traceDepth",
    ///    "traceRef"
    ///  ],
    ///  "properties": {
    ///    "collectionEntityIpv4Addr": {
    ///      "$ref": "#/components/schemas/Ipv4Addr"
    ///    },
    ///    "collectionEntityIpv6Addr": {
    ///      "$ref": "#/components/schemas/Ipv6Addr"
    ///    },
    ///    "eventList": {
    ///      "description": "Triggering events (see 3GPP TS 32.422).It shall be
    /// encoded as an octet string in hexadecimal representation. Each character
    /// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
    /// \"A\" to \"F\" and shall represent 4 bits. The most significant
    /// character representing the 4 most significant bits shall appear first in
    /// the string, and the character representing the 4 least significant bit
    /// shall appear last in the string. Octets shall be coded according to 3GPP
    /// TS 32.422.\n",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]+$"
    ///    },
    ///    "interfaceList": {
    ///      "description": "List of Interfaces (see 3GPP TS 32.422).It shall be
    /// encoded as an octet string in hexadecimal representation. Each character
    /// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
    /// \"A\" to \"F\" and shall represent 4 bits. The most significant
    /// character representing the 4 most significant bits shall appear first in
    /// the string, and the character representing the  4 least significant bit
    /// shall appear last in the string. Octets shall be coded according to 3GPP
    /// TS 32.422. If this attribute is not present, all the interfaces
    /// applicable to the list of NE types indicated in the neTypeList attribute
    /// should be traced.\n",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]+$"
    ///    },
    ///    "neTypeList": {
    ///      "description": "List of NE Types (see 3GPP TS 32.422).It shall be
    /// encoded as an octet string in hexadecimal representation. Each character
    /// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
    /// \"A\" to \"F\" and shall represent 4 bits. The most significant
    /// character representing the 4 most significant bits shall Appear first in
    /// the string, and the character representing the 4 least significant bit
    /// shall appear last in the string.Octets shall be coded according to 3GPP
    /// TS 32.422.\n",
    ///      "type": "string",
    ///      "pattern": "^[A-Fa-f0-9]+$"
    ///    },
    ///    "traceDepth": {
    ///      "$ref": "#/components/schemas/TraceDepth"
    ///    },
    ///    "traceRef": {
    ///      "description": "Trace Reference (see 3GPP TS 32.422).It shall be
    /// encoded as the concatenation of MCC, MNC and Trace ID as follows:
    /// <MCC><MNC>-<Trace ID> The Trace ID shall be encoded as a 3 octet string
    /// in hexadecimal representation. Each character in the Trace ID string
    /// shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\"
    /// and shall represent 4 bits. The most significant character representing
    /// the 4 most significant bits of the Trace ID shall appear first  in the
    /// string, and the character representing the 4 least significant bit of
    /// the Trace ID shall appear last in the string.\n",
    ///      "type": "string",
    ///      "pattern": "^[0-9]{3}[0-9]{2,3}-[A-Fa-f0-9]{6}$"
    ///    },
    ///    "traceReportingConsumerUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TraceDataInner {
        #[serde(
            rename = "collectionEntityIpv4Addr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub collection_entity_ipv4_addr: Option<Ipv4Addr>,
        #[serde(
            rename = "collectionEntityIpv6Addr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub collection_entity_ipv6_addr: Option<Ipv6Addr>,
        ///Triggering events (see 3GPP TS 32.422).It shall be encoded as an
        /// octet string in hexadecimal representation. Each character in the
        /// string shall take a value of "0" to "9", "a" to "f" or "A" to "F"
        /// and shall represent 4 bits. The most significant character
        /// representing the 4 most significant bits shall appear first in the
        /// string, and the character representing the 4 least significant bit
        /// shall appear last in the string. Octets shall be coded according to
        /// 3GPP TS 32.422.
        #[serde(rename = "eventList")]
        pub event_list: TraceDataInnerEventList,
        ///List of Interfaces (see 3GPP TS 32.422).It shall be encoded as an
        /// octet string in hexadecimal representation. Each character in the
        /// string shall take a value of "0" to "9", "a" to "f" or "A" to "F"
        /// and shall represent 4 bits. The most significant character
        /// representing the 4 most significant bits shall appear first in the
        /// string, and the character representing the  4 least significant bit
        /// shall appear last in the string. Octets shall be coded according to
        /// 3GPP TS 32.422. If this attribute is not present, all the interfaces
        /// applicable to the list of NE types indicated in the neTypeList
        /// attribute should be traced.
        #[serde(
            rename = "interfaceList",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub interface_list: Option<TraceDataInnerInterfaceList>,
        ///List of NE Types (see 3GPP TS 32.422).It shall be encoded as an
        /// octet string in hexadecimal representation. Each character in the
        /// string shall take a value of "0" to "9", "a" to "f" or "A" to "F"
        /// and shall represent 4 bits. The most significant character
        /// representing the 4 most significant bits shall Appear first in the
        /// string, and the character representing the 4 least significant bit
        /// shall appear last in the string.Octets shall be coded according to
        /// 3GPP TS 32.422.
        #[serde(rename = "neTypeList")]
        pub ne_type_list: TraceDataInnerNeTypeList,
        #[serde(rename = "traceDepth")]
        pub trace_depth: TraceDepth,
        ///Trace Reference (see 3GPP TS 32.422).It shall be encoded as the
        /// concatenation of MCC, MNC and Trace ID as follows: <MCC><MNC>-<Trace
        /// ID> The Trace ID shall be encoded as a 3 octet string in hexadecimal
        /// representation. Each character in the Trace ID string shall take a
        /// value of "0" to "9", "a" to "f" or "A" to "F" and shall represent 4
        /// bits. The most significant character representing the 4 most
        /// significant bits of the Trace ID shall appear first  in the string,
        /// and the character representing the 4 least significant bit of the
        /// Trace ID shall appear last in the string.
        #[serde(rename = "traceRef")]
        pub trace_ref: TraceDataInnerTraceRef,
        #[serde(
            rename = "traceReportingConsumerUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub trace_reporting_consumer_uri: Option<Uri>,
    }

    impl From<&TraceDataInner> for TraceDataInner {
        fn from(value: &TraceDataInner) -> Self {
            value.clone()
        }
    }

    ///Triggering events (see 3GPP TS 32.422).It shall be encoded as an octet
    /// string in hexadecimal representation. Each character in the string shall
    /// take a value of "0" to "9", "a" to "f" or "A" to "F" and shall represent
    /// 4 bits. The most significant character representing the 4 most
    /// significant bits shall appear first in the string, and the character
    /// representing the 4 least significant bit shall appear last in the
    /// string. Octets shall be coded according to 3GPP TS 32.422.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Triggering events (see 3GPP TS 32.422).It shall be
    /// encoded as an octet string in hexadecimal representation. Each character
    /// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
    /// \"A\" to \"F\" and shall represent 4 bits. The most significant
    /// character representing the 4 most significant bits shall appear first in
    /// the string, and the character representing the 4 least significant bit
    /// shall appear last in the string. Octets shall be coded according to 3GPP
    /// TS 32.422.\n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]+$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct TraceDataInnerEventList(String);
    impl ::std::ops::Deref for TraceDataInnerEventList {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<TraceDataInnerEventList> for String {
        fn from(value: TraceDataInnerEventList) -> Self {
            value.0
        }
    }

    impl From<&TraceDataInnerEventList> for TraceDataInnerEventList {
        fn from(value: &TraceDataInnerEventList) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for TraceDataInnerEventList {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]+$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for TraceDataInnerEventList {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for TraceDataInnerEventList {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for TraceDataInnerEventList {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for TraceDataInnerEventList {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///List of Interfaces (see 3GPP TS 32.422).It shall be encoded as an octet
    /// string in hexadecimal representation. Each character in the string shall
    /// take a value of "0" to "9", "a" to "f" or "A" to "F" and shall represent
    /// 4 bits. The most significant character representing the 4 most
    /// significant bits shall appear first in the string, and the character
    /// representing the  4 least significant bit shall appear last in the
    /// string. Octets shall be coded according to 3GPP TS 32.422. If this
    /// attribute is not present, all the interfaces applicable to the list of
    /// NE types indicated in the neTypeList attribute should be traced.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of Interfaces (see 3GPP TS 32.422).It shall be
    /// encoded as an octet string in hexadecimal representation. Each character
    /// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
    /// \"A\" to \"F\" and shall represent 4 bits. The most significant
    /// character representing the 4 most significant bits shall appear first in
    /// the string, and the character representing the  4 least significant bit
    /// shall appear last in the string. Octets shall be coded according to 3GPP
    /// TS 32.422. If this attribute is not present, all the interfaces
    /// applicable to the list of NE types indicated in the neTypeList attribute
    /// should be traced.\n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]+$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct TraceDataInnerInterfaceList(String);
    impl ::std::ops::Deref for TraceDataInnerInterfaceList {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<TraceDataInnerInterfaceList> for String {
        fn from(value: TraceDataInnerInterfaceList) -> Self {
            value.0
        }
    }

    impl From<&TraceDataInnerInterfaceList> for TraceDataInnerInterfaceList {
        fn from(value: &TraceDataInnerInterfaceList) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for TraceDataInnerInterfaceList {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]+$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for TraceDataInnerInterfaceList {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for TraceDataInnerInterfaceList {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for TraceDataInnerInterfaceList {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for TraceDataInnerInterfaceList {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///List of NE Types (see 3GPP TS 32.422).It shall be encoded as an octet
    /// string in hexadecimal representation. Each character in the string shall
    /// take a value of "0" to "9", "a" to "f" or "A" to "F" and shall represent
    /// 4 bits. The most significant character representing the 4 most
    /// significant bits shall Appear first in the string, and the character
    /// representing the 4 least significant bit shall appear last in the
    /// string.Octets shall be coded according to 3GPP TS 32.422.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "List of NE Types (see 3GPP TS 32.422).It shall be
    /// encoded as an octet string in hexadecimal representation. Each character
    /// in the string shall take a value of \"0\" to \"9\", \"a\" to \"f\" or
    /// \"A\" to \"F\" and shall represent 4 bits. The most significant
    /// character representing the 4 most significant bits shall Appear first in
    /// the string, and the character representing the 4 least significant bit
    /// shall appear last in the string.Octets shall be coded according to 3GPP
    /// TS 32.422.\n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]+$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct TraceDataInnerNeTypeList(String);
    impl ::std::ops::Deref for TraceDataInnerNeTypeList {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<TraceDataInnerNeTypeList> for String {
        fn from(value: TraceDataInnerNeTypeList) -> Self {
            value.0
        }
    }

    impl From<&TraceDataInnerNeTypeList> for TraceDataInnerNeTypeList {
        fn from(value: &TraceDataInnerNeTypeList) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for TraceDataInnerNeTypeList {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]+$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for TraceDataInnerNeTypeList {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for TraceDataInnerNeTypeList {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for TraceDataInnerNeTypeList {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for TraceDataInnerNeTypeList {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Trace Reference (see 3GPP TS 32.422).It shall be encoded as the
    /// concatenation of MCC, MNC and Trace ID as follows: <MCC><MNC>-<Trace ID>
    /// The Trace ID shall be encoded as a 3 octet string in hexadecimal
    /// representation. Each character in the Trace ID string shall take a value
    /// of "0" to "9", "a" to "f" or "A" to "F" and shall represent 4 bits. The
    /// most significant character representing the 4 most significant bits of
    /// the Trace ID shall appear first  in the string, and the character
    /// representing the 4 least significant bit of the Trace ID shall appear
    /// last in the string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Trace Reference (see 3GPP TS 32.422).It shall be
    /// encoded as the concatenation of MCC, MNC and Trace ID as follows:
    /// <MCC><MNC>-<Trace ID> The Trace ID shall be encoded as a 3 octet string
    /// in hexadecimal representation. Each character in the Trace ID string
    /// shall take a value of \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\"
    /// and shall represent 4 bits. The most significant character representing
    /// the 4 most significant bits of the Trace ID shall appear first  in the
    /// string, and the character representing the 4 least significant bit of
    /// the Trace ID shall appear last in the string.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9]{3}[0-9]{2,3}-[A-Fa-f0-9]{6}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct TraceDataInnerTraceRef(String);
    impl ::std::ops::Deref for TraceDataInnerTraceRef {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<TraceDataInnerTraceRef> for String {
        fn from(value: TraceDataInnerTraceRef) -> Self {
            value.0
        }
    }

    impl From<&TraceDataInnerTraceRef> for TraceDataInnerTraceRef {
        fn from(value: &TraceDataInnerTraceRef) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for TraceDataInnerTraceRef {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9]{3}[0-9]{2,3}-[A-Fa-f0-9]{6}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9]{3}[0-9]{2,3}-[A-Fa-f0-9]{6}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for TraceDataInnerTraceRef {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for TraceDataInnerTraceRef {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for TraceDataInnerTraceRef {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for TraceDataInnerTraceRef {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///The enumeration TraceDepth defines how detailed information should be
    /// recorded in the trace. See 3GPP TS 32.422 for further description of the
    /// values. It shall comply with the provisions defined in table 5.6.3.1-1
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The enumeration TraceDepth defines how detailed
    /// information should be recorded in the trace. See 3GPP TS 32.422 for
    /// further description of the values. It shall comply with the provisions
    /// defined in table 5.6.3.1-1\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "MINIMUM",
    ///    "MEDIUM",
    ///    "MAXIMUM",
    ///    "MINIMUM_WO_VENDOR_EXTENSION",
    ///    "MEDIUM_WO_VENDOR_EXTENSION",
    ///    "MAXIMUM_WO_VENDOR_EXTENSION"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TraceDepth {
        #[serde(rename = "MINIMUM")]
        Minimum,
        #[serde(rename = "MEDIUM")]
        Medium,
        #[serde(rename = "MAXIMUM")]
        Maximum,
        #[serde(rename = "MINIMUM_WO_VENDOR_EXTENSION")]
        MinimumWoVendorExtension,
        #[serde(rename = "MEDIUM_WO_VENDOR_EXTENSION")]
        MediumWoVendorExtension,
        #[serde(rename = "MAXIMUM_WO_VENDOR_EXTENSION")]
        MaximumWoVendorExtension,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&TraceDepth> for TraceDepth {
        fn from(value: &TraceDepth) -> Self {
            value.clone()
        }
    }

    impl ToString for TraceDepth {
        fn to_string(&self) -> String {
            match *self {
                Self::Minimum => "MINIMUM".to_string(),
                Self::Medium => "MEDIUM".to_string(),
                Self::Maximum => "MAXIMUM".to_string(),
                Self::MinimumWoVendorExtension => "MINIMUM_WO_VENDOR_EXTENSION".to_string(),
                Self::MediumWoVendorExtension => "MEDIUM_WO_VENDOR_EXTENSION".to_string(),
                Self::MaximumWoVendorExtension => "MAXIMUM_WO_VENDOR_EXTENSION".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for TraceDepth {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "MINIMUM" => Ok(Self::Minimum),
                "MEDIUM" => Ok(Self::Medium),
                "MAXIMUM" => Ok(Self::Maximum),
                "MINIMUM_WO_VENDOR_EXTENSION" => Ok(Self::MinimumWoVendorExtension),
                "MEDIUM_WO_VENDOR_EXTENSION" => Ok(Self::MediumWoVendorExtension),
                "MAXIMUM_WO_VENDOR_EXTENSION" => Ok(Self::MaximumWoVendorExtension),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for TraceDepth {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TraceDepth {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TraceDepth {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Identifies the detailed traffic characterization.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Identifies the detailed traffic characterization.",
    ///  "type": "object",
    ///  "anyOf": [
    ///    {
    ///      "required": [
    ///        "ulVol"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "dlVol"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "appId": {
    ///      "$ref": "#/components/schemas/ApplicationId"
    ///    },
    ///    "dlVol": {
    ///      "$ref": "#/components/schemas/Volume"
    ///    },
    ///    "dlVolVariance": {
    ///      "$ref": "#/components/schemas/Float"
    ///    },
    ///    "dnn": {
    ///      "$ref": "#/components/schemas/Dnn"
    ///    },
    ///    "fDescs": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IpEthFlowDescription"
    ///      },
    ///      "maxItems": 2,
    ///      "minItems": 1
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    },
    ///    "ulVol": {
    ///      "$ref": "#/components/schemas/Volume"
    ///    },
    ///    "ulVolVariance": {
    ///      "$ref": "#/components/schemas/Float"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum TrafficCharacterization {
        Variant0 {
            #[serde(rename = "appId", default, skip_serializing_if = "Option::is_none")]
            app_id: Option<ApplicationId>,
            #[serde(
                rename = "dlVolVariance",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            dl_vol_variance: Option<Float>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            dnn: Option<Dnn>,
            #[serde(rename = "fDescs", default, skip_serializing_if = "Vec::is_empty")]
            f_descs: Vec<IpEthFlowDescription>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            snssai: Option<Snssai>,
            #[serde(rename = "ulVol")]
            ul_vol: Volume,
            #[serde(
                rename = "ulVolVariance",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            ul_vol_variance: Option<Float>,
        },
        Variant1 {
            #[serde(rename = "appId", default, skip_serializing_if = "Option::is_none")]
            app_id: Option<ApplicationId>,
            #[serde(rename = "dlVol")]
            dl_vol: Volume,
            #[serde(
                rename = "dlVolVariance",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            dl_vol_variance: Option<Float>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            dnn: Option<Dnn>,
            #[serde(rename = "fDescs", default, skip_serializing_if = "Vec::is_empty")]
            f_descs: Vec<IpEthFlowDescription>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            snssai: Option<Snssai>,
            #[serde(
                rename = "ulVolVariance",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            ul_vol_variance: Option<Float>,
        },
    }

    impl From<&TrafficCharacterization> for TrafficCharacterization {
        fn from(value: &TrafficCharacterization) -> Self {
            value.clone()
        }
    }

    ///Represents the Traffic Descriptor
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the Traffic Descriptor",
    ///  "type": "object",
    ///  "properties": {
    ///    "dddTrafficDescriptorList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DddTrafficDescriptor"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "dnn": {
    ///      "$ref": "#/components/schemas/Dnn"
    ///    },
    ///    "sNssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TrafficDescriptor {
        #[serde(
            rename = "dddTrafficDescriptorList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub ddd_traffic_descriptor_list: Vec<DddTrafficDescriptor>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dnn: Option<Dnn>,
        #[serde(rename = "sNssai", default, skip_serializing_if = "Option::is_none")]
        pub s_nssai: Option<Snssai>,
    }

    impl From<&TrafficDescriptor> for TrafficDescriptor {
        fn from(value: &TrafficDescriptor) -> Self {
            value.clone()
        }
    }

    ///Traffic information including UL/DL data rate and/or Traffic volume.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Traffic information including UL/DL data rate and/or
    /// Traffic volume.",
    ///  "type": "object",
    ///  "anyOf": [
    ///    {
    ///      "required": [
    ///        "uplinkRate"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "downlinkRate"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "uplinkVolume"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "downlinkVolume"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "totalVolume"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "downlinkRate": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "downlinkVolume": {
    ///      "$ref": "#/components/schemas/Volume"
    ///    },
    ///    "totalVolume": {
    ///      "$ref": "#/components/schemas/Volume"
    ///    },
    ///    "uplinkRate": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "uplinkVolume": {
    ///      "$ref": "#/components/schemas/Volume"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum TrafficInformation {
        Variant0 {
            #[serde(rename = "uplinkRate")]
            uplink_rate: BitRate,
        },
        Variant1 {
            #[serde(rename = "downlinkRate")]
            downlink_rate: BitRate,
        },
        Variant2 {
            #[serde(rename = "uplinkVolume")]
            uplink_volume: Volume,
        },
        Variant3 {
            #[serde(rename = "downlinkVolume")]
            downlink_volume: Volume,
        },
        Variant4 {
            #[serde(rename = "totalVolume")]
            total_volume: Volume,
        },
    }

    impl From<&TrafficInformation> for TrafficInformation {
        fn from(value: &TrafficInformation) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - SINGLE_TRANS_UL: Uplink single packet transmission.
    /// - SINGLE_TRANS_DL: Downlink single packet transmission.
    /// - DUAL_TRANS_UL_FIRST: Dual packet transmission, firstly uplink packet
    ///   transmission
    ///  with subsequent downlink packet transmission.
    /// - DUAL_TRANS_DL_FIRST: Dual packet transmission, firstly downlink packet
    ///   transmission
    ///  with subsequent uplink packet transmission.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- SINGLE_TRANS_UL: Uplink single
    /// packet transmission.\n- SINGLE_TRANS_DL: Downlink single packet
    /// transmission.\n- DUAL_TRANS_UL_FIRST: Dual packet transmission, firstly
    /// uplink packet transmission\n  with subsequent downlink packet
    /// transmission.\n- DUAL_TRANS_DL_FIRST: Dual packet transmission, firstly
    /// downlink packet transmission\n  with subsequent uplink packet
    /// transmission. \n",
    ///  "type": "string",
    ///  "enum": [
    ///    "SINGLE_TRANS_UL",
    ///    "SINGLE_TRANS_DL",
    ///    "DUAL_TRANS_UL_FIRST",
    ///    "DUAL_TRANS_DL_FIRST",
    ///    "MULTI_TRANS"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TrafficProfile {
        #[serde(rename = "SINGLE_TRANS_UL")]
        SingleTransUl,
        #[serde(rename = "SINGLE_TRANS_DL")]
        SingleTransDl,
        #[serde(rename = "DUAL_TRANS_UL_FIRST")]
        DualTransUlFirst,
        #[serde(rename = "DUAL_TRANS_DL_FIRST")]
        DualTransDlFirst,
        #[serde(rename = "MULTI_TRANS")]
        MultiTrans,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&TrafficProfile> for TrafficProfile {
        fn from(value: &TrafficProfile) -> Self {
            value.clone()
        }
    }

    impl ToString for TrafficProfile {
        fn to_string(&self) -> String {
            match *self {
                Self::SingleTransUl => "SINGLE_TRANS_UL".to_string(),
                Self::SingleTransDl => "SINGLE_TRANS_DL".to_string(),
                Self::DualTransUlFirst => "DUAL_TRANS_UL_FIRST".to_string(),
                Self::DualTransDlFirst => "DUAL_TRANS_DL_FIRST".to_string(),
                Self::MultiTrans => "MULTI_TRANS".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for TrafficProfile {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SINGLE_TRANS_UL" => Ok(Self::SingleTransUl),
                "SINGLE_TRANS_DL" => Ok(Self::SingleTransDl),
                "DUAL_TRANS_UL_FIRST" => Ok(Self::DualTransUlFirst),
                "DUAL_TRANS_DL_FIRST" => Ok(Self::DualTransDlFirst),
                "MULTI_TRANS" => Ok(Self::MultiTrans),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for TrafficProfile {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TrafficProfile {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TrafficProfile {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates UE Context Transfer Reason
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates UE Context Transfer Reason",
    ///  "type": "string",
    ///  "enum": [
    ///    "INIT_REG",
    ///    "MOBI_REG",
    ///    "MOBI_REG_UE_VALIDATED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TransferReason {
        #[serde(rename = "INIT_REG")]
        InitReg,
        #[serde(rename = "MOBI_REG")]
        MobiReg,
        #[serde(rename = "MOBI_REG_UE_VALIDATED")]
        MobiRegUeValidated,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&TransferReason> for TransferReason {
        fn from(value: &TransferReason) -> Self {
            value.clone()
        }
    }

    impl ToString for TransferReason {
        fn to_string(&self) -> String {
            match *self {
                Self::InitReg => "INIT_REG".to_string(),
                Self::MobiReg => "MOBI_REG".to_string(),
                Self::MobiRegUeValidated => "MOBI_REG_UE_VALIDATED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for TransferReason {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "INIT_REG" => Ok(Self::InitReg),
                "MOBI_REG" => Ok(Self::MobiReg),
                "MOBI_REG_UE_VALIDATED" => Ok(Self::MobiRegUeValidated),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for TransferReason {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TransferReason {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TransferReason {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Possible values are:
    /// - UDP: User Datagram Protocol.
    /// - TCP: Transmission Control Protocol.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- UDP: User Datagram Protocol.\n-
    /// TCP: Transmission Control Protocol. \n",
    ///  "type": "string",
    ///  "enum": [
    ///    "UDP",
    ///    "TCP"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum TransportProtocol {
        #[serde(rename = "UDP")]
        Udp,
        #[serde(rename = "TCP")]
        Tcp,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&TransportProtocol> for TransportProtocol {
        fn from(value: &TransportProtocol) -> Self {
            value.clone()
        }
    }

    impl ToString for TransportProtocol {
        fn to_string(&self) -> String {
            match *self {
                Self::Udp => "UDP".to_string(),
                Self::Tcp => "TCP".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for TransportProtocol {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "UDP" => Ok(Self::Udp),
                "TCP" => Ok(Self::Tcp),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for TransportProtocol {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TransportProtocol {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TransportProtocol {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Contain the TWAP Identifier as defined in clause 4.2.8.5.3 of 3GPP TS
    /// 23.501 or the WLAN location information as defined in clause 4.5.7.2.8
    /// of 3GPP TS 23.402.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contain the TWAP Identifier as defined in clause
    /// 4.2.8.5.3 of 3GPP TS 23.501 or the WLAN location information as defined
    /// in clause 4.5.7.2.8 of 3GPP TS 23.402.\n",
    ///  "type": "object",
    ///  "required": [
    ///    "ssId"
    ///  ],
    ///  "properties": {
    ///    "bssId": {
    ///      "description": "When present, it shall contain the BSSID of the
    /// access point to which the UE is attached, for trusted WLAN access, see
    /// IEEE Std 802.11-2012. \n",
    ///      "type": "string"
    ///    },
    ///    "civicAddress": {
    ///      "$ref": "#/components/schemas/Bytes"
    ///    },
    ///    "ssId": {
    ///      "description": "This IE shall contain the SSID of the access point
    /// to which the UE is attached, that is received over NGAP, see IEEE Std
    /// 802.11-2012. \n",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct TwapId {
        ///When present, it shall contain the BSSID of the access point to
        /// which the UE is attached, for trusted WLAN access, see IEEE Std
        /// 802.11-2012.
        #[serde(rename = "bssId", default, skip_serializing_if = "Option::is_none")]
        pub bss_id: Option<String>,
        #[serde(
            rename = "civicAddress",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub civic_address: Option<Bytes>,
        ///This IE shall contain the SSID of the access point to which the UE
        /// is attached, that is received over NGAP, see IEEE Std 802.11-2012.
        #[serde(rename = "ssId")]
        pub ss_id: String,
    }

    impl From<&TwapId> for TwapId {
        fn from(value: &TwapId) -> Self {
            value.clone()
        }
    }

    ///Report Item for UE Access Behavior Trends event.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Report Item for UE Access Behavior Trends event.",
    ///  "type": "object",
    ///  "required": [
    ///    "duration",
    ///    "spacing",
    ///    "stateTransitionType"
    ///  ],
    ///  "properties": {
    ///    "duration": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "spacing": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "stateTransitionType": {
    ///      "$ref": "#/components/schemas/AccessStateTransitionType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeAccessBehaviorReportItem {
        pub duration: DurationSec,
        pub spacing: DurationSec,
        #[serde(rename = "stateTransitionType")]
        pub state_transition_type: AccessStateTransitionType,
    }

    impl From<&UeAccessBehaviorReportItem> for UeAccessBehaviorReportItem {
        fn from(value: &UeAccessBehaviorReportItem) -> Self {
            value.clone()
        }
    }

    ///Contains information about available UE related analytics contexts.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains information about available UE related
    /// analytics contexts.",
    ///  "type": "object",
    ///  "required": [
    ///    "anaTypes",
    ///    "supi"
    ///  ],
    ///  "properties": {
    ///    "anaTypes": {
    ///      "description": "List of analytics types for which UE related
    /// analytics contexts can be retrieved.\n",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NwdafEvent"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "supi": {
    ///      "$ref": "#/components/schemas/Supi"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeAnalyticsContextDescriptor {
        ///List of analytics types for which UE related analytics contexts can
        /// be retrieved.
        #[serde(rename = "anaTypes")]
        pub ana_types: Vec<NwdafEvent>,
        pub supi: Supi,
    }

    impl From<&UeAnalyticsContextDescriptor> for UeAnalyticsContextDescriptor {
        fn from(value: &UeAnalyticsContextDescriptor) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - AUTHORIZED: Indicates that the UE is authorized.
    /// - NOT_AUTHORIZED: Indicates that the UE is not authorized.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- AUTHORIZED: Indicates that the
    /// UE is authorized.\n- NOT_AUTHORIZED: Indicates that the UE is not
    /// authorized.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "AUTHORIZED",
    ///    "NOT_AUTHORIZED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UeAuth {
        #[serde(rename = "AUTHORIZED")]
        Authorized,
        #[serde(rename = "NOT_AUTHORIZED")]
        NotAuthorized,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&UeAuth> for UeAuth {
        fn from(value: &UeAuth) -> Self {
            value.clone()
        }
    }

    impl ToString for UeAuth {
        fn to_string(&self) -> String {
            match *self {
                Self::Authorized => "AUTHORIZED".to_string(),
                Self::NotAuthorized => "NOT_AUTHORIZED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for UeAuth {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AUTHORIZED" => Ok(Self::Authorized),
                "NOT_AUTHORIZED" => Ok(Self::NotAuthorized),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for UeAuth {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for UeAuth {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for UeAuth {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents UE communication information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents UE communication information.",
    ///  "type": "object",
    ///  "allOf": [
    ///    {
    ///      "required": [
    ///        "commDur"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "trafChar"
    ///      ]
    ///    },
    ///    {
    ///      "oneOf": [
    ///        {
    ///          "required": [
    ///            "ts"
    ///          ]
    ///        },
    ///        {
    ///          "required": [
    ///            "recurringTime"
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "anaOfAppList": {
    ///      "$ref": "#/components/schemas/AppListForUeComm"
    ///    },
    ///    "commDur": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "commDurVariance": {
    ///      "$ref": "#/components/schemas/Float"
    ///    },
    ///    "confidence": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "perioCommInd": {
    ///      "type": "boolean"
    ///    },
    ///    "perioTime": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "perioTimeVariance": {
    ///      "$ref": "#/components/schemas/Float"
    ///    },
    ///    "ratio": {
    ///      "$ref": "#/components/schemas/SamplingRatio"
    ///    },
    ///    "recurringTime": {
    ///      "$ref": "#/components/schemas/schemas-ScheduledCommunicationTime"
    ///    },
    ///    "sessInactTimer": {
    ///      "$ref": "#/components/schemas/SessInactTimerForUeComm"
    ///    },
    ///    "trafChar": {
    ///      "$ref": "#/components/schemas/TrafficCharacterization"
    ///    },
    ///    "ts": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "tsVariance": {
    ///      "$ref": "#/components/schemas/Float"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum UeCommunication {
        Variant0 {
            #[serde(
                rename = "anaOfAppList",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            ana_of_app_list: Option<AppListForUeComm>,
            #[serde(rename = "commDur")]
            comm_dur: DurationSec,
            #[serde(
                rename = "commDurVariance",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            comm_dur_variance: Option<Float>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            #[serde(
                rename = "perioCommInd",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            perio_comm_ind: Option<bool>,
            #[serde(rename = "perioTime", default, skip_serializing_if = "Option::is_none")]
            perio_time: Option<DurationSec>,
            #[serde(
                rename = "perioTimeVariance",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            perio_time_variance: Option<Float>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            ratio: Option<SamplingRatio>,
            #[serde(
                rename = "sessInactTimer",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            sess_inact_timer: Option<SessInactTimerForUeComm>,
            #[serde(rename = "trafChar")]
            traf_char: TrafficCharacterization,
            ts: DateTime,
            #[serde(
                rename = "tsVariance",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            ts_variance: Option<Float>,
        },
        Variant1 {
            #[serde(
                rename = "anaOfAppList",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            ana_of_app_list: Option<AppListForUeComm>,
            #[serde(rename = "commDur")]
            comm_dur: DurationSec,
            #[serde(
                rename = "commDurVariance",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            comm_dur_variance: Option<Float>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            #[serde(
                rename = "perioCommInd",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            perio_comm_ind: Option<bool>,
            #[serde(rename = "perioTime", default, skip_serializing_if = "Option::is_none")]
            perio_time: Option<DurationSec>,
            #[serde(
                rename = "perioTimeVariance",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            perio_time_variance: Option<Float>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            ratio: Option<SamplingRatio>,
            #[serde(rename = "recurringTime")]
            recurring_time: SchemasScheduledCommunicationTime,
            #[serde(
                rename = "sessInactTimer",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            sess_inact_timer: Option<SessInactTimerForUeComm>,
            #[serde(rename = "trafChar")]
            traf_char: TrafficCharacterization,
            #[serde(
                rename = "tsVariance",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            ts_variance: Option<Float>,
        },
    }

    impl From<&UeCommunication> for UeCommunication {
        fn from(value: &UeCommunication) -> Self {
            value.clone()
        }
    }

    ///Represents an individual ueContext resource
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents an individual ueContext resource",
    ///  "type": "object",
    ///  "properties": {
    ///    "5gMmCapability": {
    ///      "$ref": "#/components/schemas/Bytes"
    ///    },
    ///    "amPolicyReqTriggerList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PolicyReqTrigger"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "analyticsSubscriptionList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AnalyticsSubscription"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "asTimeDisParam": {
    ///      "$ref": "#/components/schemas/AsTimeDistributionParam"
    ///    },
    ///    "astiDistributionIndication": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "ausfGroupId": {
    ///      "$ref": "#/components/schemas/NfGroupId"
    ///    },
    ///    "cMsisdn": {
    ///      "$ref": "#/components/schemas/CMsisdn"
    ///    },
    ///    "cagData": {
    ///      "$ref": "#/components/schemas/CagData"
    ///    },
    ///    "disasterPlmn": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    },
    ///    "disasterRoamingInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "drxParameter": {
    ///      "$ref": "#/components/schemas/Bytes"
    ///    },
    ///    "ecRestrictionDataNb": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "ecRestrictionDataWb": {
    ///      "$ref": "#/components/schemas/EcRestrictionDataWb"
    ///    },
    ///    "epsInterworkingInfo": {
    ///      "$ref": "#/components/schemas/EpsInterworkingInfo"
    ///    },
    ///    "eventSubscriptionList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ExtAmfEventSubscription"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "forbiddenAreaList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Area"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "gpsiList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Gpsi"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "groupList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/GroupId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "hNwPubKeyId": {
    ///      "type": "integer"
    ///    },
    ///    "hpcfId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "hpcfSetId": {
    ///      "$ref": "#/components/schemas/NfSetId"
    ///    },
    ///    "iabOperationAllowed": {
    ///      "type": "boolean"
    ///    },
    ///    "immediateMdtConf": {
    ///      "$ref": "#/components/schemas/ImmediateMdtConf"
    ///    },
    ///    "lteCatMInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "managementMdtInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "mmContextList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/MmContext"
    ///      },
    ///      "maxItems": 2,
    ///      "minItems": 1
    ///    },
    ///    "moExpDataCounter": {
    ///      "$ref": "#/components/schemas/MoExpDataCounter"
    ///    },
    ///    "msClassmark2": {
    ///      "$ref": "#/components/schemas/Bytes"
    ///    },
    ///    "pcfAmPolicyUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "pcfAmpBindingInfo": {
    ///      "type": "string"
    ///    },
    ///    "pcfAmpServiceSetId": {
    ///      "$ref": "#/components/schemas/NfServiceSetId"
    ///    },
    ///    "pcfBinding": {
    ///      "$ref": "#/components/schemas/SbiBindingLevel"
    ///    },
    ///    "pcfGroupId": {
    ///      "$ref": "#/components/schemas/NfGroupId"
    ///    },
    ///    "pcfId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "pcfRfsp": {
    ///      "$ref": "#/components/schemas/RfspIndex"
    ///    },
    ///    "pcfSetId": {
    ///      "$ref": "#/components/schemas/NfSetId"
    ///    },
    ///    "pcfUeAmbr": {
    ///      "$ref": "#/components/schemas/Ambr"
    ///    },
    ///    "pcfUeCallbackInfo": {
    ///      "$ref": "#/components/schemas/PcfUeCallbackInfo"
    ///    },
    ///    "pcfUePolicyUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "pcfUeSliceMbrList": {
    ///      "description": "A map(list of key-value pairs) where Snssai serves
    /// as key.",
    ///      "type": "object",
    ///      "minProperties": 1,
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/SliceMbr"
    ///      }
    ///    },
    ///    "pcfUepBindingInfo": {
    ///      "type": "string"
    ///    },
    ///    "pcfUepServiceSetId": {
    ///      "$ref": "#/components/schemas/NfServiceSetId"
    ///    },
    ///    "pei": {
    ///      "$ref": "#/components/schemas/Pei"
    ///    },
    ///    "praInAmPolicy": {
    ///      "description": "A map(list of key-value pairs) where praId serves
    /// as key.",
    ///      "type": "object",
    ///      "minProperties": 1,
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/PresenceInfo"
    ///      }
    ///    },
    ///    "praInUePolicy": {
    ///      "description": "A map(list of key-value pairs) where praId serves
    /// as key.",
    ///      "type": "object",
    ///      "minProperties": 1,
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/PresenceInfo"
    ///      }
    ///    },
    ///    "proseContext": {
    ///      "$ref": "#/components/schemas/ProseContext"
    ///    },
    ///    "redCapInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "restrictedCoreNwTypeList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CoreNetworkType"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "restrictedPrimaryRatList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RatType"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "restrictedRatList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RatType"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "restrictedSecondaryRatList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RatType"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "routingIndicator": {
    ///      "type": "string"
    ///    },
    ///    "seafData": {
    ///      "$ref": "#/components/schemas/SeafData"
    ///    },
    ///    "serviceAreaRestriction": {
    ///      "$ref": "#/components/schemas/ServiceAreaRestriction"
    ///    },
    ///    "serviceGapExpiryTime": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "sessionContextList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PduSessionContext"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "smPolicyNotifyPduList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PduSessionInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "smallDataRateStatusInfos": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SmallDataRateStatusInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "smfSelInfo": {
    ///      "$ref": "#/components/schemas/SmfSelectionData"
    ///    },
    ///    "smsfBindingInfo": {
    ///      "type": "string"
    ///    },
    ///    "smsfId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "smsfServiceSetId": {
    ///      "$ref": "#/components/schemas/NfServiceSetId"
    ///    },
    ///    "smsfSetId": {
    ///      "$ref": "#/components/schemas/NfSetId"
    ///    },
    ///    "snpnOnboardInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "stnSr": {
    ///      "$ref": "#/components/schemas/StnSr"
    ///    },
    ///    "subRfsp": {
    ///      "$ref": "#/components/schemas/RfspIndex"
    ///    },
    ///    "subUeAmbr": {
    ///      "$ref": "#/components/schemas/Ambr"
    ///    },
    ///    "subUeSliceMbrList": {
    ///      "description": "A map(list of key-value pairs) where Snssai serves
    /// as key.",
    ///      "type": "object",
    ///      "minProperties": 1,
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/SliceMbr"
    ///      }
    ///    },
    ///    "supi": {
    ///      "$ref": "#/components/schemas/Supi"
    ///    },
    ///    "supiUnauthInd": {
    ///      "type": "boolean"
    ///    },
    ///    "supportedCodecList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Bytes"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "traceData": {
    ///      "$ref": "#/components/schemas/TraceData"
    ///    },
    ///    "tsErrorBudget": {
    ///      "type": "integer"
    ///    },
    ///    "udmGroupId": {
    ///      "$ref": "#/components/schemas/NfGroupId"
    ///    },
    ///    "uePolicyReqTriggerList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PolicyReqTrigger"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "uePositioningCap": {
    ///      "$ref": "#/components/schemas/UePositioningCapabilities"
    ///    },
    ///    "updpSubscriptionData": {
    ///      "$ref": "#/components/schemas/UpdpSubscriptionData"
    ///    },
    ///    "usedRfsp": {
    ///      "$ref": "#/components/schemas/RfspIndex"
    ///    },
    ///    "usedServiceAreaRestriction": {
    ///      "$ref": "#/components/schemas/ServiceAreaRestriction"
    ///    },
    ///    "v2xContext": {
    ///      "$ref": "#/components/schemas/V2xContext"
    ///    },
    ///    "wlServAreaRes": {
    ///      "$ref": "#/components/schemas/WirelineServiceAreaRestriction"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeContext {
        #[serde(
            rename = "amPolicyReqTriggerList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub am_policy_req_trigger_list: Vec<PolicyReqTrigger>,
        #[serde(
            rename = "analyticsSubscriptionList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub analytics_subscription_list: Vec<AnalyticsSubscription>,
        #[serde(
            rename = "asTimeDisParam",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub as_time_dis_param: Option<AsTimeDistributionParam>,
        #[serde(rename = "astiDistributionIndication", default)]
        pub asti_distribution_indication: bool,
        #[serde(
            rename = "ausfGroupId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ausf_group_id: Option<NfGroupId>,
        #[serde(rename = "cMsisdn", default, skip_serializing_if = "Option::is_none")]
        pub c_msisdn: Option<CMsisdn>,
        #[serde(rename = "cagData", default, skip_serializing_if = "Option::is_none")]
        pub cag_data: Option<CagData>,
        #[serde(
            rename = "disasterPlmn",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub disaster_plmn: Option<PlmnId>,
        #[serde(rename = "disasterRoamingInd", default)]
        pub disaster_roaming_ind: bool,
        #[serde(
            rename = "drxParameter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub drx_parameter: Option<Bytes>,
        #[serde(rename = "ecRestrictionDataNb", default)]
        pub ec_restriction_data_nb: bool,
        #[serde(
            rename = "ecRestrictionDataWb",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ec_restriction_data_wb: Option<EcRestrictionDataWb>,
        #[serde(
            rename = "epsInterworkingInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub eps_interworking_info: Option<EpsInterworkingInfo>,
        #[serde(
            rename = "eventSubscriptionList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub event_subscription_list: Vec<ExtAmfEventSubscription>,
        #[serde(
            rename = "5gMmCapability",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub five_g_mm_capability: Option<Bytes>,
        #[serde(
            rename = "forbiddenAreaList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub forbidden_area_list: Vec<Area>,
        #[serde(rename = "gpsiList", default, skip_serializing_if = "Vec::is_empty")]
        pub gpsi_list: Vec<Gpsi>,
        #[serde(rename = "groupList", default, skip_serializing_if = "Vec::is_empty")]
        pub group_list: Vec<GroupId>,
        #[serde(
            rename = "hNwPubKeyId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub h_nw_pub_key_id: Option<i64>,
        #[serde(rename = "hpcfId", default, skip_serializing_if = "Option::is_none")]
        pub hpcf_id: Option<NfInstanceId>,
        #[serde(rename = "hpcfSetId", default, skip_serializing_if = "Option::is_none")]
        pub hpcf_set_id: Option<NfSetId>,
        #[serde(
            rename = "iabOperationAllowed",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub iab_operation_allowed: Option<bool>,
        #[serde(
            rename = "immediateMdtConf",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub immediate_mdt_conf: Option<ImmediateMdtConf>,
        #[serde(rename = "lteCatMInd", default)]
        pub lte_cat_m_ind: bool,
        #[serde(rename = "managementMdtInd", default)]
        pub management_mdt_ind: bool,
        #[serde(
            rename = "mmContextList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub mm_context_list: Vec<MmContext>,
        #[serde(
            rename = "moExpDataCounter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub mo_exp_data_counter: Option<MoExpDataCounter>,
        #[serde(
            rename = "msClassmark2",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ms_classmark2: Option<Bytes>,
        #[serde(
            rename = "pcfAmPolicyUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pcf_am_policy_uri: Option<Uri>,
        #[serde(
            rename = "pcfAmpBindingInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pcf_amp_binding_info: Option<String>,
        #[serde(
            rename = "pcfAmpServiceSetId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pcf_amp_service_set_id: Option<NfServiceSetId>,
        #[serde(
            rename = "pcfBinding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pcf_binding: Option<SbiBindingLevel>,
        #[serde(
            rename = "pcfGroupId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pcf_group_id: Option<NfGroupId>,
        #[serde(rename = "pcfId", default, skip_serializing_if = "Option::is_none")]
        pub pcf_id: Option<NfInstanceId>,
        #[serde(rename = "pcfRfsp", default, skip_serializing_if = "Option::is_none")]
        pub pcf_rfsp: Option<RfspIndex>,
        #[serde(rename = "pcfSetId", default, skip_serializing_if = "Option::is_none")]
        pub pcf_set_id: Option<NfSetId>,
        #[serde(rename = "pcfUeAmbr", default, skip_serializing_if = "Option::is_none")]
        pub pcf_ue_ambr: Option<Ambr>,
        #[serde(
            rename = "pcfUeCallbackInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pcf_ue_callback_info: Option<PcfUeCallbackInfo>,
        #[serde(
            rename = "pcfUePolicyUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pcf_ue_policy_uri: Option<Uri>,
        ///A map(list of key-value pairs) where Snssai serves as key.
        #[serde(
            rename = "pcfUeSliceMbrList",
            default,
            skip_serializing_if = "::std::collections::HashMap::is_empty"
        )]
        pub pcf_ue_slice_mbr_list: ::std::collections::HashMap<String, SliceMbr>,
        #[serde(
            rename = "pcfUepBindingInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pcf_uep_binding_info: Option<String>,
        #[serde(
            rename = "pcfUepServiceSetId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pcf_uep_service_set_id: Option<NfServiceSetId>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pei: Option<Pei>,
        ///A map(list of key-value pairs) where praId serves as key.
        #[serde(
            rename = "praInAmPolicy",
            default,
            skip_serializing_if = "::std::collections::HashMap::is_empty"
        )]
        pub pra_in_am_policy: ::std::collections::HashMap<String, PresenceInfo>,
        ///A map(list of key-value pairs) where praId serves as key.
        #[serde(
            rename = "praInUePolicy",
            default,
            skip_serializing_if = "::std::collections::HashMap::is_empty"
        )]
        pub pra_in_ue_policy: ::std::collections::HashMap<String, PresenceInfo>,
        #[serde(
            rename = "proseContext",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub prose_context: Option<ProseContext>,
        #[serde(rename = "redCapInd", default)]
        pub red_cap_ind: bool,
        #[serde(
            rename = "restrictedCoreNwTypeList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub restricted_core_nw_type_list: Vec<CoreNetworkType>,
        #[serde(
            rename = "restrictedPrimaryRatList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub restricted_primary_rat_list: Vec<RatType>,
        #[serde(
            rename = "restrictedRatList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub restricted_rat_list: Vec<RatType>,
        #[serde(
            rename = "restrictedSecondaryRatList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub restricted_secondary_rat_list: Vec<RatType>,
        #[serde(
            rename = "routingIndicator",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub routing_indicator: Option<String>,
        #[serde(rename = "seafData", default, skip_serializing_if = "Option::is_none")]
        pub seaf_data: Option<SeafData>,
        #[serde(
            rename = "serviceAreaRestriction",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub service_area_restriction: Option<ServiceAreaRestriction>,
        #[serde(
            rename = "serviceGapExpiryTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub service_gap_expiry_time: Option<DateTime>,
        #[serde(
            rename = "sessionContextList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub session_context_list: Vec<PduSessionContext>,
        #[serde(
            rename = "smPolicyNotifyPduList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub sm_policy_notify_pdu_list: Vec<PduSessionInfo>,
        #[serde(
            rename = "smallDataRateStatusInfos",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub small_data_rate_status_infos: Vec<SmallDataRateStatusInfo>,
        #[serde(
            rename = "smfSelInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub smf_sel_info: Option<SmfSelectionData>,
        #[serde(
            rename = "smsfBindingInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub smsf_binding_info: Option<String>,
        #[serde(rename = "smsfId", default, skip_serializing_if = "Option::is_none")]
        pub smsf_id: Option<NfInstanceId>,
        #[serde(
            rename = "smsfServiceSetId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub smsf_service_set_id: Option<NfServiceSetId>,
        #[serde(rename = "smsfSetId", default, skip_serializing_if = "Option::is_none")]
        pub smsf_set_id: Option<NfSetId>,
        #[serde(rename = "snpnOnboardInd", default)]
        pub snpn_onboard_ind: bool,
        #[serde(rename = "stnSr", default, skip_serializing_if = "Option::is_none")]
        pub stn_sr: Option<StnSr>,
        #[serde(rename = "subRfsp", default, skip_serializing_if = "Option::is_none")]
        pub sub_rfsp: Option<RfspIndex>,
        #[serde(rename = "subUeAmbr", default, skip_serializing_if = "Option::is_none")]
        pub sub_ue_ambr: Option<Ambr>,
        ///A map(list of key-value pairs) where Snssai serves as key.
        #[serde(
            rename = "subUeSliceMbrList",
            default,
            skip_serializing_if = "::std::collections::HashMap::is_empty"
        )]
        pub sub_ue_slice_mbr_list: ::std::collections::HashMap<String, SliceMbr>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub supi: Option<Supi>,
        #[serde(
            rename = "supiUnauthInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supi_unauth_ind: Option<bool>,
        #[serde(
            rename = "supportedCodecList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub supported_codec_list: Vec<Bytes>,
        #[serde(rename = "traceData", default, skip_serializing_if = "Option::is_none")]
        pub trace_data: Option<TraceData>,
        #[serde(
            rename = "tsErrorBudget",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ts_error_budget: Option<i64>,
        #[serde(
            rename = "udmGroupId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub udm_group_id: Option<NfGroupId>,
        #[serde(
            rename = "uePolicyReqTriggerList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub ue_policy_req_trigger_list: Vec<PolicyReqTrigger>,
        #[serde(
            rename = "uePositioningCap",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_positioning_cap: Option<UePositioningCapabilities>,
        #[serde(
            rename = "updpSubscriptionData",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updp_subscription_data: Option<UpdpSubscriptionData>,
        #[serde(rename = "usedRfsp", default, skip_serializing_if = "Option::is_none")]
        pub used_rfsp: Option<RfspIndex>,
        #[serde(
            rename = "usedServiceAreaRestriction",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub used_service_area_restriction: Option<ServiceAreaRestriction>,
        #[serde(
            rename = "v2xContext",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub v2x_context: Option<V2xContext>,
        #[serde(
            rename = "wlServAreaRes",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub wl_serv_area_res: Option<WirelineServiceAreaRestriction>,
    }

    impl From<&UeContext> for UeContext {
        fn from(value: &UeContext) -> Self {
            value.clone()
        }
    }

    ///Data structure used for cancellation of UE Context Relocation
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data structure used for cancellation of UE Context
    /// Relocation",
    ///  "type": "object",
    ///  "required": [
    ///    "relocationCancelRequest"
    ///  ],
    ///  "properties": {
    ///    "relocationCancelRequest": {
    ///      "$ref": "#/components/schemas/RefToBinaryData"
    ///    },
    ///    "supi": {
    ///      "$ref": "#/components/schemas/Supi"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeContextCancelRelocateData {
        #[serde(rename = "relocationCancelRequest")]
        pub relocation_cancel_request: RefToBinaryData,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub supi: Option<Supi>,
    }

    impl From<&UeContextCancelRelocateData> for UeContextCancelRelocateData {
        fn from(value: &UeContextCancelRelocateData) -> Self {
            value.clone()
        }
    }

    ///Data within a request to create an individual ueContext resource
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a request to create an individual ueContext
    /// resource",
    ///  "type": "object",
    ///  "required": [
    ///    "pduSessionList",
    ///    "sourceToTargetData",
    ///    "targetId",
    ///    "ueContext"
    ///  ],
    ///  "properties": {
    ///    "n2NotifyUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "ngapCause": {
    ///      "$ref": "#/components/schemas/NgApCause"
    ///    },
    ///    "pduSessionList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/N2SmInformation"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "servingNetwork": {
    ///      "$ref": "#/components/schemas/PlmnIdNid"
    ///    },
    ///    "sourceToTargetData": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    },
    ///    "targetId": {
    ///      "$ref": "#/components/schemas/NgRanTargetId"
    ///    },
    ///    "ueContext": {
    ///      "$ref": "#/components/schemas/UeContext"
    ///    },
    ///    "ueRadioCapability": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    },
    ///    "ueRadioCapabilityForPaging": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeContextCreateData {
        #[serde(
            rename = "n2NotifyUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n2_notify_uri: Option<Uri>,
        #[serde(rename = "ngapCause", default, skip_serializing_if = "Option::is_none")]
        pub ngap_cause: Option<NgApCause>,
        #[serde(rename = "pduSessionList")]
        pub pdu_session_list: Vec<N2SmInformation>,
        #[serde(
            rename = "servingNetwork",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub serving_network: Option<PlmnIdNid>,
        #[serde(rename = "sourceToTargetData")]
        pub source_to_target_data: N2InfoContent,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
        #[serde(rename = "targetId")]
        pub target_id: NgRanTargetId,
        #[serde(rename = "ueContext")]
        pub ue_context: UeContext,
        #[serde(
            rename = "ueRadioCapability",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_radio_capability: Option<N2InfoContent>,
        #[serde(
            rename = "ueRadioCapabilityForPaging",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_radio_capability_for_paging: Option<N2InfoContent>,
    }

    impl From<&UeContextCreateData> for UeContextCreateData {
        fn from(value: &UeContextCreateData) -> Self {
            value.clone()
        }
    }

    ///Data within a failure response for creating a UE context
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a failure response for creating a UE
    /// context",
    ///  "type": "object",
    ///  "required": [
    ///    "error"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "$ref": "#/components/schemas/ProblemDetails"
    ///    },
    ///    "ngapCause": {
    ///      "$ref": "#/components/schemas/NgApCause"
    ///    },
    ///    "targetToSourceFailureData": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeContextCreateError {
        pub error: ProblemDetails,
        #[serde(rename = "ngapCause", default, skip_serializing_if = "Option::is_none")]
        pub ngap_cause: Option<NgApCause>,
        #[serde(
            rename = "targetToSourceFailureData",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub target_to_source_failure_data: Option<N2InfoContent>,
    }

    impl From<&UeContextCreateError> for UeContextCreateError {
        fn from(value: &UeContextCreateError) -> Self {
            value.clone()
        }
    }

    ///Data within a successful response for creating an individual ueContext
    /// resource
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a successful response for creating an
    /// individual ueContext resource",
    ///  "type": "object",
    ///  "required": [
    ///    "pduSessionList",
    ///    "targetToSourceData",
    ///    "ueContext"
    ///  ],
    ///  "properties": {
    ///    "analyticsNotUsedList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Uri"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "failedSessionList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/N2SmInformation"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "pcfReselectedInd": {
    ///      "type": "boolean"
    ///    },
    ///    "pduSessionList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/N2SmInformation"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    },
    ///    "targetToSourceData": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    },
    ///    "ueContext": {
    ///      "$ref": "#/components/schemas/UeContext"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeContextCreatedData {
        #[serde(
            rename = "analyticsNotUsedList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub analytics_not_used_list: Vec<Uri>,
        #[serde(
            rename = "failedSessionList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub failed_session_list: Vec<N2SmInformation>,
        #[serde(
            rename = "pcfReselectedInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pcf_reselected_ind: Option<bool>,
        #[serde(rename = "pduSessionList")]
        pub pdu_session_list: Vec<N2SmInformation>,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
        #[serde(rename = "targetToSourceData")]
        pub target_to_source_data: N2InfoContent,
        #[serde(rename = "ueContext")]
        pub ue_context: UeContext,
    }

    impl From<&UeContextCreatedData> for UeContextCreatedData {
        fn from(value: &UeContextCreatedData) -> Self {
            value.clone()
        }
    }

    ///UE Context Information
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "UE Context Information",
    ///  "type": "object",
    ///  "properties": {
    ///    "accessType": {
    ///      "$ref": "#/components/schemas/AccessType"
    ///    },
    ///    "lastActTime": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    },
    ///    "ratType": {
    ///      "$ref": "#/components/schemas/RatType"
    ///    },
    ///    "supportVoPS": {
    ///      "type": "boolean"
    ///    },
    ///    "supportVoPSn3gpp": {
    ///      "type": "boolean"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeContextInfo {
        #[serde(
            rename = "accessType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub access_type: Option<AccessType>,
        #[serde(
            rename = "lastActTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub last_act_time: Option<DateTime>,
        #[serde(rename = "ratType", default, skip_serializing_if = "Option::is_none")]
        pub rat_type: Option<RatType>,
        #[serde(
            rename = "supportVoPSn3gpp",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub support_vo_p_sn3gpp: Option<bool>,
        #[serde(
            rename = "supportVoPS",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub support_vo_ps: Option<bool>,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
    }

    impl From<&UeContextInfo> for UeContextInfo {
        fn from(value: &UeContextInfo) -> Self {
            value.clone()
        }
    }

    ///Indicates the UE Context information class
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the UE Context information class",
    ///  "type": "string",
    ///  "enum": [
    ///    "TADS"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UeContextInfoClass {
        #[serde(rename = "TADS")]
        Tads,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&UeContextInfoClass> for UeContextInfoClass {
        fn from(value: &UeContextInfoClass) -> Self {
            value.clone()
        }
    }

    impl ToString for UeContextInfoClass {
        fn to_string(&self) -> String {
            match *self {
                Self::Tads => "TADS".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for UeContextInfoClass {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TADS" => Ok(Self::Tads),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for UeContextInfoClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for UeContextInfoClass {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for UeContextInfoClass {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Data within a Release UE Context request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a Release UE Context request",
    ///  "type": "object",
    ///  "required": [
    ///    "ngapCause"
    ///  ],
    ///  "properties": {
    ///    "ngapCause": {
    ///      "$ref": "#/components/schemas/NgApCause"
    ///    },
    ///    "supi": {
    ///      "$ref": "#/components/schemas/Supi"
    ///    },
    ///    "unauthenticatedSupi": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeContextRelease {
        #[serde(rename = "ngapCause")]
        pub ngap_cause: NgApCause,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub supi: Option<Supi>,
        #[serde(rename = "unauthenticatedSupi", default)]
        pub unauthenticated_supi: bool,
    }

    impl From<&UeContextRelease> for UeContextRelease {
        fn from(value: &UeContextRelease) -> Self {
            value.clone()
        }
    }

    ///Data within a Relocate UE Context request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a Relocate UE Context request",
    ///  "type": "object",
    ///  "required": [
    ///    "forwardRelocationRequest",
    ///    "sourceToTargetData",
    ///    "targetId",
    ///    "ueContext"
    ///  ],
    ///  "properties": {
    ///    "forwardRelocationRequest": {
    ///      "$ref": "#/components/schemas/RefToBinaryData"
    ///    },
    ///    "ngapCause": {
    ///      "$ref": "#/components/schemas/NgApCause"
    ///    },
    ///    "pduSessionList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/N2SmInformation"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "sourceToTargetData": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    },
    ///    "targetId": {
    ///      "$ref": "#/components/schemas/NgRanTargetId"
    ///    },
    ///    "ueContext": {
    ///      "$ref": "#/components/schemas/UeContext"
    ///    },
    ///    "ueRadioCapability": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeContextRelocateData {
        #[serde(rename = "forwardRelocationRequest")]
        pub forward_relocation_request: RefToBinaryData,
        #[serde(rename = "ngapCause", default, skip_serializing_if = "Option::is_none")]
        pub ngap_cause: Option<NgApCause>,
        #[serde(
            rename = "pduSessionList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub pdu_session_list: Vec<N2SmInformation>,
        #[serde(rename = "sourceToTargetData")]
        pub source_to_target_data: N2InfoContent,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
        #[serde(rename = "targetId")]
        pub target_id: NgRanTargetId,
        #[serde(rename = "ueContext")]
        pub ue_context: UeContext,
        #[serde(
            rename = "ueRadioCapability",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_radio_capability: Option<N2InfoContent>,
    }

    impl From<&UeContextRelocateData> for UeContextRelocateData {
        fn from(value: &UeContextRelocateData) -> Self {
            value.clone()
        }
    }

    ///Data within a Relocate UE Context response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a Relocate UE Context response",
    ///  "type": "object",
    ///  "required": [
    ///    "ueContext"
    ///  ],
    ///  "properties": {
    ///    "ueContext": {
    ///      "$ref": "#/components/schemas/UeContext"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeContextRelocatedData {
        #[serde(rename = "ueContext")]
        pub ue_context: UeContext,
    }

    impl From<&UeContextRelocatedData> for UeContextRelocatedData {
        fn from(value: &UeContextRelocatedData) -> Self {
            value.clone()
        }
    }

    ///Data within a UE Context Transfer Request to start transferring of an
    /// individual ueContext resource from old AMF to new AMF
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a UE Context Transfer Request to start
    /// transferring of an individual ueContext resource from old AMF to new
    /// AMF",
    ///  "type": "object",
    ///  "required": [
    ///    "accessType",
    ///    "reason"
    ///  ],
    ///  "properties": {
    ///    "accessType": {
    ///      "$ref": "#/components/schemas/AccessType"
    ///    },
    ///    "plmnId": {
    ///      "$ref": "#/components/schemas/PlmnId"
    ///    },
    ///    "reason": {
    ///      "$ref": "#/components/schemas/TransferReason"
    ///    },
    ///    "regRequest": {
    ///      "$ref": "#/components/schemas/N1MessageContainer"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeContextTransferReqData {
        #[serde(rename = "accessType")]
        pub access_type: AccessType,
        #[serde(rename = "plmnId", default, skip_serializing_if = "Option::is_none")]
        pub plmn_id: Option<PlmnId>,
        pub reason: TransferReason,
        #[serde(
            rename = "regRequest",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub reg_request: Option<N1MessageContainer>,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
    }

    impl From<&UeContextTransferReqData> for UeContextTransferReqData {
        fn from(value: &UeContextTransferReqData) -> Self {
            value.clone()
        }
    }

    ///Data within a successful response to the UE Context Transfer request
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a successful response to the UE Context
    /// Transfer request",
    ///  "type": "object",
    ///  "required": [
    ///    "ueContext"
    ///  ],
    ///  "properties": {
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    },
    ///    "ueContext": {
    ///      "$ref": "#/components/schemas/UeContext"
    ///    },
    ///    "ueNbiotRadioCapability": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    },
    ///    "ueRadioCapability": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    },
    ///    "ueRadioCapabilityForPaging": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeContextTransferRspData {
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
        #[serde(rename = "ueContext")]
        pub ue_context: UeContext,
        #[serde(
            rename = "ueNbiotRadioCapability",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_nbiot_radio_capability: Option<N2InfoContent>,
        #[serde(
            rename = "ueRadioCapability",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_radio_capability: Option<N2InfoContent>,
        #[serde(
            rename = "ueRadioCapabilityForPaging",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub ue_radio_capability_for_paging: Option<N2InfoContent>,
    }

    impl From<&UeContextTransferRspData> for UeContextTransferRspData {
        fn from(value: &UeContextTransferRspData) -> Self {
            value.clone()
        }
    }

    ///Describes the status of an individual ueContext resource in UE Context
    /// Transfer procedures
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the status of an individual ueContext
    /// resource in UE Context Transfer procedures",
    ///  "type": "string",
    ///  "enum": [
    ///    "TRANSFERRED",
    ///    "NOT_TRANSFERRED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UeContextTransferStatus {
        #[serde(rename = "TRANSFERRED")]
        Transferred,
        #[serde(rename = "NOT_TRANSFERRED")]
        NotTransferred,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&UeContextTransferStatus> for UeContextTransferStatus {
        fn from(value: &UeContextTransferStatus) -> Self {
            value.clone()
        }
    }

    impl ToString for UeContextTransferStatus {
        fn to_string(&self) -> String {
            match *self {
                Self::Transferred => "TRANSFERRED".to_string(),
                Self::NotTransferred => "NOT_TRANSFERRED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for UeContextTransferStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TRANSFERRED" => Ok(Self::Transferred),
                "NOT_TRANSFERRED" => Ok(Self::NotTransferred),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for UeContextTransferStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for UeContextTransferStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for UeContextTransferStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents the UE Differentiation Information and its validity time
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the UE Differentiation Information and its
    /// validity time",
    ///  "type": "object",
    ///  "properties": {
    ///    "batteryInd": {
    ///      "$ref": "#/components/schemas/BatteryIndication"
    ///    },
    ///    "periodicComInd": {
    ///      "$ref": "#/components/schemas/PeriodicCommunicationIndicator"
    ///    },
    ///    "periodicTime": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "scheduledComTime": {
    ///      "$ref": "#/components/schemas/ScheduledCommunicationTime"
    ///    },
    ///    "stationaryInd": {
    ///      "$ref": "#/components/schemas/StationaryIndication"
    ///    },
    ///    "trafficProfile": {
    ///      "$ref": "#/components/schemas/TrafficProfile"
    ///    },
    ///    "validityTime": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeDifferentiationInfo {
        #[serde(
            rename = "batteryInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub battery_ind: Option<BatteryIndication>,
        #[serde(
            rename = "periodicComInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub periodic_com_ind: Option<PeriodicCommunicationIndicator>,
        #[serde(
            rename = "periodicTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub periodic_time: Option<DurationSec>,
        #[serde(
            rename = "scheduledComTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub scheduled_com_time: Option<ScheduledCommunicationTime>,
        #[serde(
            rename = "stationaryInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub stationary_ind: Option<StationaryIndication>,
        #[serde(
            rename = "trafficProfile",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub traffic_profile: Option<TrafficProfile>,
        #[serde(
            rename = "validityTime",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub validity_time: Option<DateTime>,
    }

    impl From<&UeDifferentiationInfo> for UeDifferentiationInfo {
        fn from(value: &UeDifferentiationInfo) -> Self {
            value.clone()
        }
    }

    ///UE Identity
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "UE Identity",
    ///  "type": "object",
    ///  "properties": {
    ///    "gpsi": {
    ///      "$ref": "#/components/schemas/Gpsi"
    ///    },
    ///    "supi": {
    ///      "$ref": "#/components/schemas/Supi"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeIdExt {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub gpsi: Option<Gpsi>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub supi: Option<Supi>,
    }

    impl From<&UeIdExt> for UeIdExt {
        fn from(value: &UeIdExt) -> Self {
            value.clone()
        }
    }

    ///Additional filters for UE in Area Report event
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Additional filters for UE in Area Report event",
    ///  "type": "object",
    ///  "properties": {
    ///    "aerialSrvDnnInd": {
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "ueType": {
    ///      "$ref": "#/components/schemas/UeType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeInAreaFilter {
        #[serde(rename = "aerialSrvDnnInd", default)]
        pub aerial_srv_dnn_ind: bool,
        #[serde(rename = "ueType", default, skip_serializing_if = "Option::is_none")]
        pub ue_type: Option<UeType>,
    }

    impl From<&UeInAreaFilter> for UeInAreaFilter {
        fn from(value: &UeInAreaFilter) -> Self {
            value.clone()
        }
    }

    ///list of UEs requested to be made reachable for the MBS Session
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "list of UEs requested to be made reachable for the MBS
    /// Session",
    ///  "type": "object",
    ///  "required": [
    ///    "ueList"
    ///  ],
    ///  "properties": {
    ///    "pduSessionId": {
    ///      "$ref": "#/components/schemas/PduSessionId"
    ///    },
    ///    "ueList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Supi"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeInfo {
        #[serde(
            rename = "pduSessionId",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pdu_session_id: Option<PduSessionId>,
        #[serde(rename = "ueList")]
        pub ue_list: Vec<Supi>,
    }

    impl From<&UeInfo> for UeInfo {
        fn from(value: &UeInfo) -> Self {
            value.clone()
        }
    }

    ///Report Item for UE Location Trends event.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Report Item for UE Location Trends event.",
    ///  "type": "object",
    ///  "required": [
    ///    "duration",
    ///    "spacing",
    ///    "timestamp"
    ///  ],
    ///  "properties": {
    ///    "duration": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "ecgi": {
    ///      "$ref": "#/components/schemas/Ecgi"
    ///    },
    ///    "n3gaLocation": {
    ///      "$ref": "#/components/schemas/N3gaLocation"
    ///    },
    ///    "ncgi": {
    ///      "$ref": "#/components/schemas/Ncgi"
    ///    },
    ///    "spacing": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "tai": {
    ///      "$ref": "#/components/schemas/Tai"
    ///    },
    ///    "timestamp": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeLocationTrendsReportItem {
        pub duration: DurationSec,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ecgi: Option<Ecgi>,
        #[serde(
            rename = "n3gaLocation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n3ga_location: Option<N3gaLocation>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ncgi: Option<Ncgi>,
        pub spacing: DurationSec,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub tai: Option<Tai>,
        pub timestamp: DateTime,
    }

    impl From<&UeLocationTrendsReportItem> for UeLocationTrendsReportItem {
        fn from(value: &UeLocationTrendsReportItem) -> Self {
            value.clone()
        }
    }

    ///Represents UE mobility information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents UE mobility information.",
    ///  "type": "object",
    ///  "allOf": [
    ///    {
    ///      "required": [
    ///        "duration"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "locInfos"
    ///      ]
    ///    },
    ///    {
    ///      "oneOf": [
    ///        {
    ///          "required": [
    ///            "ts"
    ///          ]
    ///        },
    ///        {
    ///          "required": [
    ///            "recurringTime"
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "duration": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "durationVariance": {
    ///      "$ref": "#/components/schemas/Float"
    ///    },
    ///    "locInfos": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LocationInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "recurringTime": {
    ///      "$ref": "#/components/schemas/schemas-ScheduledCommunicationTime"
    ///    },
    ///    "ts": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum UeMobility {
        Variant0 {
            duration: DurationSec,
            #[serde(
                rename = "durationVariance",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            duration_variance: Option<Float>,
            #[serde(rename = "locInfos")]
            loc_infos: Vec<LocationInfo>,
            ts: DateTime,
        },
        Variant1 {
            duration: DurationSec,
            #[serde(
                rename = "durationVariance",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            duration_variance: Option<Float>,
            #[serde(rename = "locInfos")]
            loc_infos: Vec<LocationInfo>,
            #[serde(rename = "recurringTime")]
            recurring_time: SchemasScheduledCommunicationTime,
        },
    }

    impl From<&UeMobility> for UeMobility {
        fn from(value: &UeMobility) -> Self {
            value.clone()
        }
    }

    ///Data within a create subscription request for UE specific N1 and/or N2
    /// information notification
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a create subscription request for UE
    /// specific N1 and/or N2 information notification",
    ///  "type": "object",
    ///  "properties": {
    ///    "n1MessageClass": {
    ///      "$ref": "#/components/schemas/N1MessageClass"
    ///    },
    ///    "n1NotifyCallbackUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "n2InformationClass": {
    ///      "$ref": "#/components/schemas/N2InformationClass"
    ///    },
    ///    "n2NotifyCallbackUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "nfId": {
    ///      "$ref": "#/components/schemas/NfInstanceId"
    ///    },
    ///    "oldGuami": {
    ///      "$ref": "#/components/schemas/Guami"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeN1n2InfoSubscriptionCreateData {
        #[serde(
            rename = "n1MessageClass",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n1_message_class: Option<N1MessageClass>,
        #[serde(
            rename = "n1NotifyCallbackUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n1_notify_callback_uri: Option<Uri>,
        #[serde(
            rename = "n2InformationClass",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n2_information_class: Option<N2InformationClass>,
        #[serde(
            rename = "n2NotifyCallbackUri",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n2_notify_callback_uri: Option<Uri>,
        #[serde(rename = "nfId", default, skip_serializing_if = "Option::is_none")]
        pub nf_id: Option<NfInstanceId>,
        #[serde(rename = "oldGuami", default, skip_serializing_if = "Option::is_none")]
        pub old_guami: Option<Guami>,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
    }

    impl From<&UeN1n2InfoSubscriptionCreateData> for UeN1n2InfoSubscriptionCreateData {
        fn from(value: &UeN1n2InfoSubscriptionCreateData) -> Self {
            value.clone()
        }
    }

    ///Data for the created subscription for UE specific N1 and/or N2
    /// information notification
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data for the created subscription for UE specific N1
    /// and/or N2 information notification",
    ///  "type": "object",
    ///  "required": [
    ///    "n1n2NotifySubscriptionId"
    ///  ],
    ///  "properties": {
    ///    "n1n2NotifySubscriptionId": {
    ///      "type": "string"
    ///    },
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeN1n2InfoSubscriptionCreatedData {
        #[serde(rename = "n1n2NotifySubscriptionId")]
        pub n1n2_notify_subscription_id: String,
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
    }

    impl From<&UeN1n2InfoSubscriptionCreatedData> for UeN1n2InfoSubscriptionCreatedData {
        fn from(value: &UeN1n2InfoSubscriptionCreatedData) -> Self {
            value.clone()
        }
    }

    ///Positioning capabilities supported by the UE. A string encoding the
    /// "ProvideCapabilities-r9-IEs" IE as specified in clause 6.3 of 3GPP TS
    /// 37.355 (start from octet 1).
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Positioning capabilities supported by the UE. A string
    /// encoding the \"ProvideCapabilities-r9-IEs\" IE as specified in clause
    /// 6.3 of 3GPP TS 37.355 (start from octet 1).",
    ///  "type": "string",
    ///  "format": "byte"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct UePositioningCapabilities(pub String);
    impl ::std::ops::Deref for UePositioningCapabilities {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<UePositioningCapabilities> for String {
        fn from(value: UePositioningCapabilities) -> Self {
            value.0
        }
    }

    impl From<&UePositioningCapabilities> for UePositioningCapabilities {
        fn from(value: &UePositioningCapabilities) -> Self {
            value.clone()
        }
    }

    impl From<String> for UePositioningCapabilities {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for UePositioningCapabilities {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for UePositioningCapabilities {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///UE privacy requirements from (H)GMLC to the serving AMF or VGMLC(in the
    /// roaming case) for the target UE
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "UE privacy requirements from (H)GMLC to the serving AMF
    /// or VGMLC(in the roaming case) for the target UE",
    ///  "type": "object",
    ///  "properties": {
    ///    "codeWordCheck": {
    ///      "type": "boolean"
    ///    },
    ///    "lcsServiceAuthInfo": {
    ///      "$ref": "#/components/schemas/LcsServiceAuth"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UePrivacyRequirements {
        #[serde(
            rename = "codeWordCheck",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub code_word_check: Option<bool>,
        #[serde(
            rename = "lcsServiceAuthInfo",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub lcs_service_auth_info: Option<LcsServiceAuth>,
    }

    impl From<&UePrivacyRequirements> for UePrivacyRequirements {
        fn from(value: &UePrivacyRequirements) -> Self {
            value.clone()
        }
    }

    ///Describes the reachability of the UE
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the reachability of the UE",
    ///  "type": "string",
    ///  "enum": [
    ///    "UNREACHABLE",
    ///    "REACHABLE",
    ///    "REGULATORY_ONLY"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UeReachability {
        #[serde(rename = "UNREACHABLE")]
        Unreachable,
        #[serde(rename = "REACHABLE")]
        Reachable,
        #[serde(rename = "REGULATORY_ONLY")]
        RegulatoryOnly,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&UeReachability> for UeReachability {
        fn from(value: &UeReachability) -> Self {
            value.clone()
        }
    }

    impl ToString for UeReachability {
        fn to_string(&self) -> String {
            match *self {
                Self::Unreachable => "UNREACHABLE".to_string(),
                Self::Reachable => "REACHABLE".to_string(),
                Self::RegulatoryOnly => "REGULATORY_ONLY".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for UeReachability {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "UNREACHABLE" => Ok(Self::Unreachable),
                "REACHABLE" => Ok(Self::Reachable),
                "REGULATORY_ONLY" => Ok(Self::RegulatoryOnly),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for UeReachability {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for UeReachability {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for UeReachability {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Data within a UE registration status update request to indicate a
    /// completion of transferring at a target AMF
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a UE registration status update request to
    /// indicate a completion of transferring at a target AMF",
    ///  "type": "object",
    ///  "required": [
    ///    "transferStatus"
    ///  ],
    ///  "properties": {
    ///    "analyticsNotUsedList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Uri"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "pcfReselectedInd": {
    ///      "type": "boolean"
    ///    },
    ///    "smfChangeInfoList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SmfChangeInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "toReleaseSessionInfo": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ReleaseSessionInfo"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "toReleaseSessionList": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PduSessionId"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "transferStatus": {
    ///      "$ref": "#/components/schemas/UeContextTransferStatus"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeRegStatusUpdateReqData {
        #[serde(
            rename = "analyticsNotUsedList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub analytics_not_used_list: Vec<Uri>,
        #[serde(
            rename = "pcfReselectedInd",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pcf_reselected_ind: Option<bool>,
        #[serde(
            rename = "smfChangeInfoList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub smf_change_info_list: Vec<SmfChangeInfo>,
        #[serde(
            rename = "toReleaseSessionInfo",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub to_release_session_info: Vec<ReleaseSessionInfo>,
        #[serde(
            rename = "toReleaseSessionList",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub to_release_session_list: Vec<PduSessionId>,
        #[serde(rename = "transferStatus")]
        pub transfer_status: UeContextTransferStatus,
    }

    impl From<&UeRegStatusUpdateReqData> for UeRegStatusUpdateReqData {
        fn from(value: &UeRegStatusUpdateReqData) -> Self {
            value.clone()
        }
    }

    ///Data within a UE registration status update response to provide the
    /// status of UE context transfer status update at a source AMF
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Data within a UE registration status update response to
    /// provide the status of UE context transfer status update at a source
    /// AMF",
    ///  "type": "object",
    ///  "required": [
    ///    "regStatusTransferComplete"
    ///  ],
    ///  "properties": {
    ///    "regStatusTransferComplete": {
    ///      "type": "boolean"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeRegStatusUpdateRspData {
        #[serde(rename = "regStatusTransferComplete")]
        pub reg_status_transfer_complete: bool,
    }

    impl From<&UeRegStatusUpdateRspData> for UeRegStatusUpdateRspData {
        fn from(value: &UeRegStatusUpdateRspData) -> Self {
            value.clone()
        }
    }

    ///UeSecurityCapability
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "$ref": "#/components/schemas/Bytes"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UeSecurityCapability(pub Bytes);
    impl ::std::ops::Deref for UeSecurityCapability {
        type Target = Bytes;
        fn deref(&self) -> &Bytes {
            &self.0
        }
    }

    impl From<UeSecurityCapability> for Bytes {
        fn from(value: UeSecurityCapability) -> Self {
            value.0
        }
    }

    impl From<&UeSecurityCapability> for UeSecurityCapability {
        fn from(value: &UeSecurityCapability) -> Self {
            value.clone()
        }
    }

    impl From<Bytes> for UeSecurityCapability {
        fn from(value: Bytes) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for UeSecurityCapability {
        type Err = <Bytes as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for UeSecurityCapability {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for UeSecurityCapability {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for UeSecurityCapability {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for UeSecurityCapability {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Describes the type of UEs
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the type of UEs",
    ///  "type": "string",
    ///  "enum": [
    ///    "AERIAL_UE"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UeType {
        #[serde(rename = "AERIAL_UE")]
        AerialUe,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&UeType> for UeType {
        fn from(value: &UeType) -> Self {
            value.clone()
        }
    }

    impl ToString for UeType {
        fn to_string(&self) -> String {
            match *self {
                Self::AerialUe => "AERIAL_UE".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for UeType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "AERIAL_UE" => Ok(Self::AerialUe),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for UeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for UeType {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for UeType {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Integer where the allowed values correspond to the value range of an
    /// unsigned 16-bit integer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Integer where the allowed values correspond to the
    /// value range of an unsigned 16-bit integer.",
    ///  "type": "integer",
    ///  "maximum": 65535.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Uint16(pub u16);
    impl ::std::ops::Deref for Uint16 {
        type Target = u16;
        fn deref(&self) -> &u16 {
            &self.0
        }
    }

    impl From<Uint16> for u16 {
        fn from(value: Uint16) -> Self {
            value.0
        }
    }

    impl From<&Uint16> for Uint16 {
        fn from(value: &Uint16) -> Self {
            value.clone()
        }
    }

    impl From<u16> for Uint16 {
        fn from(value: u16) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for Uint16 {
        type Err = <u16 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for Uint16 {
        type Error = <u16 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Uint16 {
        type Error = <u16 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Uint16 {
        type Error = <u16 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for Uint16 {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Unsigned Integer, i.e. only value 0 and integers above 0 are
    /// permissible.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unsigned Integer, i.e. only value 0 and integers above
    /// 0 are permissible.",
    ///  "type": "integer",
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Uinteger(pub u64);
    impl ::std::ops::Deref for Uinteger {
        type Target = u64;
        fn deref(&self) -> &u64 {
            &self.0
        }
    }

    impl From<Uinteger> for u64 {
        fn from(value: Uinteger) -> Self {
            value.0
        }
    }

    impl From<&Uinteger> for Uinteger {
        fn from(value: &Uinteger) -> Self {
            value.clone()
        }
    }

    impl From<u64> for Uinteger {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for Uinteger {
        type Err = <u64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for Uinteger {
        type Error = <u64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Uinteger {
        type Error = <u64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Uinteger {
        type Error = <u64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for Uinteger {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Unsigned Integer, i.e. only value 0 and integers above 0 are permissible
    /// with the OpenAPI 'nullable: true' property.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unsigned Integer, i.e. only value 0 and integers above
    /// 0 are permissible with the OpenAPI 'nullable: true' property.\n",
    ///  "type": [
    ///    "integer",
    ///    "null"
    ///  ],
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UintegerRm(pub Option<u64>);
    impl ::std::ops::Deref for UintegerRm {
        type Target = Option<u64>;
        fn deref(&self) -> &Option<u64> {
            &self.0
        }
    }

    impl From<UintegerRm> for Option<u64> {
        fn from(value: UintegerRm) -> Self {
            value.0
        }
    }

    impl From<&UintegerRm> for UintegerRm {
        fn from(value: &UintegerRm) -> Self {
            value.clone()
        }
    }

    impl From<Option<u64>> for UintegerRm {
        fn from(value: Option<u64>) -> Self {
            Self(value)
        }
    }

    ///UmtTime
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "type": "object",
    ///  "required": [
    ///    "dayOfWeek",
    ///    "timeOfDay"
    ///  ],
    ///  "properties": {
    ///    "dayOfWeek": {
    ///      "$ref": "#/components/schemas/DayOfWeek"
    ///    },
    ///    "timeOfDay": {
    ///      "$ref": "#/components/schemas/TimeOfDay"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UmtTime {
        #[serde(rename = "dayOfWeek")]
        pub day_of_week: DayOfWeek,
        #[serde(rename = "timeOfDay")]
        pub time_of_day: TimeOfDay,
    }

    impl From<&UmtTime> for UmtTime {
        fn from(value: &UmtTime) -> Self {
            value.clone()
        }
    }

    ///Uncertainty
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates value of uncertainty.",
    ///  "type": "number",
    ///  "format": "float",
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Uncertainty(pub f32);
    impl ::std::ops::Deref for Uncertainty {
        type Target = f32;
        fn deref(&self) -> &f32 {
            &self.0
        }
    }

    impl From<Uncertainty> for f32 {
        fn from(value: Uncertainty) -> Self {
            value.0
        }
    }

    impl From<&Uncertainty> for Uncertainty {
        fn from(value: &Uncertainty) -> Self {
            value.clone()
        }
    }

    impl From<f32> for Uncertainty {
        fn from(value: f32) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for Uncertainty {
        type Err = <f32 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for Uncertainty {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Uncertainty {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Uncertainty {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for Uncertainty {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Ellipse with uncertainty.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Ellipse with uncertainty.",
    ///  "type": "object",
    ///  "required": [
    ///    "orientationMajor",
    ///    "semiMajor",
    ///    "semiMinor"
    ///  ],
    ///  "properties": {
    ///    "orientationMajor": {
    ///      "$ref": "#/components/schemas/Orientation"
    ///    },
    ///    "semiMajor": {
    ///      "$ref": "#/components/schemas/Uncertainty"
    ///    },
    ///    "semiMinor": {
    ///      "$ref": "#/components/schemas/Uncertainty"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UncertaintyEllipse {
        #[serde(rename = "orientationMajor")]
        pub orientation_major: Orientation,
        #[serde(rename = "semiMajor")]
        pub semi_major: Uncertainty,
        #[serde(rename = "semiMinor")]
        pub semi_minor: Uncertainty,
    }

    impl From<&UncertaintyEllipse> for UncertaintyEllipse {
        fn from(value: &UncertaintyEllipse) -> Self {
            value.clone()
        }
    }

    ///Ellipsoid with uncertainty
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Ellipsoid with uncertainty",
    ///  "type": "object",
    ///  "required": [
    ///    "orientationMajor",
    ///    "semiMajor",
    ///    "semiMinor",
    ///    "vertical"
    ///  ],
    ///  "properties": {
    ///    "orientationMajor": {
    ///      "$ref": "#/components/schemas/Orientation"
    ///    },
    ///    "semiMajor": {
    ///      "$ref": "#/components/schemas/Uncertainty"
    ///    },
    ///    "semiMinor": {
    ///      "$ref": "#/components/schemas/Uncertainty"
    ///    },
    ///    "vertical": {
    ///      "$ref": "#/components/schemas/Uncertainty"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UncertaintyEllipsoid {
        #[serde(rename = "orientationMajor")]
        pub orientation_major: Orientation,
        #[serde(rename = "semiMajor")]
        pub semi_major: Uncertainty,
        #[serde(rename = "semiMinor")]
        pub semi_minor: Uncertainty,
        pub vertical: Uncertainty,
    }

    impl From<&UncertaintyEllipsoid> for UncertaintyEllipsoid {
        fn from(value: &UncertaintyEllipsoid) -> Self {
            value.clone()
        }
    }

    ///UE policy delivery related N1 message notification subscription data.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "UE policy delivery related N1 message notification
    /// subscription data.",
    ///  "type": "object",
    ///  "required": [
    ///    "updpNotifyCallbackUri",
    ///    "updpNotifySubscriptionId"
    ///  ],
    ///  "properties": {
    ///    "supportedFeatures": {
    ///      "$ref": "#/components/schemas/SupportedFeatures"
    ///    },
    ///    "updpCallbackBinding": {
    ///      "type": "string"
    ///    },
    ///    "updpNotifyCallbackUri": {
    ///      "$ref": "#/components/schemas/Uri"
    ///    },
    ///    "updpNotifySubscriptionId": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpdpSubscriptionData {
        #[serde(
            rename = "supportedFeatures",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub supported_features: Option<SupportedFeatures>,
        #[serde(
            rename = "updpCallbackBinding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub updp_callback_binding: Option<String>,
        #[serde(rename = "updpNotifyCallbackUri")]
        pub updp_notify_callback_uri: Uri,
        #[serde(rename = "updpNotifySubscriptionId")]
        pub updp_notify_subscription_id: String,
    }

    impl From<&UpdpSubscriptionData> for UpdpSubscriptionData {
        fn from(value: &UpdpSubscriptionData) -> Self {
            value.clone()
        }
    }

    ///Represents the ID/address/FQDN of the UPF.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the ID/address/FQDN of the UPF.",
    ///  "type": "object",
    ///  "properties": {
    ///    "upfAddr": {
    ///      "$ref": "#/components/schemas/AddrFqdn"
    ///    },
    ///    "upfId": {
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UpfInformation {
        #[serde(rename = "upfAddr", default, skip_serializing_if = "Option::is_none")]
        pub upf_addr: Option<AddrFqdn>,
        #[serde(rename = "upfId", default, skip_serializing_if = "Option::is_none")]
        pub upf_id: Option<String>,
    }

    impl From<&UpfInformation> for UpfInformation {
        fn from(value: &UpfInformation) -> Self {
            value.clone()
        }
    }

    ///String providing an URI formatted according to RFC 3986.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "String providing an URI formatted according to RFC
    /// 3986.",
    ///  "type": "string"
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub struct Uri(pub String);
    impl ::std::ops::Deref for Uri {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Uri> for String {
        fn from(value: Uri) -> Self {
            value.0
        }
    }

    impl From<&Uri> for Uri {
        fn from(value: &Uri) -> Self {
            value.clone()
        }
    }

    impl From<String> for Uri {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for Uri {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for Uri {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Indicates usage made of the location measurement.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates usage made of the location measurement.",
    ///  "type": "string",
    ///  "enum": [
    ///    "UNSUCCESS",
    ///    "SUCCESS_RESULTS_NOT_USED",
    ///    "SUCCESS_RESULTS_USED_TO_VERIFY_LOCATION",
    ///    "SUCCESS_RESULTS_USED_TO_GENERATE_LOCATION",
    ///    "SUCCESS_METHOD_NOT_DETERMINED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum Usage {
        #[serde(rename = "UNSUCCESS")]
        Unsuccess,
        #[serde(rename = "SUCCESS_RESULTS_NOT_USED")]
        SuccessResultsNotUsed,
        #[serde(rename = "SUCCESS_RESULTS_USED_TO_VERIFY_LOCATION")]
        SuccessResultsUsedToVerifyLocation,
        #[serde(rename = "SUCCESS_RESULTS_USED_TO_GENERATE_LOCATION")]
        SuccessResultsUsedToGenerateLocation,
        #[serde(rename = "SUCCESS_METHOD_NOT_DETERMINED")]
        SuccessMethodNotDetermined,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&Usage> for Usage {
        fn from(value: &Usage) -> Self {
            value.clone()
        }
    }

    impl ToString for Usage {
        fn to_string(&self) -> String {
            match *self {
                Self::Unsuccess => "UNSUCCESS".to_string(),
                Self::SuccessResultsNotUsed => "SUCCESS_RESULTS_NOT_USED".to_string(),
                Self::SuccessResultsUsedToVerifyLocation => {
                    "SUCCESS_RESULTS_USED_TO_VERIFY_LOCATION".to_string()
                }
                Self::SuccessResultsUsedToGenerateLocation => {
                    "SUCCESS_RESULTS_USED_TO_GENERATE_LOCATION".to_string()
                }
                Self::SuccessMethodNotDetermined => "SUCCESS_METHOD_NOT_DETERMINED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for Usage {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "UNSUCCESS" => Ok(Self::Unsuccess),
                "SUCCESS_RESULTS_NOT_USED" => Ok(Self::SuccessResultsNotUsed),
                "SUCCESS_RESULTS_USED_TO_VERIFY_LOCATION" => {
                    Ok(Self::SuccessResultsUsedToVerifyLocation)
                }
                "SUCCESS_RESULTS_USED_TO_GENERATE_LOCATION" => {
                    Ok(Self::SuccessResultsUsedToGenerateLocation)
                }
                "SUCCESS_METHOD_NOT_DETERMINED" => Ok(Self::SuccessMethodNotDetermined),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for Usage {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Usage {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Usage {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents the user data congestion information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the user data congestion information.",
    ///  "type": "object",
    ///  "required": [
    ///    "congestionInfo",
    ///    "networkArea"
    ///  ],
    ///  "properties": {
    ///    "congestionInfo": {
    ///      "$ref": "#/components/schemas/CongestionInfo"
    ///    },
    ///    "networkArea": {
    ///      "$ref": "#/components/schemas/NetworkAreaInfo"
    ///    },
    ///    "snssai": {
    ///      "$ref": "#/components/schemas/Snssai"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserDataCongestionInfo {
        #[serde(rename = "congestionInfo")]
        pub congestion_info: CongestionInfo,
        #[serde(rename = "networkArea")]
        pub network_area: NetworkAreaInfo,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub snssai: Option<Snssai>,
    }

    impl From<&UserDataCongestionInfo> for UserDataCongestionInfo {
        fn from(value: &UserDataCongestionInfo) -> Self {
            value.clone()
        }
    }

    ///At least one of eutraLocation, nrLocation and n3gaLocation shall be
    /// present. Several of them may be present.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "At least one of eutraLocation, nrLocation and
    /// n3gaLocation shall be present. Several of them may be present.\n",
    ///  "type": "object",
    ///  "properties": {
    ///    "eutraLocation": {
    ///      "$ref": "#/components/schemas/EutraLocation"
    ///    },
    ///    "geraLocation": {
    ///      "$ref": "#/components/schemas/GeraLocation"
    ///    },
    ///    "n3gaLocation": {
    ///      "$ref": "#/components/schemas/N3gaLocation"
    ///    },
    ///    "nrLocation": {
    ///      "$ref": "#/components/schemas/NrLocation"
    ///    },
    ///    "utraLocation": {
    ///      "$ref": "#/components/schemas/UtraLocation"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct UserLocation {
        #[serde(
            rename = "eutraLocation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub eutra_location: Option<EutraLocation>,
        #[serde(
            rename = "geraLocation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub gera_location: Option<GeraLocation>,
        #[serde(
            rename = "n3gaLocation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub n3ga_location: Option<N3gaLocation>,
        #[serde(
            rename = "nrLocation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nr_location: Option<NrLocation>,
        #[serde(
            rename = "utraLocation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub utra_location: Option<UtraLocation>,
    }

    impl From<&UserLocation> for UserLocation {
        fn from(value: &UserLocation) -> Self {
            value.clone()
        }
    }

    ///Exactly one of cgi, sai or lai shall be present.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Exactly one of cgi, sai or lai shall be present.",
    ///  "type": "object",
    ///  "oneOf": [
    ///    {
    ///      "required": [
    ///        "cgi"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "sai"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "lai"
    ///      ]
    ///    }
    ///  ],
    ///  "properties": {
    ///    "ageOfLocationInformation": {
    ///      "description": "The value represents the elapsed time in minutes
    /// since the last network contact of the mobile station.  Value \"0\"
    /// indicates that the location information was obtained after a successful
    /// paging procedure for  Active Location Retrieval when the UE is in idle
    /// mode\n or after a successful location reporting procedure  the UE is in
    /// connected mode. Any\nother value than \"0\" indicates that the location
    /// information is the last known one.  See 3GPP TS 29.002 clause
    /// 17.7.8.\n",
    ///      "type": "integer",
    ///      "maximum": 32767.0,
    ///      "minimum": 0.0
    ///    },
    ///    "cgi": {
    ///      "$ref": "#/components/schemas/CellGlobalId"
    ///    },
    ///    "geodeticInformation": {
    ///      "description": "Refers to Calling Geodetic Location. See ITU-T
    /// Recommendation Q.763 (1999) clause 3.88.2. Only the description of an
    /// ellipsoid point with uncertainty circle is allowed to be used.\n",
    ///      "type": "string",
    ///      "pattern": "^[0-9A-F]{20}$"
    ///    },
    ///    "geographicalInformation": {
    ///      "description": "Refer to geographical Information.See 3GPP TS
    /// 23.032 clause 7.3.2. Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.\n",
    ///      "type": "string",
    ///      "pattern": "^[0-9A-F]{16}$"
    ///    },
    ///    "lai": {
    ///      "$ref": "#/components/schemas/LocationAreaId"
    ///    },
    ///    "rai": {
    ///      "$ref": "#/components/schemas/RoutingAreaId"
    ///    },
    ///    "sai": {
    ///      "$ref": "#/components/schemas/ServiceAreaId"
    ///    },
    ///    "ueLocationTimestamp": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum UtraLocation {
        Variant0 {
            ///The value represents the elapsed time in minutes since the last
            /// network contact of the mobile station.  Value "0" indicates that
            /// the location information was obtained after a successful paging
            /// procedure for  Active Location Retrieval when the UE is in idle
            /// mode or after a successful location reporting
            /// procedure  the UE is in connected mode. Any
            /// other value than "0" indicates that the location information is
            /// the last known one.  See 3GPP TS 29.002 clause 17.7.8.
            #[serde(
                rename = "ageOfLocationInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            age_of_location_information: Option<i64>,
            cgi: CellGlobalId,
            ///Refers to Calling Geodetic Location. See ITU-TRecommendation
            /// Q.763 (1999) clause 3.88.2. Only the description of an ellipsoid
            /// point with uncertainty circle is allowed to be used.
            #[serde(
                rename = "geodeticInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            geodetic_information: Option<UtraLocationVariant0GeodeticInformation>,
            ///Refer to geographical Information.See 3GPP TS 23.032 clause
            /// 7.3.2. Only the description of an ellipsoid point with
            /// uncertainty circle is allowed to be used.
            #[serde(
                rename = "geographicalInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            geographical_information: Option<UtraLocationVariant0GeographicalInformation>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            rai: Option<RoutingAreaId>,
            #[serde(
                rename = "ueLocationTimestamp",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            ue_location_timestamp: Option<DateTime>,
        },
        Variant1 {
            ///The value represents the elapsed time in minutes since the last
            /// network contact of the mobile station.  Value "0" indicates that
            /// the location information was obtained after a successful paging
            /// procedure for  Active Location Retrieval when the UE is in idle
            /// mode or after a successful location reporting
            /// procedure  the UE is in connected mode. Any
            /// other value than "0" indicates that the location information is
            /// the last known one.  See 3GPP TS 29.002 clause 17.7.8.
            #[serde(
                rename = "ageOfLocationInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            age_of_location_information: Option<i64>,
            ///Refers to Calling Geodetic Location. See ITU-TRecommendation
            /// Q.763 (1999) clause 3.88.2. Only the description of an ellipsoid
            /// point with uncertainty circle is allowed to be used.
            #[serde(
                rename = "geodeticInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            geodetic_information: Option<UtraLocationVariant1GeodeticInformation>,
            ///Refer to geographical Information.See 3GPP TS 23.032 clause
            /// 7.3.2. Only the description of an ellipsoid point with
            /// uncertainty circle is allowed to be used.
            #[serde(
                rename = "geographicalInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            geographical_information: Option<UtraLocationVariant1GeographicalInformation>,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            rai: Option<RoutingAreaId>,
            sai: ServiceAreaId,
            #[serde(
                rename = "ueLocationTimestamp",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            ue_location_timestamp: Option<DateTime>,
        },
        Variant2 {
            ///The value represents the elapsed time in minutes since the last
            /// network contact of the mobile station.  Value "0" indicates that
            /// the location information was obtained after a successful paging
            /// procedure for  Active Location Retrieval when the UE is in idle
            /// mode or after a successful location reporting
            /// procedure  the UE is in connected mode. Any
            /// other value than "0" indicates that the location information is
            /// the last known one.  See 3GPP TS 29.002 clause 17.7.8.
            #[serde(
                rename = "ageOfLocationInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            age_of_location_information: Option<i64>,
            ///Refers to Calling Geodetic Location. See ITU-TRecommendation
            /// Q.763 (1999) clause 3.88.2. Only the description of an ellipsoid
            /// point with uncertainty circle is allowed to be used.
            #[serde(
                rename = "geodeticInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            geodetic_information: Option<UtraLocationVariant2GeodeticInformation>,
            ///Refer to geographical Information.See 3GPP TS 23.032 clause
            /// 7.3.2. Only the description of an ellipsoid point with
            /// uncertainty circle is allowed to be used.
            #[serde(
                rename = "geographicalInformation",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            geographical_information: Option<UtraLocationVariant2GeographicalInformation>,
            lai: LocationAreaId,
            #[serde(default, skip_serializing_if = "Option::is_none")]
            rai: Option<RoutingAreaId>,
            #[serde(
                rename = "ueLocationTimestamp",
                default,
                skip_serializing_if = "Option::is_none"
            )]
            ue_location_timestamp: Option<DateTime>,
        },
    }

    impl From<&UtraLocation> for UtraLocation {
        fn from(value: &UtraLocation) -> Self {
            value.clone()
        }
    }

    ///Refers to Calling Geodetic Location. See ITU-TRecommendation Q.763
    /// (1999) clause 3.88.2. Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refers to Calling Geodetic Location. See ITU-T
    /// Recommendation Q.763 (1999) clause 3.88.2. Only the description of an
    /// ellipsoid point with uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{20}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct UtraLocationVariant0GeodeticInformation(String);
    impl ::std::ops::Deref for UtraLocationVariant0GeodeticInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<UtraLocationVariant0GeodeticInformation> for String {
        fn from(value: UtraLocationVariant0GeodeticInformation) -> Self {
            value.0
        }
    }

    impl From<&UtraLocationVariant0GeodeticInformation> for UtraLocationVariant0GeodeticInformation {
        fn from(value: &UtraLocationVariant0GeodeticInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UtraLocationVariant0GeodeticInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{20}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UtraLocationVariant0GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for UtraLocationVariant0GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for UtraLocationVariant0GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UtraLocationVariant0GeodeticInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Refer to geographical Information.See 3GPP TS 23.032 clause 7.3.2. Only
    /// the description of an ellipsoid point with uncertainty circle is allowed
    /// to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refer to geographical Information.See 3GPP TS 23.032
    /// clause 7.3.2. Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{16}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct UtraLocationVariant0GeographicalInformation(String);
    impl ::std::ops::Deref for UtraLocationVariant0GeographicalInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<UtraLocationVariant0GeographicalInformation> for String {
        fn from(value: UtraLocationVariant0GeographicalInformation) -> Self {
            value.0
        }
    }

    impl From<&UtraLocationVariant0GeographicalInformation>
        for UtraLocationVariant0GeographicalInformation
    {
        fn from(value: &UtraLocationVariant0GeographicalInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UtraLocationVariant0GeographicalInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{16}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UtraLocationVariant0GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for UtraLocationVariant0GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for UtraLocationVariant0GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UtraLocationVariant0GeographicalInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Refers to Calling Geodetic Location. See ITU-TRecommendation Q.763
    /// (1999) clause 3.88.2. Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refers to Calling Geodetic Location. See ITU-T
    /// Recommendation Q.763 (1999) clause 3.88.2. Only the description of an
    /// ellipsoid point with uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{20}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct UtraLocationVariant1GeodeticInformation(String);
    impl ::std::ops::Deref for UtraLocationVariant1GeodeticInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<UtraLocationVariant1GeodeticInformation> for String {
        fn from(value: UtraLocationVariant1GeodeticInformation) -> Self {
            value.0
        }
    }

    impl From<&UtraLocationVariant1GeodeticInformation> for UtraLocationVariant1GeodeticInformation {
        fn from(value: &UtraLocationVariant1GeodeticInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UtraLocationVariant1GeodeticInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{20}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UtraLocationVariant1GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for UtraLocationVariant1GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for UtraLocationVariant1GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UtraLocationVariant1GeodeticInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Refer to geographical Information.See 3GPP TS 23.032 clause 7.3.2. Only
    /// the description of an ellipsoid point with uncertainty circle is allowed
    /// to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refer to geographical Information.See 3GPP TS 23.032
    /// clause 7.3.2. Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{16}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct UtraLocationVariant1GeographicalInformation(String);
    impl ::std::ops::Deref for UtraLocationVariant1GeographicalInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<UtraLocationVariant1GeographicalInformation> for String {
        fn from(value: UtraLocationVariant1GeographicalInformation) -> Self {
            value.0
        }
    }

    impl From<&UtraLocationVariant1GeographicalInformation>
        for UtraLocationVariant1GeographicalInformation
    {
        fn from(value: &UtraLocationVariant1GeographicalInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UtraLocationVariant1GeographicalInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{16}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UtraLocationVariant1GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for UtraLocationVariant1GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for UtraLocationVariant1GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UtraLocationVariant1GeographicalInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Refers to Calling Geodetic Location. See ITU-TRecommendation Q.763
    /// (1999) clause 3.88.2. Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refers to Calling Geodetic Location. See ITU-T
    /// Recommendation Q.763 (1999) clause 3.88.2. Only the description of an
    /// ellipsoid point with uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{20}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct UtraLocationVariant2GeodeticInformation(String);
    impl ::std::ops::Deref for UtraLocationVariant2GeodeticInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<UtraLocationVariant2GeodeticInformation> for String {
        fn from(value: UtraLocationVariant2GeodeticInformation) -> Self {
            value.0
        }
    }

    impl From<&UtraLocationVariant2GeodeticInformation> for UtraLocationVariant2GeodeticInformation {
        fn from(value: &UtraLocationVariant2GeodeticInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UtraLocationVariant2GeodeticInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{20}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{20}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UtraLocationVariant2GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for UtraLocationVariant2GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for UtraLocationVariant2GeodeticInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UtraLocationVariant2GeodeticInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Refer to geographical Information.See 3GPP TS 23.032 clause 7.3.2. Only
    /// the description of an ellipsoid point with uncertainty circle is allowed
    /// to be used.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Refer to geographical Information.See 3GPP TS 23.032
    /// clause 7.3.2. Only the description of an ellipsoid point with
    /// uncertainty circle is allowed to be used.\n",
    ///  "type": "string",
    ///  "pattern": "^[0-9A-F]{16}$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct UtraLocationVariant2GeographicalInformation(String);
    impl ::std::ops::Deref for UtraLocationVariant2GeographicalInformation {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<UtraLocationVariant2GeographicalInformation> for String {
        fn from(value: UtraLocationVariant2GeographicalInformation) -> Self {
            value.0
        }
    }

    impl From<&UtraLocationVariant2GeographicalInformation>
        for UtraLocationVariant2GeographicalInformation
    {
        fn from(value: &UtraLocationVariant2GeographicalInformation) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UtraLocationVariant2GeographicalInformation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[0-9A-F]{16}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9A-F]{16}$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UtraLocationVariant2GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for UtraLocationVariant2GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for UtraLocationVariant2GeographicalInformation {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UtraLocationVariant2GeographicalInformation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///Indicates the UUAA-MM status
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates the UUAA-MM status",
    ///  "type": "string",
    ///  "enum": [
    ///    "SUCCESS",
    ///    "PENDING",
    ///    "FAILED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum UuaaMmStatus {
        #[serde(rename = "SUCCESS")]
        Success,
        #[serde(rename = "PENDING")]
        Pending,
        #[serde(rename = "FAILED")]
        Failed,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&UuaaMmStatus> for UuaaMmStatus {
        fn from(value: &UuaaMmStatus) -> Self {
            value.clone()
        }
    }

    impl ToString for UuaaMmStatus {
        fn to_string(&self) -> String {
            match *self {
                Self::Success => "SUCCESS".to_string(),
                Self::Pending => "PENDING".to_string(),
                Self::Failed => "FAILED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for UuaaMmStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "SUCCESS" => Ok(Self::Success),
                "PENDING" => Ok(Self::Pending),
                "FAILED" => Ok(Self::Failed),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for UuaaMmStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for UuaaMmStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for UuaaMmStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents the V2X services related parameters
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the V2X services related parameters",
    ///  "type": "object",
    ///  "properties": {
    ///    "lteUeSidelinkAmbr": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "lteV2xServicesAuth": {
    ///      "$ref": "#/components/schemas/LteV2xAuth"
    ///    },
    ///    "nrUeSidelinkAmbr": {
    ///      "$ref": "#/components/schemas/BitRate"
    ///    },
    ///    "nrV2xServicesAuth": {
    ///      "$ref": "#/components/schemas/NrV2xAuth"
    ///    },
    ///    "pc5QoSPara": {
    ///      "$ref": "#/components/schemas/Pc5QoSPara"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct V2xContext {
        #[serde(
            rename = "lteUeSidelinkAmbr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub lte_ue_sidelink_ambr: Option<BitRate>,
        #[serde(
            rename = "lteV2xServicesAuth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub lte_v2x_services_auth: Option<LteV2xAuth>,
        #[serde(
            rename = "nrUeSidelinkAmbr",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nr_ue_sidelink_ambr: Option<BitRate>,
        #[serde(
            rename = "nrV2xServicesAuth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub nr_v2x_services_auth: Option<NrV2xAuth>,
        #[serde(
            rename = "pc5QoSPara",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub pc5_qo_s_para: Option<Pc5QoSPara>,
    }

    impl From<&V2xContext> for V2xContext {
        fn from(value: &V2xContext) -> Self {
            value.clone()
        }
    }

    ///V2X related N2 information
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "V2X related N2 information",
    ///  "type": "object",
    ///  "properties": {
    ///    "n2Pc5Pol": {
    ///      "$ref": "#/components/schemas/N2InfoContent"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct V2xInformation {
        #[serde(rename = "n2Pc5Pol", default, skip_serializing_if = "Option::is_none")]
        pub n2_pc5_pol: Option<N2InfoContent>,
    }

    impl From<&V2xInformation> for V2xInformation {
        fn from(value: &V2xInformation) -> Self {
            value.clone()
        }
    }

    ///Velocity estimate.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Velocity estimate.",
    ///  "oneOf": [
    ///    {
    ///      "$ref": "#/components/schemas/HorizontalVelocity"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/HorizontalWithVerticalVelocity"
    ///    },
    ///    {
    ///      "$ref": "#/components/schemas/HorizontalVelocityWithUncertainty"
    ///    },
    ///    {
    ///      "$ref":
    /// "#/components/schemas/HorizontalWithVerticalVelocityAndUncertainty"
    ///    }
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum VelocityEstimate {
        Velocity(HorizontalVelocity),
        WithVerticalVelocity(HorizontalWithVerticalVelocity),
        VelocityWithUncertainty(HorizontalVelocityWithUncertainty),
        WithVerticalVelocityAndUncertainty(HorizontalWithVerticalVelocityAndUncertainty),
    }

    impl From<&VelocityEstimate> for VelocityEstimate {
        fn from(value: &VelocityEstimate) -> Self {
            value.clone()
        }
    }

    impl From<HorizontalVelocity> for VelocityEstimate {
        fn from(value: HorizontalVelocity) -> Self {
            Self::Velocity(value)
        }
    }

    impl From<HorizontalWithVerticalVelocity> for VelocityEstimate {
        fn from(value: HorizontalWithVerticalVelocity) -> Self {
            Self::WithVerticalVelocity(value)
        }
    }

    impl From<HorizontalVelocityWithUncertainty> for VelocityEstimate {
        fn from(value: HorizontalVelocityWithUncertainty) -> Self {
            Self::VelocityWithUncertainty(value)
        }
    }

    impl From<HorizontalWithVerticalVelocityAndUncertainty> for VelocityEstimate {
        fn from(value: HorizontalWithVerticalVelocityAndUncertainty) -> Self {
            Self::WithVerticalVelocityAndUncertainty(value)
        }
    }

    ///Indicates velocity requirement.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates velocity requirement.",
    ///  "type": "string",
    ///  "enum": [
    ///    "VELOCITY_IS_NOT_REQUESTED",
    ///    "VELOCITY_IS_REQUESTED"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum VelocityRequested {
        #[serde(rename = "VELOCITY_IS_NOT_REQUESTED")]
        VelocityIsNotRequested,
        #[serde(rename = "VELOCITY_IS_REQUESTED")]
        VelocityIsRequested,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&VelocityRequested> for VelocityRequested {
        fn from(value: &VelocityRequested) -> Self {
            value.clone()
        }
    }

    impl ToString for VelocityRequested {
        fn to_string(&self) -> String {
            match *self {
                Self::VelocityIsNotRequested => "VELOCITY_IS_NOT_REQUESTED".to_string(),
                Self::VelocityIsRequested => "VELOCITY_IS_REQUESTED".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for VelocityRequested {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "VELOCITY_IS_NOT_REQUESTED" => Ok(Self::VelocityIsNotRequested),
                "VELOCITY_IS_REQUESTED" => Ok(Self::VelocityIsRequested),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for VelocityRequested {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for VelocityRequested {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for VelocityRequested {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Indicates direction of vertical speed.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates direction of vertical speed.",
    ///  "type": "string",
    ///  "enum": [
    ///    "UPWARD",
    ///    "DOWNWARD"
    ///  ]
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum VerticalDirection {
        #[serde(rename = "UPWARD")]
        Upward,
        #[serde(rename = "DOWNWARD")]
        Downward,
    }

    impl From<&VerticalDirection> for VerticalDirection {
        fn from(value: &VerticalDirection) -> Self {
            value.clone()
        }
    }

    impl ToString for VerticalDirection {
        fn to_string(&self) -> String {
            match *self {
                Self::Upward => "UPWARD".to_string(),
                Self::Downward => "DOWNWARD".to_string(),
            }
        }
    }

    impl std::str::FromStr for VerticalDirection {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "UPWARD" => Ok(Self::Upward),
                "DOWNWARD" => Ok(Self::Downward),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl std::convert::TryFrom<&str> for VerticalDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for VerticalDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for VerticalDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Contains the Vertical Protection Level
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Contains the Vertical Protection Level",
    ///  "type": "integer",
    ///  "maximum": 50000.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VerticalProtectionLevel(pub i64);
    impl ::std::ops::Deref for VerticalProtectionLevel {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<VerticalProtectionLevel> for i64 {
        fn from(value: VerticalProtectionLevel) -> Self {
            value.0
        }
    }

    impl From<&VerticalProtectionLevel> for VerticalProtectionLevel {
        fn from(value: &VerticalProtectionLevel) -> Self {
            value.clone()
        }
    }

    impl From<i64> for VerticalProtectionLevel {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for VerticalProtectionLevel {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for VerticalProtectionLevel {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for VerticalProtectionLevel {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for VerticalProtectionLevel {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for VerticalProtectionLevel {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///VerticalSpeed
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Indicates value of vertical speed.",
    ///  "type": "number",
    ///  "format": "float",
    ///  "maximum": 255.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct VerticalSpeed(pub f32);
    impl ::std::ops::Deref for VerticalSpeed {
        type Target = f32;
        fn deref(&self) -> &f32 {
            &self.0
        }
    }

    impl From<VerticalSpeed> for f32 {
        fn from(value: VerticalSpeed) -> Self {
            value.0
        }
    }

    impl From<&VerticalSpeed> for VerticalSpeed {
        fn from(value: &VerticalSpeed) -> Self {
            value.clone()
        }
    }

    impl From<f32> for VerticalSpeed {
        fn from(value: f32) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for VerticalSpeed {
        type Err = <f32 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for VerticalSpeed {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for VerticalSpeed {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for VerticalSpeed {
        type Error = <f32 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for VerticalSpeed {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Unsigned integer identifying a volume in units of bytes.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unsigned integer identifying a volume in units of
    /// bytes.",
    ///  "type": "integer",
    ///  "format": "int64",
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct Volume(pub i64);
    impl ::std::ops::Deref for Volume {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<Volume> for i64 {
        fn from(value: Volume) -> Self {
            value.0
        }
    }

    impl From<&Volume> for Volume {
        fn from(value: &Volume) -> Self {
            value.clone()
        }
    }

    impl From<i64> for Volume {
        fn from(value: i64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for Volume {
        type Err = <i64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for Volume {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Volume {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Volume {
        type Error = <i64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for Volume {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///This represents the identifier of the W-AGF ID as specified in clause
    /// 9.3.1.162 of  3GPP TS 38.413 in hexadecimal representation. Each
    /// character in the string shall take a value  of "0" to "9", "a" to "f" or
    /// "A" to "F" and shall represent 4 bits. The most significant  character
    /// representing the 4 most significant bits of the W-AGF ID shall appear
    /// first in the  string, and the character representing the 4 least
    /// significant bit of the W-AGF ID shall  appear last in the string.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "This represents the identifier of the W-AGF ID as
    /// specified in clause 9.3.1.162 of  3GPP TS 38.413 in hexadecimal
    /// representation. Each character in the string shall take a value  of
    /// \"0\" to \"9\", \"a\" to \"f\" or \"A\" to \"F\" and shall represent 4
    /// bits. The most significant  character representing the 4 most
    /// significant bits of the W-AGF ID shall appear first in the  string, and
    /// the character representing the 4 least significant bit of the W-AGF ID
    /// shall  appear last in the string. \n",
    ///  "type": "string",
    ///  "pattern": "^[A-Fa-f0-9]+$"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct WAgfId(String);
    impl ::std::ops::Deref for WAgfId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<WAgfId> for String {
        fn from(value: WAgfId) -> Self {
            value.0
        }
    }

    impl From<&WAgfId> for WAgfId {
        fn from(value: &WAgfId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for WAgfId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^[A-Fa-f0-9]+$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[A-Fa-f0-9]+$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for WAgfId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for WAgfId {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for WAgfId {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for WAgfId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    ///One and only one of the "globLineIds", "hfcNIds", "areaCodeB" and
    /// "areaCodeC" attributes shall be included in a WirelineArea data
    /// structure
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "One and only one of the \"globLineIds\", \"hfcNIds\",
    /// \"areaCodeB\" and \"areaCodeC\" attributes shall be included in a
    /// WirelineArea data structure\n",
    ///  "type": "object",
    ///  "properties": {
    ///    "areaCodeB": {
    ///      "$ref": "#/components/schemas/AreaCode"
    ///    },
    ///    "areaCodeC": {
    ///      "$ref": "#/components/schemas/AreaCode"
    ///    },
    ///    "globalLineIds": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Bytes"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "hfcNIds": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/HfcNId"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WirelineArea {
        #[serde(rename = "areaCodeB", default, skip_serializing_if = "Option::is_none")]
        pub area_code_b: Option<AreaCode>,
        #[serde(rename = "areaCodeC", default, skip_serializing_if = "Option::is_none")]
        pub area_code_c: Option<AreaCode>,
        #[serde(
            rename = "globalLineIds",
            default,
            skip_serializing_if = "Vec::is_empty"
        )]
        pub global_line_ids: Vec<Bytes>,
        #[serde(rename = "hfcNIds", default, skip_serializing_if = "Vec::is_empty")]
        pub hfc_n_ids: Vec<HfcNId>,
    }

    impl From<&WirelineArea> for WirelineArea {
        fn from(value: &WirelineArea) -> Self {
            value.clone()
        }
    }

    ///The "restrictionType" attribute and the "areas" attribute shall be
    /// either both present or absent.  The empty array of areas is used when
    /// service is allowed/restricted nowhere.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The \"restrictionType\" attribute and the \"areas\"
    /// attribute shall be either both present or absent.  The empty array of
    /// areas is used when service is allowed/restricted nowhere.\n",
    ///  "type": "object",
    ///  "properties": {
    ///    "areas": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/WirelineArea"
    ///      }
    ///    },
    ///    "restrictionType": {
    ///      "$ref": "#/components/schemas/RestrictionType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WirelineServiceAreaRestriction {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub areas: Vec<WirelineArea>,
        #[serde(
            rename = "restrictionType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub restriction_type: Option<RestrictionType>,
    }

    impl From<&WirelineServiceAreaRestriction> for WirelineServiceAreaRestriction {
        fn from(value: &WirelineServiceAreaRestriction) -> Self {
            value.clone()
        }
    }

    ///Possible values are:
    /// - TIME_SLOT_START: Indicates the order of time slot start.
    /// - NUMBER_OF_UES: Indicates the order of number of UEs.
    /// - RSSI: Indicates the order of RSSI.
    /// - RTT: Indicates the order of RTT.
    /// - TRAFFIC_INFO: Indicates the order of Traffic information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Possible values are:\n- TIME_SLOT_START: Indicates the
    /// order of time slot start.\n- NUMBER_OF_UES: Indicates the order of
    /// number of UEs.\n- RSSI: Indicates the order of RSSI.\n- RTT: Indicates
    /// the order of RTT.\n- TRAFFIC_INFO: Indicates the order of Traffic
    /// information.\n",
    ///  "type": "string",
    ///  "enum": [
    ///    "TIME_SLOT_START",
    ///    "NUMBER_OF_UES",
    ///    "RSSI",
    ///    "RTT",
    ///    "TRAFFIC_INFO"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum WlanOrderingCriterion {
        #[serde(rename = "TIME_SLOT_START")]
        TimeSlotStart,
        #[serde(rename = "NUMBER_OF_UES")]
        NumberOfUes,
        #[serde(rename = "RSSI")]
        Rssi,
        #[serde(rename = "RTT")]
        Rtt,
        #[serde(rename = "TRAFFIC_INFO")]
        TrafficInfo,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&WlanOrderingCriterion> for WlanOrderingCriterion {
        fn from(value: &WlanOrderingCriterion) -> Self {
            value.clone()
        }
    }

    impl ToString for WlanOrderingCriterion {
        fn to_string(&self) -> String {
            match *self {
                Self::TimeSlotStart => "TIME_SLOT_START".to_string(),
                Self::NumberOfUes => "NUMBER_OF_UES".to_string(),
                Self::Rssi => "RSSI".to_string(),
                Self::Rtt => "RTT".to_string(),
                Self::TrafficInfo => "TRAFFIC_INFO".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for WlanOrderingCriterion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "TIME_SLOT_START" => Ok(Self::TimeSlotStart),
                "NUMBER_OF_UES" => Ok(Self::NumberOfUes),
                "RSSI" => Ok(Self::Rssi),
                "RTT" => Ok(Self::Rtt),
                "TRAFFIC_INFO" => Ok(Self::TrafficInfo),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for WlanOrderingCriterion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for WlanOrderingCriterion {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for WlanOrderingCriterion {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///The WLAN performance per SSID.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The WLAN performance per SSID.",
    ///  "type": "object",
    ///  "required": [
    ///    "ssId",
    ///    "wlanPerTsInfos"
    ///  ],
    ///  "properties": {
    ///    "ssId": {
    ///      "type": "string"
    ///    },
    ///    "wlanPerTsInfos": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/WlanPerTsPerformanceInfo"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WlanPerSsIdPerformanceInfo {
        #[serde(rename = "ssId")]
        pub ss_id: String,
        #[serde(rename = "wlanPerTsInfos")]
        pub wlan_per_ts_infos: Vec<WlanPerTsPerformanceInfo>,
    }

    impl From<&WlanPerSsIdPerformanceInfo> for WlanPerSsIdPerformanceInfo {
        fn from(value: &WlanPerSsIdPerformanceInfo) -> Self {
            value.clone()
        }
    }

    ///WLAN performance information per Time Slot during the analytics target
    /// period.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "WLAN performance information per Time Slot during the
    /// analytics target period.",
    ///  "type": "object",
    ///  "anyOf": [
    ///    {
    ///      "required": [
    ///        "rssi"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "rtt"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "trafficInfo"
    ///      ]
    ///    },
    ///    {
    ///      "required": [
    ///        "numberOfUes"
    ///      ]
    ///    }
    ///  ],
    ///  "required": [
    ///    "tsDuration",
    ///    "tsStart"
    ///  ],
    ///  "properties": {
    ///    "confidence": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "numberOfUes": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "rssi": {
    ///      "type": "integer"
    ///    },
    ///    "rtt": {
    ///      "$ref": "#/components/schemas/Uinteger"
    ///    },
    ///    "trafficInfo": {
    ///      "$ref": "#/components/schemas/TrafficInformation"
    ///    },
    ///    "tsDuration": {
    ///      "$ref": "#/components/schemas/DurationSec"
    ///    },
    ///    "tsStart": {
    ///      "$ref": "#/components/schemas/DateTime"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    #[serde(untagged)]
    pub enum WlanPerTsPerformanceInfo {
        Variant0 {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            rssi: i64,
            #[serde(rename = "tsDuration")]
            ts_duration: DurationSec,
            #[serde(rename = "tsStart")]
            ts_start: DateTime,
        },
        Variant1 {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            rtt: Uinteger,
            #[serde(rename = "tsDuration")]
            ts_duration: DurationSec,
            #[serde(rename = "tsStart")]
            ts_start: DateTime,
        },
        Variant2 {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            #[serde(rename = "trafficInfo")]
            traffic_info: TrafficInformation,
            #[serde(rename = "tsDuration")]
            ts_duration: DurationSec,
            #[serde(rename = "tsStart")]
            ts_start: DateTime,
        },
        Variant3 {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            confidence: Option<Uinteger>,
            #[serde(rename = "numberOfUes")]
            number_of_ues: Uinteger,
            #[serde(rename = "tsDuration")]
            ts_duration: DurationSec,
            #[serde(rename = "tsStart")]
            ts_start: DateTime,
        },
    }

    impl From<&WlanPerTsPerformanceInfo> for WlanPerTsPerformanceInfo {
        fn from(value: &WlanPerTsPerformanceInfo) -> Self {
            value.clone()
        }
    }

    ///The WLAN performance related information.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "The WLAN performance related information.",
    ///  "type": "object",
    ///  "required": [
    ///    "wlanPerSsidInfos"
    ///  ],
    ///  "properties": {
    ///    "networkArea": {
    ///      "$ref": "#/components/schemas/NetworkAreaInfo"
    ///    },
    ///    "wlanPerSsidInfos": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/WlanPerSsIdPerformanceInfo"
    ///      },
    ///      "minItems": 1
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WlanPerformanceInfo {
        #[serde(
            rename = "networkArea",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub network_area: Option<NetworkAreaInfo>,
        #[serde(rename = "wlanPerSsidInfos")]
        pub wlan_per_ssid_infos: Vec<WlanPerSsIdPerformanceInfo>,
    }

    impl From<&WlanPerformanceInfo> for WlanPerformanceInfo {
        fn from(value: &WlanPerformanceInfo) -> Self {
            value.clone()
        }
    }

    ///Represents other WLAN performance analytics requirements.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents other WLAN performance analytics
    /// requirements.",
    ///  "type": "object",
    ///  "properties": {
    ///    "bssIds": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "order": {
    ///      "$ref": "#/components/schemas/MatchingDirection"
    ///    },
    ///    "ssIds": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      },
    ///      "minItems": 1
    ///    },
    ///    "wlanOrderCriter": {
    ///      "$ref": "#/components/schemas/WlanOrderingCriterion"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct WlanPerformanceReq {
        #[serde(rename = "bssIds", default, skip_serializing_if = "Vec::is_empty")]
        pub bss_ids: Vec<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub order: Option<MatchingDirection>,
        #[serde(rename = "ssIds", default, skip_serializing_if = "Vec::is_empty")]
        pub ss_ids: Vec<String>,
        #[serde(
            rename = "wlanOrderCriter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        pub wlan_order_criter: Option<WlanOrderingCriterion>,
    }

    impl From<&WlanPerformanceReq> for WlanPerformanceReq {
        fn from(value: &WlanPerformanceReq) -> Self {
            value.clone()
        }
    }

    ///_5gMmCapability
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "$ref": "#/components/schemas/Bytes"
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct _5gMmCapability(pub Bytes);
    impl ::std::ops::Deref for _5gMmCapability {
        type Target = Bytes;
        fn deref(&self) -> &Bytes {
            &self.0
        }
    }

    impl From<_5gMmCapability> for Bytes {
        fn from(value: _5gMmCapability) -> Self {
            value.0
        }
    }

    impl From<&_5gMmCapability> for _5gMmCapability {
        fn from(value: &_5gMmCapability) -> Self {
            value.clone()
        }
    }

    impl From<Bytes> for _5gMmCapability {
        fn from(value: Bytes) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for _5gMmCapability {
        type Err = <Bytes as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for _5gMmCapability {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for _5gMmCapability {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for _5gMmCapability {
        type Error = <Bytes as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for _5gMmCapability {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    ///Describes the 5GS User State of a UE
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Describes the 5GS User State of a UE",
    ///  "type": "string",
    ///  "enum": [
    ///    "DEREGISTERED",
    ///    "CONNECTED_NOT_REACHABLE_FOR_PAGING",
    ///    "CONNECTED_REACHABLE_FOR_PAGING",
    ///    "NOT_PROVIDED_FROM_AMF"
    ///  ],
    ///  "x-allow-unknown": true
    ///}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
    )]
    pub enum _5gsUserState {
        #[serde(rename = "DEREGISTERED")]
        Deregistered,
        #[serde(rename = "CONNECTED_NOT_REACHABLE_FOR_PAGING")]
        ConnectedNotReachableForPaging,
        #[serde(rename = "CONNECTED_REACHABLE_FOR_PAGING")]
        ConnectedReachableForPaging,
        #[serde(rename = "NOT_PROVIDED_FROM_AMF")]
        NotProvidedFromAmf,
        #[serde(untagged)]
        UnknownOther(String),
    }

    impl From<&_5gsUserState> for _5gsUserState {
        fn from(value: &_5gsUserState) -> Self {
            value.clone()
        }
    }

    impl ToString for _5gsUserState {
        fn to_string(&self) -> String {
            match *self {
                Self::Deregistered => "DEREGISTERED".to_string(),
                Self::ConnectedNotReachableForPaging => {
                    "CONNECTED_NOT_REACHABLE_FOR_PAGING".to_string()
                }
                Self::ConnectedReachableForPaging => "CONNECTED_REACHABLE_FOR_PAGING".to_string(),
                Self::NotProvidedFromAmf => "NOT_PROVIDED_FROM_AMF".to_string(),
                Self::UnknownOther(ref value) => value.clone(),
            }
        }
    }

    impl std::str::FromStr for _5gsUserState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
            match value {
                "DEREGISTERED" => Ok(Self::Deregistered),
                "CONNECTED_NOT_REACHABLE_FOR_PAGING" => Ok(Self::ConnectedNotReachableForPaging),
                "CONNECTED_REACHABLE_FOR_PAGING" => Ok(Self::ConnectedReachableForPaging),
                "NOT_PROVIDED_FROM_AMF" => Ok(Self::NotProvidedFromAmf),
                _ => Ok(Self::UnknownOther(value.to_string())),
            }
        }
    }

    impl std::convert::TryFrom<&str> for _5gsUserState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for _5gsUserState {
        type Error = self::error::ConversionError;
        fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for _5gsUserState {
        type Error = self::error::ConversionError;
        fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    ///Represents the 5GS User state of the UE for an access type
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Represents the 5GS User state of the UE for an access
    /// type",
    ///  "type": "object",
    ///  "required": [
    ///    "5gsUserState",
    ///    "accessType"
    ///  ],
    ///  "properties": {
    ///    "5gsUserState": {
    ///      "$ref": "#/components/schemas/5GsUserState"
    ///    },
    ///    "accessType": {
    ///      "$ref": "#/components/schemas/AccessType"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct _5gsUserStateInfo {
        #[serde(rename = "accessType")]
        pub access_type: AccessType,
        #[serde(rename = "5gsUserState")]
        pub five_gs_user_state: _5gsUserState,
    }

    impl From<&_5gsUserStateInfo> for _5gsUserStateInfo {
        fn from(value: &_5gsUserStateInfo) -> Self {
            value.clone()
        }
    }

    ///Unsigned integer representing a 5G QoS Identifier (see clause 5.7.2.1 of
    /// 3GPP TS 23.501, within the range 0 to 255.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Unsigned integer representing a 5G QoS Identifier (see
    /// clause 5.7.2.1 of 3GPP TS 23.501, within the range 0 to 255.\n",
    ///  "type": "integer",
    ///  "maximum": 255.0,
    ///  "minimum": 0.0
    ///}
    /// ```
    /// </details>
    #[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
    pub struct _5qi(pub u8);
    impl ::std::ops::Deref for _5qi {
        type Target = u8;
        fn deref(&self) -> &u8 {
            &self.0
        }
    }

    impl From<_5qi> for u8 {
        fn from(value: _5qi) -> Self {
            value.0
        }
    }

    impl From<&_5qi> for _5qi {
        fn from(value: &_5qi) -> Self {
            value.clone()
        }
    }

    impl From<u8> for _5qi {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for _5qi {
        type Err = <u8 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for _5qi {
        type Error = <u8 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for _5qi {
        type Error = <u8 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for _5qi {
        type Error = <u8 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for _5qi {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    /// Generation of default values for serde.
    pub mod defaults {
        pub(super) fn default_bool<const V: bool>() -> bool {
            V
        }
    }
}

#[derive(Clone, Debug)]
///Client for Openapi-5GC
///
///Merged Apis.  2024, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI,
/// TSDSI, TTA, TTC). All rights reserved.
///
///Version: 1.2.6
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}

impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = std::time::Duration::from_secs(15);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }

    /// Construct a new client with an existing `reqwest::Client`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }

    /// Get the base URL to which requests are made.
    pub fn baseurl(&self) -> &String {
        &self.baseurl
    }

    /// Get the internal `reqwest::Client` used to make requests.
    pub fn client(&self) -> &reqwest::Client {
        &self.client
    }

    /// Get the version of this API.
    ///
    /// This string is pulled directly from the source OpenAPI
    /// document and may be in any format the API selects.
    pub fn api_version(&self) -> &'static str {
        "1.2.6"
    }
}

#[allow(clippy::all)]
impl Client {}
/// Items consumers will typically use such as the Client.
pub mod prelude {
    #[allow(unused_imports)]
    pub use super::Client;
}
